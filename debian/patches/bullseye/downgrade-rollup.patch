author: Andres Salomon <dilinger@debian.org>
description: downgrade rollup from 3.12 to 2.58 to build w/ bullseye's nodejs

diff -urN /chromium-112.0.5615.49/third_party/node/node_modules/rollup/dist/bin/rollup /chromium-111.0.5563.110/third_party/node/node_modules/rollup/dist/bin/rollup
--- a/third_party/node/node_modules/rollup/dist/bin/rollup	2023-04-03 01:19:24.738789854 +0000
+++ b/third_party/node/node_modules/rollup/dist/bin/rollup	2023-01-12 22:12:55.000000000 +0000
@@ -2,8 +2,9 @@
 
 /*
   @license
-	Rollup.js v3.12.0
-	Sat, 28 Jan 2023 05:55:49 GMT - commit 01ddea09dfdf1c396c1c24ba3d97743698fe1508
+	Rollup.js v2.58.0
+	Fri, 01 Oct 2021 06:54:03 GMT - commit 3a404a07f41a10d10b7af536f05b90ea46d8ad3d
+
 
 	https://github.com/rollup/rollup
 
@@ -11,23 +12,34 @@
 */
 'use strict';
 
-Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
+Object.defineProperty(exports, '__esModule', { value: true });
 
-const process$1 = require('node:process');
 const rollup = require('../shared/rollup.js');
 const require$$2 = require('util');
-const require$$0 = require('path');
-const require$$0$1 = require('fs');
-const promises = require('node:fs/promises');
-const node_path = require('node:path');
+const fs = require('fs');
+const path$1 = require('path');
+const mergeOptions = require('../shared/mergeOptions.js');
 const loadConfigFile_js = require('../shared/loadConfigFile.js');
-require('node:perf_hooks');
-require('node:crypto');
-require('node:events');
+const require$$1 = require('module');
+require('crypto');
+require('events');
+require('url');
 require('tty');
-require('node:url');
 
-const help = "rollup version __VERSION__\n=====================================\n\nUsage: rollup [options] <entry file>\n\nBasic options:\n\n-c, --config <filename>     Use this config file (if argument is used but value\n                              is unspecified, defaults to rollup.config.js)\n-d, --dir <dirname>         Directory for chunks (if absent, prints to stdout)\n-e, --external <ids>        Comma-separate list of module IDs to exclude\n-f, --format <format>       Type of output (amd, cjs, es, iife, umd, system)\n-g, --globals <pairs>       Comma-separate list of `moduleID:Global` pairs\n-h, --help                  Show this help message\n-i, --input <filename>      Input (alternative to <entry file>)\n-m, --sourcemap             Generate sourcemap (`-m inline` for inline map)\n-n, --name <name>           Name for UMD export\n-o, --file <output>         Single output file (if absent, prints to stdout)\n-p, --plugin <plugin>       Use the plugin specified (may be repeated)\n-v, --version               Show version number\n-w, --watch                 Watch files in bundle and rebuild on changes\n--amd.autoId                Generate the AMD ID based off the chunk name\n--amd.basePath <prefix>     Path to prepend to auto generated AMD ID\n--amd.define <name>         Function to use in place of `define`\n--amd.forceJsExtensionForImports Use `.js` extension in AMD imports\n--amd.id <id>               ID for AMD module (default is anonymous)\n--assetFileNames <pattern>  Name pattern for emitted assets\n--banner <text>             Code to insert at top of bundle (outside wrapper)\n--chunkFileNames <pattern>  Name pattern for emitted secondary chunks\n--compact                   Minify wrapper code\n--context <variable>        Specify top-level `this` value\n--no-dynamicImportInCjs     Write external dynamic CommonJS imports as require\n--entryFileNames <pattern>  Name pattern for emitted entry chunks\n--environment <values>      Settings passed to config file (see example)\n--no-esModule               Do not add __esModule property\n--exports <mode>            Specify export mode (auto, default, named, none)\n--extend                    Extend global variable defined by --name\n--no-externalImportAssertions Omit import assertions in \"es\" output\n--no-externalLiveBindings   Do not generate code to support live bindings\n--failAfterWarnings         Exit with an error if the build produced warnings\n--footer <text>             Code to insert at end of bundle (outside wrapper)\n--no-freeze                 Do not freeze namespace objects\n--generatedCode <preset>    Which code features to use (es5/es2015)\n--generatedCode.arrowFunctions Use arrow functions in generated code\n--generatedCode.constBindings Use \"const\" in generated code\n--generatedCode.objectShorthand Use shorthand properties in generated code\n--no-generatedCode.reservedNamesAsProps Always quote reserved names as props\n--generatedCode.symbols     Use symbols in generated code\n--no-hoistTransitiveImports Do not hoist transitive imports into entry chunks\n--no-indent                 Don't indent result\n--inlineDynamicImports      Create single bundle when using dynamic imports\n--no-interop                Do not include interop block\n--intro <text>              Code to insert at top of bundle (inside wrapper)\n--no-makeAbsoluteExternalsRelative Prevent normalization of external imports\n--maxParallelFileOps <value> How many files to read in parallel\n--minifyInternalExports     Force or disable minification of internal exports\n--noConflict                Generate a noConflict method for UMD globals\n--outro <text>              Code to insert at end of bundle (inside wrapper)\n--perf                      Display performance timings\n--no-preserveEntrySignatures Avoid facade chunks for entry points\n--preserveModules           Preserve module structure\n--preserveModulesRoot       Put preserved modules under this path at root level\n--preserveSymlinks          Do not follow symlinks when resolving files\n--no-sanitizeFileName       Do not replace invalid characters in file names\n--shimMissingExports        Create shim variables for missing exports\n--silent                    Don't print warnings\n--sourcemapBaseUrl <url>    Emit absolute sourcemap URLs with given base\n--sourcemapExcludeSources   Do not include source code in source maps\n--sourcemapFile <file>      Specify bundle position for source maps\n--stdin=ext                 Specify file extension used for stdin input\n--no-stdin                  Do not read \"-\" from stdin\n--no-strict                 Don't emit `\"use strict\";` in the generated modules\n--strictDeprecations        Throw errors for deprecated features\n--no-systemNullSetters      Do not replace empty SystemJS setters with `null`\n--no-treeshake              Disable tree-shaking optimisations\n--no-treeshake.annotations  Ignore pure call annotations\n--treeshake.correctVarValueBeforeDeclaration Deoptimize variables until declared\n--treeshake.manualPureFunctions <names> Manually declare functions as pure\n--no-treeshake.moduleSideEffects Assume modules have no side effects\n--no-treeshake.propertyReadSideEffects Ignore property access side effects\n--no-treeshake.tryCatchDeoptimization Do not turn off try-catch-tree-shaking\n--no-treeshake.unknownGlobalSideEffects Assume unknown globals do not throw\n--validate                  Validate output\n--waitForBundleInput        Wait for bundle input files\n--watch.buildDelay <number> Throttle watch rebuilds\n--no-watch.clearScreen      Do not clear the screen when rebuilding\n--watch.exclude <files>     Exclude files from being watched\n--watch.include <files>     Limit watching to specified files\n--watch.onBundleEnd <cmd>   Shell command to run on `\"BUNDLE_END\"` event\n--watch.onBundleStart <cmd> Shell command to run on `\"BUNDLE_START\"` event\n--watch.onEnd <cmd>         Shell command to run on `\"END\"` event\n--watch.onError <cmd>       Shell command to run on `\"ERROR\"` event\n--watch.onStart <cmd>       Shell command to run on `\"START\"` event\n--watch.skipWrite           Do not write files to disk when watching\n\nExamples:\n\n# use settings in config file\nrollup -c\n\n# in config file, process.env.INCLUDE_DEPS === 'true'\n# and process.env.BUILD === 'production'\nrollup -c --environment INCLUDE_DEPS,BUILD:production\n\n# create CommonJS bundle.js from src/main.js\nrollup --format=cjs --file=bundle.js -- src/main.js\n\n# create self-executing IIFE using `window.jQuery`\n# and `window._` as external globals\nrollup -f iife --globals jquery:jQuery,lodash:_ \\\n  -i src/app.js -o build/app.js -m build/app.js.map\n\nNotes:\n\n* When piping to stdout, only inline sourcemaps are permitted\n\nFor more information visit https://rollupjs.org\n";
+function _interopNamespaceDefault(e) {
+  const n = Object.create(null);
+  if (e) {
+    for (const k in e) {
+      n[k] = e[k];
+    }
+  }
+  n.default = e;
+  return n;
+}
+
+const path__namespace = /*#__PURE__*/_interopNamespaceDefault(path$1);
+
+const help = "rollup version __VERSION__\n=====================================\n\nUsage: rollup [options] <entry file>\n\nBasic options:\n\n-c, --config <filename>     Use this config file (if argument is used but value\n                              is unspecified, defaults to rollup.config.js)\n-d, --dir <dirname>         Directory for chunks (if absent, prints to stdout)\n-e, --external <ids>        Comma-separate list of module IDs to exclude\n-f, --format <format>       Type of output (amd, cjs, es, iife, umd, system)\n-g, --globals <pairs>       Comma-separate list of `moduleID:Global` pairs\n-h, --help                  Show this help message\n-i, --input <filename>      Input (alternative to <entry file>)\n-m, --sourcemap             Generate sourcemap (`-m inline` for inline map)\n-n, --name <name>           Name for UMD export\n-o, --file <output>         Single output file (if absent, prints to stdout)\n-p, --plugin <plugin>       Use the plugin specified (may be repeated)\n-v, --version               Show version number\n-w, --watch                 Watch files in bundle and rebuild on changes\n--amd.id <id>               ID for AMD module (default is anonymous)\n--amd.autoId                Generate the AMD ID based off the chunk name\n--amd.basePath <prefix>     Path to prepend to auto generated AMD ID\n--amd.define <name>         Function to use in place of `define`\n--assetFileNames <pattern>  Name pattern for emitted assets\n--banner <text>             Code to insert at top of bundle (outside wrapper)\n--chunkFileNames <pattern>  Name pattern for emitted secondary chunks\n--compact                   Minify wrapper code\n--context <variable>        Specify top-level `this` value\n--entryFileNames <pattern>  Name pattern for emitted entry chunks\n--environment <values>      Settings passed to config file (see example)\n--no-esModule               Do not add __esModule property\n--exports <mode>            Specify export mode (auto, default, named, none)\n--extend                    Extend global variable defined by --name\n--no-externalLiveBindings   Do not generate code to support live bindings\n--failAfterWarnings         Exit with an error if the build produced warnings\n--footer <text>             Code to insert at end of bundle (outside wrapper)\n--no-freeze                 Do not freeze namespace objects\n--no-hoistTransitiveImports Do not hoist transitive imports into entry chunks\n--no-indent                 Don't indent result\n--no-interop                Do not include interop block\n--inlineDynamicImports      Create single bundle when using dynamic imports\n--intro <text>              Code to insert at top of bundle (inside wrapper)\n--minifyInternalExports     Force or disable minification of internal exports\n--namespaceToStringTag      Create proper `.toString` methods for namespaces\n--noConflict                Generate a noConflict method for UMD globals\n--outro <text>              Code to insert at end of bundle (inside wrapper)\n--preferConst               Use `const` instead of `var` for exports\n--no-preserveEntrySignatures Avoid facade chunks for entry points\n--preserveModules           Preserve module structure\n--preserveModulesRoot       Put preserved modules under this path at root level\n--preserveSymlinks          Do not follow symlinks when resolving files\n--no-sanitizeFileName       Do not replace invalid characters in file names\n--shimMissingExports        Create shim variables for missing exports\n--silent                    Don't print warnings\n--sourcemapExcludeSources   Do not include source code in source maps\n--sourcemapFile <file>      Specify bundle position for source maps\n--stdin=ext                 Specify file extension used for stdin input\n--no-stdin                  Do not read \"-\" from stdin\n--no-strict                 Don't emit `\"use strict\";` in the generated modules\n--strictDeprecations        Throw errors for deprecated features\n--systemNullSetters         Replace empty SystemJS setters with `null`\n--no-treeshake              Disable tree-shaking optimisations\n--no-treeshake.annotations  Ignore pure call annotations\n--no-treeshake.moduleSideEffects Assume modules have no side-effects\n--no-treeshake.propertyReadSideEffects Ignore property access side-effects\n--no-treeshake.tryCatchDeoptimization Do not turn off try-catch-tree-shaking\n--no-treeshake.unknownGlobalSideEffects Assume unknown globals do not throw\n--waitForBundleInput        Wait for bundle input files\n--watch.buildDelay <number> Throttle watch rebuilds\n--no-watch.clearScreen      Do not clear the screen when rebuilding\n--watch.skipWrite           Do not write files to disk when watching\n--watch.exclude <files>     Exclude files from being watched\n--watch.include <files>     Limit watching to specified files\n--validate                  Validate output\n\nExamples:\n\n# use settings in config file\nrollup -c\n\n# in config file, process.env.INCLUDE_DEPS === 'true'\n# and process.env.BUILD === 'production'\nrollup -c --environment INCLUDE_DEPS,BUILD:production\n\n# create CommonJS bundle.js from src/main.js\nrollup --format=cjs --file=bundle.js -- src/main.js\n\n# create self-executing IIFE using `window.jQuery`\n# and `window._` as external globals\nrollup -f iife --globals jquery:jQuery,lodash:_ \\\n  -i src/app.js -o build/app.js -m build/app.js.map\n\nNotes:\n\n* When piping to stdout, only inline sourcemaps are permitted\n\nFor more information visit https://rollupjs.org\n";
 
 /**
  * @license
@@ -181,9 +193,6 @@
         // allow a string argument to be passed in rather
         // than an argv array.
         const args = tokenizeArgString(argsInput);
-        // tokenizeArgString adds extra quotes to args if argsInput is a string
-        // only strip those extra quotes in processValue if argsInput is a string
-        const inputIsString = typeof argsInput === 'string';
         // aliases might have transitive relationships, normalize this.
         const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));
         const configuration = Object.assign({
@@ -325,11 +334,11 @@
             let next;
             let value;
             // any unknown option (except for end-of-options, "--")
-            if (arg !== '--' && /^-/.test(arg) && isUnknownOptionAsArg(arg)) {
+            if (arg !== '--' && isUnknownOptionAsArg(arg)) {
                 pushPositional(arg);
                 // ---, ---=, ----, etc,
             }
-            else if (truncatedArg.match(/^---+(=|$)/)) {
+            else if (truncatedArg.match(/---+(=|$)/)) {
                 // options without key name are invalid.
                 pushPositional(arg);
                 continue;
@@ -350,7 +359,7 @@
                         i = eatNargs(i, m[1], args, m[2]);
                     }
                     else {
-                        setArg(m[1], m[2], true);
+                        setArg(m[1], m[2]);
                     }
                 }
             }
@@ -623,7 +632,7 @@
             else {
                 // value in --option=value is eaten as is
                 if (!isUndefined(argAfterEqualSign)) {
-                    argsToSet.push(processValue(key, argAfterEqualSign, true));
+                    argsToSet.push(processValue(key, argAfterEqualSign));
                 }
                 for (let ii = i + 1; ii < args.length; ii++) {
                     if ((!configuration['greedy-arrays'] && argsToSet.length > 0) ||
@@ -633,7 +642,7 @@
                     if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))
                         break;
                     i = ii;
-                    argsToSet.push(processValue(key, next, inputIsString));
+                    argsToSet.push(processValue(key, next));
                 }
             }
             // If both array and nargs are configured, create an error if less than
@@ -646,14 +655,14 @@
             setArg(key, argsToSet);
             return i;
         }
-        function setArg(key, val, shouldStripQuotes = inputIsString) {
+        function setArg(key, val) {
             if (/-/.test(key) && configuration['camel-case-expansion']) {
                 const alias = key.split('.').map(function (prop) {
                     return camelCase(prop);
                 }).join('.');
                 addNewAlias(key, alias);
             }
-            const value = processValue(key, val, shouldStripQuotes);
+            const value = processValue(key, val);
             const splitKey = key.split('.');
             setKey(argv, splitKey, value);
             // handle populating aliases of the full key
@@ -703,10 +712,12 @@
                 addNewAlias(alias, key);
             }
         }
-        function processValue(key, val, shouldStripQuotes) {
+        function processValue(key, val) {
             // strings may be quoted, clean this up as we assign values.
-            if (shouldStripQuotes) {
-                val = stripQuotes(val);
+            if (typeof val === 'string' &&
+                (val[0] === "'" || val[0] === '"') &&
+                val[val.length - 1] === val[0]) {
+                val = val.substring(1, val.length - 1);
             }
             // handle parsing boolean arguments --foo=true --bar false.
             if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
@@ -1181,13 +1192,6 @@
         return '___proto___';
     return key;
 }
-function stripQuotes(val) {
-    return (typeof val === 'string' &&
-        (val[0] === "'" || val[0] === '"') &&
-        val[val.length - 1] === val[0])
-        ? val.substring(1, val.length - 1)
-        : val;
-}
 
 /**
  * @fileoverview Main entrypoint for libraries using yargs-parser in Node.js
@@ -1197,15 +1201,13 @@
  * Copyright (c) 2016, Contributors
  * SPDX-License-Identifier: ISC
  */
-var _a, _b, _c;
 // See https://github.com/yargs/yargs-parser#supported-nodejs-versions for our
 // version support policy. The YARGS_MIN_NODE_VERSION is used for testing only.
 const minNodeVersion = (process && process.env && process.env.YARGS_MIN_NODE_VERSION)
     ? Number(process.env.YARGS_MIN_NODE_VERSION)
-    : 12;
-const nodeVersion = (_b = (_a = process === null || process === void 0 ? void 0 : process.versions) === null || _a === void 0 ? void 0 : _a.node) !== null && _b !== void 0 ? _b : (_c = process === null || process === void 0 ? void 0 : process.version) === null || _c === void 0 ? void 0 : _c.slice(1);
-if (nodeVersion) {
-    const major = Number(nodeVersion.match(/^([^.]+)/)[1]);
+    : 10;
+if (process && process.version) {
+    const major = Number(process.version.match(/v([^.]+)/)[1]);
     if (major < minNodeVersion) {
         throw Error(`yargs parser supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`);
     }
@@ -1218,8 +1220,8 @@
         return env;
     },
     format: require$$2.format,
-    normalize: require$$0.normalize,
-    resolve: require$$0.resolve,
+    normalize: path$1.normalize,
+    resolve: path$1.resolve,
     // TODO: figure  out a  way to combine ESM and CJS coverage, such  that
     // we can exercise all the lines below:
     require: (path) => {
@@ -1227,8 +1229,7 @@
             return require(path);
         }
         else if (path.match(/\.json$/)) {
-            // Addresses: https://github.com/yargs/yargs/issues/2040
-            return JSON.parse(require$$0$1.readFileSync(path, 'utf8'));
+            return fs.readFileSync(path, 'utf8');
         }
         else {
             throw Error('only .json config files are supported in ESM');
@@ -1247,7 +1248,7 @@
 yargsParser.looksLikeNumber = looksLikeNumber;
 const argParser = yargsParser;
 
-function parseMilliseconds(milliseconds) {
+var parseMs = milliseconds => {
 	if (typeof milliseconds !== 'number') {
 		throw new TypeError('Expected a number');
 	}
@@ -1263,13 +1264,15 @@
 		microseconds: roundTowardsZero(milliseconds * 1000) % 1000,
 		nanoseconds: roundTowardsZero(milliseconds * 1e6) % 1000
 	};
-}
+};
+
+const parseMilliseconds = parseMs;
 
 const pluralize = (word, count) => count === 1 ? word : `${word}s`;
 
-const SECOND_ROUNDING_EPSILON = 0.000_000_1;
+const SECOND_ROUNDING_EPSILON = 0.0000001;
 
-function prettyMilliseconds(milliseconds, options = {}) {
+var prettyMs = (milliseconds, options = {}) => {
 	if (!Number.isFinite(milliseconds)) {
 		throw new TypeError('Expected a finite number');
 	}
@@ -1324,9 +1327,9 @@
 	add(parsed.minutes, 'minute', 'm');
 
 	if (
-		options.separateMilliseconds
-		|| options.formatSubMilliseconds
-		|| (!options.colonNotation && milliseconds < 1000)
+		options.separateMilliseconds ||
+		options.formatSubMilliseconds ||
+		(!options.colonNotation && milliseconds < 1000)
 	) {
 		add(parsed.seconds, 'second', 's');
 		if (options.formatSubMilliseconds) {
@@ -1334,42 +1337,42 @@
 			add(parsed.microseconds, 'microsecond', 'µs');
 			add(parsed.nanoseconds, 'nanosecond', 'ns');
 		} else {
-			const millisecondsAndBelow
-				= parsed.milliseconds
-				+ (parsed.microseconds / 1000)
-				+ (parsed.nanoseconds / 1e6);
-
-			const millisecondsDecimalDigits
-				= typeof options.millisecondsDecimalDigits === 'number'
-					? options.millisecondsDecimalDigits
-					: 0;
-
-			const roundedMiliseconds = millisecondsAndBelow >= 1
-				? Math.round(millisecondsAndBelow)
-				: Math.ceil(millisecondsAndBelow);
-
-			const millisecondsString = millisecondsDecimalDigits
-				? millisecondsAndBelow.toFixed(millisecondsDecimalDigits)
-				: roundedMiliseconds;
+			const millisecondsAndBelow =
+				parsed.milliseconds +
+				(parsed.microseconds / 1000) +
+				(parsed.nanoseconds / 1e6);
+
+			const millisecondsDecimalDigits =
+				typeof options.millisecondsDecimalDigits === 'number' ?
+					options.millisecondsDecimalDigits :
+					0;
+
+			const roundedMiliseconds = millisecondsAndBelow >= 1 ?
+				Math.round(millisecondsAndBelow) :
+				Math.ceil(millisecondsAndBelow);
+
+			const millisecondsString = millisecondsDecimalDigits ?
+				millisecondsAndBelow.toFixed(millisecondsDecimalDigits) :
+				roundedMiliseconds;
 
 			add(
-				Number.parseFloat(millisecondsString),
+				Number.parseFloat(millisecondsString, 10),
 				'millisecond',
 				'ms',
-				millisecondsString,
+				millisecondsString
 			);
 		}
 	} else {
 		const seconds = (milliseconds / 1000) % 60;
-		const secondsDecimalDigits
-			= typeof options.secondsDecimalDigits === 'number'
-				? options.secondsDecimalDigits
-				: 1;
+		const secondsDecimalDigits =
+			typeof options.secondsDecimalDigits === 'number' ?
+				options.secondsDecimalDigits :
+				1;
 		const secondsFixed = floorDecimals(seconds, secondsDecimalDigits);
-		const secondsString = options.keepDecimalsOnWholeSeconds
-			? secondsFixed
-			: secondsFixed.replace(/\.0+$/, '');
-		add(Number.parseFloat(secondsString), 'second', 's', secondsString);
+		const secondsString = options.keepDecimalsOnWholeSeconds ?
+			secondsFixed :
+			secondsFixed.replace(/\.0+$/, '');
+		add(Number.parseFloat(secondsString, 10), 'second', 's', secondsString);
 	}
 
 	if (result.length === 0) {
@@ -1386,7 +1389,13 @@
 	}
 
 	return options.colonNotation ? result.join('') : result.join(' ');
-}
+};
+
+const ms = prettyMs;
+
+let SOURCEMAPPING_URL = 'sourceMa';
+SOURCEMAPPING_URL += 'ppingURL';
+const SOURCEMAPPING_URL$1 = SOURCEMAPPING_URL;
 
 const BYTE_UNITS = [
 	'B',
@@ -1397,7 +1406,7 @@
 	'PB',
 	'EB',
 	'ZB',
-	'YB',
+	'YB'
 ];
 
 const BIBYTE_UNITS = [
@@ -1409,7 +1418,7 @@
 	'PiB',
 	'EiB',
 	'ZiB',
-	'YiB',
+	'YiB'
 ];
 
 const BIT_UNITS = [
@@ -1421,7 +1430,7 @@
 	'Pbit',
 	'Ebit',
 	'Zbit',
-	'Ybit',
+	'Ybit'
 ];
 
 const BIBIT_UNITS = [
@@ -1433,7 +1442,7 @@
 	'Pibit',
 	'Eibit',
 	'Zibit',
-	'Yibit',
+	'Yibit'
 ];
 
 /*
@@ -1453,20 +1462,16 @@
 	return result;
 };
 
-function prettyBytes(number, options) {
+var prettyBytes = (number, options) => {
 	if (!Number.isFinite(number)) {
 		throw new TypeError(`Expected a finite number, got ${typeof number}: ${number}`);
 	}
 
-	options = {
-		bits: false,
-		binary: false,
-		...options,
-	};
+	options = Object.assign({bits: false, binary: false}, options);
 
-	const UNITS = options.bits
-		? (options.binary ? BIBIT_UNITS : BIT_UNITS)
-		: (options.binary ? BIBYTE_UNITS : BYTE_UNITS);
+	const UNITS = options.bits ?
+		(options.binary ? BIBIT_UNITS : BIT_UNITS) :
+		(options.binary ? BIBYTE_UNITS : BYTE_UNITS);
 
 	if (options.signed && number === 0) {
 		return ` 0 ${UNITS[0]}`;
@@ -1486,7 +1491,7 @@
 	}
 
 	if (options.maximumFractionDigits !== undefined) {
-		localeOptions = {maximumFractionDigits: options.maximumFractionDigits, ...localeOptions};
+		localeOptions = Object.assign({maximumFractionDigits: options.maximumFractionDigits}, localeOptions);
 	}
 
 	if (number < 1) {
@@ -1495,7 +1500,8 @@
 	}
 
 	const exponent = Math.min(Math.floor(options.binary ? Math.log(number) / Math.log(1024) : Math.log10(number) / 3), UNITS.length - 1);
-	number /= (options.binary ? 1024 : 1000) ** exponent;
+	// eslint-disable-next-line unicorn/prefer-exponentiation-operator
+	number /= Math.pow(options.binary ? 1024 : 1000, exponent);
 
 	if (!localeOptions) {
 		number = number.toPrecision(3);
@@ -1506,14 +1512,17 @@
 	const unit = UNITS[exponent];
 
 	return prefix + numberString + ' ' + unit;
-}
+};
+
+const prettyBytes$1 = prettyBytes;
 
 function printTimings(timings) {
-    for (const [label, [time, memory, total]] of Object.entries(timings)) {
-        const appliedColor = label[0] === '#' ? (label[1] === '#' ? rollup.bold : rollup.underline) : (text) => text;
-        const row = `${label}: ${time.toFixed(0)}ms, ${prettyBytes(memory)} / ${prettyBytes(total)}`;
+    Object.keys(timings).forEach(label => {
+        const appliedColor = label[0] === '#' ? (label[1] !== '#' ? loadConfigFile_js.underline : loadConfigFile_js.bold) : (text) => text;
+        const [time, memory, total] = timings[label];
+        const row = `${label}: ${time.toFixed(0)}ms, ${prettyBytes$1(memory)} / ${prettyBytes$1(total)}`;
         console.info(appliedColor(row));
-    }
+    });
 }
 
 async function build(inputOptions, warnings, silent = false) {
@@ -1526,25 +1535,38 @@
         if (typeof inputOptions.input === 'string') {
             inputFiles = inputOptions.input;
         }
-        else if (Array.isArray(inputOptions.input)) {
+        else if (inputOptions.input instanceof Array) {
             inputFiles = inputOptions.input.join(', ');
         }
         else if (typeof inputOptions.input === 'object' && inputOptions.input !== null) {
             inputFiles = Object.values(inputOptions.input).join(', ');
         }
-        rollup.stderr(rollup.cyan(`\n${rollup.bold(inputFiles)} → ${rollup.bold(files.join(', '))}...`));
+        loadConfigFile_js.stderr(loadConfigFile_js.cyan(`\n${loadConfigFile_js.bold(inputFiles)} → ${loadConfigFile_js.bold(files.join(', '))}...`));
     }
     const bundle = await rollup.rollup(inputOptions);
     if (useStdout) {
         const output = outputOptions[0];
         if (output.sourcemap && output.sourcemap !== 'inline') {
-            rollup.handleError(rollup.errorOnlyInlineSourcemapsForStdout());
+            loadConfigFile_js.handleError({
+                code: 'ONLY_INLINE_SOURCEMAPS',
+                message: 'Only inline sourcemaps are supported when bundling to stdout.'
+            });
         }
         const { output: outputs } = await bundle.generate(output);
         for (const file of outputs) {
+            let source;
+            if (file.type === 'asset') {
+                source = file.source;
+            }
+            else {
+                source = file.code;
+                if (output.sourcemap === 'inline') {
+                    source += `\n//# ${SOURCEMAPPING_URL$1}=${file.map.toUrl()}\n`;
+                }
+            }
             if (outputs.length > 1)
-                process$1.stdout.write(`\n${rollup.cyan(rollup.bold(`//→ ${file.fileName}:`))}\n`);
-            process$1.stdout.write(file.type === 'asset' ? file.source : file.code);
+                process.stdout.write(`\n${loadConfigFile_js.cyan(loadConfigFile_js.bold(`//→ ${file.fileName}:`))}\n`);
+            process.stdout.write(source);
         }
         if (!silent) {
             warnings.flush();
@@ -1555,56 +1577,94 @@
     await bundle.close();
     if (!silent) {
         warnings.flush();
-        rollup.stderr(rollup.green(`created ${rollup.bold(files.join(', '))} in ${rollup.bold(prettyMilliseconds(Date.now() - start))}`));
+        loadConfigFile_js.stderr(loadConfigFile_js.green(`created ${loadConfigFile_js.bold(files.join(', '))} in ${loadConfigFile_js.bold(ms(Date.now() - start))}`));
         if (bundle && bundle.getTimings) {
             printTimings(bundle.getTimings());
         }
     }
 }
 
+/*
+relative require
+*/
+
+var path = path$1;
+var Module = require$$1;
+
+var modules = {};
+
+var getModule = function(dir) {
+  var rootPath = dir ? path.resolve(dir) : process.cwd();
+  var rootName = path.join(rootPath, '@root');
+  var root = modules[rootName];
+  if (!root) {
+    root = new Module(rootName);
+    root.filename = rootName;
+    root.paths = Module._nodeModulePaths(rootPath);
+    modules[rootName] = root;
+  }
+  return root;
+};
+
+var requireRelative = function(requested, relativeTo) {
+  var root = getModule(relativeTo);
+  return root.require(requested);
+};
+
+requireRelative.resolve = function(requested, relativeTo) {
+  var root = getModule(relativeTo);
+  return Module._resolveFilename(requested, root);
+};
+
+var requireRelative_1 = requireRelative;
+
+const relative = requireRelative_1;
+
 const DEFAULT_CONFIG_BASE = 'rollup.config';
-async function getConfigPath(commandConfig) {
+function getConfigPath(commandConfig) {
+    const cwd = process.cwd();
     if (commandConfig === true) {
-        return node_path.resolve(await findConfigFileNameInCwd());
+        return path__namespace.resolve(findConfigFileNameInCwd());
     }
     if (commandConfig.slice(0, 5) === 'node:') {
-        const packageName = commandConfig.slice(5);
+        const pkgName = commandConfig.slice(5);
         try {
-            // eslint-disable-next-line unicorn/prefer-module
-            return require.resolve(`rollup-config-${packageName}`, { paths: [process$1.cwd()] });
+            return relative.resolve(`rollup-config-${pkgName}`, cwd);
         }
-        catch {
+        catch (_a) {
             try {
-                // eslint-disable-next-line unicorn/prefer-module
-                return require.resolve(packageName, { paths: [process$1.cwd()] });
+                return relative.resolve(pkgName, cwd);
             }
-            catch (error) {
-                if (error.code === 'MODULE_NOT_FOUND') {
-                    rollup.handleError(rollup.errorMissingExternalConfig(commandConfig));
+            catch (err) {
+                if (err.code === 'MODULE_NOT_FOUND') {
+                    loadConfigFile_js.handleError({
+                        code: 'MISSING_EXTERNAL_CONFIG',
+                        message: `Could not resolve config file "${commandConfig}"`
+                    });
                 }
-                throw error;
+                throw err;
             }
         }
     }
-    return node_path.resolve(commandConfig);
+    return path__namespace.resolve(commandConfig);
 }
-async function findConfigFileNameInCwd() {
-    const filesInWorkingDirectory = new Set(await promises.readdir(process$1.cwd()));
+function findConfigFileNameInCwd() {
+    const filesInWorkingDir = new Set(fs.readdirSync(process.cwd()));
     for (const extension of ['mjs', 'cjs', 'ts']) {
         const fileName = `${DEFAULT_CONFIG_BASE}.${extension}`;
-        if (filesInWorkingDirectory.has(fileName))
+        if (filesInWorkingDir.has(fileName))
             return fileName;
     }
     return `${DEFAULT_CONFIG_BASE}.js`;
 }
 
-async function loadConfigFromCommand(command) {
+function loadConfigFromCommand(command) {
     const warnings = loadConfigFile_js.batchWarnings();
-    if (!command.input && (command.stdin || !process$1.stdin.isTTY)) {
+    if (!command.input && (command.stdin || !process.stdin.isTTY)) {
         command.input = loadConfigFile_js.stdinName;
     }
-    const options = await rollup.mergeOptions({ input: [] }, command, warnings.add);
-    await loadConfigFile_js.addCommandPluginsToInputOptions(options, command);
+    const options = mergeOptions.mergeOptions({ input: [] }, command, warnings.add);
+    loadConfigFile_js.addCommandPluginsToInputOptions(options, command);
     return { options: [options], warnings };
 }
 
@@ -1612,7 +1672,10 @@
     let inputSource;
     if (command._.length > 0) {
         if (command.input) {
-            rollup.handleError(rollup.errorDuplicateImportOptions());
+            loadConfigFile_js.handleError({
+                code: 'DUPLICATE_IMPORT_OPTIONS',
+                message: 'Either use --input, or pass input path as argument'
+            });
         }
         inputSource = command._;
     }
@@ -1623,14 +1686,16 @@
         inputSource = command.input;
     }
     if (inputSource && inputSource.length > 0) {
-        if (inputSource.some((input) => input.includes('='))) {
+        if (inputSource.some((input) => input.indexOf('=') !== -1)) {
             command.input = {};
-            for (const input of inputSource) {
+            inputSource.forEach((input) => {
                 const equalsIndex = input.indexOf('=');
-                const value = input.slice(Math.max(0, equalsIndex + 1));
-                const key = input.slice(0, Math.max(0, equalsIndex)) || rollup.getAliasName(input);
+                const value = input.substr(equalsIndex + 1);
+                let key = input.substr(0, equalsIndex);
+                if (!key)
+                    key = rollup.getAliasName(input);
                 command.input[key] = value;
-            }
+            });
         }
         else {
             command.input = inputSource;
@@ -1640,14 +1705,19 @@
         const environment = Array.isArray(command.environment)
             ? command.environment
             : [command.environment];
-        for (const argument of environment) {
-            for (const pair of argument.split(',')) {
+        environment.forEach((arg) => {
+            arg.split(',').forEach((pair) => {
                 const [key, ...value] = pair.split(':');
-                process$1.env[key] = value.length === 0 ? String(true) : value.join(':');
-            }
-        }
+                if (value.length) {
+                    process.env[key] = value.join(':');
+                }
+                else {
+                    process.env[key] = String(true);
+                }
+            });
+        });
     }
-    if (rollup.isWatchEnabled(command.watch)) {
+    if (command.watch) {
         await rollup.loadFsEvents();
         const { watch } = await Promise.resolve().then(() => require('../shared/watch-cli.js'));
         watch(command);
@@ -1661,33 +1731,36 @@
                 }
                 if (command.failAfterWarnings && warnings.warningOccurred) {
                     warnings.flush();
-                    rollup.handleError(rollup.errorFailAfterWarnings());
+                    loadConfigFile_js.handleError({
+                        code: 'FAIL_AFTER_WARNINGS',
+                        message: 'Warnings occurred and --failAfterWarnings flag present'
+                    });
                 }
             }
-            catch (error) {
+            catch (err) {
                 warnings.flush();
-                rollup.handleError(error);
+                loadConfigFile_js.handleError(err);
             }
         }
-        catch (error) {
-            rollup.handleError(error);
+        catch (err) {
+            loadConfigFile_js.handleError(err);
         }
     }
 }
 async function getConfigs(command) {
     if (command.config) {
-        const configFile = await getConfigPath(command.config);
-        const { options, warnings } = await loadConfigFile_js.loadConfigFile(configFile, command);
+        const configFile = getConfigPath(command.config);
+        const { options, warnings } = await loadConfigFile_js.loadAndParseConfigFile(configFile, command);
         return { options, warnings };
     }
-    return await loadConfigFromCommand(command);
+    return loadConfigFromCommand(command);
 }
 
-const command = argParser(process$1.argv.slice(2), {
-    alias: rollup.commandAliases,
+const command = argParser(process.argv.slice(2), {
+    alias: mergeOptions.commandAliases,
     configuration: { 'camel-case-expansion': false }
 });
-if (command.help || (process$1.argv.length <= 2 && process$1.stdin.isTTY)) {
+if (command.help || (process.argv.length <= 2 && process.stdin.isTTY)) {
     console.log(`\n${help.replace('__VERSION__', rollup.version)}\n`);
 }
 else if (command.version) {
@@ -1695,10 +1768,9 @@
 }
 else {
     try {
-        // eslint-disable-next-line unicorn/prefer-module
         require('source-map-support').install();
     }
-    catch {
+    catch (_a) {
         // do nothing
     }
     runRollup(command);
@@ -1706,6 +1778,6 @@
 
 exports.getConfigPath = getConfigPath;
 exports.loadConfigFromCommand = loadConfigFromCommand;
-exports.prettyMilliseconds = prettyMilliseconds;
+exports.ms = ms;
 exports.printTimings = printTimings;
 //# sourceMappingURL=rollup.map
diff -urN /chromium-112.0.5615.49/third_party/node/node_modules/rollup/dist/es/rollup.browser.js /chromium-111.0.5563.110/third_party/node/node_modules/rollup/dist/es/rollup.browser.js
--- a/third_party/node/node_modules/rollup/dist/es/rollup.browser.js	1970-01-01 00:00:00.000000000 +0000
+++ b/third_party/node/node_modules/rollup/dist/es/rollup.browser.js	2023-01-12 22:12:55.000000000 +0000
@@ -0,0 +1,11 @@
+/*
+  @license
+	Rollup.js v2.58.0
+	Fri, 01 Oct 2021 06:54:03 GMT - commit 3a404a07f41a10d10b7af536f05b90ea46d8ad3d
+
+
+	https://github.com/rollup/rollup
+
+	Released under the MIT License.
+*/
+for(var e="2.58.0",t={},s="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",i=0;i<s.length;i++)t[s.charCodeAt(i)]=i;function n(e,t,s){4===s?e.push([t[0],t[1],t[2],t[3]]):5===s?e.push([t[0],t[1],t[2],t[3],t[4]]):1===s&&e.push([t[0]])}function r(e){var t="";e=e<0?-e<<1|1:e<<1;do{var i=31&e;(e>>>=5)>0&&(i|=32),t+=s[i]}while(e>0);return t}var a=function e(t){this.bits=t instanceof e?t.bits.slice():[]};a.prototype.add=function(e){this.bits[e>>5]|=1<<(31&e)},a.prototype.has=function(e){return!!(this.bits[e>>5]&1<<(31&e))};var o=function(e,t,s){this.start=e,this.end=t,this.original=s,this.intro="",this.outro="",this.content=s,this.storeName=!1,this.edited=!1,Object.defineProperties(this,{previous:{writable:!0,value:null},next:{writable:!0,value:null}})};o.prototype.appendLeft=function(e){this.outro+=e},o.prototype.appendRight=function(e){this.intro=this.intro+e},o.prototype.clone=function(){var e=new o(this.start,this.end,this.original);return e.intro=this.intro,e.outro=this.outro,e.content=this.content,e.storeName=this.storeName,e.edited=this.edited,e},o.prototype.contains=function(e){return this.start<e&&e<this.end},o.prototype.eachNext=function(e){for(var t=this;t;)e(t),t=t.next},o.prototype.eachPrevious=function(e){for(var t=this;t;)e(t),t=t.previous},o.prototype.edit=function(e,t,s){return this.content=e,s||(this.intro="",this.outro=""),this.storeName=t,this.edited=!0,this},o.prototype.prependLeft=function(e){this.outro=e+this.outro},o.prototype.prependRight=function(e){this.intro=e+this.intro},o.prototype.split=function(e){var t=e-this.start,s=this.original.slice(0,t),i=this.original.slice(t);this.original=s;var n=new o(e,this.end,i);return n.outro=this.outro,this.outro="",this.end=e,this.edited?(n.edit("",!1),this.content=""):this.content=s,n.next=this.next,n.next&&(n.next.previous=n),n.previous=this,this.next=n,n},o.prototype.toString=function(){return this.intro+this.content+this.outro},o.prototype.trimEnd=function(e){if(this.outro=this.outro.replace(e,""),this.outro.length)return!0;var t=this.content.replace(e,"");return t.length?(t!==this.content&&this.split(this.start+t.length).edit("",void 0,!0),!0):(this.edit("",void 0,!0),this.intro=this.intro.replace(e,""),!!this.intro.length||void 0)},o.prototype.trimStart=function(e){if(this.intro=this.intro.replace(e,""),this.intro.length)return!0;var t=this.content.replace(e,"");return t.length?(t!==this.content&&(this.split(this.end-t.length),this.edit("",void 0,!0)),!0):(this.edit("",void 0,!0),this.outro=this.outro.replace(e,""),!!this.outro.length||void 0)};var h=function(){throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.")};"undefined"!=typeof window&&"function"==typeof window.btoa?h=function(e){return window.btoa(unescape(encodeURIComponent(e)))}:"function"==typeof Buffer&&(h=function(e){return Buffer.from(e,"utf-8").toString("base64")});var l=function(e){this.version=3,this.file=e.file,this.sources=e.sources,this.sourcesContent=e.sourcesContent,this.names=e.names,this.mappings=function(e){for(var t=0,s=0,i=0,n=0,a="",o=0;o<e.length;o++){var h=e[o];if(o>0&&(a+=";"),0!==h.length){for(var l=0,c=[],u=0,d=h;u<d.length;u++){var p=d[u],f=r(p[0]-l);l=p[0],p.length>1&&(f+=r(p[1]-t)+r(p[2]-s)+r(p[3]-i),t=p[1],s=p[2],i=p[3]),5===p.length&&(f+=r(p[4]-n),n=p[4]),c.push(f)}a+=c.join(",")}}return a}(e.mappings)};function c(e){var t=e.split("\n"),s=t.filter((function(e){return/^\t+/.test(e)})),i=t.filter((function(e){return/^ {2,}/.test(e)}));if(0===s.length&&0===i.length)return null;if(s.length>=i.length)return"\t";var n=i.reduce((function(e,t){var s=/^ +/.exec(t)[0].length;return Math.min(s,e)}),1/0);return new Array(n+1).join(" ")}function u(e,t){var s=e.split(/[/\\]/),i=t.split(/[/\\]/);for(s.pop();s[0]===i[0];)s.shift(),i.shift();if(s.length)for(var n=s.length;n--;)s[n]="..";return s.concat(i).join("/")}l.prototype.toString=function(){return JSON.stringify(this)},l.prototype.toUrl=function(){return"data:application/json;charset=utf-8;base64,"+h(this.toString())};var d=Object.prototype.toString;function p(e){return"[object Object]"===d.call(e)}function f(e){for(var t=e.split("\n"),s=[],i=0,n=0;i<t.length;i++)s.push(n),n+=t[i].length+1;return function(e){for(var t=0,i=s.length;t<i;){var n=t+i>>1;e<s[n]?i=n:t=n+1}var r=t-1;return{line:r,column:e-s[r]}}}var m=function(e){this.hires=e,this.generatedCodeLine=0,this.generatedCodeColumn=0,this.raw=[],this.rawSegments=this.raw[this.generatedCodeLine]=[],this.pending=null};m.prototype.addEdit=function(e,t,s,i){if(t.length){var n=[this.generatedCodeColumn,e,s.line,s.column];i>=0&&n.push(i),this.rawSegments.push(n)}else this.pending&&this.rawSegments.push(this.pending);this.advance(t),this.pending=null},m.prototype.addUneditedChunk=function(e,t,s,i,n){for(var r=t.start,a=!0;r<t.end;)(this.hires||a||n.has(r))&&this.rawSegments.push([this.generatedCodeColumn,e,i.line,i.column]),"\n"===s[r]?(i.line+=1,i.column=0,this.generatedCodeLine+=1,this.raw[this.generatedCodeLine]=this.rawSegments=[],this.generatedCodeColumn=0,a=!0):(i.column+=1,this.generatedCodeColumn+=1,a=!1),r+=1;this.pending=null},m.prototype.advance=function(e){if(e){var t=e.split("\n");if(t.length>1){for(var s=0;s<t.length-1;s++)this.generatedCodeLine++,this.raw[this.generatedCodeLine]=this.rawSegments=[];this.generatedCodeColumn=0}this.generatedCodeColumn+=t[t.length-1].length}};var g="\n",y={insertLeft:!1,insertRight:!1,storeName:!1},E=function(e,t){void 0===t&&(t={});var s=new o(0,e.length,e);Object.defineProperties(this,{original:{writable:!0,value:e},outro:{writable:!0,value:""},intro:{writable:!0,value:""},firstChunk:{writable:!0,value:s},lastChunk:{writable:!0,value:s},lastSearchedChunk:{writable:!0,value:s},byStart:{writable:!0,value:{}},byEnd:{writable:!0,value:{}},filename:{writable:!0,value:t.filename},indentExclusionRanges:{writable:!0,value:t.indentExclusionRanges},sourcemapLocations:{writable:!0,value:new a},storedNames:{writable:!0,value:{}},indentStr:{writable:!0,value:c(e)}}),this.byStart[0]=s,this.byEnd[e.length]=s};E.prototype.addSourcemapLocation=function(e){this.sourcemapLocations.add(e)},E.prototype.append=function(e){if("string"!=typeof e)throw new TypeError("outro content must be a string");return this.outro+=e,this},E.prototype.appendLeft=function(e,t){if("string"!=typeof t)throw new TypeError("inserted content must be a string");this._split(e);var s=this.byEnd[e];return s?s.appendLeft(t):this.intro+=t,this},E.prototype.appendRight=function(e,t){if("string"!=typeof t)throw new TypeError("inserted content must be a string");this._split(e);var s=this.byStart[e];return s?s.appendRight(t):this.outro+=t,this},E.prototype.clone=function(){for(var e=new E(this.original,{filename:this.filename}),t=this.firstChunk,s=e.firstChunk=e.lastSearchedChunk=t.clone();t;){e.byStart[s.start]=s,e.byEnd[s.end]=s;var i=t.next,n=i&&i.clone();n&&(s.next=n,n.previous=s,s=n),t=i}return e.lastChunk=s,this.indentExclusionRanges&&(e.indentExclusionRanges=this.indentExclusionRanges.slice()),e.sourcemapLocations=new a(this.sourcemapLocations),e.intro=this.intro,e.outro=this.outro,e},E.prototype.generateDecodedMap=function(e){var t=this;e=e||{};var s=Object.keys(this.storedNames),i=new m(e.hires),n=f(this.original);return this.intro&&i.advance(this.intro),this.firstChunk.eachNext((function(e){var r=n(e.start);e.intro.length&&i.advance(e.intro),e.edited?i.addEdit(0,e.content,r,e.storeName?s.indexOf(e.original):-1):i.addUneditedChunk(0,e,t.original,r,t.sourcemapLocations),e.outro.length&&i.advance(e.outro)})),{file:e.file?e.file.split(/[/\\]/).pop():null,sources:[e.source?u(e.file||"",e.source):null],sourcesContent:e.includeContent?[this.original]:[null],names:s,mappings:i.raw}},E.prototype.generateMap=function(e){return new l(this.generateDecodedMap(e))},E.prototype.getIndentString=function(){return null===this.indentStr?"\t":this.indentStr},E.prototype.indent=function(e,t){var s=/^[^\r\n]/gm;if(p(e)&&(t=e,e=void 0),""===(e=void 0!==e?e:this.indentStr||"\t"))return this;var i={};(t=t||{}).exclude&&("number"==typeof t.exclude[0]?[t.exclude]:t.exclude).forEach((function(e){for(var t=e[0];t<e[1];t+=1)i[t]=!0}));var n=!1!==t.indentStart,r=function(t){return n?""+e+t:(n=!0,t)};this.intro=this.intro.replace(s,r);for(var a=0,o=this.firstChunk;o;){var h=o.end;if(o.edited)i[a]||(o.content=o.content.replace(s,r),o.content.length&&(n="\n"===o.content[o.content.length-1]));else for(a=o.start;a<h;){if(!i[a]){var l=this.original[a];"\n"===l?n=!0:"\r"!==l&&n&&(n=!1,a===o.start?o.prependRight(e):(this._splitChunk(o,a),(o=o.next).prependRight(e)))}a+=1}a=o.end,o=o.next}return this.outro=this.outro.replace(s,r),this},E.prototype.insert=function(){throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)")},E.prototype.insertLeft=function(e,t){return y.insertLeft||(console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"),y.insertLeft=!0),this.appendLeft(e,t)},E.prototype.insertRight=function(e,t){return y.insertRight||(console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"),y.insertRight=!0),this.prependRight(e,t)},E.prototype.move=function(e,t,s){if(s>=e&&s<=t)throw new Error("Cannot move a selection inside itself");this._split(e),this._split(t),this._split(s);var i=this.byStart[e],n=this.byEnd[t],r=i.previous,a=n.next,o=this.byStart[s];if(!o&&n===this.lastChunk)return this;var h=o?o.previous:this.lastChunk;return r&&(r.next=a),a&&(a.previous=r),h&&(h.next=i),o&&(o.previous=n),i.previous||(this.firstChunk=n.next),n.next||(this.lastChunk=i.previous,this.lastChunk.next=null),i.previous=h,n.next=o||null,h||(this.firstChunk=i),o||(this.lastChunk=n),this},E.prototype.overwrite=function(e,t,s,i){if("string"!=typeof s)throw new TypeError("replacement content must be a string");for(;e<0;)e+=this.original.length;for(;t<0;)t+=this.original.length;if(t>this.original.length)throw new Error("end is out of bounds");if(e===t)throw new Error("Cannot overwrite a zero-length range – use appendLeft or prependRight instead");this._split(e),this._split(t),!0===i&&(y.storeName||(console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"),y.storeName=!0),i={storeName:!0});var n=void 0!==i&&i.storeName,r=void 0!==i&&i.contentOnly;if(n){var a=this.original.slice(e,t);this.storedNames[a]=!0}var h=this.byStart[e],l=this.byEnd[t];if(h){if(t>h.end&&h.next!==this.byStart[h.end])throw new Error("Cannot overwrite across a split point");if(h.edit(s,n,r),h!==l){for(var c=h.next;c!==l;)c.edit("",!1),c=c.next;c.edit("",!1)}}else{var u=new o(e,t,"").edit(s,n);l.next=u,u.previous=l}return this},E.prototype.prepend=function(e){if("string"!=typeof e)throw new TypeError("outro content must be a string");return this.intro=e+this.intro,this},E.prototype.prependLeft=function(e,t){if("string"!=typeof t)throw new TypeError("inserted content must be a string");this._split(e);var s=this.byEnd[e];return s?s.prependLeft(t):this.intro=t+this.intro,this},E.prototype.prependRight=function(e,t){if("string"!=typeof t)throw new TypeError("inserted content must be a string");this._split(e);var s=this.byStart[e];return s?s.prependRight(t):this.outro=t+this.outro,this},E.prototype.remove=function(e,t){for(;e<0;)e+=this.original.length;for(;t<0;)t+=this.original.length;if(e===t)return this;if(e<0||t>this.original.length)throw new Error("Character is out of bounds");if(e>t)throw new Error("end must be greater than start");this._split(e),this._split(t);for(var s=this.byStart[e];s;)s.intro="",s.outro="",s.edit(""),s=t>s.end?this.byStart[s.end]:null;return this},E.prototype.lastChar=function(){if(this.outro.length)return this.outro[this.outro.length-1];var e=this.lastChunk;do{if(e.outro.length)return e.outro[e.outro.length-1];if(e.content.length)return e.content[e.content.length-1];if(e.intro.length)return e.intro[e.intro.length-1]}while(e=e.previous);return this.intro.length?this.intro[this.intro.length-1]:""},E.prototype.lastLine=function(){var e=this.outro.lastIndexOf(g);if(-1!==e)return this.outro.substr(e+1);var t=this.outro,s=this.lastChunk;do{if(s.outro.length>0){if(-1!==(e=s.outro.lastIndexOf(g)))return s.outro.substr(e+1)+t;t=s.outro+t}if(s.content.length>0){if(-1!==(e=s.content.lastIndexOf(g)))return s.content.substr(e+1)+t;t=s.content+t}if(s.intro.length>0){if(-1!==(e=s.intro.lastIndexOf(g)))return s.intro.substr(e+1)+t;t=s.intro+t}}while(s=s.previous);return-1!==(e=this.intro.lastIndexOf(g))?this.intro.substr(e+1)+t:this.intro+t},E.prototype.slice=function(e,t){for(void 0===e&&(e=0),void 0===t&&(t=this.original.length);e<0;)e+=this.original.length;for(;t<0;)t+=this.original.length;for(var s="",i=this.firstChunk;i&&(i.start>e||i.end<=e);){if(i.start<t&&i.end>=t)return s;i=i.next}if(i&&i.edited&&i.start!==e)throw new Error("Cannot use replaced character "+e+" as slice start anchor.");for(var n=i;i;){!i.intro||n===i&&i.start!==e||(s+=i.intro);var r=i.start<t&&i.end>=t;if(r&&i.edited&&i.end!==t)throw new Error("Cannot use replaced character "+t+" as slice end anchor.");var a=n===i?e-i.start:0,o=r?i.content.length+t-i.end:i.content.length;if(s+=i.content.slice(a,o),!i.outro||r&&i.end!==t||(s+=i.outro),r)break;i=i.next}return s},E.prototype.snip=function(e,t){var s=this.clone();return s.remove(0,e),s.remove(t,s.original.length),s},E.prototype._split=function(e){if(!this.byStart[e]&&!this.byEnd[e])for(var t=this.lastSearchedChunk,s=e>t.end;t;){if(t.contains(e))return this._splitChunk(t,e);t=s?this.byStart[t.end]:this.byEnd[t.start]}},E.prototype._splitChunk=function(e,t){if(e.edited&&e.content.length){var s=f(this.original)(t);throw new Error("Cannot split a chunk that has already been edited ("+s.line+":"+s.column+' – "'+e.original+'")')}var i=e.split(t);return this.byEnd[t]=e,this.byStart[t]=i,this.byEnd[i.end]=i,e===this.lastChunk&&(this.lastChunk=i),this.lastSearchedChunk=e,!0},E.prototype.toString=function(){for(var e=this.intro,t=this.firstChunk;t;)e+=t.toString(),t=t.next;return e+this.outro},E.prototype.isEmpty=function(){var e=this.firstChunk;do{if(e.intro.length&&e.intro.trim()||e.content.length&&e.content.trim()||e.outro.length&&e.outro.trim())return!1}while(e=e.next);return!0},E.prototype.length=function(){var e=this.firstChunk,t=0;do{t+=e.intro.length+e.content.length+e.outro.length}while(e=e.next);return t},E.prototype.trimLines=function(){return this.trim("[\\r\\n]")},E.prototype.trim=function(e){return this.trimStart(e).trimEnd(e)},E.prototype.trimEndAborted=function(e){var t=new RegExp((e||"\\s")+"+$");if(this.outro=this.outro.replace(t,""),this.outro.length)return!0;var s=this.lastChunk;do{var i=s.end,n=s.trimEnd(t);if(s.end!==i&&(this.lastChunk===s&&(this.lastChunk=s.next),this.byEnd[s.end]=s,this.byStart[s.next.start]=s.next,this.byEnd[s.next.end]=s.next),n)return!0;s=s.previous}while(s);return!1},E.prototype.trimEnd=function(e){return this.trimEndAborted(e),this},E.prototype.trimStartAborted=function(e){var t=new RegExp("^"+(e||"\\s")+"+");if(this.intro=this.intro.replace(t,""),this.intro.length)return!0;var s=this.firstChunk;do{var i=s.end,n=s.trimStart(t);if(s.end!==i&&(s===this.lastChunk&&(this.lastChunk=s.next),this.byEnd[s.end]=s,this.byStart[s.next.start]=s.next,this.byEnd[s.next.end]=s.next),n)return!0;s=s.next}while(s);return!1},E.prototype.trimStart=function(e){return this.trimStartAborted(e),this};var x=Object.prototype.hasOwnProperty,v=function(e){void 0===e&&(e={}),this.intro=e.intro||"",this.separator=void 0!==e.separator?e.separator:"\n",this.sources=[],this.uniqueSources=[],this.uniqueSourceIndexByFilename={}};v.prototype.addSource=function(e){if(e instanceof E)return this.addSource({content:e,filename:e.filename,separator:this.separator});if(!p(e)||!e.content)throw new Error("bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`");if(["filename","indentExclusionRanges","separator"].forEach((function(t){x.call(e,t)||(e[t]=e.content[t])})),void 0===e.separator&&(e.separator=this.separator),e.filename)if(x.call(this.uniqueSourceIndexByFilename,e.filename)){var t=this.uniqueSources[this.uniqueSourceIndexByFilename[e.filename]];if(e.content.original!==t.content)throw new Error("Illegal source: same filename ("+e.filename+"), different contents")}else this.uniqueSourceIndexByFilename[e.filename]=this.uniqueSources.length,this.uniqueSources.push({filename:e.filename,content:e.content.original});return this.sources.push(e),this},v.prototype.append=function(e,t){return this.addSource({content:new E(e),separator:t&&t.separator||""}),this},v.prototype.clone=function(){var e=new v({intro:this.intro,separator:this.separator});return this.sources.forEach((function(t){e.addSource({filename:t.filename,content:t.content.clone(),separator:t.separator})})),e},v.prototype.generateDecodedMap=function(e){var t=this;void 0===e&&(e={});var s=[];this.sources.forEach((function(e){Object.keys(e.content.storedNames).forEach((function(e){~s.indexOf(e)||s.push(e)}))}));var i=new m(e.hires);return this.intro&&i.advance(this.intro),this.sources.forEach((function(e,n){n>0&&i.advance(t.separator);var r=e.filename?t.uniqueSourceIndexByFilename[e.filename]:-1,a=e.content,o=f(a.original);a.intro&&i.advance(a.intro),a.firstChunk.eachNext((function(t){var n=o(t.start);t.intro.length&&i.advance(t.intro),e.filename?t.edited?i.addEdit(r,t.content,n,t.storeName?s.indexOf(t.original):-1):i.addUneditedChunk(r,t,a.original,n,a.sourcemapLocations):i.advance(t.content),t.outro.length&&i.advance(t.outro)})),a.outro&&i.advance(a.outro)})),{file:e.file?e.file.split(/[/\\]/).pop():null,sources:this.uniqueSources.map((function(t){return e.file?u(e.file,t.filename):t.filename})),sourcesContent:this.uniqueSources.map((function(t){return e.includeContent?t.content:null})),names:s,mappings:i.raw}},v.prototype.generateMap=function(e){return new l(this.generateDecodedMap(e))},v.prototype.getIndentString=function(){var e={};return this.sources.forEach((function(t){var s=t.content.indentStr;null!==s&&(e[s]||(e[s]=0),e[s]+=1)})),Object.keys(e).sort((function(t,s){return e[t]-e[s]}))[0]||"\t"},v.prototype.indent=function(e){var t=this;if(arguments.length||(e=this.getIndentString()),""===e)return this;var s=!this.intro||"\n"===this.intro.slice(-1);return this.sources.forEach((function(i,n){var r=void 0!==i.separator?i.separator:t.separator,a=s||n>0&&/\r?\n$/.test(r);i.content.indent(e,{exclude:i.indentExclusionRanges,indentStart:a}),s="\n"===i.content.lastChar()})),this.intro&&(this.intro=e+this.intro.replace(/^[^\n]/gm,(function(t,s){return s>0?e+t:t}))),this},v.prototype.prepend=function(e){return this.intro=e+this.intro,this},v.prototype.toString=function(){var e=this,t=this.sources.map((function(t,s){var i=void 0!==t.separator?t.separator:e.separator;return(s>0?i:"")+t.content.toString()})).join("");return this.intro+t},v.prototype.isEmpty=function(){return(!this.intro.length||!this.intro.trim())&&!this.sources.some((function(e){return!e.content.isEmpty()}))},v.prototype.length=function(){return this.sources.reduce((function(e,t){return e+t.content.length()}),this.intro.length)},v.prototype.trimLines=function(){return this.trim("[\\r\\n]")},v.prototype.trim=function(e){return this.trimStart(e).trimEnd(e)},v.prototype.trimStart=function(e){var t=new RegExp("^"+(e||"\\s")+"+");if(this.intro=this.intro.replace(t,""),!this.intro){var s,i=0;do{if(!(s=this.sources[i++]))break}while(!s.content.trimStartAborted(e))}return this},v.prototype.trimEnd=function(e){var t,s=new RegExp((e||"\\s")+"+$"),i=this.sources.length-1;do{if(!(t=this.sources[i--])){this.intro=this.intro.replace(s,"");break}}while(!t.content.trimEndAborted(e));return this};var b=E;const S=/^(?:\/|(?:[A-Za-z]:)?[\\|/])/,A=/^\.?\.\//;function P(e){return S.test(e)}function k(e){return A.test(e)}function w(e){return e.replace(/\\/g,"/")}function C(e){return e.split(/[/\\]/).pop()||""}function I(e){const t=/[/\\][^/\\]*$/.exec(e);if(!t)return".";const s=e.slice(0,-t[0].length);return s||"/"}function N(e){const t=/\.[^.]+$/.exec(C(e));return t?t[0]:""}function _(e,t){const s=e.split(/[/\\]/).filter(Boolean),i=t.split(/[/\\]/).filter(Boolean);for("."===s[0]&&s.shift(),"."===i[0]&&i.shift();s[0]&&i[0]&&s[0]===i[0];)s.shift(),i.shift();for(;".."===i[0]&&s.length>0;)i.shift(),s.pop();for(;s.pop();)i.unshift("..");return i.join("/")}function $(...e){const t=e.shift();if(!t)return"/";let s=t.split(/[/\\]/);for(const t of e)if(P(t))s=t.split(/[/\\]/);else{const e=t.split(/[/\\]/);for(;"."===e[0]||".."===e[0];){".."===e.shift()&&s.pop()}s.push(...e)}return s.join("/")}function T(e,t,s){const i=e.get(t);if(i)return i;const n=s();return e.set(t,n),n}const R=Symbol("Unknown Key"),M=Symbol("Unknown Integer"),D=[],L=[R],O=[M],V=Symbol("Entities");class B{constructor(){this.entityPaths=Object.create(null,{[V]:{value:new Set}})}trackEntityAtPathAndGetIfTracked(e,t){const s=this.getEntities(e);return!!s.has(t)||(s.add(t),!1)}withTrackedEntityAtPath(e,t,s,i){const n=this.getEntities(e);if(n.has(t))return i;n.add(t);const r=s();return n.delete(t),r}getEntities(e){let t=this.entityPaths;for(const s of e)t=t[s]=t[s]||Object.create(null,{[V]:{value:new Set}});return t[V]}}const F=new B;class z{constructor(){this.entityPaths=Object.create(null,{[V]:{value:new Map}})}trackEntityAtPathAndGetIfTracked(e,t,s){let i=this.entityPaths;for(const t of e)i=i[t]=i[t]||Object.create(null,{[V]:{value:new Map}});const n=T(i[V],t,(()=>new Set));return!!n.has(s)||(n.add(s),!1)}}const W=Symbol("Unknown Value");class j{constructor(){this.included=!1}deoptimizePath(e){}deoptimizeThisOnEventAtPath(e,t,s,i){s.deoptimizePath(L)}getLiteralValueAtPath(e,t,s){return W}getReturnExpressionWhenCalledAtPath(e,t,s,i){return U}hasEffectsWhenAccessedAtPath(e,t){return!0}hasEffectsWhenAssignedAtPath(e,t){return!0}hasEffectsWhenCalledAtPath(e,t,s){return!0}include(e,t){this.included=!0}includeCallArguments(e,t){for(const s of t)s.include(e,!1)}}const U=new class extends j{};class G extends j{constructor(e){super(),this.name=e,this.alwaysRendered=!1,this.initReached=!1,this.isId=!1,this.isReassigned=!1,this.kind=null,this.renderBaseName=null,this.renderName=null}addReference(e){}getBaseVariableName(){return this.renderBaseName||this.renderName||this.name}getName(e){const t=this.renderName||this.name;return this.renderBaseName?`${this.renderBaseName}${e(t)}`:t}hasEffectsWhenAccessedAtPath(e,t){return e.length>0}include(){this.included=!0}markCalledFromTryStatement(){}setRenderNames(e,t){this.renderBaseName=e,this.renderName=t}}class H extends G{constructor(e,t){super(t),this.referenced=!1,this.module=e,this.isNamespace="*"===t}addReference(e){this.referenced=!0,"default"!==this.name&&"*"!==this.name||this.module.suggestName(e.name)}hasEffectsWhenAccessedAtPath(e){return e.length>(this.isNamespace?1:0)}include(){this.included||(this.included=!0,this.module.used=!0)}}const q=Object.freeze(Object.create(null)),K=Object.freeze({}),X=Object.freeze([]),Y="break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public".split(" "),Q="Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl".split(" "),Z=new Set(Y.concat(Q)),J=/[^$_a-zA-Z0-9]/g,ee=e=>/\d/.test(e[0]);function te(e){return e=e.replace(/-(\w)/g,((e,t)=>t.toUpperCase())).replace(J,"_"),(ee(e)||Z.has(e))&&(e=`_${e}`),e||"_"}function se(e,t){const s=e.length<=1,i=e.map((e=>`"${e}"`));let n=s?i[0]:`${i.slice(0,-1).join(", ")} and ${i.slice(-1)[0]}`;return t&&(n+=` ${s?t[0]:t[1]}`),n}function ie(e){const t=C(e);return t.substr(0,t.length-N(e).length)}function ne(e){return P(e)?_($(),e):e}function re(e){return"/"===e[0]||"."===e[0]&&("/"===e[1]||"."===e[1])||P(e)}class ae{constructor(e,t,s,i,n){this.options=e,this.id=t,this.renormalizeRenderPath=n,this.declarations=Object.create(null),this.defaultVariableName="",this.dynamicImporters=[],this.execIndex=1/0,this.exportedVariables=new Map,this.importers=[],this.mostCommonSuggestion=0,this.nameSuggestions=Object.create(null),this.namespaceVariableName="",this.reexported=!1,this.renderPath=void 0,this.used=!1,this.variableName="",this.suggestedVariableName=te(t.split(/[\\/]/).pop());const{importers:r,dynamicImporters:a}=this;this.info={ast:null,code:null,dynamicallyImportedIds:X,get dynamicImporters(){return a.sort()},hasModuleSideEffects:s,id:t,implicitlyLoadedAfterOneOf:X,implicitlyLoadedBefore:X,importedIds:X,get importers(){return r.sort()},isEntry:!1,isExternal:!0,meta:i,syntheticNamedExports:!1}}getVariableForExportName(e){let t=this.declarations[e];return t||(this.declarations[e]=t=new H(this,e),this.exportedVariables.set(t,e),t)}setRenderPath(e,t){return this.renderPath="function"==typeof e.paths?e.paths(this.id):e.paths[this.id],this.renderPath||(this.renderPath=this.renormalizeRenderPath?w(_(t,this.id)):this.id),this.renderPath}suggestName(e){this.nameSuggestions[e]||(this.nameSuggestions[e]=0),this.nameSuggestions[e]+=1,this.nameSuggestions[e]>this.mostCommonSuggestion&&(this.mostCommonSuggestion=this.nameSuggestions[e],this.suggestedVariableName=e)}warnUnusedImports(){const e=Object.keys(this.declarations).filter((e=>{if("*"===e)return!1;const t=this.declarations[e];return!t.included&&!this.reexported&&!t.referenced}));if(0===e.length)return;const t=new Set;for(const s of e){const{importers:e}=this.declarations[s].module;for(const s of e)t.add(s)}const s=[...t];this.options.onwarn({code:"UNUSED_EXTERNAL_IMPORT",message:`${se(e,["is","are"])} imported from external module "${this.id}" but never used in ${se(s.map((e=>ne(e))))}.`,names:e,source:this.id,sources:s})}}const oe={ArrayPattern(e,t){for(const s of t.elements)s&&oe[s.type](e,s)},AssignmentPattern(e,t){oe[t.left.type](e,t.left)},Identifier(e,t){e.push(t.name)},MemberExpression(){},ObjectPattern(e,t){for(const s of t.properties)"RestElement"===s.type?oe.RestElement(e,s):oe[s.value.type](e,s.value)},RestElement(e,t){oe[t.argument.type](e,t.argument)}},he=function(e){const t=[];return oe[e.type](t,e),t};function le(e,t,s){if("number"==typeof s)throw new Error("locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument");return function(e,t){void 0===t&&(t={});var s=t.offsetLine||0,i=t.offsetColumn||0,n=e.split("\n"),r=0,a=n.map((function(e,t){var s=r+e.length+1,i={start:r,end:s,line:t};return r=s,i})),o=0;function h(e,t){return e.start<=t&&t<e.end}function l(e,t){return{line:s+e.line,column:i+t-e.start,character:t}}return function(t,s){"string"==typeof t&&(t=e.indexOf(t,s||0));for(var i=a[o],n=t>=i.end?1:-1;i;){if(h(i,t))return l(i,t);i=a[o+=n]}}}(e,s)(t,s&&s.startIndex)}new Set("break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl".split(" ")).add("");function ce(){return{brokenFlow:0,includedCallArguments:new Set,includedLabels:new Set}}function ue(){return{accessed:new B,assigned:new B,brokenFlow:0,called:new z,ignore:{breaks:!1,continues:!1,labels:new Set,returnYield:!1},includedLabels:new Set,instantiated:new z,replacedVariableInits:new Map}}function de(e,t,s){s(e,t)}function pe(e,t,s){}var fe={};fe.Program=fe.BlockStatement=fe.StaticBlock=function(e,t,s){for(var i=0,n=e.body;i<n.length;i+=1){s(n[i],t,"Statement")}},fe.Statement=de,fe.EmptyStatement=pe,fe.ExpressionStatement=fe.ParenthesizedExpression=fe.ChainExpression=function(e,t,s){return s(e.expression,t,"Expression")},fe.IfStatement=function(e,t,s){s(e.test,t,"Expression"),s(e.consequent,t,"Statement"),e.alternate&&s(e.alternate,t,"Statement")},fe.LabeledStatement=function(e,t,s){return s(e.body,t,"Statement")},fe.BreakStatement=fe.ContinueStatement=pe,fe.WithStatement=function(e,t,s){s(e.object,t,"Expression"),s(e.body,t,"Statement")},fe.SwitchStatement=function(e,t,s){s(e.discriminant,t,"Expression");for(var i=0,n=e.cases;i<n.length;i+=1){var r=n[i];r.test&&s(r.test,t,"Expression");for(var a=0,o=r.consequent;a<o.length;a+=1){s(o[a],t,"Statement")}}},fe.SwitchCase=function(e,t,s){e.test&&s(e.test,t,"Expression");for(var i=0,n=e.consequent;i<n.length;i+=1){s(n[i],t,"Statement")}},fe.ReturnStatement=fe.YieldExpression=fe.AwaitExpression=function(e,t,s){e.argument&&s(e.argument,t,"Expression")},fe.ThrowStatement=fe.SpreadElement=function(e,t,s){return s(e.argument,t,"Expression")},fe.TryStatement=function(e,t,s){s(e.block,t,"Statement"),e.handler&&s(e.handler,t),e.finalizer&&s(e.finalizer,t,"Statement")},fe.CatchClause=function(e,t,s){e.param&&s(e.param,t,"Pattern"),s(e.body,t,"Statement")},fe.WhileStatement=fe.DoWhileStatement=function(e,t,s){s(e.test,t,"Expression"),s(e.body,t,"Statement")},fe.ForStatement=function(e,t,s){e.init&&s(e.init,t,"ForInit"),e.test&&s(e.test,t,"Expression"),e.update&&s(e.update,t,"Expression"),s(e.body,t,"Statement")},fe.ForInStatement=fe.ForOfStatement=function(e,t,s){s(e.left,t,"ForInit"),s(e.right,t,"Expression"),s(e.body,t,"Statement")},fe.ForInit=function(e,t,s){"VariableDeclaration"===e.type?s(e,t):s(e,t,"Expression")},fe.DebuggerStatement=pe,fe.FunctionDeclaration=function(e,t,s){return s(e,t,"Function")},fe.VariableDeclaration=function(e,t,s){for(var i=0,n=e.declarations;i<n.length;i+=1){s(n[i],t)}},fe.VariableDeclarator=function(e,t,s){s(e.id,t,"Pattern"),e.init&&s(e.init,t,"Expression")},fe.Function=function(e,t,s){e.id&&s(e.id,t,"Pattern");for(var i=0,n=e.params;i<n.length;i+=1){s(n[i],t,"Pattern")}s(e.body,t,e.expression?"Expression":"Statement")},fe.Pattern=function(e,t,s){"Identifier"===e.type?s(e,t,"VariablePattern"):"MemberExpression"===e.type?s(e,t,"MemberPattern"):s(e,t)},fe.VariablePattern=pe,fe.MemberPattern=de,fe.RestElement=function(e,t,s){return s(e.argument,t,"Pattern")},fe.ArrayPattern=function(e,t,s){for(var i=0,n=e.elements;i<n.length;i+=1){var r=n[i];r&&s(r,t,"Pattern")}},fe.ObjectPattern=function(e,t,s){for(var i=0,n=e.properties;i<n.length;i+=1){var r=n[i];"Property"===r.type?(r.computed&&s(r.key,t,"Expression"),s(r.value,t,"Pattern")):"RestElement"===r.type&&s(r.argument,t,"Pattern")}},fe.Expression=de,fe.ThisExpression=fe.Super=fe.MetaProperty=pe,fe.ArrayExpression=function(e,t,s){for(var i=0,n=e.elements;i<n.length;i+=1){var r=n[i];r&&s(r,t,"Expression")}},fe.ObjectExpression=function(e,t,s){for(var i=0,n=e.properties;i<n.length;i+=1){s(n[i],t)}},fe.FunctionExpression=fe.ArrowFunctionExpression=fe.FunctionDeclaration,fe.SequenceExpression=function(e,t,s){for(var i=0,n=e.expressions;i<n.length;i+=1){s(n[i],t,"Expression")}},fe.TemplateLiteral=function(e,t,s){for(var i=0,n=e.quasis;i<n.length;i+=1){s(n[i],t)}for(var r=0,a=e.expressions;r<a.length;r+=1){s(a[r],t,"Expression")}},fe.TemplateElement=pe,fe.UnaryExpression=fe.UpdateExpression=function(e,t,s){s(e.argument,t,"Expression")},fe.BinaryExpression=fe.LogicalExpression=function(e,t,s){s(e.left,t,"Expression"),s(e.right,t,"Expression")},fe.AssignmentExpression=fe.AssignmentPattern=function(e,t,s){s(e.left,t,"Pattern"),s(e.right,t,"Expression")},fe.ConditionalExpression=function(e,t,s){s(e.test,t,"Expression"),s(e.consequent,t,"Expression"),s(e.alternate,t,"Expression")},fe.NewExpression=fe.CallExpression=function(e,t,s){if(s(e.callee,t,"Expression"),e.arguments)for(var i=0,n=e.arguments;i<n.length;i+=1){s(n[i],t,"Expression")}},fe.MemberExpression=function(e,t,s){s(e.object,t,"Expression"),e.computed&&s(e.property,t,"Expression")},fe.ExportNamedDeclaration=fe.ExportDefaultDeclaration=function(e,t,s){e.declaration&&s(e.declaration,t,"ExportNamedDeclaration"===e.type||e.declaration.id?"Statement":"Expression"),e.source&&s(e.source,t,"Expression")},fe.ExportAllDeclaration=function(e,t,s){e.exported&&s(e.exported,t),s(e.source,t,"Expression")},fe.ImportDeclaration=function(e,t,s){for(var i=0,n=e.specifiers;i<n.length;i+=1){s(n[i],t)}s(e.source,t,"Expression")},fe.ImportExpression=function(e,t,s){s(e.source,t,"Expression")},fe.ImportSpecifier=fe.ImportDefaultSpecifier=fe.ImportNamespaceSpecifier=fe.Identifier=fe.PrivateIdentifier=fe.Literal=pe,fe.TaggedTemplateExpression=function(e,t,s){s(e.tag,t,"Expression"),s(e.quasi,t,"Expression")},fe.ClassDeclaration=fe.ClassExpression=function(e,t,s){return s(e,t,"Class")},fe.Class=function(e,t,s){e.id&&s(e.id,t,"Pattern"),e.superClass&&s(e.superClass,t,"Expression"),s(e.body,t)},fe.ClassBody=function(e,t,s){for(var i=0,n=e.body;i<n.length;i+=1){s(n[i],t)}},fe.MethodDefinition=fe.PropertyDefinition=fe.Property=function(e,t,s){e.computed&&s(e.key,t,"Expression"),e.value&&s(e.value,t,"Expression")};let me="sourceMa";me+="ppingURL";const ge=new RegExp("^#[ \\f\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]+sourceMappingURL=.+");fe.PropertyDefinition=function(e,t,s){e.computed&&s(e.key,t,"Expression"),e.value&&s(e.value,t,"Expression")};function ye(e,t,s=e.type){const{annotations:i}=t;let n=i[t.annotationIndex];for(;n&&e.start>=n.end;)ve(e,n,t.code),n=i[++t.annotationIndex];if(n&&n.end<=e.end)for(fe[s](e,t,ye);(n=i[t.annotationIndex])&&n.end<=e.end;)++t.annotationIndex,Ae(e,n,!1)}const Ee=/[^\s(]/g,xe=/\S/g;function ve(e,t,s){const i=[];let n;if(be(s.slice(t.end,e.start),Ee)){const t=e.start;for(;;){switch(i.push(e),e.type){case"ExpressionStatement":case"ChainExpression":e=e.expression;continue;case"SequenceExpression":if(be(s.slice(t,e.start),xe)){e=e.expressions[0];continue}n=!0;break;case"ConditionalExpression":if(be(s.slice(t,e.start),xe)){e=e.test;continue}n=!0;break;case"LogicalExpression":case"BinaryExpression":if(be(s.slice(t,e.start),xe)){e=e.left;continue}n=!0;break;case"CallExpression":case"NewExpression":break;default:n=!0}break}}else n=!0;if(n)Ae(e,t,!1);else for(const e of i)Ae(e,t,!0)}function be(e,t){let s;for(;null!==(s=t.exec(e));){if("/"===s[0]){const s=e.charCodeAt(t.lastIndex);if(42===s){t.lastIndex=e.indexOf("*/",t.lastIndex+1)+2;continue}if(47===s){t.lastIndex=e.indexOf("\n",t.lastIndex+1)+1;continue}}return t.lastIndex=0,!1}return!0}const Se=/[@#]__PURE__/;function Ae(e,t,s){const i=s?"_rollupAnnotations":"_rollupRemoved",n=e[i];n?n.push(t):e[i]=[t]}const Pe={Literal:[],Program:["body"]};class ke extends j{constructor(e,t,s){super(),this.esTreeNode=e,this.keys=Pe[e.type]||function(e){return Pe[e.type]=Object.keys(e).filter((t=>"object"==typeof e[t]&&95!==t.charCodeAt(0))),Pe[e.type]}(e),this.parent=t,this.context=t.context,this.createScope(s),this.parseNode(e),this.initialise(),this.context.magicString.addSourcemapLocation(this.start),this.context.magicString.addSourcemapLocation(this.end)}addExportedVariables(e,t){}bind(){for(const e of this.keys){const t=this[e];if(null!==t)if(Array.isArray(t))for(const e of t)null!==e&&e.bind();else t.bind()}}createScope(e){this.scope=e}hasEffects(e){!1===this.deoptimized&&this.applyDeoptimizations();for(const t of this.keys){const s=this[t];if(null!==s)if(Array.isArray(s)){for(const t of s)if(null!==t&&t.hasEffects(e))return!0}else if(s.hasEffects(e))return!0}return!1}include(e,t){!1===this.deoptimized&&this.applyDeoptimizations(),this.included=!0;for(const s of this.keys){const i=this[s];if(null!==i)if(Array.isArray(i))for(const s of i)null!==s&&s.include(e,t);else i.include(e,t)}}includeAsSingleStatement(e,t){this.include(e,t)}initialise(){}insertSemicolon(e){";"!==e.original[this.end-1]&&e.appendLeft(this.end,";")}parseNode(e){for(const[t,s]of Object.entries(e))if(!this.hasOwnProperty(t))if(95===t.charCodeAt(0)){if("_rollupAnnotations"===t)this.annotations=s;else if("_rollupRemoved"===t)for(const{start:e,end:t}of s)this.context.magicString.remove(e,t)}else if("object"!=typeof s||null===s)this[t]=s;else if(Array.isArray(s)){this[t]=[];for(const e of s)this[t].push(null===e?null:new(this.context.nodeConstructors[e.type]||this.context.nodeConstructors.UnknownNode)(e,this,this.scope))}else this[t]=new(this.context.nodeConstructors[s.type]||this.context.nodeConstructors.UnknownNode)(s,this,this.scope)}render(e,t){for(const s of this.keys){const i=this[s];if(null!==i)if(Array.isArray(i))for(const s of i)null!==s&&s.render(e,t);else i.render(e,t)}}shouldBeIncluded(e){return this.included||!e.brokenFlow&&this.hasEffects(ue())}applyDeoptimizations(){}}class we extends ke{hasEffects(){return!1}initialise(){this.context.addExport(this)}render(e,t,s){e.remove(s.start,s.end)}}function Ce(e,t,s,i){if(t.remove(s,i),e.annotations)for(const i of e.annotations){if(!(i.start<s))return;t.remove(i.start,i.end)}}function Ie(e,t){if(e.annotations||"ExpressionStatement"!==e.parent.type||(e=e.parent),e.annotations)for(const s of e.annotations)t.remove(s.start,s.end)}we.prototype.needsBoundaries=!0;const Ne={isNoStatement:!0};function _e(e,t,s=0){let i,n;for(i=e.indexOf(t,s);;){if(-1===(s=e.indexOf("/",s))||s>=i)return i;n=e.charCodeAt(++s),++s,(s=47===n?e.indexOf("\n",s)+1:e.indexOf("*/",s)+2)>i&&(i=e.indexOf(t,s))}}const $e=/\S/g;function Te(e,t){$e.lastIndex=t;return $e.exec(e).index}function Re(e){let t,s,i=0;for(t=e.indexOf("\n",i);;){if(i=e.indexOf("/",i),-1===i||i>t)return[t,t+1];if(s=e.charCodeAt(i+1),47===s)return[i,t+1];i=e.indexOf("*/",i+3)+2,i>t&&(t=e.indexOf("\n",i))}}function Me(e,t,s,i,n){let r,a,o,h,l=e[0],c=!l.included||l.needsBoundaries;c&&(h=s+Re(t.original.slice(s,l.start))[1]);for(let s=1;s<=e.length;s++)r=l,a=h,o=c,l=e[s],c=void 0!==l&&(!l.included||l.needsBoundaries),o||c?(h=r.end+Re(t.original.slice(r.end,void 0===l?i:l.start))[1],r.included?o?r.render(t,n,{end:h,start:a}):r.render(t,n):Ce(r,t,a,h)):r.render(t,n)}function De(e,t,s,i){const n=[];let r,a,o,h,l,c=s-1;for(let i=0;i<e.length;i++){for(a=e[i],void 0!==r&&(c=r.end+_e(t.original.slice(r.end,a.start),",")),o=h=c+1+Re(t.original.slice(c+1,a.start))[1];l=t.original.charCodeAt(o),32===l||9===l||10===l||13===l;)o++;void 0!==r&&n.push({contentEnd:h,end:o,node:r,separator:c,start:s}),r=a,s=o}return n.push({contentEnd:i,end:i,node:r,separator:null,start:s}),n}function Le(e,t,s){for(;;){const[i,n]=Re(e.original.slice(t,s));if(-1===i)break;e.remove(t+i,t+=n)}}function Oe(e,{exportNamesByVariable:t,snippets:{_:s,getObject:i,getPropertyAccess:n}},r=""){if(1===e.length&&1===t.get(e[0]).length){const i=e[0];return`exports('${t.get(i)}',${s}${i.getName(n)}${r})`}{const s=[];for(const i of e)for(const e of t.get(i))s.push([e,i.getName(n)+r]);return`exports(${i(s,{lineBreakIndent:null})})`}}function Ve(e,t,s,i,{exportNamesByVariable:n,snippets:{_:r}}){i.prependRight(t,`exports('${n.get(e)}',${r}`),i.appendLeft(s,")")}function Be(e,t,s,i,n,r){const{_:a,getPropertyAccess:o}=r.snippets;n.appendLeft(s,`,${a}${Oe([e],r)},${a}${e.getName(o)}`),i&&(n.prependRight(t,"("),n.appendLeft(s,")"))}function Fe(e){let t="";do{const s=e%64;e=Math.floor(e/64),t="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$"[s]+t}while(0!==e);return t}const ze={__proto__:null,await:!0,break:!0,case:!0,catch:!0,class:!0,const:!0,continue:!0,debugger:!0,default:!0,delete:!0,do:!0,else:!0,enum:!0,eval:!0,export:!0,extends:!0,false:!0,finally:!0,for:!0,function:!0,if:!0,implements:!0,import:!0,in:!0,instanceof:!0,interface:!0,let:!0,new:!0,null:!0,package:!0,private:!0,protected:!0,public:!0,return:!0,static:!0,super:!0,switch:!0,this:!0,throw:!0,true:!0,try:!0,typeof:!0,undefined:!0,var:!0,void:!0,while:!0,with:!0,yield:!0};function We(e,t){let s=e,i=1;for(;t.has(s)||ze[s];)s=`${e}$${Fe(i++)}`;return t.add(s),s}const je=[];function Ue(e,t=null){return Object.create(t,e)}const Ge=new class extends j{getLiteralValueAtPath(){}},He={value:{callsArgs:null,returns:U}},qe=new class extends j{getReturnExpressionWhenCalledAtPath(e){return 1===e.length?nt(et,e[0]):U}hasEffectsWhenAccessedAtPath(e){return e.length>1}hasEffectsWhenCalledAtPath(e,t,s){return 1!==e.length||it(et,e[0],t,s)}},Ke={value:{callsArgs:null,returns:qe}},Xe=new class extends j{getReturnExpressionWhenCalledAtPath(e){return 1===e.length?nt(tt,e[0]):U}hasEffectsWhenAccessedAtPath(e){return e.length>1}hasEffectsWhenCalledAtPath(e,t,s){return 1!==e.length||it(tt,e[0],t,s)}},Ye={value:{callsArgs:null,returns:Xe}},Qe=new class extends j{getReturnExpressionWhenCalledAtPath(e){return 1===e.length?nt(st,e[0]):U}hasEffectsWhenAccessedAtPath(e){return e.length>1}hasEffectsWhenCalledAtPath(e,t,s){return 1!==e.length||it(st,e[0],t,s)}},Ze={value:{callsArgs:null,returns:Qe}},Je=Ue({hasOwnProperty:Ke,isPrototypeOf:Ke,propertyIsEnumerable:Ke,toLocaleString:Ze,toString:Ze,valueOf:He}),et=Ue({valueOf:Ke},Je),tt=Ue({toExponential:Ze,toFixed:Ze,toLocaleString:Ze,toPrecision:Ze,valueOf:Ye},Je),st=Ue({charAt:Ze,charCodeAt:Ye,codePointAt:Ye,concat:Ze,endsWith:Ke,includes:Ke,indexOf:Ye,lastIndexOf:Ye,localeCompare:Ye,match:Ke,normalize:Ze,padEnd:Ze,padStart:Ze,repeat:Ze,replace:{value:{callsArgs:[1],returns:Qe}},search:Ye,slice:Ze,split:He,startsWith:Ke,substr:Ze,substring:Ze,toLocaleLowerCase:Ze,toLocaleUpperCase:Ze,toLowerCase:Ze,toUpperCase:Ze,trim:Ze,valueOf:Ze},Je);function it(e,t,s,i){if("string"!=typeof t||!e[t])return!0;if(!e[t].callsArgs)return!1;for(const n of e[t].callsArgs)if(s.args[n]&&s.args[n].hasEffectsWhenCalledAtPath(D,{args:je,thisParam:null,withNew:!1},i))return!0;return!1}function nt(e,t){return"string"==typeof t&&e[t]?e[t].returns:U}class rt extends G{constructor(e,t,s,i){super(e),this.calledFromTryStatement=!1,this.additionalInitializers=null,this.expressionsToBeDeoptimized=[],this.declarations=t?[t]:[],this.init=s,this.deoptimizationTracker=i.deoptimizationTracker,this.module=i.module}addDeclaration(e,t){this.declarations.push(e);const s=this.markInitializersForDeoptimization();null!==t&&s.push(t)}consolidateInitializers(){if(null!==this.additionalInitializers){for(const e of this.additionalInitializers)e.deoptimizePath(L);this.additionalInitializers=null}}deoptimizePath(e){var t,s;if(!this.isReassigned&&!this.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(e,this))if(0===e.length){if(!this.isReassigned){this.isReassigned=!0;const e=this.expressionsToBeDeoptimized;this.expressionsToBeDeoptimized=[];for(const t of e)t.deoptimizeCache();null===(t=this.init)||void 0===t||t.deoptimizePath(L)}}else null===(s=this.init)||void 0===s||s.deoptimizePath(e)}deoptimizeThisOnEventAtPath(e,t,s,i){if(this.isReassigned||!this.init)return s.deoptimizePath(L);i.withTrackedEntityAtPath(t,this.init,(()=>this.init.deoptimizeThisOnEventAtPath(e,t,s,i)),void 0)}getLiteralValueAtPath(e,t,s){return this.isReassigned||!this.init?W:t.withTrackedEntityAtPath(e,this.init,(()=>(this.expressionsToBeDeoptimized.push(s),this.init.getLiteralValueAtPath(e,t,s))),W)}getReturnExpressionWhenCalledAtPath(e,t,s,i){return this.isReassigned||!this.init?U:s.withTrackedEntityAtPath(e,this.init,(()=>(this.expressionsToBeDeoptimized.push(i),this.init.getReturnExpressionWhenCalledAtPath(e,t,s,i))),U)}hasEffectsWhenAccessedAtPath(e,t){return!!this.isReassigned||this.init&&!t.accessed.trackEntityAtPathAndGetIfTracked(e,this)&&this.init.hasEffectsWhenAccessedAtPath(e,t)}hasEffectsWhenAssignedAtPath(e,t){return!!this.included||0!==e.length&&(!!this.isReassigned||this.init&&!t.accessed.trackEntityAtPathAndGetIfTracked(e,this)&&this.init.hasEffectsWhenAssignedAtPath(e,t))}hasEffectsWhenCalledAtPath(e,t,s){return!!this.isReassigned||this.init&&!(t.withNew?s.instantiated:s.called).trackEntityAtPathAndGetIfTracked(e,t,this)&&this.init.hasEffectsWhenCalledAtPath(e,t,s)}include(){if(!this.included){this.included=!0;for(const e of this.declarations){e.included||e.include(ce(),!1);let t=e.parent;for(;!t.included&&(t.included=!0,"Program"!==t.type);)t=t.parent}}}includeCallArguments(e,t){if(this.isReassigned||this.init&&e.includedCallArguments.has(this.init))for(const s of t)s.include(e,!1);else this.init&&(e.includedCallArguments.add(this.init),this.init.includeCallArguments(e,t),e.includedCallArguments.delete(this.init))}markCalledFromTryStatement(){this.calledFromTryStatement=!0}markInitializersForDeoptimization(){return null===this.additionalInitializers&&(this.additionalInitializers=null===this.init?[]:[this.init],this.init=U,this.isReassigned=!0),this.additionalInitializers}}class at{constructor(){this.children=[],this.variables=new Map}addDeclaration(e,t,s,i){const n=e.name;let r=this.variables.get(n);return r?r.addDeclaration(e,s):(r=new rt(e.name,e,s||Ge,t),this.variables.set(n,r)),r}contains(e){return this.variables.has(e)}findVariable(e){throw new Error("Internal Error: findVariable needs to be implemented by a subclass")}}class ot extends at{constructor(e){super(),this.accessedOutsideVariables=new Map,this.parent=e,e.children.push(this)}addAccessedDynamicImport(e){(this.accessedDynamicImports||(this.accessedDynamicImports=new Set)).add(e),this.parent instanceof ot&&this.parent.addAccessedDynamicImport(e)}addAccessedGlobals(e,t){const s=t.get(this)||new Set;for(const t of e)s.add(t);t.set(this,s),this.parent instanceof ot&&this.parent.addAccessedGlobals(e,t)}addNamespaceMemberAccess(e,t){this.accessedOutsideVariables.set(e,t),this.parent.addNamespaceMemberAccess(e,t)}addReturnExpression(e){this.parent instanceof ot&&this.parent.addReturnExpression(e)}addUsedOutsideNames(e,t,s,i){for(const i of this.accessedOutsideVariables.values())i.included&&(e.add(i.getBaseVariableName()),"system"===t&&s.has(i)&&e.add("exports"));const n=i.get(this);if(n)for(const t of n)e.add(t)}contains(e){return this.variables.has(e)||this.parent.contains(e)}deconflict(e,t,s){const i=new Set;if(this.addUsedOutsideNames(i,e,t,s),this.accessedDynamicImports)for(const e of this.accessedDynamicImports)e.inlineNamespace&&i.add(e.inlineNamespace.getBaseVariableName());for(const[e,t]of this.variables)(t.included||t.alwaysRendered)&&t.setRenderNames(null,We(e,i));for(const i of this.children)i.deconflict(e,t,s)}findLexicalBoundary(){return this.parent.findLexicalBoundary()}findVariable(e){const t=this.variables.get(e)||this.accessedOutsideVariables.get(e);if(t)return t;const s=this.parent.findVariable(e);return this.accessedOutsideVariables.set(e,s),s}}function ht(e,t){if("MemberExpression"===e.type)return!e.computed&&ht(e.object,e);if("Identifier"===e.type){if(!t)return!0;switch(t.type){case"MemberExpression":return t.computed||e===t.object;case"MethodDefinition":return t.computed;case"PropertyDefinition":case"Property":return t.computed||e===t.value;case"ExportSpecifier":case"ImportSpecifier":return e===t.local;case"LabeledStatement":case"BreakStatement":case"ContinueStatement":return!1;default:return!0}}return!1}const lt=Symbol("Value Properties"),ct={pure:!0},ut={pure:!1},dt={__proto__:null,[lt]:ut},pt={__proto__:null,[lt]:ct},ft={__proto__:null,[lt]:ut,prototype:dt},mt={__proto__:null,[lt]:ct,prototype:dt},gt={__proto__:null,[lt]:ct,from:pt,of:pt,prototype:dt},yt={__proto__:null,[lt]:ct,supportedLocalesOf:mt},Et={global:dt,globalThis:dt,self:dt,window:dt,__proto__:null,[lt]:ut,Array:{__proto__:null,[lt]:ut,from:dt,isArray:pt,of:pt,prototype:dt},ArrayBuffer:{__proto__:null,[lt]:ct,isView:pt,prototype:dt},Atomics:dt,BigInt:ft,BigInt64Array:ft,BigUint64Array:ft,Boolean:mt,constructor:ft,DataView:mt,Date:{__proto__:null,[lt]:ct,now:pt,parse:pt,prototype:dt,UTC:pt},decodeURI:pt,decodeURIComponent:pt,encodeURI:pt,encodeURIComponent:pt,Error:mt,escape:pt,eval:dt,EvalError:mt,Float32Array:gt,Float64Array:gt,Function:ft,hasOwnProperty:dt,Infinity:dt,Int16Array:gt,Int32Array:gt,Int8Array:gt,isFinite:pt,isNaN:pt,isPrototypeOf:dt,JSON:dt,Map:mt,Math:{__proto__:null,[lt]:ut,abs:pt,acos:pt,acosh:pt,asin:pt,asinh:pt,atan:pt,atan2:pt,atanh:pt,cbrt:pt,ceil:pt,clz32:pt,cos:pt,cosh:pt,exp:pt,expm1:pt,floor:pt,fround:pt,hypot:pt,imul:pt,log:pt,log10:pt,log1p:pt,log2:pt,max:pt,min:pt,pow:pt,random:pt,round:pt,sign:pt,sin:pt,sinh:pt,sqrt:pt,tan:pt,tanh:pt,trunc:pt},NaN:dt,Number:{__proto__:null,[lt]:ct,isFinite:pt,isInteger:pt,isNaN:pt,isSafeInteger:pt,parseFloat:pt,parseInt:pt,prototype:dt},Object:{__proto__:null,[lt]:ct,create:pt,getNotifier:pt,getOwn:pt,getOwnPropertyDescriptor:pt,getOwnPropertyNames:pt,getOwnPropertySymbols:pt,getPrototypeOf:pt,is:pt,isExtensible:pt,isFrozen:pt,isSealed:pt,keys:pt,prototype:dt},parseFloat:pt,parseInt:pt,Promise:{__proto__:null,[lt]:ut,all:dt,prototype:dt,race:dt,reject:dt,resolve:dt},propertyIsEnumerable:dt,Proxy:dt,RangeError:mt,ReferenceError:mt,Reflect:dt,RegExp:mt,Set:mt,SharedArrayBuffer:ft,String:{__proto__:null,[lt]:ct,fromCharCode:pt,fromCodePoint:pt,prototype:dt,raw:pt},Symbol:{__proto__:null,[lt]:ct,for:pt,keyFor:pt,prototype:dt},SyntaxError:mt,toLocaleString:dt,toString:dt,TypeError:mt,Uint16Array:gt,Uint32Array:gt,Uint8Array:gt,Uint8ClampedArray:gt,unescape:pt,URIError:mt,valueOf:dt,WeakMap:mt,WeakSet:mt,clearInterval:ft,clearTimeout:ft,console:dt,Intl:{__proto__:null,[lt]:ut,Collator:yt,DateTimeFormat:yt,ListFormat:yt,NumberFormat:yt,PluralRules:yt,RelativeTimeFormat:yt},setInterval:ft,setTimeout:ft,TextDecoder:ft,TextEncoder:ft,URL:ft,URLSearchParams:ft,AbortController:ft,AbortSignal:ft,addEventListener:dt,alert:dt,AnalyserNode:ft,Animation:ft,AnimationEvent:ft,applicationCache:dt,ApplicationCache:ft,ApplicationCacheErrorEvent:ft,atob:dt,Attr:ft,Audio:ft,AudioBuffer:ft,AudioBufferSourceNode:ft,AudioContext:ft,AudioDestinationNode:ft,AudioListener:ft,AudioNode:ft,AudioParam:ft,AudioProcessingEvent:ft,AudioScheduledSourceNode:ft,AudioWorkletNode:ft,BarProp:ft,BaseAudioContext:ft,BatteryManager:ft,BeforeUnloadEvent:ft,BiquadFilterNode:ft,Blob:ft,BlobEvent:ft,blur:dt,BroadcastChannel:ft,btoa:dt,ByteLengthQueuingStrategy:ft,Cache:ft,caches:dt,CacheStorage:ft,cancelAnimationFrame:dt,cancelIdleCallback:dt,CanvasCaptureMediaStreamTrack:ft,CanvasGradient:ft,CanvasPattern:ft,CanvasRenderingContext2D:ft,ChannelMergerNode:ft,ChannelSplitterNode:ft,CharacterData:ft,clientInformation:dt,ClipboardEvent:ft,close:dt,closed:dt,CloseEvent:ft,Comment:ft,CompositionEvent:ft,confirm:dt,ConstantSourceNode:ft,ConvolverNode:ft,CountQueuingStrategy:ft,createImageBitmap:dt,Credential:ft,CredentialsContainer:ft,crypto:dt,Crypto:ft,CryptoKey:ft,CSS:ft,CSSConditionRule:ft,CSSFontFaceRule:ft,CSSGroupingRule:ft,CSSImportRule:ft,CSSKeyframeRule:ft,CSSKeyframesRule:ft,CSSMediaRule:ft,CSSNamespaceRule:ft,CSSPageRule:ft,CSSRule:ft,CSSRuleList:ft,CSSStyleDeclaration:ft,CSSStyleRule:ft,CSSStyleSheet:ft,CSSSupportsRule:ft,CustomElementRegistry:ft,customElements:dt,CustomEvent:ft,DataTransfer:ft,DataTransferItem:ft,DataTransferItemList:ft,defaultstatus:dt,defaultStatus:dt,DelayNode:ft,DeviceMotionEvent:ft,DeviceOrientationEvent:ft,devicePixelRatio:dt,dispatchEvent:dt,document:dt,Document:ft,DocumentFragment:ft,DocumentType:ft,DOMError:ft,DOMException:ft,DOMImplementation:ft,DOMMatrix:ft,DOMMatrixReadOnly:ft,DOMParser:ft,DOMPoint:ft,DOMPointReadOnly:ft,DOMQuad:ft,DOMRect:ft,DOMRectReadOnly:ft,DOMStringList:ft,DOMStringMap:ft,DOMTokenList:ft,DragEvent:ft,DynamicsCompressorNode:ft,Element:ft,ErrorEvent:ft,Event:ft,EventSource:ft,EventTarget:ft,external:dt,fetch:dt,File:ft,FileList:ft,FileReader:ft,find:dt,focus:dt,FocusEvent:ft,FontFace:ft,FontFaceSetLoadEvent:ft,FormData:ft,frames:dt,GainNode:ft,Gamepad:ft,GamepadButton:ft,GamepadEvent:ft,getComputedStyle:dt,getSelection:dt,HashChangeEvent:ft,Headers:ft,history:dt,History:ft,HTMLAllCollection:ft,HTMLAnchorElement:ft,HTMLAreaElement:ft,HTMLAudioElement:ft,HTMLBaseElement:ft,HTMLBodyElement:ft,HTMLBRElement:ft,HTMLButtonElement:ft,HTMLCanvasElement:ft,HTMLCollection:ft,HTMLContentElement:ft,HTMLDataElement:ft,HTMLDataListElement:ft,HTMLDetailsElement:ft,HTMLDialogElement:ft,HTMLDirectoryElement:ft,HTMLDivElement:ft,HTMLDListElement:ft,HTMLDocument:ft,HTMLElement:ft,HTMLEmbedElement:ft,HTMLFieldSetElement:ft,HTMLFontElement:ft,HTMLFormControlsCollection:ft,HTMLFormElement:ft,HTMLFrameElement:ft,HTMLFrameSetElement:ft,HTMLHeadElement:ft,HTMLHeadingElement:ft,HTMLHRElement:ft,HTMLHtmlElement:ft,HTMLIFrameElement:ft,HTMLImageElement:ft,HTMLInputElement:ft,HTMLLabelElement:ft,HTMLLegendElement:ft,HTMLLIElement:ft,HTMLLinkElement:ft,HTMLMapElement:ft,HTMLMarqueeElement:ft,HTMLMediaElement:ft,HTMLMenuElement:ft,HTMLMetaElement:ft,HTMLMeterElement:ft,HTMLModElement:ft,HTMLObjectElement:ft,HTMLOListElement:ft,HTMLOptGroupElement:ft,HTMLOptionElement:ft,HTMLOptionsCollection:ft,HTMLOutputElement:ft,HTMLParagraphElement:ft,HTMLParamElement:ft,HTMLPictureElement:ft,HTMLPreElement:ft,HTMLProgressElement:ft,HTMLQuoteElement:ft,HTMLScriptElement:ft,HTMLSelectElement:ft,HTMLShadowElement:ft,HTMLSlotElement:ft,HTMLSourceElement:ft,HTMLSpanElement:ft,HTMLStyleElement:ft,HTMLTableCaptionElement:ft,HTMLTableCellElement:ft,HTMLTableColElement:ft,HTMLTableElement:ft,HTMLTableRowElement:ft,HTMLTableSectionElement:ft,HTMLTemplateElement:ft,HTMLTextAreaElement:ft,HTMLTimeElement:ft,HTMLTitleElement:ft,HTMLTrackElement:ft,HTMLUListElement:ft,HTMLUnknownElement:ft,HTMLVideoElement:ft,IDBCursor:ft,IDBCursorWithValue:ft,IDBDatabase:ft,IDBFactory:ft,IDBIndex:ft,IDBKeyRange:ft,IDBObjectStore:ft,IDBOpenDBRequest:ft,IDBRequest:ft,IDBTransaction:ft,IDBVersionChangeEvent:ft,IdleDeadline:ft,IIRFilterNode:ft,Image:ft,ImageBitmap:ft,ImageBitmapRenderingContext:ft,ImageCapture:ft,ImageData:ft,indexedDB:dt,innerHeight:dt,innerWidth:dt,InputEvent:ft,IntersectionObserver:ft,IntersectionObserverEntry:ft,isSecureContext:dt,KeyboardEvent:ft,KeyframeEffect:ft,length:dt,localStorage:dt,location:dt,Location:ft,locationbar:dt,matchMedia:dt,MediaDeviceInfo:ft,MediaDevices:ft,MediaElementAudioSourceNode:ft,MediaEncryptedEvent:ft,MediaError:ft,MediaKeyMessageEvent:ft,MediaKeySession:ft,MediaKeyStatusMap:ft,MediaKeySystemAccess:ft,MediaList:ft,MediaQueryList:ft,MediaQueryListEvent:ft,MediaRecorder:ft,MediaSettingsRange:ft,MediaSource:ft,MediaStream:ft,MediaStreamAudioDestinationNode:ft,MediaStreamAudioSourceNode:ft,MediaStreamEvent:ft,MediaStreamTrack:ft,MediaStreamTrackEvent:ft,menubar:dt,MessageChannel:ft,MessageEvent:ft,MessagePort:ft,MIDIAccess:ft,MIDIConnectionEvent:ft,MIDIInput:ft,MIDIInputMap:ft,MIDIMessageEvent:ft,MIDIOutput:ft,MIDIOutputMap:ft,MIDIPort:ft,MimeType:ft,MimeTypeArray:ft,MouseEvent:ft,moveBy:dt,moveTo:dt,MutationEvent:ft,MutationObserver:ft,MutationRecord:ft,name:dt,NamedNodeMap:ft,NavigationPreloadManager:ft,navigator:dt,Navigator:ft,NetworkInformation:ft,Node:ft,NodeFilter:dt,NodeIterator:ft,NodeList:ft,Notification:ft,OfflineAudioCompletionEvent:ft,OfflineAudioContext:ft,offscreenBuffering:dt,OffscreenCanvas:ft,open:dt,openDatabase:dt,Option:ft,origin:dt,OscillatorNode:ft,outerHeight:dt,outerWidth:dt,PageTransitionEvent:ft,pageXOffset:dt,pageYOffset:dt,PannerNode:ft,parent:dt,Path2D:ft,PaymentAddress:ft,PaymentRequest:ft,PaymentRequestUpdateEvent:ft,PaymentResponse:ft,performance:dt,Performance:ft,PerformanceEntry:ft,PerformanceLongTaskTiming:ft,PerformanceMark:ft,PerformanceMeasure:ft,PerformanceNavigation:ft,PerformanceNavigationTiming:ft,PerformanceObserver:ft,PerformanceObserverEntryList:ft,PerformancePaintTiming:ft,PerformanceResourceTiming:ft,PerformanceTiming:ft,PeriodicWave:ft,Permissions:ft,PermissionStatus:ft,personalbar:dt,PhotoCapabilities:ft,Plugin:ft,PluginArray:ft,PointerEvent:ft,PopStateEvent:ft,postMessage:dt,Presentation:ft,PresentationAvailability:ft,PresentationConnection:ft,PresentationConnectionAvailableEvent:ft,PresentationConnectionCloseEvent:ft,PresentationConnectionList:ft,PresentationReceiver:ft,PresentationRequest:ft,print:dt,ProcessingInstruction:ft,ProgressEvent:ft,PromiseRejectionEvent:ft,prompt:dt,PushManager:ft,PushSubscription:ft,PushSubscriptionOptions:ft,queueMicrotask:dt,RadioNodeList:ft,Range:ft,ReadableStream:ft,RemotePlayback:ft,removeEventListener:dt,Request:ft,requestAnimationFrame:dt,requestIdleCallback:dt,resizeBy:dt,ResizeObserver:ft,ResizeObserverEntry:ft,resizeTo:dt,Response:ft,RTCCertificate:ft,RTCDataChannel:ft,RTCDataChannelEvent:ft,RTCDtlsTransport:ft,RTCIceCandidate:ft,RTCIceTransport:ft,RTCPeerConnection:ft,RTCPeerConnectionIceEvent:ft,RTCRtpReceiver:ft,RTCRtpSender:ft,RTCSctpTransport:ft,RTCSessionDescription:ft,RTCStatsReport:ft,RTCTrackEvent:ft,screen:dt,Screen:ft,screenLeft:dt,ScreenOrientation:ft,screenTop:dt,screenX:dt,screenY:dt,ScriptProcessorNode:ft,scroll:dt,scrollbars:dt,scrollBy:dt,scrollTo:dt,scrollX:dt,scrollY:dt,SecurityPolicyViolationEvent:ft,Selection:ft,ServiceWorker:ft,ServiceWorkerContainer:ft,ServiceWorkerRegistration:ft,sessionStorage:dt,ShadowRoot:ft,SharedWorker:ft,SourceBuffer:ft,SourceBufferList:ft,speechSynthesis:dt,SpeechSynthesisEvent:ft,SpeechSynthesisUtterance:ft,StaticRange:ft,status:dt,statusbar:dt,StereoPannerNode:ft,stop:dt,Storage:ft,StorageEvent:ft,StorageManager:ft,styleMedia:dt,StyleSheet:ft,StyleSheetList:ft,SubtleCrypto:ft,SVGAElement:ft,SVGAngle:ft,SVGAnimatedAngle:ft,SVGAnimatedBoolean:ft,SVGAnimatedEnumeration:ft,SVGAnimatedInteger:ft,SVGAnimatedLength:ft,SVGAnimatedLengthList:ft,SVGAnimatedNumber:ft,SVGAnimatedNumberList:ft,SVGAnimatedPreserveAspectRatio:ft,SVGAnimatedRect:ft,SVGAnimatedString:ft,SVGAnimatedTransformList:ft,SVGAnimateElement:ft,SVGAnimateMotionElement:ft,SVGAnimateTransformElement:ft,SVGAnimationElement:ft,SVGCircleElement:ft,SVGClipPathElement:ft,SVGComponentTransferFunctionElement:ft,SVGDefsElement:ft,SVGDescElement:ft,SVGDiscardElement:ft,SVGElement:ft,SVGEllipseElement:ft,SVGFEBlendElement:ft,SVGFEColorMatrixElement:ft,SVGFEComponentTransferElement:ft,SVGFECompositeElement:ft,SVGFEConvolveMatrixElement:ft,SVGFEDiffuseLightingElement:ft,SVGFEDisplacementMapElement:ft,SVGFEDistantLightElement:ft,SVGFEDropShadowElement:ft,SVGFEFloodElement:ft,SVGFEFuncAElement:ft,SVGFEFuncBElement:ft,SVGFEFuncGElement:ft,SVGFEFuncRElement:ft,SVGFEGaussianBlurElement:ft,SVGFEImageElement:ft,SVGFEMergeElement:ft,SVGFEMergeNodeElement:ft,SVGFEMorphologyElement:ft,SVGFEOffsetElement:ft,SVGFEPointLightElement:ft,SVGFESpecularLightingElement:ft,SVGFESpotLightElement:ft,SVGFETileElement:ft,SVGFETurbulenceElement:ft,SVGFilterElement:ft,SVGForeignObjectElement:ft,SVGGElement:ft,SVGGeometryElement:ft,SVGGradientElement:ft,SVGGraphicsElement:ft,SVGImageElement:ft,SVGLength:ft,SVGLengthList:ft,SVGLinearGradientElement:ft,SVGLineElement:ft,SVGMarkerElement:ft,SVGMaskElement:ft,SVGMatrix:ft,SVGMetadataElement:ft,SVGMPathElement:ft,SVGNumber:ft,SVGNumberList:ft,SVGPathElement:ft,SVGPatternElement:ft,SVGPoint:ft,SVGPointList:ft,SVGPolygonElement:ft,SVGPolylineElement:ft,SVGPreserveAspectRatio:ft,SVGRadialGradientElement:ft,SVGRect:ft,SVGRectElement:ft,SVGScriptElement:ft,SVGSetElement:ft,SVGStopElement:ft,SVGStringList:ft,SVGStyleElement:ft,SVGSVGElement:ft,SVGSwitchElement:ft,SVGSymbolElement:ft,SVGTextContentElement:ft,SVGTextElement:ft,SVGTextPathElement:ft,SVGTextPositioningElement:ft,SVGTitleElement:ft,SVGTransform:ft,SVGTransformList:ft,SVGTSpanElement:ft,SVGUnitTypes:ft,SVGUseElement:ft,SVGViewElement:ft,TaskAttributionTiming:ft,Text:ft,TextEvent:ft,TextMetrics:ft,TextTrack:ft,TextTrackCue:ft,TextTrackCueList:ft,TextTrackList:ft,TimeRanges:ft,toolbar:dt,top:dt,Touch:ft,TouchEvent:ft,TouchList:ft,TrackEvent:ft,TransitionEvent:ft,TreeWalker:ft,UIEvent:ft,ValidityState:ft,visualViewport:dt,VisualViewport:ft,VTTCue:ft,WaveShaperNode:ft,WebAssembly:dt,WebGL2RenderingContext:ft,WebGLActiveInfo:ft,WebGLBuffer:ft,WebGLContextEvent:ft,WebGLFramebuffer:ft,WebGLProgram:ft,WebGLQuery:ft,WebGLRenderbuffer:ft,WebGLRenderingContext:ft,WebGLSampler:ft,WebGLShader:ft,WebGLShaderPrecisionFormat:ft,WebGLSync:ft,WebGLTexture:ft,WebGLTransformFeedback:ft,WebGLUniformLocation:ft,WebGLVertexArrayObject:ft,WebSocket:ft,WheelEvent:ft,Window:ft,Worker:ft,WritableStream:ft,XMLDocument:ft,XMLHttpRequest:ft,XMLHttpRequestEventTarget:ft,XMLHttpRequestUpload:ft,XMLSerializer:ft,XPathEvaluator:ft,XPathExpression:ft,XPathResult:ft,XSLTProcessor:ft};for(const e of["window","global","self","globalThis"])Et[e]=Et;function xt(e){let t=Et;for(const s of e){if("string"!=typeof s)return null;if(t=t[s],!t)return null}return t[lt]}class vt extends G{constructor(){super(...arguments),this.isReassigned=!0}hasEffectsWhenAccessedAtPath(e){return!function(e){return 1===e.length?"undefined"===e[0]||null!==xt(e):null!==xt(e.slice(0,-1))}([this.name,...e])}hasEffectsWhenCalledAtPath(e){return!function(e){const t=xt(e);return null!==t&&t.pure}([this.name,...e])}}const bt={__proto__:null,class:!0,const:!0,let:!0,var:!0};class St extends ke{constructor(){super(...arguments),this.variable=null,this.deoptimized=!1,this.isTDZAccess=null}addExportedVariables(e,t){null!==this.variable&&t.has(this.variable)&&e.push(this.variable)}bind(){null===this.variable&&ht(this,this.parent)&&(this.variable=this.scope.findVariable(this.name),this.variable.addReference(this))}declare(e,t){let s;const{treeshake:i}=this.context.options;switch(e){case"var":s=this.scope.addDeclaration(this,this.context,t,!0),i&&i.correctVarValueBeforeDeclaration&&s.markInitializersForDeoptimization();break;case"function":case"let":case"const":case"class":s=this.scope.addDeclaration(this,this.context,t,!1);break;case"parameter":s=this.scope.addParameterDeclaration(this);break;default:throw new Error(`Internal Error: Unexpected identifier kind ${e}.`)}return s.kind=e,[this.variable=s]}deoptimizePath(e){0!==e.length||this.scope.contains(this.name)||this.disallowImportReassignment(),this.variable.deoptimizePath(e)}deoptimizeThisOnEventAtPath(e,t,s,i){this.variable.deoptimizeThisOnEventAtPath(e,t,s,i)}getLiteralValueAtPath(e,t,s){return this.getVariableRespectingTDZ().getLiteralValueAtPath(e,t,s)}getReturnExpressionWhenCalledAtPath(e,t,s,i){return this.getVariableRespectingTDZ().getReturnExpressionWhenCalledAtPath(e,t,s,i)}hasEffects(){return this.deoptimized||this.applyDeoptimizations(),!(!this.isPossibleTDZ()||"var"===this.variable.kind)||this.context.options.treeshake.unknownGlobalSideEffects&&this.variable instanceof vt&&this.variable.hasEffectsWhenAccessedAtPath(D)}hasEffectsWhenAccessedAtPath(e,t){return null!==this.variable&&this.getVariableRespectingTDZ().hasEffectsWhenAccessedAtPath(e,t)}hasEffectsWhenAssignedAtPath(e,t){return!this.variable||(e.length>0?this.getVariableRespectingTDZ():this.variable).hasEffectsWhenAssignedAtPath(e,t)}hasEffectsWhenCalledAtPath(e,t,s){return!this.variable||this.getVariableRespectingTDZ().hasEffectsWhenCalledAtPath(e,t,s)}include(){this.deoptimized||this.applyDeoptimizations(),this.included||(this.included=!0,null!==this.variable&&this.context.includeVariableInModule(this.variable))}includeCallArguments(e,t){this.getVariableRespectingTDZ().includeCallArguments(e,t)}isPossibleTDZ(){if(null!==this.isTDZAccess)return this.isTDZAccess;if(!(this.variable instanceof rt&&this.variable.kind&&this.variable.kind in bt))return this.isTDZAccess=!1;let e;return this.variable.declarations&&1===this.variable.declarations.length&&(e=this.variable.declarations[0])&&this.start<e.start&&At(this)===At(e)?this.isTDZAccess=!0:this.variable.initReached?this.isTDZAccess=!1:this.isTDZAccess=!0}markDeclarationReached(){this.variable.initReached=!0}render(e,{snippets:{getPropertyAccess:t}},{renderedParentType:s,isCalleeOfRenderedParent:i,isShorthandProperty:n}=q){if(this.variable){const r=this.variable.getName(t);r!==this.name&&(e.overwrite(this.start,this.end,r,{contentOnly:!0,storeName:!0}),n&&e.prependRight(this.start,`${this.name}: `)),"eval"===r&&"CallExpression"===s&&i&&e.appendRight(this.start,"0, ")}}applyDeoptimizations(){this.deoptimized=!0,null!==this.variable&&this.variable instanceof rt&&(this.variable.consolidateInitializers(),this.context.requestTreeshakingPass())}disallowImportReassignment(){return this.context.error({code:"ILLEGAL_REASSIGNMENT",message:`Illegal reassignment to import '${this.name}'`},this.start)}getVariableRespectingTDZ(){return this.isPossibleTDZ()?U:this.variable}}function At(e){for(;e&&!/^Program|Function/.test(e.type);)e=e.parent;return e}class Pt extends ke{constructor(){super(...arguments),this.accessedValue=null,this.accessorCallOptions={args:je,thisParam:null,withNew:!1}}deoptimizeCache(){}deoptimizePath(e){this.getAccessedValue().deoptimizePath(e)}deoptimizeThisOnEventAtPath(e,t,s,i){return 0===e&&"get"===this.kind&&0===t.length||1===e&&"set"===this.kind&&0===t.length?this.value.deoptimizeThisOnEventAtPath(2,D,s,i):void this.getAccessedValue().deoptimizeThisOnEventAtPath(e,t,s,i)}getLiteralValueAtPath(e,t,s){return this.getAccessedValue().getLiteralValueAtPath(e,t,s)}getReturnExpressionWhenCalledAtPath(e,t,s,i){return this.getAccessedValue().getReturnExpressionWhenCalledAtPath(e,t,s,i)}hasEffects(e){return this.key.hasEffects(e)}hasEffectsWhenAccessedAtPath(e,t){return"get"===this.kind&&0===e.length?this.value.hasEffectsWhenCalledAtPath(D,this.accessorCallOptions,t):this.getAccessedValue().hasEffectsWhenAccessedAtPath(e,t)}hasEffectsWhenAssignedAtPath(e,t){return"set"===this.kind?this.value.hasEffectsWhenCalledAtPath(D,this.accessorCallOptions,t):this.getAccessedValue().hasEffectsWhenAssignedAtPath(e,t)}hasEffectsWhenCalledAtPath(e,t,s){return this.getAccessedValue().hasEffectsWhenCalledAtPath(e,t,s)}getAccessedValue(){return null===this.accessedValue?"get"===this.kind?(this.accessedValue=U,this.accessedValue=this.value.getReturnExpressionWhenCalledAtPath(D,this.accessorCallOptions,F,this)):this.accessedValue=this.value:this.accessedValue}}class kt extends Pt{}const wt=/^\d+$/;class Ct extends j{constructor(e,t,s=!1){if(super(),this.prototypeExpression=t,this.immutable=s,this.allProperties=[],this.deoptimizedPaths=Object.create(null),this.expressionsToBeDeoptimizedByKey=Object.create(null),this.gettersByKey=Object.create(null),this.hasUnknownDeoptimizedInteger=!1,this.hasUnknownDeoptimizedProperty=!1,this.propertiesAndGettersByKey=Object.create(null),this.propertiesAndSettersByKey=Object.create(null),this.settersByKey=Object.create(null),this.thisParametersToBeDeoptimized=new Set,this.unknownIntegerProps=[],this.unmatchableGetters=[],this.unmatchablePropertiesAndGetters=[],this.unmatchableSetters=[],Array.isArray(e))this.buildPropertyMaps(e);else{this.propertiesAndGettersByKey=this.propertiesAndSettersByKey=e;for(const t of Object.values(e))this.allProperties.push(...t)}}deoptimizeAllProperties(){var e;if(!this.hasUnknownDeoptimizedProperty){this.hasUnknownDeoptimizedProperty=!0;for(const e of Object.values(this.propertiesAndGettersByKey).concat(Object.values(this.settersByKey)))for(const t of e)t.deoptimizePath(L);null===(e=this.prototypeExpression)||void 0===e||e.deoptimizePath([R,R]),this.deoptimizeCachedEntities()}}deoptimizeIntegerProperties(){if(!this.hasUnknownDeoptimizedProperty&&!this.hasUnknownDeoptimizedInteger){this.hasUnknownDeoptimizedInteger=!0;for(const[e,t]of Object.entries(this.propertiesAndGettersByKey))if(wt.test(e))for(const e of t)e.deoptimizePath(L);this.deoptimizeCachedIntegerEntities()}}deoptimizePath(e){var t;if(this.hasUnknownDeoptimizedProperty||this.immutable)return;const s=e[0];if(1===e.length){if("string"!=typeof s)return s===M?this.deoptimizeIntegerProperties():this.deoptimizeAllProperties();if(!this.deoptimizedPaths[s]){this.deoptimizedPaths[s]=!0;const e=this.expressionsToBeDeoptimizedByKey[s];if(e)for(const t of e)t.deoptimizeCache()}}const i=1===e.length?L:e.slice(1);for(const e of"string"==typeof s?(this.propertiesAndGettersByKey[s]||this.unmatchablePropertiesAndGetters).concat(this.settersByKey[s]||this.unmatchableSetters):this.allProperties)e.deoptimizePath(i);null===(t=this.prototypeExpression)||void 0===t||t.deoptimizePath(1===e.length?[R,R]:e)}deoptimizeThisOnEventAtPath(e,t,s,i){var n;const[r,...a]=t;if(this.hasUnknownDeoptimizedProperty||(2===e||t.length>1)&&"string"==typeof r&&this.deoptimizedPaths[r])return void s.deoptimizePath(L);const[o,h,l]=2===e||t.length>1?[this.propertiesAndGettersByKey,this.propertiesAndGettersByKey,this.unmatchablePropertiesAndGetters]:0===e?[this.propertiesAndGettersByKey,this.gettersByKey,this.unmatchableGetters]:[this.propertiesAndSettersByKey,this.settersByKey,this.unmatchableSetters];if("string"==typeof r){if(o[r]){const t=h[r];if(t)for(const n of t)n.deoptimizeThisOnEventAtPath(e,a,s,i);return void(this.immutable||this.thisParametersToBeDeoptimized.add(s))}for(const t of l)t.deoptimizeThisOnEventAtPath(e,a,s,i);if(wt.test(r))for(const t of this.unknownIntegerProps)t.deoptimizeThisOnEventAtPath(e,a,s,i)}else{for(const t of Object.values(h).concat([l]))for(const n of t)n.deoptimizeThisOnEventAtPath(e,a,s,i);for(const t of this.unknownIntegerProps)t.deoptimizeThisOnEventAtPath(e,a,s,i)}this.immutable||this.thisParametersToBeDeoptimized.add(s),null===(n=this.prototypeExpression)||void 0===n||n.deoptimizeThisOnEventAtPath(e,t,s,i)}getLiteralValueAtPath(e,t,s){if(0===e.length)return W;const i=e[0],n=this.getMemberExpressionAndTrackDeopt(i,s);return n?n.getLiteralValueAtPath(e.slice(1),t,s):this.prototypeExpression?this.prototypeExpression.getLiteralValueAtPath(e,t,s):1!==e.length?W:void 0}getReturnExpressionWhenCalledAtPath(e,t,s,i){if(0===e.length)return U;const n=e[0],r=this.getMemberExpressionAndTrackDeopt(n,i);return r?r.getReturnExpressionWhenCalledAtPath(e.slice(1),t,s,i):this.prototypeExpression?this.prototypeExpression.getReturnExpressionWhenCalledAtPath(e,t,s,i):U}hasEffectsWhenAccessedAtPath(e,t){const[s,...i]=e;if(e.length>1){if("string"!=typeof s)return!0;const n=this.getMemberExpression(s);return n?n.hasEffectsWhenAccessedAtPath(i,t):!this.prototypeExpression||this.prototypeExpression.hasEffectsWhenAccessedAtPath(e,t)}if(this.hasUnknownDeoptimizedProperty)return!0;if("string"==typeof s){if(this.propertiesAndGettersByKey[s]){const e=this.gettersByKey[s];if(e)for(const s of e)if(s.hasEffectsWhenAccessedAtPath(i,t))return!0;return!1}for(const e of this.unmatchableGetters)if(e.hasEffectsWhenAccessedAtPath(i,t))return!0}else for(const e of Object.values(this.gettersByKey).concat([this.unmatchableGetters]))for(const s of e)if(s.hasEffectsWhenAccessedAtPath(i,t))return!0;return!!this.prototypeExpression&&this.prototypeExpression.hasEffectsWhenAccessedAtPath(e,t)}hasEffectsWhenAssignedAtPath(e,t){const[s,...i]=e;if(e.length>1){if("string"!=typeof s)return!0;const n=this.getMemberExpression(s);return n?n.hasEffectsWhenAssignedAtPath(i,t):!this.prototypeExpression||this.prototypeExpression.hasEffectsWhenAssignedAtPath(e,t)}if(this.hasUnknownDeoptimizedProperty)return!0;if("string"==typeof s){if(this.propertiesAndSettersByKey[s]){const e=this.settersByKey[s];if(e)for(const s of e)if(s.hasEffectsWhenAssignedAtPath(i,t))return!0;return!1}for(const e of this.unmatchableSetters)if(e.hasEffectsWhenAssignedAtPath(i,t))return!0}return!!this.prototypeExpression&&this.prototypeExpression.hasEffectsWhenAssignedAtPath(e,t)}hasEffectsWhenCalledAtPath(e,t,s){const i=e[0],n=this.getMemberExpression(i);return n?n.hasEffectsWhenCalledAtPath(e.slice(1),t,s):!this.prototypeExpression||this.prototypeExpression.hasEffectsWhenCalledAtPath(e,t,s)}buildPropertyMaps(e){const{allProperties:t,propertiesAndGettersByKey:s,propertiesAndSettersByKey:i,settersByKey:n,gettersByKey:r,unknownIntegerProps:a,unmatchablePropertiesAndGetters:o,unmatchableGetters:h,unmatchableSetters:l}=this,c=[];for(let u=e.length-1;u>=0;u--){const{key:d,kind:p,property:f}=e[u];if(t.push(f),"string"!=typeof d){if(d===M){a.push(f);continue}"set"===p&&l.push(f),"get"===p&&h.push(f),"get"!==p&&c.push(f),"set"!==p&&o.push(f)}else"set"===p?i[d]||(i[d]=[f,...c],n[d]=[f,...l]):"get"===p?s[d]||(s[d]=[f,...o],r[d]=[f,...h]):(i[d]||(i[d]=[f,...c]),s[d]||(s[d]=[f,...o]))}}deoptimizeCachedEntities(){for(const e of Object.values(this.expressionsToBeDeoptimizedByKey))for(const t of e)t.deoptimizeCache();for(const e of this.thisParametersToBeDeoptimized)e.deoptimizePath(L)}deoptimizeCachedIntegerEntities(){for(const[e,t]of Object.entries(this.expressionsToBeDeoptimizedByKey))if(wt.test(e))for(const e of t)e.deoptimizeCache();for(const e of this.thisParametersToBeDeoptimized)e.deoptimizePath(O)}getMemberExpression(e){if(this.hasUnknownDeoptimizedProperty||"string"!=typeof e||this.hasUnknownDeoptimizedInteger&&wt.test(e)||this.deoptimizedPaths[e])return U;const t=this.propertiesAndGettersByKey[e];return 1===(null==t?void 0:t.length)?t[0]:t||this.unmatchablePropertiesAndGetters.length>0||this.unknownIntegerProps.length&&wt.test(e)?U:null}getMemberExpressionAndTrackDeopt(e,t){if("string"!=typeof e)return U;const s=this.getMemberExpression(e);if(s!==U&&!this.immutable){(this.expressionsToBeDeoptimizedByKey[e]=this.expressionsToBeDeoptimizedByKey[e]||[]).push(t)}return s}}class It extends j{constructor(e,t){super(),this.object=e,this.key=t}deoptimizePath(e){this.object.deoptimizePath([this.key,...e])}deoptimizeThisOnEventAtPath(e,t,s,i){this.object.deoptimizeThisOnEventAtPath(e,[this.key,...t],s,i)}getLiteralValueAtPath(e,t,s){return this.object.getLiteralValueAtPath([this.key,...e],t,s)}getReturnExpressionWhenCalledAtPath(e,t,s,i){return this.object.getReturnExpressionWhenCalledAtPath([this.key,...e],t,s,i)}hasEffectsWhenAccessedAtPath(e,t){return 0!==e.length&&this.object.hasEffectsWhenAccessedAtPath([this.key,...e],t)}hasEffectsWhenAssignedAtPath(e,t){return this.object.hasEffectsWhenAssignedAtPath([this.key,...e],t)}hasEffectsWhenCalledAtPath(e,t,s){return this.object.hasEffectsWhenCalledAtPath([this.key,...e],t,s)}}class Nt extends j{constructor(e){super(),this.description=e}deoptimizeThisOnEventAtPath(e,t,s){2===e&&0===t.length&&this.description.mutatesSelfAsArray&&s.deoptimizePath(O)}getReturnExpressionWhenCalledAtPath(e,t){return e.length>0?U:this.description.returnsPrimitive||("self"===this.description.returns?t.thisParam||U:this.description.returns())}hasEffectsWhenAccessedAtPath(e){return e.length>1}hasEffectsWhenAssignedAtPath(e){return e.length>0}hasEffectsWhenCalledAtPath(e,t,s){var i,n;if(e.length>0||!0===this.description.mutatesSelfAsArray&&(null===(i=t.thisParam)||void 0===i?void 0:i.hasEffectsWhenAssignedAtPath(O,s)))return!0;if(!this.description.callsArgs)return!1;for(const e of this.description.callsArgs)if(null===(n=t.args[e])||void 0===n?void 0:n.hasEffectsWhenCalledAtPath(D,{args:je,thisParam:null,withNew:!1},s))return!0;return!1}includeCallArguments(e,t){for(const s of t)s.include(e,!1)}}const _t=[new Nt({callsArgs:null,mutatesSelfAsArray:!1,returns:null,returnsPrimitive:qe})],$t=[new Nt({callsArgs:null,mutatesSelfAsArray:!1,returns:null,returnsPrimitive:Qe})],Tt=[new Nt({callsArgs:null,mutatesSelfAsArray:!1,returns:null,returnsPrimitive:Xe})],Rt=[new Nt({callsArgs:null,mutatesSelfAsArray:!1,returns:null,returnsPrimitive:U})],Mt=new Ct({__proto__:null,hasOwnProperty:_t,isPrototypeOf:_t,propertyIsEnumerable:_t,toLocaleString:$t,toString:$t,valueOf:Rt},null,!0);class Dt extends ke{constructor(){super(...arguments),this.objectEntity=null}createScope(e){this.scope=new ot(e)}deoptimizeCache(){this.getObjectEntity().deoptimizeAllProperties()}deoptimizePath(e){this.getObjectEntity().deoptimizePath(e)}deoptimizeThisOnEventAtPath(e,t,s,i){this.getObjectEntity().deoptimizeThisOnEventAtPath(e,t,s,i)}getLiteralValueAtPath(e,t,s){return this.getObjectEntity().getLiteralValueAtPath(e,t,s)}getReturnExpressionWhenCalledAtPath(e,t,s,i){return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(e,t,s,i)}hasEffects(e){var t,s;const i=(null===(t=this.superClass)||void 0===t?void 0:t.hasEffects(e))||this.body.hasEffects(e);return null===(s=this.id)||void 0===s||s.markDeclarationReached(),i||super.hasEffects(e)}hasEffectsWhenAccessedAtPath(e,t){return this.getObjectEntity().hasEffectsWhenAccessedAtPath(e,t)}hasEffectsWhenAssignedAtPath(e,t){return this.getObjectEntity().hasEffectsWhenAssignedAtPath(e,t)}hasEffectsWhenCalledAtPath(e,t,s){return 0===e.length?!t.withNew||(null!==this.classConstructor?this.classConstructor.hasEffectsWhenCalledAtPath(D,t,s):null!==this.superClass&&this.superClass.hasEffectsWhenCalledAtPath(e,t,s)):this.getObjectEntity().hasEffectsWhenCalledAtPath(e,t,s)}include(e,t){var s;this.included=!0,null===(s=this.superClass)||void 0===s||s.include(e,t),this.body.include(e,t),this.id&&(this.id.markDeclarationReached(),this.id.include())}initialise(){var e;null===(e=this.id)||void 0===e||e.declare("class",this);for(const e of this.body.body)if(e instanceof kt&&"constructor"===e.kind)return void(this.classConstructor=e);this.classConstructor=null}getObjectEntity(){if(null!==this.objectEntity)return this.objectEntity;const e=[],t=[];for(const s of this.body.body){const i=s.static?e:t,n=s.kind;if(i===t&&!n)continue;const r="set"===n||"get"===n?n:"init";let a;if(s.computed){const e=s.key.getLiteralValueAtPath(D,F,this);if(e===W){i.push({key:R,kind:r,property:s});continue}a=String(e)}else a=s.key instanceof St?s.key.name:String(s.key.value);i.push({key:a,kind:r,property:s})}return e.unshift({key:"prototype",kind:"init",property:new Ct(t,this.superClass?new It(this.superClass,"prototype"):Mt)}),this.objectEntity=new Ct(e,this.superClass||Mt)}}class Lt extends Dt{initialise(){super.initialise(),null!==this.id&&(this.id.variable.isId=!0)}parseNode(e){null!==e.id&&(this.id=new this.context.nodeConstructors.Identifier(e.id,this,this.scope.parent)),super.parseNode(e)}render(e,t){const{exportNamesByVariable:s,format:i,snippets:{_:n}}=t;"system"===i&&this.id&&s.has(this.id.variable)&&e.appendLeft(this.end,`${n}${Oe([this.id.variable],t)};`),super.render(e,t)}}class Ot extends rt{constructor(e){super("arguments",null,U,e)}hasEffectsWhenAccessedAtPath(e){return e.length>1}hasEffectsWhenAssignedAtPath(){return!0}hasEffectsWhenCalledAtPath(){return!0}}class Vt extends rt{constructor(e){super("this",null,null,e),this.deoptimizedPaths=[],this.entitiesToBeDeoptimized=new Set,this.thisDeoptimizationList=[],this.thisDeoptimizations=new z}addEntityToBeDeoptimized(e){for(const t of this.deoptimizedPaths)e.deoptimizePath(t);for(const t of this.thisDeoptimizationList)this.applyThisDeoptimizationEvent(e,t);this.entitiesToBeDeoptimized.add(e)}deoptimizePath(e){if(0!==e.length&&!this.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(e,this)){this.deoptimizedPaths.push(e);for(const t of this.entitiesToBeDeoptimized)t.deoptimizePath(e)}}deoptimizeThisOnEventAtPath(e,t,s){const i={event:e,path:t,thisParameter:s};if(!this.thisDeoptimizations.trackEntityAtPathAndGetIfTracked(t,e,s)){for(const e of this.entitiesToBeDeoptimized)this.applyThisDeoptimizationEvent(e,i);this.thisDeoptimizationList.push(i)}}hasEffectsWhenAccessedAtPath(e,t){return this.getInit(t).hasEffectsWhenAccessedAtPath(e,t)||super.hasEffectsWhenAccessedAtPath(e,t)}hasEffectsWhenAssignedAtPath(e,t){return this.getInit(t).hasEffectsWhenAssignedAtPath(e,t)||super.hasEffectsWhenAssignedAtPath(e,t)}applyThisDeoptimizationEvent(e,{event:t,path:s,thisParameter:i}){e.deoptimizeThisOnEventAtPath(t,s,i===this?e:i,F)}getInit(e){return e.replacedVariableInits.get(this)||U}}class Bt extends ke{constructor(){super(...arguments),this.deoptimized=!1}deoptimizeThisOnEventAtPath(e,t,s,i){t.length>0&&this.argument.deoptimizeThisOnEventAtPath(e,[R,...t],s,i)}hasEffects(e){this.deoptimized||this.applyDeoptimizations();const{propertyReadSideEffects:t}=this.context.options.treeshake;return this.argument.hasEffects(e)||t&&("always"===t||this.argument.hasEffectsWhenAccessedAtPath(L,e))}applyDeoptimizations(){this.deoptimized=!0,this.argument.deoptimizePath([R,R]),this.context.requestTreeshakingPass()}}class Ft extends ot{constructor(e,t){super(e),this.parameters=[],this.hasRest=!1,this.context=t,this.hoistedBodyVarScope=new ot(this)}addParameterDeclaration(e){const t=e.name;let s=this.hoistedBodyVarScope.variables.get(t);return s?s.addDeclaration(e,null):s=new rt(t,e,U,this.context),this.variables.set(t,s),s}addParameterVariables(e,t){this.parameters=e;for(const t of e)for(const e of t)e.alwaysRendered=!0;this.hasRest=t}includeCallArguments(e,t){let s=!1,i=!1;const n=this.hasRest&&this.parameters[this.parameters.length-1];for(const s of t)if(s instanceof Bt){for(const s of t)s.include(e,!1);break}for(let r=t.length-1;r>=0;r--){const a=this.parameters[r]||n,o=t[r];if(a)if(s=!1,0===a.length)i=!0;else for(const e of a)e.included&&(i=!0),e.calledFromTryStatement&&(s=!0);!i&&o.shouldBeIncluded(e)&&(i=!0),i&&o.include(e,s)}}}class zt extends Ft{constructor(){super(...arguments),this.returnExpression=null,this.returnExpressions=[]}addReturnExpression(e){this.returnExpressions.push(e)}getReturnExpression(){return null===this.returnExpression&&this.updateReturnExpression(),this.returnExpression}updateReturnExpression(){if(1===this.returnExpressions.length)this.returnExpression=this.returnExpressions[0];else{this.returnExpression=U;for(const e of this.returnExpressions)e.deoptimizePath(L)}}}class Wt extends zt{constructor(e,t){super(e,t),this.variables.set("arguments",this.argumentsVariable=new Ot(t)),this.variables.set("this",this.thisVariable=new Vt(t))}findLexicalBoundary(){return this}includeCallArguments(e,t){if(super.includeCallArguments(e,t),this.argumentsVariable.included)for(const s of t)s.included||s.include(e,!1)}}class jt extends ke{constructor(){super(...arguments),this.deoptimized=!1,this.declarationInit=null}addExportedVariables(e,t){this.argument.addExportedVariables(e,t)}declare(e,t){return this.declarationInit=t,this.argument.declare(e,U)}deoptimizePath(e){0===e.length&&this.argument.deoptimizePath(D)}hasEffectsWhenAssignedAtPath(e,t){return e.length>0||this.argument.hasEffectsWhenAssignedAtPath(D,t)}markDeclarationReached(){this.argument.markDeclarationReached()}applyDeoptimizations(){this.deoptimized=!0,null!==this.declarationInit&&(this.declarationInit.deoptimizePath([R,R]),this.context.requestTreeshakingPass())}}class Ut extends ke{constructor(){super(...arguments),this.deoptimizedReturn=!1,this.isPrototypeDeoptimized=!1}createScope(e){this.scope=new Wt(e,this.context)}deoptimizePath(e){1===e.length&&("prototype"===e[0]?this.isPrototypeDeoptimized=!0:e[0]===R&&(this.isPrototypeDeoptimized=!0,this.scope.getReturnExpression().deoptimizePath(L)))}deoptimizeThisOnEventAtPath(e,t,s){2===e&&(t.length>0?s.deoptimizePath(L):this.scope.thisVariable.addEntityToBeDeoptimized(s))}getReturnExpressionWhenCalledAtPath(e){return 0!==e.length?U:this.async?(this.deoptimizedReturn||(this.deoptimizedReturn=!0,this.scope.getReturnExpression().deoptimizePath(L),this.context.requestTreeshakingPass()),U):this.scope.getReturnExpression()}hasEffects(){return null!==this.id&&this.id.hasEffects()}hasEffectsWhenAccessedAtPath(e){return!(e.length<=1)&&(e.length>2||"prototype"!==e[0]||this.isPrototypeDeoptimized)}hasEffectsWhenAssignedAtPath(e){return!(e.length<=1)&&(e.length>2||"prototype"!==e[0]||this.isPrototypeDeoptimized)}hasEffectsWhenCalledAtPath(e,t,s){if(e.length>0)return!0;if(this.async){const{propertyReadSideEffects:e}=this.context.options.treeshake,t=this.scope.getReturnExpression();if(t.hasEffectsWhenCalledAtPath(["then"],{args:je,thisParam:null,withNew:!1},s)||e&&("always"===e||t.hasEffectsWhenAccessedAtPath(["then"],s)))return!0}for(const e of this.params)if(e.hasEffects(s))return!0;const i=s.replacedVariableInits.get(this.scope.thisVariable);s.replacedVariableInits.set(this.scope.thisVariable,t.withNew?new Ct(Object.create(null),Mt):U);const{brokenFlow:n,ignore:r}=s;return s.ignore={breaks:!1,continues:!1,labels:new Set,returnYield:!0},!!this.body.hasEffects(s)||(s.brokenFlow=n,i?s.replacedVariableInits.set(this.scope.thisVariable,i):s.replacedVariableInits.delete(this.scope.thisVariable),s.ignore=r,!1)}include(e,t){this.included=!0,this.id&&this.id.include();const s=this.scope.argumentsVariable.included;for(const i of this.params)i instanceof St&&!s||i.include(e,t);const{brokenFlow:i}=e;e.brokenFlow=0,this.body.include(e,t),e.brokenFlow=i}includeCallArguments(e,t){this.scope.includeCallArguments(e,t)}initialise(){null!==this.id&&this.id.declare("function",this),this.scope.addParameterVariables(this.params.map((e=>e.declare("parameter",U))),this.params[this.params.length-1]instanceof jt),this.body.addImplicitReturnExpressionToScope()}parseNode(e){this.body=new this.context.nodeConstructors.BlockStatement(e.body,this,this.scope.hoistedBodyVarScope),super.parseNode(e)}}Ut.prototype.preventChildBlockScope=!0;class Gt extends Ut{initialise(){super.initialise(),null!==this.id&&(this.id.variable.isId=!0)}parseNode(e){null!==e.id&&(this.id=new this.context.nodeConstructors.Identifier(e.id,this,this.scope.parent)),super.parseNode(e)}}class Ht extends ke{include(e,t){super.include(e,t),t&&this.context.includeVariableInModule(this.variable)}initialise(){const e=this.declaration;this.declarationName=e.id&&e.id.name||this.declaration.name,this.variable=this.scope.addExportDefaultDeclaration(this.declarationName||this.context.getModuleName(),this,this.context),this.context.addExport(this)}render(e,t,s){const{start:i,end:n}=s,r=function(e,t){return Te(e,_e(e,"default",t)+7)}(e.original,this.start);if(this.declaration instanceof Gt)this.renderNamedDeclaration(e,r,"function","(",null===this.declaration.id,t);else if(this.declaration instanceof Lt)this.renderNamedDeclaration(e,r,"class","{",null===this.declaration.id,t);else{if(this.variable.getOriginalVariable()!==this.variable)return void Ce(this,e,i,n);if(!this.variable.included)return e.remove(this.start,r),this.declaration.render(e,t,{renderedSurroundingElement:"ExpressionStatement"}),void(";"!==e.original[this.end-1]&&e.appendLeft(this.end,";"));this.renderVariableDeclaration(e,r,t)}this.declaration.render(e,t)}renderNamedDeclaration(e,t,s,i,n,r){const{exportNamesByVariable:a,format:o,snippets:{getPropertyAccess:h}}=r,l=this.variable.getName(h);e.remove(this.start,t),n&&e.appendLeft(function(e,t,s,i){const n=_e(e,t,i)+t.length;e=e.slice(n,_e(e,s,n));const r=_e(e,"*");return-1===r?n:n+r+1}(e.original,s,i,t),` ${l}`),"system"===o&&this.declaration instanceof Lt&&a.has(this.variable)&&e.appendLeft(this.end,` ${Oe([this.variable],r)};`)}renderVariableDeclaration(e,t,{format:s,exportNamesByVariable:i,snippets:{cnst:n,getPropertyAccess:r}}){const a=59===e.original.charCodeAt(this.end-1),o="system"===s&&i.get(this.variable);o?(e.overwrite(this.start,t,`${n} ${this.variable.getName(r)} = exports('${o[0]}', `),e.appendRight(a?this.end-1:this.end,")"+(a?"":";"))):(e.overwrite(this.start,t,`${n} ${this.variable.getName(r)} = `),a||e.appendLeft(this.end,";"))}}Ht.prototype.needsBoundaries=!0;class qt extends ke{deoptimizeThisOnEventAtPath(){}getLiteralValueAtPath(e){return e.length>0||null===this.value&&110!==this.context.code.charCodeAt(this.start)||"bigint"==typeof this.value||47===this.context.code.charCodeAt(this.start)?W:this.value}getReturnExpressionWhenCalledAtPath(e){return 1!==e.length?U:nt(this.members,e[0])}hasEffectsWhenAccessedAtPath(e){return null===this.value?e.length>0:e.length>1}hasEffectsWhenAssignedAtPath(e){return e.length>0}hasEffectsWhenCalledAtPath(e,t,s){return 1!==e.length||it(this.members,e[0],t,s)}initialise(){this.members=function(e){switch(typeof e){case"boolean":return et;case"number":return tt;case"string":return st;default:return Object.create(null)}}(this.value)}parseNode(e){this.value=e.value,this.regex=e.regex,super.parseNode(e)}render(e){"string"==typeof this.value&&e.indentExclusionRanges.push([this.start+1,this.end-1])}}class Kt extends ke{constructor(){super(...arguments),this.hasCachedEffect=!1}hasEffects(e){if(this.hasCachedEffect)return!0;for(const t of this.body)if(t.hasEffects(e))return this.hasCachedEffect=!0;return!1}include(e,t){this.included=!0;for(const s of this.body)(t||s.shouldBeIncluded(e))&&s.include(e,t)}render(e,t){this.body.length?Me(this.body,e,this.start,this.end,t):super.render(e,t)}}class Xt extends ke{getLiteralValueAtPath(e){return e.length>0||1!==this.quasis.length?W:this.quasis[0].value.cooked}render(e,t){e.indentExclusionRanges.push([this.start,this.end]),super.render(e,t)}}function Yt(e,t){return null!==e.renderBaseName&&t.has(e)&&e.isReassigned}class Qt extends ke{deoptimizePath(){for(const e of this.declarations)e.deoptimizePath(D)}hasEffectsWhenAssignedAtPath(){return!1}include(e,t){this.included=!0;for(const s of this.declarations)(t||s.shouldBeIncluded(e))&&s.include(e,t)}includeAsSingleStatement(e,t){this.included=!0;for(const s of this.declarations)(t||s.shouldBeIncluded(e))&&(s.include(e,t),s.id.include(e,t))}initialise(){for(const e of this.declarations)e.declareDeclarator(this.kind)}render(e,t,s=q){if(function(e,t){for(const s of e){if(!s.id.included)return!1;if("Identifier"===s.id.type){if(t.has(s.id.variable))return!1}else{const e=[];if(s.id.addExportedVariables(e,t),e.length>0)return!1}}return!0}(this.declarations,t.exportNamesByVariable)){for(const s of this.declarations)s.render(e,t);s.isNoStatement||59===e.original.charCodeAt(this.end-1)||e.appendLeft(this.end,";")}else this.renderReplacedDeclarations(e,t,s)}renderDeclarationEnd(e,t,s,i,n,r,a,o){59===e.original.charCodeAt(this.end-1)&&e.remove(this.end-1,this.end),o||(t+=";"),null!==s?(10!==e.original.charCodeAt(i-1)||10!==e.original.charCodeAt(this.end)&&13!==e.original.charCodeAt(this.end)||(i--,13===e.original.charCodeAt(i)&&i--),i===s+1?e.overwrite(s,n,t):(e.overwrite(s,s+1,t),e.remove(i,n))):e.appendLeft(n,t),r.length>0&&e.appendLeft(n,` ${Oe(r,a)};`)}renderReplacedDeclarations(e,t,{isNoStatement:s}){const i=De(this.declarations,e,this.start+this.kind.length,this.end-(59===e.original.charCodeAt(this.end-1)?1:0));let n,r;r=Te(e.original,this.start+this.kind.length);let a=r-1;e.remove(this.start,a);let o,h,l=!1,c=!1,u="";const d=[],p=function(e,t,s){var i;let n=null;if("system"===t.format){for(const{node:r}of e)r.id instanceof St&&r.init&&0===s.length&&1===(null===(i=t.exportNamesByVariable.get(r.id.variable))||void 0===i?void 0:i.length)?(n=r.id.variable,s.push(n)):r.id.addExportedVariables(s,t.exportNamesByVariable);s.length>1?n=null:n&&(s.length=0)}return n}(i,t,d);for(const{node:s,start:d,separator:f,contentEnd:m,end:g}of i)if(s.included){if(s.render(e,t),o="",h="",!s.id.included||s.id instanceof St&&Yt(s.id.variable,t.exportNamesByVariable))c&&(u+=";"),l=!1;else{if(p&&p===s.id.variable){const i=_e(e.original,"=",s.id.end);Ve(p,Te(e.original,i+1),null===f?m:f,e,t)}l?u+=",":(c&&(u+=";"),o+=`${this.kind} `,l=!0)}r===a+1?e.overwrite(a,r,u+o):(e.overwrite(a,a+1,u),e.appendLeft(r,o)),n=m,r=g,c=!0,a=f,u=""}else e.remove(d,g);this.renderDeclarationEnd(e,u,a,n,r,d,t,s)}}const Zt=[{key:M,kind:"init",property:U},{key:"length",kind:"init",property:Xe}],Jt=[new Nt({callsArgs:[0],mutatesSelfAsArray:"deopt-only",returns:null,returnsPrimitive:qe})],es=[new Nt({callsArgs:[0],mutatesSelfAsArray:"deopt-only",returns:null,returnsPrimitive:Xe})],ts=[new Nt({callsArgs:null,mutatesSelfAsArray:!0,returns:()=>new Ct(Zt,cs),returnsPrimitive:null})],ss=[new Nt({callsArgs:null,mutatesSelfAsArray:"deopt-only",returns:()=>new Ct(Zt,cs),returnsPrimitive:null})],is=[new Nt({callsArgs:[0],mutatesSelfAsArray:"deopt-only",returns:()=>new Ct(Zt,cs),returnsPrimitive:null})],ns=[new Nt({callsArgs:null,mutatesSelfAsArray:!0,returns:null,returnsPrimitive:Xe})],rs=[new Nt({callsArgs:null,mutatesSelfAsArray:!0,returns:null,returnsPrimitive:U})],as=[new Nt({callsArgs:null,mutatesSelfAsArray:"deopt-only",returns:null,returnsPrimitive:U})],os=[new Nt({callsArgs:[0],mutatesSelfAsArray:"deopt-only",returns:null,returnsPrimitive:U})],hs=[new Nt({callsArgs:null,mutatesSelfAsArray:!0,returns:"self",returnsPrimitive:null})],ls=[new Nt({callsArgs:[0],mutatesSelfAsArray:!0,returns:"self",returnsPrimitive:null})],cs=new Ct({__proto__:null,at:as,concat:ss,copyWithin:hs,entries:ss,every:Jt,fill:hs,filter:is,find:os,findIndex:es,forEach:os,includes:_t,indexOf:Tt,join:$t,keys:Rt,lastIndexOf:Tt,map:is,pop:rs,push:ns,reduce:os,reduceRight:os,reverse:hs,shift:rs,slice:ss,some:Jt,sort:ls,splice:ts,unshift:ns,values:as},Mt,!0);class us extends ot{addDeclaration(e,t,s,i){if(i){const n=this.parent.addDeclaration(e,t,s,i);return n.markInitializersForDeoptimization(),n}return super.addDeclaration(e,t,s,!1)}}class ds extends ke{initialise(){this.directive&&"use strict"!==this.directive&&"Program"===this.parent.type&&this.context.warn({code:"MODULE_LEVEL_DIRECTIVE",message:`Module level directives cause errors when bundled, '${this.directive}' was ignored.`},this.start)}render(e,t){super.render(e,t),this.included&&this.insertSemicolon(e)}shouldBeIncluded(e){return this.directive&&"use strict"!==this.directive?"Program"!==this.parent.type:super.shouldBeIncluded(e)}}class ps extends ke{constructor(){super(...arguments),this.directlyIncluded=!1}addImplicitReturnExpressionToScope(){const e=this.body[this.body.length-1];e&&"ReturnStatement"===e.type||this.scope.addReturnExpression(U)}createScope(e){this.scope=this.parent.preventChildBlockScope?e:new us(e)}hasEffects(e){if(this.deoptimizeBody)return!0;for(const t of this.body){if(t.hasEffects(e))return!0;if(e.brokenFlow)break}return!1}include(e,t){if(!this.deoptimizeBody||!this.directlyIncluded){this.included=!0,this.directlyIncluded=!0,this.deoptimizeBody&&(t=!0);for(const s of this.body)(t||s.shouldBeIncluded(e))&&s.include(e,t)}}initialise(){const e=this.body[0];this.deoptimizeBody=e instanceof ds&&"use asm"===e.directive}render(e,t){this.body.length?Me(this.body,e,this.start+1,this.end-1,t):super.render(e,t)}}class fs extends ke{constructor(){super(...arguments),this.deoptimizedReturn=!1}createScope(e){this.scope=new zt(e,this.context)}deoptimizePath(e){1===e.length&&e[0]===R&&this.scope.getReturnExpression().deoptimizePath(L)}deoptimizeThisOnEventAtPath(){}getReturnExpressionWhenCalledAtPath(e){return 0!==e.length?U:this.async?(this.deoptimizedReturn||(this.deoptimizedReturn=!0,this.scope.getReturnExpression().deoptimizePath(L),this.context.requestTreeshakingPass()),U):this.scope.getReturnExpression()}hasEffects(){return!1}hasEffectsWhenAccessedAtPath(e){return e.length>1}hasEffectsWhenAssignedAtPath(e){return e.length>1}hasEffectsWhenCalledAtPath(e,t,s){if(e.length>0)return!0;if(this.async){const{propertyReadSideEffects:e}=this.context.options.treeshake,t=this.scope.getReturnExpression();if(t.hasEffectsWhenCalledAtPath(["then"],{args:je,thisParam:null,withNew:!1},s)||e&&("always"===e||t.hasEffectsWhenAccessedAtPath(["then"],s)))return!0}for(const e of this.params)if(e.hasEffects(s))return!0;const{ignore:i,brokenFlow:n}=s;return s.ignore={breaks:!1,continues:!1,labels:new Set,returnYield:!0},!!this.body.hasEffects(s)||(s.ignore=i,s.brokenFlow=n,!1)}include(e,t){this.included=!0;for(const s of this.params)s instanceof St||s.include(e,t);const{brokenFlow:s}=e;e.brokenFlow=0,this.body.include(e,t),e.brokenFlow=s}includeCallArguments(e,t){this.scope.includeCallArguments(e,t)}initialise(){this.scope.addParameterVariables(this.params.map((e=>e.declare("parameter",U))),this.params[this.params.length-1]instanceof jt),this.body instanceof ps?this.body.addImplicitReturnExpressionToScope():this.scope.addReturnExpression(this.body)}parseNode(e){"BlockStatement"===e.body.type&&(this.body=new this.context.nodeConstructors.BlockStatement(e.body,this,this.scope.hoistedBodyVarScope)),super.parseNode(e)}}fs.prototype.preventChildBlockScope=!0;class ms extends ke{addExportedVariables(e,t){for(const s of this.properties)"Property"===s.type?s.value.addExportedVariables(e,t):s.argument.addExportedVariables(e,t)}declare(e,t){const s=[];for(const i of this.properties)s.push(...i.declare(e,t));return s}deoptimizePath(e){if(0===e.length)for(const t of this.properties)t.deoptimizePath(e)}hasEffectsWhenAssignedAtPath(e,t){if(e.length>0)return!0;for(const e of this.properties)if(e.hasEffectsWhenAssignedAtPath(D,t))return!0;return!1}markDeclarationReached(){for(const e of this.properties)e.markDeclarationReached()}}class gs extends ke{constructor(){super(...arguments),this.deoptimized=!1}hasEffects(e){return this.deoptimized||this.applyDeoptimizations(),this.right.hasEffects(e)||this.left.hasEffects(e)||this.left.hasEffectsWhenAssignedAtPath(D,e)}hasEffectsWhenAccessedAtPath(e,t){return e.length>0&&this.right.hasEffectsWhenAccessedAtPath(e,t)}include(e,t){let s;this.deoptimized||this.applyDeoptimizations(),this.included=!0,(t||"="!==this.operator||this.left.included||(s=ue(),this.left.hasEffects(s)||this.left.hasEffectsWhenAssignedAtPath(D,s)))&&this.left.include(e,t),this.right.include(e,t)}render(e,t,{preventASI:s,renderedParentType:i,renderedSurroundingElement:n}=q){if(this.left.included)this.left.render(e,t),this.right.render(e,t);else{const r=Te(e.original,_e(e.original,"=",this.left.end)+1);e.remove(this.start,r),s&&Le(e,r,this.right.start),this.right.render(e,t,{renderedParentType:i||this.parent.type,renderedSurroundingElement:n||this.parent.type})}if("system"===t.format)if(this.left instanceof St){const s=this.left.variable,i=t.exportNamesByVariable.get(s);if(i)return void(1===i.length?Ve(s,this.start,this.end,e,t):Be(s,this.start,this.end,"ExpressionStatement"!==this.parent.type,e,t))}else{const s=[];if(this.left.addExportedVariables(s,t.exportNamesByVariable),s.length>0)return void function(e,t,s,i,n,r){const{_:a,getDirectReturnIifeLeft:o}=r.snippets;n.prependRight(t,o(["v"],`${Oe(e,r)},${a}v`,{needsArrowReturnParens:!0,needsWrappedFunction:i})),n.appendLeft(s,")")}(s,this.start,this.end,"ExpressionStatement"===n,e,t)}this.left.included&&this.left instanceof ms&&("ExpressionStatement"===n||"ArrowFunctionExpression"===n)&&(e.appendRight(this.start,"("),e.prependLeft(this.end,")"))}applyDeoptimizations(){this.deoptimized=!0,this.left.deoptimizePath(D),this.right.deoptimizePath(L),this.context.requestTreeshakingPass()}}const ys={"!=":(e,t)=>e!=t,"!==":(e,t)=>e!==t,"%":(e,t)=>e%t,"&":(e,t)=>e&t,"*":(e,t)=>e*t,"**":(e,t)=>e**t,"+":(e,t)=>e+t,"-":(e,t)=>e-t,"/":(e,t)=>e/t,"<":(e,t)=>e<t,"<<":(e,t)=>e<<t,"<=":(e,t)=>e<=t,"==":(e,t)=>e==t,"===":(e,t)=>e===t,">":(e,t)=>e>t,">=":(e,t)=>e>=t,">>":(e,t)=>e>>t,">>>":(e,t)=>e>>>t,"^":(e,t)=>e^t,in:()=>W,instanceof:()=>W,"|":(e,t)=>e|t};function Es(e){return e.computed?function(e){if(e instanceof qt)return String(e.value);return null}(e.property):e.property.name}function xs(e){const t=e.propertyKey,s=e.object;if("string"==typeof t){if(s instanceof St)return[{key:s.name,pos:s.start},{key:t,pos:e.property.start}];if(s instanceof vs){const i=xs(s);return i&&[...i,{key:t,pos:e.property.start}]}}return null}class vs extends ke{constructor(){super(...arguments),this.variable=null,this.deoptimized=!1,this.bound=!1,this.expressionsToBeDeoptimized=[],this.replacement=null}bind(){this.bound=!0;const e=xs(this),t=e&&this.scope.findVariable(e[0].key);if(t&&t.isNamespace){const s=this.resolveNamespaceVariables(t,e.slice(1));s?"string"==typeof s?this.replacement=s:(this.variable=s,this.scope.addNamespaceMemberAccess(function(e){let t=e[0].key;for(let s=1;s<e.length;s++)t+="."+e[s].key;return t}(e),s)):super.bind()}else super.bind()}deoptimizeCache(){const e=this.expressionsToBeDeoptimized;this.expressionsToBeDeoptimized=[],this.propertyKey=R,this.object.deoptimizePath(L);for(const t of e)t.deoptimizeCache()}deoptimizePath(e){0===e.length&&this.disallowNamespaceReassignment(),this.variable?this.variable.deoptimizePath(e):this.replacement||e.length<7&&this.object.deoptimizePath([this.getPropertyKey(),...e])}deoptimizeThisOnEventAtPath(e,t,s,i){this.variable?this.variable.deoptimizeThisOnEventAtPath(e,t,s,i):this.replacement||(t.length<7?this.object.deoptimizeThisOnEventAtPath(e,[this.getPropertyKey(),...t],s,i):s.deoptimizePath(L))}getLiteralValueAtPath(e,t,s){return null!==this.variable?this.variable.getLiteralValueAtPath(e,t,s):this.replacement?W:(this.expressionsToBeDeoptimized.push(s),e.length<7?this.object.getLiteralValueAtPath([this.getPropertyKey(),...e],t,s):W)}getReturnExpressionWhenCalledAtPath(e,t,s,i){return null!==this.variable?this.variable.getReturnExpressionWhenCalledAtPath(e,t,s,i):this.replacement?U:(this.expressionsToBeDeoptimized.push(i),e.length<7?this.object.getReturnExpressionWhenCalledAtPath([this.getPropertyKey(),...e],t,s,i):U)}hasEffects(e){this.deoptimized||this.applyDeoptimizations();const{propertyReadSideEffects:t}=this.context.options.treeshake;return this.property.hasEffects(e)||this.object.hasEffects(e)||!(this.variable||this.replacement||this.parent instanceof gs&&"="===this.parent.operator)&&t&&("always"===t||this.object.hasEffectsWhenAccessedAtPath([this.getPropertyKey()],e))}hasEffectsWhenAccessedAtPath(e,t){return null!==this.variable?this.variable.hasEffectsWhenAccessedAtPath(e,t):!!this.replacement||(!(e.length<7)||this.object.hasEffectsWhenAccessedAtPath([this.getPropertyKey(),...e],t))}hasEffectsWhenAssignedAtPath(e,t){return null!==this.variable?this.variable.hasEffectsWhenAssignedAtPath(e,t):!!this.replacement||(!(e.length<7)||this.object.hasEffectsWhenAssignedAtPath([this.getPropertyKey(),...e],t))}hasEffectsWhenCalledAtPath(e,t,s){return null!==this.variable?this.variable.hasEffectsWhenCalledAtPath(e,t,s):!!this.replacement||(!(e.length<7)||this.object.hasEffectsWhenCalledAtPath([this.getPropertyKey(),...e],t,s))}include(e,t){this.deoptimized||this.applyDeoptimizations(),this.included||(this.included=!0,null!==this.variable&&this.context.includeVariableInModule(this.variable)),this.object.include(e,t),this.property.include(e,t)}includeCallArguments(e,t){this.variable?this.variable.includeCallArguments(e,t):super.includeCallArguments(e,t)}initialise(){this.propertyKey=Es(this)}render(e,t,{renderedParentType:s,isCalleeOfRenderedParent:i,renderedSurroundingElement:n}=q){if(this.variable||this.replacement){const{snippets:{getPropertyAccess:n}}=t;let r=this.variable?this.variable.getName(n):this.replacement;s&&i&&(r="0, "+r),e.overwrite(this.start,this.end,r,{contentOnly:!0,storeName:!0})}else s&&i&&e.appendRight(this.start,"0, "),this.object.render(e,t,{renderedSurroundingElement:n}),this.property.render(e,t)}applyDeoptimizations(){this.deoptimized=!0;const{propertyReadSideEffects:e}=this.context.options.treeshake;this.bound&&e&&!this.variable&&!this.replacement&&(this.parent instanceof gs&&"="===this.parent.operator||this.object.deoptimizeThisOnEventAtPath(0,[this.propertyKey],this.object,F),this.parent instanceof gs&&this.object.deoptimizeThisOnEventAtPath(1,[this.propertyKey],this.object,F),this.context.requestTreeshakingPass())}disallowNamespaceReassignment(){if(this.object instanceof St){this.scope.findVariable(this.object.name).isNamespace&&(this.variable&&this.context.includeVariableInModule(this.variable),this.context.warn({code:"ILLEGAL_NAMESPACE_REASSIGNMENT",message:`Illegal reassignment to import '${this.object.name}'`},this.start))}}getPropertyKey(){if(null===this.propertyKey){this.propertyKey=R;const e=this.property.getLiteralValueAtPath(D,F,this);return this.propertyKey=e===W?R:String(e)}return this.propertyKey}resolveNamespaceVariables(e,t){if(0===t.length)return e;if(!e.isNamespace||e instanceof H)return null;const s=t[0].key,i=e.context.traceExport(s);if(!i){const i=e.context.fileName;return this.context.warn({code:"MISSING_EXPORT",exporter:ne(i),importer:ne(this.context.fileName),message:`'${s}' is not exported by '${ne(i)}'`,missing:s,url:"https://rollupjs.org/guide/en/#error-name-is-not-exported-by-module"},t[0].pos),"undefined"}return this.resolveNamespaceVariables(i,t.slice(1))}}class bs extends Ft{addDeclaration(e,t,s,i){const n=this.variables.get(e.name);return n?(this.parent.addDeclaration(e,t,Ge,i),n.addDeclaration(e,s),n):this.parent.addDeclaration(e,t,s,i)}}class Ss extends ot{constructor(e,t,s){super(e),this.variables.set("this",this.thisVariable=new rt("this",null,t,s)),this.instanceScope=new ot(this),this.instanceScope.variables.set("this",new Vt(s))}findLexicalBoundary(){return this}}class As extends j{constructor(e){super(),this.expressions=e,this.included=!1}deoptimizePath(e){for(const t of this.expressions)t.deoptimizePath(e)}getReturnExpressionWhenCalledAtPath(e,t,s,i){return new As(this.expressions.map((n=>n.getReturnExpressionWhenCalledAtPath(e,t,s,i))))}hasEffectsWhenAccessedAtPath(e,t){for(const s of this.expressions)if(s.hasEffectsWhenAccessedAtPath(e,t))return!0;return!1}hasEffectsWhenAssignedAtPath(e,t){for(const s of this.expressions)if(s.hasEffectsWhenAssignedAtPath(e,t))return!0;return!1}hasEffectsWhenCalledAtPath(e,t,s){for(const i of this.expressions)if(i.hasEffectsWhenCalledAtPath(e,t,s))return!0;return!1}include(e,t){for(const s of this.expressions)s.included||s.include(e,t)}}class Ps extends ke{bind(){null!==this.declaration&&this.declaration.bind()}hasEffects(e){return null!==this.declaration&&this.declaration.hasEffects(e)}initialise(){this.context.addExport(this)}render(e,t,s){const{start:i,end:n}=s;null===this.declaration?e.remove(i,n):(e.remove(this.start,this.declaration.start),this.declaration.render(e,t,{end:n,start:i}))}}Ps.prototype.needsBoundaries=!0;class ks extends us{constructor(){super(...arguments),this.hoistedDeclarations=[]}addDeclaration(e,t,s,i){return this.hoistedDeclarations.push(e),super.addDeclaration(e,t,s,i)}}const ws=Symbol("unset");class Cs extends ke{constructor(){super(...arguments),this.testValue=ws}deoptimizeCache(){this.testValue=W}hasEffects(e){if(this.test.hasEffects(e))return!0;const t=this.getTestValue();if(t===W){const{brokenFlow:t}=e;if(this.consequent.hasEffects(e))return!0;const s=e.brokenFlow;return e.brokenFlow=t,null===this.alternate?!1:!!this.alternate.hasEffects(e)||(e.brokenFlow=e.brokenFlow<s?e.brokenFlow:s,!1)}return t?this.consequent.hasEffects(e):null!==this.alternate&&this.alternate.hasEffects(e)}include(e,t){if(this.included=!0,t)this.includeRecursively(t,e);else{const t=this.getTestValue();t===W?this.includeUnknownTest(e):this.includeKnownTest(e,t)}}parseNode(e){this.consequentScope=new ks(this.scope),this.consequent=new(this.context.nodeConstructors[e.consequent.type]||this.context.nodeConstructors.UnknownNode)(e.consequent,this,this.consequentScope),e.alternate&&(this.alternateScope=new ks(this.scope),this.alternate=new(this.context.nodeConstructors[e.alternate.type]||this.context.nodeConstructors.UnknownNode)(e.alternate,this,this.alternateScope)),super.parseNode(e)}render(e,t){const{snippets:{getPropertyAccess:s}}=t,i=this.getTestValue(),n=[],r=this.test.included,a=!this.context.options.treeshake;r?this.test.render(e,t):e.remove(this.start,this.consequent.start),this.consequent.included&&(a||i===W||i)?this.consequent.render(e,t):(e.overwrite(this.consequent.start,this.consequent.end,r?";":""),n.push(...this.consequentScope.hoistedDeclarations)),this.alternate&&(!this.alternate.included||!a&&i!==W&&i?(r&&this.shouldKeepAlternateBranch()?e.overwrite(this.alternate.start,this.end,";"):e.remove(this.consequent.end,this.end),n.push(...this.alternateScope.hoistedDeclarations)):(r?101===e.original.charCodeAt(this.alternate.start-1)&&e.prependLeft(this.alternate.start," "):e.remove(this.consequent.end,this.alternate.start),this.alternate.render(e,t))),this.renderHoistedDeclarations(n,e,s)}getTestValue(){return this.testValue===ws?this.testValue=this.test.getLiteralValueAtPath(D,F,this):this.testValue}includeKnownTest(e,t){this.test.shouldBeIncluded(e)&&this.test.include(e,!1),t&&this.consequent.shouldBeIncluded(e)&&this.consequent.includeAsSingleStatement(e,!1),null!==this.alternate&&!t&&this.alternate.shouldBeIncluded(e)&&this.alternate.includeAsSingleStatement(e,!1)}includeRecursively(e,t){this.test.include(t,e),this.consequent.include(t,e),null!==this.alternate&&this.alternate.include(t,e)}includeUnknownTest(e){this.test.include(e,!1);const{brokenFlow:t}=e;let s=0;this.consequent.shouldBeIncluded(e)&&(this.consequent.includeAsSingleStatement(e,!1),s=e.brokenFlow,e.brokenFlow=t),null!==this.alternate&&this.alternate.shouldBeIncluded(e)&&(this.alternate.includeAsSingleStatement(e,!1),e.brokenFlow=e.brokenFlow<s?e.brokenFlow:s)}renderHoistedDeclarations(e,t,s){const i=[...new Set(e.map((e=>{const t=e.variable;return t.included?t.getName(s):""})))].filter(Boolean).join(", ");if(i){const e=this.parent.type,s="Program"!==e&&"BlockStatement"!==e;t.prependRight(this.start,`${s?"{ ":""}var ${i}; `),s&&t.appendLeft(this.end," }")}}shouldKeepAlternateBranch(){let e=this.parent;do{if(e instanceof Cs&&e.alternate)return!0;if(e instanceof ps)return!1;e=e.parent}while(e);return!1}}class Is extends ke{bind(){}hasEffects(){return!1}initialise(){this.context.addImport(this)}render(e,t,s){e.remove(s.start,s.end)}}Is.prototype.needsBoundaries=!0;const Ns={auto:"_interopDefault",default:null,defaultOnly:null,esModule:null,false:null,true:"_interopDefaultLegacy"},_s=(e,t)=>"esModule"===e||t&&("auto"===e||"true"===e),$s={auto:"_interopNamespace",default:"_interopNamespaceDefault",defaultOnly:"_interopNamespaceDefaultOnly",esModule:null,false:null,true:"_interopNamespace"},Ts=(e,t)=>_s(e,t)&&"_interopDefault"===Ns[e],Rs=(e,t,s,i,n,r,a)=>{const o=new Set(e);for(const e of Us)t.has(e)&&o.add(e);return Us.map((e=>o.has(e)?Ms[e](s,i,n,r,a,o):"")).join("")},Ms={_interopDefaultLegacy(e,t,s){const{_:i,getDirectReturnFunction:n,n:r}=t,[a,o]=n(["e"],{functionReturn:!0,lineBreakIndent:null,name:"_interopDefaultLegacy"});return`${a}e${i}&&${i}typeof e${i}===${i}'object'${i}&&${i}'default'${i}in e${i}?${i}${s?Ds(t):Ls(t)}${o}${r}${r}`},_interopDefault(e,t,s){const{_:i,getDirectReturnFunction:n,n:r}=t,[a,o]=n(["e"],{functionReturn:!0,lineBreakIndent:null,name:"_interopDefault"});return`${a}e${i}&&${i}e.__esModule${i}?${i}${s?Ds(t):Ls(t)}${o}${r}${r}`},_interopNamespaceDefaultOnly(e,{_:t,getDirectReturnFunction:s,getObject:i,n:n},r,a,o){const[h,l]=s(["e"],{functionReturn:!0,lineBreakIndent:null,name:"_interopNamespaceDefaultOnly"});return`${h}${js(i([["__proto__","null"],...o?[[null,`[Symbol.toStringTag]:${t}'Module'`]]:[],["default","e"]],{lineBreakIndent:null}),a)}${l}${n}${n}`},_interopNamespaceDefault(e,t,s,i,n){const{_:r,n:a}=t;return`function _interopNamespaceDefault(e)${r}{${a}`+Os(e,e,t,s,i,n)+`}${a}${a}`},_interopNamespace(e,t,s,i,n,r){const{_:a,getDirectReturnFunction:o,n:h}=t;if(r.has("_interopNamespaceDefault")){const[e,t]=o(["e"],{functionReturn:!0,lineBreakIndent:null,name:"_interopNamespace"});return`${e}e${a}&&${a}e.__esModule${a}?${a}e${a}:${a}_interopNamespaceDefault(e)${t}${h}${h}`}return`function _interopNamespace(e)${a}{${h}${e}if${a}(e${a}&&${a}e.__esModule)${a}return e;${h}`+Os(e,e,t,s,i,n)+`}${h}${h}`},_mergeNamespaces(e,t,s,i){const{_:n,n:r}=t;return`function _mergeNamespaces(n, m)${n}{${r}${e}${Bs(`{${r}${e}${e}${e}if${n}(k${n}!==${n}'default'${n}&&${n}!(k in n))${n}{${r}`+(s?zs:Ws)(e,e+e+e+e,t)+`${e}${e}${e}}${r}`+`${e}${e}}`,!s,e,t)}${r}${e}return ${js("n",i)};${r}}${r}${r}`}},Ds=({_:e,getObject:t})=>`e${e}:${e}${t([["default","e"]],{lineBreakIndent:null})}`,Ls=({_:e,getPropertyAccess:t})=>`e${t("default")}${e}:${e}e`,Os=(e,t,s,i,n,r)=>{const{_:a,cnst:o,getPropertyAccess:h,n:l,s:c}=s,u=`{${l}`+(i?Fs:Ws)(e,t+e+e,s)+`${t}${e}}`;return`${t}${o} n${a}=${a}${r?`{__proto__:${a}null,${a}[Symbol.toStringTag]:${a}'Module'}`:"Object.create(null)"};${l}${t}if${a}(e)${a}{${l}${t}${e}${Vs(u,!i,s)}${l}${t}}${l}${t}n${h("default")}${a}=${a}e;${l}${t}return ${js("n",n)}${c}${l}`},Vs=(e,t,{_:s,cnst:i,getFunctionIntro:n,s:r})=>"var"!==i||t?`for${s}(${i} k in e)${s}${e}`:`Object.keys(e).forEach(${n(["k"],{isAsync:!1,name:null})}${e})${r}`,Bs=(e,t,s,{_:i,cnst:n,getDirectReturnFunction:r,getFunctionIntro:a,n:o})=>{if("var"!==n||t)return`for${i}(var i${i}=${i}0;${i}i${i}<${i}m.length;${i}i++)${i}{${o}${s}${s}${n} e${i}=${i}m[i];${o}${s}${s}for${i}(${n} k in e)${i}${e}${o}${s}}`;const[h,l]=r(["e"],{functionReturn:!1,lineBreakIndent:{base:s,t:s},name:null});return`m.forEach(${h}Object.keys(e).forEach(${a(["k"],{isAsync:!1,name:null})}${e})${l});`},Fs=(e,t,s)=>{const{_:i,n:n}=s;return`${t}if${i}(k${i}!==${i}'default')${i}{${n}`+zs(e,t+e,s)+`${t}}${n}`},zs=(e,t,{_:s,cnst:i,getDirectReturnFunction:n,n:r})=>{const[a,o]=n([],{functionReturn:!0,lineBreakIndent:null,name:null});return`${t}${i} d${s}=${s}Object.getOwnPropertyDescriptor(e,${s}k);${r}${t}Object.defineProperty(n,${s}k,${s}d.get${s}?${s}d${s}:${s}{${r}${t}${e}enumerable:${s}true,${r}${t}${e}get:${s}${a}e[k]${o}${r}${t}});${r}`},Ws=(e,t,{_:s,n:i})=>`${t}n[k]${s}=${s}e[k];${i}`,js=(e,t)=>t?`Object.freeze(${e})`:e,Us=Object.keys(Ms);function Gs(e,t,s){return"external"===t?$s[String(s(e instanceof ae?e.id:null))]:"default"===t?"_interopNamespaceDefaultOnly":null}const Hs={amd:["require"],cjs:["require"],system:["module"]};function qs(e){return e.replace(/^\t+/,(e=>e.split("\t").join("  ")))}function Ks(e){throw e instanceof Error||(e=Object.assign(new Error(e.message),e)),e}function Xs(e,t,s,i){if("object"==typeof t){const{line:s,column:n}=t;e.loc={column:n,file:i,line:s}}else{e.pos=t;const{line:n,column:r}=le(s,t,{offsetLine:1});e.loc={column:r,file:i,line:n}}if(void 0===e.frame){const{line:t,column:i}=e.loc;e.frame=function(e,t,s){let i=e.split("\n");const n=Math.max(0,t-3);let r=Math.min(t+2,i.length);for(i=i.slice(n,r);!/\S/.test(i[i.length-1]);)i.pop(),r-=1;const a=String(r).length;return i.map(((e,i)=>{const r=n+i+1===t;let o=String(i+n+1);for(;o.length<a;)o=` ${o}`;if(r){const t=function(e){let t="";for(;e--;)t+=" ";return t}(a+2+qs(e.slice(0,s)).length)+"^";return`${o}: ${qs(e)}\n${t}`}return`${o}: ${qs(e)}`})).join("\n")}(s,t,i)}}var Ys;function Qs({fileName:e,code:t},s){const i={code:Ys.CHUNK_INVALID,message:`Chunk "${e}" is not valid JavaScript: ${s.message}.`};return Xs(i,s.loc,t,e),i}function Zs(e,t,s){return{code:"INVALID_EXPORT_OPTION",message:`"${e}" was specified for "output.exports", but entry module "${ne(s)}" has the following exports: ${t.join(", ")}`}}function Js(e,t,s,i){return{code:Ys.INVALID_OPTION,message:`Invalid value ${void 0!==i?`${JSON.stringify(i)} `:""}for option "${e}" - ${s}.`,url:`https://rollupjs.org/guide/en/#${t}`}}function ei(e,t,s){return{code:Ys.MISSING_EXPORT,message:`'${e}' is not exported by ${ne(s)}, imported by ${ne(t)}`,url:"https://rollupjs.org/guide/en/#error-name-is-not-exported-by-module"}}function ti(e){const t=Array.from(e.implicitlyLoadedBefore,(e=>ne(e.id))).sort();return{code:Ys.MISSING_IMPLICIT_DEPENDANT,message:`Module "${ne(e.id)}" that should be implicitly loaded before ${se(t)} is not included in the module graph. Either it was not imported by an included module or only via a tree-shaken dynamic import, or no imported bindings were used and it had otherwise no side-effects.`}}function si(e,t,s){return{code:Ys.NAMESPACE_CONFLICT,message:`Conflicting namespaces: "${ne(t.id)}" re-exports "${e}" from both "${ne(t.exportsAll[e])}" and "${ne(s.exportsAll[e])}" (will be ignored)`,name:e,reexporter:t.id,sources:[t.exportsAll[e],s.exportsAll[e]]}}function ii(e,t,s,i){return{code:Ys.AMBIGUOUS_EXTERNAL_NAMESPACES,message:`Ambiguous external namespace resolution: "${ne(t)}" re-exports "${e}" from one of the external modules ${se(i.map((e=>ne(e))))}, guessing "${ne(s)}".`,name:e,reexporter:t,sources:i}}function ni(e,t,s){const i=s?"reexport":"import";return{code:Ys.UNEXPECTED_NAMED_IMPORT,id:e,message:`The named export "${t}" was ${i}ed from the external module ${ne(e)} even though its interop type is "defaultOnly". Either remove or change this ${i} or change the value of the "output.interop" option.`,url:"https://rollupjs.org/guide/en/#outputinterop"}}function ri(e){return{code:Ys.UNEXPECTED_NAMED_IMPORT,id:e,message:`There was a namespace "*" reexport from the external module ${ne(e)} even though its interop type is "defaultOnly". This will be ignored as namespace reexports only reexport named exports. If this is not intended, either remove or change this reexport or change the value of the "output.interop" option.`,url:"https://rollupjs.org/guide/en/#outputinterop"}}function ai(e){return{code:Ys.VALIDATION_ERROR,message:e}}function oi(){return{code:Ys.ALREADY_CLOSED,message:'Bundle is already closed, no more calls to "generate" or "write" are allowed.'}}function hi(e,t,s){li(e,t,s.onwarn,s.strictDeprecations)}function li(e,t,s,i){if(t||i){const t=function(e){return{code:Ys.DEPRECATED_FEATURE,..."string"==typeof e?{message:e}:e}}(e);if(i)return Ks(t);s(t)}}!function(e){e.ALREADY_CLOSED="ALREADY_CLOSED",e.ASSET_NOT_FINALISED="ASSET_NOT_FINALISED",e.ASSET_NOT_FOUND="ASSET_NOT_FOUND",e.ASSET_SOURCE_ALREADY_SET="ASSET_SOURCE_ALREADY_SET",e.ASSET_SOURCE_MISSING="ASSET_SOURCE_MISSING",e.BAD_LOADER="BAD_LOADER",e.CANNOT_EMIT_FROM_OPTIONS_HOOK="CANNOT_EMIT_FROM_OPTIONS_HOOK",e.CHUNK_NOT_GENERATED="CHUNK_NOT_GENERATED",e.CHUNK_INVALID="CHUNK_INVALID",e.CIRCULAR_REEXPORT="CIRCULAR_REEXPORT",e.CYCLIC_CROSS_CHUNK_REEXPORT="CYCLIC_CROSS_CHUNK_REEXPORT",e.DEPRECATED_FEATURE="DEPRECATED_FEATURE",e.EXTERNAL_SYNTHETIC_EXPORTS="EXTERNAL_SYNTHETIC_EXPORTS",e.FILE_NAME_CONFLICT="FILE_NAME_CONFLICT",e.FILE_NOT_FOUND="FILE_NOT_FOUND",e.INPUT_HOOK_IN_OUTPUT_PLUGIN="INPUT_HOOK_IN_OUTPUT_PLUGIN",e.INVALID_CHUNK="INVALID_CHUNK",e.INVALID_EXPORT_OPTION="INVALID_EXPORT_OPTION",e.INVALID_EXTERNAL_ID="INVALID_EXTERNAL_ID",e.INVALID_OPTION="INVALID_OPTION",e.INVALID_PLUGIN_HOOK="INVALID_PLUGIN_HOOK",e.INVALID_ROLLUP_PHASE="INVALID_ROLLUP_PHASE",e.MISSING_EXPORT="MISSING_EXPORT",e.MISSING_IMPLICIT_DEPENDANT="MISSING_IMPLICIT_DEPENDANT",e.MIXED_EXPORTS="MIXED_EXPORTS",e.NAMESPACE_CONFLICT="NAMESPACE_CONFLICT",e.AMBIGUOUS_EXTERNAL_NAMESPACES="AMBIGUOUS_EXTERNAL_NAMESPACES",e.NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE="NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE",e.PLUGIN_ERROR="PLUGIN_ERROR",e.PREFER_NAMED_EXPORTS="PREFER_NAMED_EXPORTS",e.SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT="SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT",e.UNEXPECTED_NAMED_IMPORT="UNEXPECTED_NAMED_IMPORT",e.UNRESOLVED_ENTRY="UNRESOLVED_ENTRY",e.UNRESOLVED_IMPORT="UNRESOLVED_IMPORT",e.VALIDATION_ERROR="VALIDATION_ERROR"}(Ys||(Ys={}));const ci="ROLLUP_ASSET_URL_",ui="ROLLUP_FILE_URL_";const di={amd:["document","module","URL"],cjs:["document","require","URL"],es:[],iife:["document","URL"],system:["module"],umd:["document","require","URL"]},pi={amd:["document","require","URL"],cjs:["document","require","URL"],es:[],iife:["document","URL"],system:["module","URL"],umd:["document","require","URL"]},fi=(e,t="URL")=>`new ${t}(${e}).href`,mi=(e,t=!1)=>fi(`'${e}', ${t?"typeof document === 'undefined' ? location.href : ":""}document.currentScript && document.currentScript.src || document.baseURI`),gi=e=>(t,{chunkId:s})=>{const i=e(s);return null===t?`({ url: ${i} })`:"url"===t?i:"undefined"},yi=(e,t=!1)=>`${t?"typeof document === 'undefined' ? location.href : ":""}(document.currentScript && document.currentScript.src || new URL('${e}', document.baseURI).href)`,Ei={amd:e=>("."!==e[0]&&(e="./"+e),fi(`require.toUrl('${e}'), document.baseURI`)),cjs:e=>`(typeof document === 'undefined' ? ${fi(`'file:' + __dirname + '/${e}'`,"(require('u' + 'rl').URL)")} : ${mi(e)})`,es:e=>fi(`'${e}', import.meta.url`),iife:e=>mi(e),system:e=>fi(`'${e}', module.meta.url`),umd:e=>`(typeof document === 'undefined' && typeof location === 'undefined' ? ${fi(`'file:' + __dirname + '/${e}'`,"(require('u' + 'rl').URL)")} : ${mi(e,!0)})`},xi={amd:gi((()=>fi("module.uri, document.baseURI"))),cjs:gi((e=>`(typeof document === 'undefined' ? ${fi("'file:' + __filename","(require('u' + 'rl').URL)")} : ${yi(e)})`)),iife:gi((e=>yi(e))),system:(e,{snippets:{getPropertyAccess:t}})=>null===e?"module.meta":`module.meta${t(e)}`,umd:gi((e=>`(typeof document === 'undefined' && typeof location === 'undefined' ? ${fi("'file:' + __filename","(require('u' + 'rl').URL)")} : ${yi(e,!0)})`))};class vi extends ke{hasEffects(e){if(this.test&&this.test.hasEffects(e))return!0;for(const t of this.consequent){if(e.brokenFlow)break;if(t.hasEffects(e))return!0}return!1}include(e,t){this.included=!0,this.test&&this.test.include(e,t);for(const s of this.consequent)(t||s.shouldBeIncluded(e))&&s.include(e,t)}render(e,t,s){if(this.consequent.length){this.test&&this.test.render(e,t);const i=this.test?this.test.end:_e(e.original,"default",this.start)+7,n=_e(e.original,":",i)+1;Me(this.consequent,e,n,s.end,t)}else super.render(e,t)}}vi.prototype.needsBoundaries=!0;class bi extends G{constructor(){super("undefined")}getLiteralValueAtPath(){}}class Si extends rt{constructor(e,t,s){super(e,t,t.declaration,s),this.hasId=!1,this.originalId=null,this.originalVariable=null;const i=t.declaration;(i instanceof Gt||i instanceof Lt)&&i.id?(this.hasId=!0,this.originalId=i.id):i instanceof St&&(this.originalId=i)}addReference(e){this.hasId||(this.name=e.name)}getAssignedVariableName(){return this.originalId&&this.originalId.name||null}getBaseVariableName(){const e=this.getOriginalVariable();return e===this?super.getBaseVariableName():e.getBaseVariableName()}getDirectOriginalVariable(){return!this.originalId||!this.hasId&&(this.originalId.isPossibleTDZ()||this.originalId.variable.isReassigned||this.originalId.variable instanceof bi||"syntheticNamespace"in this.originalId.variable)?null:this.originalId.variable}getName(e){const t=this.getOriginalVariable();return t===this?super.getName(e):t.getName(e)}getOriginalVariable(){if(this.originalVariable)return this.originalVariable;let e,t=this;const s=new Set;do{s.add(t),e=t,t=e.getDirectOriginalVariable()}while(t instanceof Si&&!s.has(t));return this.originalVariable=t||e}}class Ai extends ot{constructor(e,t){super(e),this.context=t,this.variables.set("this",new rt("this",null,Ge,t))}addExportDefaultDeclaration(e,t,s){const i=new Si(e,t,s);return this.variables.set("default",i),i}addNamespaceMemberAccess(){}deconflict(e,t,s){for(const i of this.children)i.deconflict(e,t,s)}findLexicalBoundary(){return this}findVariable(e){const t=this.variables.get(e)||this.accessedOutsideVariables.get(e);if(t)return t;const s=this.context.traceVariable(e)||this.parent.findVariable(e);return s instanceof vt&&this.accessedOutsideVariables.set(e,s),s}}const Pi={"!":e=>!e,"+":e=>+e,"-":e=>-e,delete:()=>W,typeof:e=>typeof e,void:()=>{},"~":e=>~e};const ki={ArrayExpression:class extends ke{constructor(){super(...arguments),this.objectEntity=null}deoptimizePath(e){this.getObjectEntity().deoptimizePath(e)}deoptimizeThisOnEventAtPath(e,t,s,i){this.getObjectEntity().deoptimizeThisOnEventAtPath(e,t,s,i)}getLiteralValueAtPath(e,t,s){return this.getObjectEntity().getLiteralValueAtPath(e,t,s)}getReturnExpressionWhenCalledAtPath(e,t,s,i){return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(e,t,s,i)}hasEffectsWhenAccessedAtPath(e,t){return this.getObjectEntity().hasEffectsWhenAccessedAtPath(e,t)}hasEffectsWhenAssignedAtPath(e,t){return this.getObjectEntity().hasEffectsWhenAssignedAtPath(e,t)}hasEffectsWhenCalledAtPath(e,t,s){return this.getObjectEntity().hasEffectsWhenCalledAtPath(e,t,s)}getObjectEntity(){if(null!==this.objectEntity)return this.objectEntity;const e=[{key:"length",kind:"init",property:Xe}];let t=!1;for(let s=0;s<this.elements.length;s++){const i=this.elements[s];i instanceof Bt||t?i&&(t=!0,e.unshift({key:M,kind:"init",property:i})):i?e.push({key:String(s),kind:"init",property:i}):e.push({key:String(s),kind:"init",property:Ge})}return this.objectEntity=new Ct(e,cs)}},ArrayPattern:class extends ke{addExportedVariables(e,t){for(const s of this.elements)null!==s&&s.addExportedVariables(e,t)}declare(e){const t=[];for(const s of this.elements)null!==s&&t.push(...s.declare(e,U));return t}deoptimizePath(e){if(0===e.length)for(const t of this.elements)null!==t&&t.deoptimizePath(e)}hasEffectsWhenAssignedAtPath(e,t){if(e.length>0)return!0;for(const e of this.elements)if(null!==e&&e.hasEffectsWhenAssignedAtPath(D,t))return!0;return!1}markDeclarationReached(){for(const e of this.elements)null!==e&&e.markDeclarationReached()}},ArrowFunctionExpression:fs,AssignmentExpression:gs,AssignmentPattern:class extends ke{constructor(){super(...arguments),this.deoptimized=!1}addExportedVariables(e,t){this.left.addExportedVariables(e,t)}declare(e,t){return this.left.declare(e,t)}deoptimizePath(e){0===e.length&&this.left.deoptimizePath(e)}hasEffectsWhenAssignedAtPath(e,t){return e.length>0||this.left.hasEffectsWhenAssignedAtPath(D,t)}markDeclarationReached(){this.left.markDeclarationReached()}render(e,t,{isShorthandProperty:s}=q){this.left.render(e,t,{isShorthandProperty:s}),this.right.render(e,t)}applyDeoptimizations(){this.deoptimized=!0,this.left.deoptimizePath(D),this.right.deoptimizePath(L),this.context.requestTreeshakingPass()}},AwaitExpression:class extends ke{constructor(){super(...arguments),this.deoptimized=!1}hasEffects(){return this.deoptimized||this.applyDeoptimizations(),!0}include(e,t){if(this.deoptimized||this.applyDeoptimizations(),!this.included){this.included=!0;e:if(!this.context.usesTopLevelAwait){let e=this.parent;do{if(e instanceof Ut||e instanceof fs)break e}while(e=e.parent);this.context.usesTopLevelAwait=!0}}this.argument.include(e,t)}applyDeoptimizations(){this.deoptimized=!0,this.argument.deoptimizePath(L),this.context.requestTreeshakingPass()}},BinaryExpression:class extends ke{deoptimizeCache(){}getLiteralValueAtPath(e,t,s){if(e.length>0)return W;const i=this.left.getLiteralValueAtPath(D,t,s);if(i===W)return W;const n=this.right.getLiteralValueAtPath(D,t,s);if(n===W)return W;const r=ys[this.operator];return r?r(i,n):W}hasEffects(e){return"+"===this.operator&&this.parent instanceof ds&&""===this.left.getLiteralValueAtPath(D,F,this)||super.hasEffects(e)}hasEffectsWhenAccessedAtPath(e){return e.length>1}render(e,t,{renderedSurroundingElement:s}=q){this.left.render(e,t,{renderedSurroundingElement:s}),this.right.render(e,t)}},BlockStatement:ps,BreakStatement:class extends ke{hasEffects(e){if(this.label){if(!e.ignore.labels.has(this.label.name))return!0;e.includedLabels.add(this.label.name),e.brokenFlow=2}else{if(!e.ignore.breaks)return!0;e.brokenFlow=1}return!1}include(e){this.included=!0,this.label&&(this.label.include(),e.includedLabels.add(this.label.name)),e.brokenFlow=this.label?2:1}},CallExpression:class extends ke{constructor(){super(...arguments),this.deoptimized=!1,this.deoptimizableDependentExpressions=[],this.expressionsToBeDeoptimized=new Set,this.returnExpression=null}bind(){if(super.bind(),this.callee instanceof St){this.scope.findVariable(this.callee.name).isNamespace&&this.context.warn({code:"CANNOT_CALL_NAMESPACE",message:`Cannot call a namespace ('${this.callee.name}')`},this.start),"eval"===this.callee.name&&this.context.warn({code:"EVAL",message:"Use of eval is strongly discouraged, as it poses security risks and may cause issues with minification",url:"https://rollupjs.org/guide/en/#avoiding-eval"},this.start)}this.callOptions={args:this.arguments,thisParam:this.callee instanceof vs&&!this.callee.variable?this.callee.object:null,withNew:!1}}deoptimizeCache(){if(this.returnExpression!==U){this.returnExpression=U;for(const e of this.deoptimizableDependentExpressions)e.deoptimizeCache();for(const e of this.expressionsToBeDeoptimized)e.deoptimizePath(L)}}deoptimizePath(e){if(0===e.length||this.context.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(e,this))return;const t=this.getReturnExpression();t!==U&&t.deoptimizePath(e)}deoptimizeThisOnEventAtPath(e,t,s,i){const n=this.getReturnExpression(i);n===U?s.deoptimizePath(L):i.withTrackedEntityAtPath(t,n,(()=>{this.expressionsToBeDeoptimized.add(s),n.deoptimizeThisOnEventAtPath(e,t,s,i)}),void 0)}getLiteralValueAtPath(e,t,s){const i=this.getReturnExpression(t);return i===U?W:t.withTrackedEntityAtPath(e,i,(()=>(this.deoptimizableDependentExpressions.push(s),i.getLiteralValueAtPath(e,t,s))),W)}getReturnExpressionWhenCalledAtPath(e,t,s,i){const n=this.getReturnExpression(s);return this.returnExpression===U?U:s.withTrackedEntityAtPath(e,n,(()=>(this.deoptimizableDependentExpressions.push(i),n.getReturnExpressionWhenCalledAtPath(e,t,s,i))),U)}hasEffects(e){try{for(const t of this.arguments)if(t.hasEffects(e))return!0;return(!this.context.options.treeshake.annotations||!this.annotations)&&(this.callee.hasEffects(e)||this.callee.hasEffectsWhenCalledAtPath(D,this.callOptions,e))}finally{this.deoptimized||this.applyDeoptimizations()}}hasEffectsWhenAccessedAtPath(e,t){return!t.accessed.trackEntityAtPathAndGetIfTracked(e,this)&&this.getReturnExpression().hasEffectsWhenAccessedAtPath(e,t)}hasEffectsWhenAssignedAtPath(e,t){return!t.assigned.trackEntityAtPathAndGetIfTracked(e,this)&&this.getReturnExpression().hasEffectsWhenAssignedAtPath(e,t)}hasEffectsWhenCalledAtPath(e,t,s){return!(t.withNew?s.instantiated:s.called).trackEntityAtPathAndGetIfTracked(e,t,this)&&this.getReturnExpression().hasEffectsWhenCalledAtPath(e,t,s)}include(e,t){this.deoptimized||this.applyDeoptimizations(),t?(super.include(e,t),"variables"===t&&this.callee instanceof St&&this.callee.variable&&this.callee.variable.markCalledFromTryStatement()):(this.included=!0,this.callee.include(e,!1)),this.callee.includeCallArguments(e,this.arguments);const s=this.getReturnExpression();s.included||s.include(e,!1)}render(e,t,{renderedSurroundingElement:s}=q){if(this.callee.render(e,t,{isCalleeOfRenderedParent:!0,renderedSurroundingElement:s}),this.arguments.length>0)if(this.arguments[this.arguments.length-1].included)for(const s of this.arguments)s.render(e,t);else{let s=this.arguments.length-2;for(;s>=0&&!this.arguments[s].included;)s--;if(s>=0){for(let i=0;i<=s;i++)this.arguments[i].render(e,t);e.remove(_e(e.original,",",this.arguments[s].end),this.end-1)}else e.remove(_e(e.original,"(",this.callee.end)+1,this.end-1)}}applyDeoptimizations(){this.deoptimized=!0;const{thisParam:e}=this.callOptions;e&&this.callee.deoptimizeThisOnEventAtPath(2,D,e,F);for(const e of this.arguments)e.deoptimizePath(L);this.context.requestTreeshakingPass()}getReturnExpression(e=F){return null===this.returnExpression?(this.returnExpression=U,this.returnExpression=this.callee.getReturnExpressionWhenCalledAtPath(D,this.callOptions,e,this)):this.returnExpression}},CatchClause:class extends ke{createScope(e){this.scope=new bs(e,this.context)}parseNode(e){const{param:t}=e;t&&(this.param=new(this.context.nodeConstructors[t.type]||this.context.nodeConstructors.UnknownNode)(t,this,this.scope),this.param.declare("parameter",U)),super.parseNode(e)}},ChainExpression:class extends ke{},ClassBody:class extends ke{createScope(e){this.scope=new Ss(e,this.parent,this.context)}include(e,t){this.included=!0,this.context.includeVariableInModule(this.scope.thisVariable);for(const s of this.body)s.include(e,t)}parseNode(e){const t=this.body=[];for(const s of e.body)t.push(new this.context.nodeConstructors[s.type](s,this,s.static?this.scope:this.scope.instanceScope));super.parseNode(e)}},ClassDeclaration:Lt,ClassExpression:class extends Dt{render(e,t,{renderedSurroundingElement:s}=q){super.render(e,t),"ExpressionStatement"===s&&(e.appendRight(this.start,"("),e.prependLeft(this.end,")"))}},ConditionalExpression:class extends ke{constructor(){super(...arguments),this.expressionsToBeDeoptimized=[],this.isBranchResolutionAnalysed=!1,this.usedBranch=null}deoptimizeCache(){if(null!==this.usedBranch){const e=this.usedBranch===this.consequent?this.alternate:this.consequent;this.usedBranch=null,e.deoptimizePath(L);for(const e of this.expressionsToBeDeoptimized)e.deoptimizeCache()}}deoptimizePath(e){const t=this.getUsedBranch();null===t?(this.consequent.deoptimizePath(e),this.alternate.deoptimizePath(e)):t.deoptimizePath(e)}deoptimizeThisOnEventAtPath(e,t,s,i){this.consequent.deoptimizeThisOnEventAtPath(e,t,s,i),this.alternate.deoptimizeThisOnEventAtPath(e,t,s,i)}getLiteralValueAtPath(e,t,s){const i=this.getUsedBranch();return null===i?W:(this.expressionsToBeDeoptimized.push(s),i.getLiteralValueAtPath(e,t,s))}getReturnExpressionWhenCalledAtPath(e,t,s,i){const n=this.getUsedBranch();return null===n?new As([this.consequent.getReturnExpressionWhenCalledAtPath(e,t,s,i),this.alternate.getReturnExpressionWhenCalledAtPath(e,t,s,i)]):(this.expressionsToBeDeoptimized.push(i),n.getReturnExpressionWhenCalledAtPath(e,t,s,i))}hasEffects(e){if(this.test.hasEffects(e))return!0;const t=this.getUsedBranch();return null===t?this.consequent.hasEffects(e)||this.alternate.hasEffects(e):t.hasEffects(e)}hasEffectsWhenAccessedAtPath(e,t){const s=this.getUsedBranch();return null===s?this.consequent.hasEffectsWhenAccessedAtPath(e,t)||this.alternate.hasEffectsWhenAccessedAtPath(e,t):s.hasEffectsWhenAccessedAtPath(e,t)}hasEffectsWhenAssignedAtPath(e,t){const s=this.getUsedBranch();return null===s?this.consequent.hasEffectsWhenAssignedAtPath(e,t)||this.alternate.hasEffectsWhenAssignedAtPath(e,t):s.hasEffectsWhenAssignedAtPath(e,t)}hasEffectsWhenCalledAtPath(e,t,s){const i=this.getUsedBranch();return null===i?this.consequent.hasEffectsWhenCalledAtPath(e,t,s)||this.alternate.hasEffectsWhenCalledAtPath(e,t,s):i.hasEffectsWhenCalledAtPath(e,t,s)}include(e,t){this.included=!0;const s=this.getUsedBranch();t||this.test.shouldBeIncluded(e)||null===s?(this.test.include(e,t),this.consequent.include(e,t),this.alternate.include(e,t)):s.include(e,t)}includeCallArguments(e,t){const s=this.getUsedBranch();null===s?(this.consequent.includeCallArguments(e,t),this.alternate.includeCallArguments(e,t)):s.includeCallArguments(e,t)}render(e,t,{isCalleeOfRenderedParent:s,preventASI:i,renderedParentType:n,renderedSurroundingElement:r}=q){const a=this.getUsedBranch();if(this.test.included)this.test.render(e,t,{renderedSurroundingElement:r}),this.consequent.render(e,t),this.alternate.render(e,t);else{const o=_e(e.original,":",this.consequent.end),h=Te(e.original,(this.consequent.included?_e(e.original,"?",this.test.end):o)+1);i&&Le(e,h,a.start),e.remove(this.start,h),this.consequent.included&&e.remove(o,this.end),Ie(this,e),a.render(e,t,{isCalleeOfRenderedParent:s,preventASI:!0,renderedParentType:n||this.parent.type,renderedSurroundingElement:r||this.parent.type})}}getUsedBranch(){if(this.isBranchResolutionAnalysed)return this.usedBranch;this.isBranchResolutionAnalysed=!0;const e=this.test.getLiteralValueAtPath(D,F,this);return e===W?null:this.usedBranch=e?this.consequent:this.alternate}},ContinueStatement:class extends ke{hasEffects(e){if(this.label){if(!e.ignore.labels.has(this.label.name))return!0;e.includedLabels.add(this.label.name),e.brokenFlow=2}else{if(!e.ignore.continues)return!0;e.brokenFlow=1}return!1}include(e){this.included=!0,this.label&&(this.label.include(),e.includedLabels.add(this.label.name)),e.brokenFlow=this.label?2:1}},DoWhileStatement:class extends ke{hasEffects(e){if(this.test.hasEffects(e))return!0;const{brokenFlow:t,ignore:{breaks:s,continues:i}}=e;return e.ignore.breaks=!0,e.ignore.continues=!0,!!this.body.hasEffects(e)||(e.ignore.breaks=s,e.ignore.continues=i,e.brokenFlow=t,!1)}include(e,t){this.included=!0,this.test.include(e,t);const{brokenFlow:s}=e;this.body.includeAsSingleStatement(e,t),e.brokenFlow=s}},EmptyStatement:class extends ke{hasEffects(){return!1}},ExportAllDeclaration:we,ExportDefaultDeclaration:Ht,ExportNamedDeclaration:Ps,ExportSpecifier:class extends ke{},ExpressionStatement:ds,ForInStatement:class extends ke{constructor(){super(...arguments),this.deoptimized=!1}createScope(e){this.scope=new us(e)}hasEffects(e){if(this.deoptimized||this.applyDeoptimizations(),this.left&&(this.left.hasEffects(e)||this.left.hasEffectsWhenAssignedAtPath(D,e))||this.right&&this.right.hasEffects(e))return!0;const{brokenFlow:t,ignore:{breaks:s,continues:i}}=e;return e.ignore.breaks=!0,e.ignore.continues=!0,!!this.body.hasEffects(e)||(e.ignore.breaks=s,e.ignore.continues=i,e.brokenFlow=t,!1)}include(e,t){this.deoptimized||this.applyDeoptimizations(),this.included=!0,this.left.include(e,t||!0),this.right.include(e,t);const{brokenFlow:s}=e;this.body.includeAsSingleStatement(e,t),e.brokenFlow=s}render(e,t){this.left.render(e,t,Ne),this.right.render(e,t,Ne),110===e.original.charCodeAt(this.right.start-1)&&e.prependLeft(this.right.start," "),this.body.render(e,t)}applyDeoptimizations(){this.deoptimized=!0,this.left.deoptimizePath(D),this.context.requestTreeshakingPass()}},ForOfStatement:class extends ke{constructor(){super(...arguments),this.deoptimized=!1}createScope(e){this.scope=new us(e)}hasEffects(){return this.deoptimized||this.applyDeoptimizations(),!0}include(e,t){this.deoptimized||this.applyDeoptimizations(),this.included=!0,this.left.include(e,t||!0),this.right.include(e,t);const{brokenFlow:s}=e;this.body.includeAsSingleStatement(e,t),e.brokenFlow=s}render(e,t){this.left.render(e,t,Ne),this.right.render(e,t,Ne),102===e.original.charCodeAt(this.right.start-1)&&e.prependLeft(this.right.start," "),this.body.render(e,t)}applyDeoptimizations(){this.deoptimized=!0,this.left.deoptimizePath(D),this.context.requestTreeshakingPass()}},ForStatement:class extends ke{createScope(e){this.scope=new us(e)}hasEffects(e){if(this.init&&this.init.hasEffects(e)||this.test&&this.test.hasEffects(e)||this.update&&this.update.hasEffects(e))return!0;const{brokenFlow:t,ignore:{breaks:s,continues:i}}=e;return e.ignore.breaks=!0,e.ignore.continues=!0,!!this.body.hasEffects(e)||(e.ignore.breaks=s,e.ignore.continues=i,e.brokenFlow=t,!1)}include(e,t){this.included=!0,this.init&&this.init.includeAsSingleStatement(e,t),this.test&&this.test.include(e,t);const{brokenFlow:s}=e;this.update&&this.update.include(e,t),this.body.includeAsSingleStatement(e,t),e.brokenFlow=s}render(e,t){this.init&&this.init.render(e,t,Ne),this.test&&this.test.render(e,t,Ne),this.update&&this.update.render(e,t,Ne),this.body.render(e,t)}},FunctionDeclaration:Gt,FunctionExpression:class extends Ut{render(e,t,{renderedSurroundingElement:s}=q){super.render(e,t),"ExpressionStatement"===s&&(e.appendRight(this.start,"("),e.prependLeft(this.end,")"))}},Identifier:St,IfStatement:Cs,ImportDeclaration:Is,ImportDefaultSpecifier:class extends ke{},ImportExpression:class extends ke{constructor(){super(...arguments),this.inlineNamespace=null,this.mechanism=null,this.resolution=null}hasEffects(){return!0}include(e,t){this.included||(this.included=!0,this.context.includeDynamicImport(this),this.scope.addAccessedDynamicImport(this)),this.source.include(e,t)}initialise(){this.context.addDynamicImport(this)}render(e,t){if(this.inlineNamespace){const{snippets:{getDirectReturnFunction:s,getPropertyAccess:i}}=t,[n,r]=s([],{functionReturn:!0,lineBreakIndent:null,name:null});e.overwrite(this.start,this.end,`Promise.resolve().then(${n}${this.inlineNamespace.getName(i)}${r})`,{contentOnly:!0})}else this.mechanism&&(e.overwrite(this.start,_e(e.original,"(",this.start+6)+1,this.mechanism.left,{contentOnly:!0}),e.overwrite(this.end-1,this.end,this.mechanism.right,{contentOnly:!0})),this.source.render(e,t)}renderFinalResolution(e,t,s,{getDirectReturnFunction:i}){if(e.overwrite(this.source.start,this.source.end,t),s){const[t,n]=i(["n"],{functionReturn:!0,lineBreakIndent:null,name:null});e.prependLeft(this.end,`.then(${t}n.${s}${n})`)}}setExternalResolution(e,t,s,i,n,r){const{format:a}=s;this.resolution=t;const o=[...Hs[a]||[]];let h;({helper:h,mechanism:this.mechanism}=this.getDynamicImportMechanismAndHelper(t,e,s,i,n)),h&&o.push(h),o.length>0&&this.scope.addAccessedGlobals(o,r)}setInternalResolution(e){this.inlineNamespace=e}getDynamicImportMechanismAndHelper(e,t,{compact:s,dynamicImportFunction:i,format:n,generatedCode:{arrowFunctions:r},interop:a},{_:o,getDirectReturnFunction:h,getDirectReturnIifeLeft:l},c){const u=c.hookFirstSync("renderDynamicImport",[{customResolution:"string"==typeof this.resolution?this.resolution:null,format:n,moduleId:this.context.module.id,targetModuleId:this.resolution&&"string"!=typeof this.resolution?this.resolution.id:null}]);if(u)return{helper:null,mechanism:u};const d=!this.resolution||"string"==typeof this.resolution;switch(n){case"cjs":{const s=Gs(e,t,a);let i="require(",n=")";s&&(i=`/*#__PURE__*/${s}(${i}`,n+=")");const[o,c]=h([],{functionReturn:!0,lineBreakIndent:null,name:null});return i=`Promise.resolve().then(${o}${i}`,n+=`${c})`,!r&&d&&(i=l(["t"],`${i}t${n}`,{needsArrowReturnParens:!1,needsWrappedFunction:!0}),n=")"),{helper:s,mechanism:{left:i,right:n}}}case"amd":{const i=s?"c":"resolve",n=s?"e":"reject",c=Gs(e,t,a),[u,p]=h(["m"],{functionReturn:!1,lineBreakIndent:null,name:null}),f=c?`${u}${i}(/*#__PURE__*/${c}(m))${p}`:i,[m,g]=h([i,n],{functionReturn:!1,lineBreakIndent:null,name:null});let y=`new Promise(${m}require([`,E=`],${o}${f},${o}${n})${g})`;return!r&&d&&(y=l(["t"],`${y}t${E}`,{needsArrowReturnParens:!1,needsWrappedFunction:!0}),E=")"),{helper:c,mechanism:{left:y,right:E}}}case"system":return{helper:null,mechanism:{left:"module.import(",right:")"}};case"es":if(i)return{helper:null,mechanism:{left:`${i}(`,right:")"}}}return{helper:null,mechanism:null}}},ImportNamespaceSpecifier:class extends ke{},ImportSpecifier:class extends ke{},LabeledStatement:class extends ke{hasEffects(e){const t=e.brokenFlow;return e.ignore.labels.add(this.label.name),!!this.body.hasEffects(e)||(e.ignore.labels.delete(this.label.name),e.includedLabels.has(this.label.name)&&(e.includedLabels.delete(this.label.name),e.brokenFlow=t),!1)}include(e,t){this.included=!0;const s=e.brokenFlow;this.body.include(e,t),(t||e.includedLabels.has(this.label.name))&&(this.label.include(),e.includedLabels.delete(this.label.name),e.brokenFlow=s)}render(e,t){this.label.included?this.label.render(e,t):e.remove(this.start,Te(e.original,_e(e.original,":",this.label.end)+1)),this.body.render(e,t)}},Literal:qt,LogicalExpression:class extends ke{constructor(){super(...arguments),this.expressionsToBeDeoptimized=[],this.isBranchResolutionAnalysed=!1,this.usedBranch=null}deoptimizeCache(){if(null!==this.usedBranch){const e=this.usedBranch===this.left?this.right:this.left;this.usedBranch=null,e.deoptimizePath(L);for(const e of this.expressionsToBeDeoptimized)e.deoptimizeCache()}}deoptimizePath(e){const t=this.getUsedBranch();null===t?(this.left.deoptimizePath(e),this.right.deoptimizePath(e)):t.deoptimizePath(e)}deoptimizeThisOnEventAtPath(e,t,s,i){this.left.deoptimizeThisOnEventAtPath(e,t,s,i),this.right.deoptimizeThisOnEventAtPath(e,t,s,i)}getLiteralValueAtPath(e,t,s){const i=this.getUsedBranch();return null===i?W:(this.expressionsToBeDeoptimized.push(s),i.getLiteralValueAtPath(e,t,s))}getReturnExpressionWhenCalledAtPath(e,t,s,i){const n=this.getUsedBranch();return null===n?new As([this.left.getReturnExpressionWhenCalledAtPath(e,t,s,i),this.right.getReturnExpressionWhenCalledAtPath(e,t,s,i)]):(this.expressionsToBeDeoptimized.push(i),n.getReturnExpressionWhenCalledAtPath(e,t,s,i))}hasEffects(e){return!!this.left.hasEffects(e)||this.getUsedBranch()!==this.left&&this.right.hasEffects(e)}hasEffectsWhenAccessedAtPath(e,t){const s=this.getUsedBranch();return null===s?this.left.hasEffectsWhenAccessedAtPath(e,t)||this.right.hasEffectsWhenAccessedAtPath(e,t):s.hasEffectsWhenAccessedAtPath(e,t)}hasEffectsWhenAssignedAtPath(e,t){const s=this.getUsedBranch();return null===s?this.left.hasEffectsWhenAssignedAtPath(e,t)||this.right.hasEffectsWhenAssignedAtPath(e,t):s.hasEffectsWhenAssignedAtPath(e,t)}hasEffectsWhenCalledAtPath(e,t,s){const i=this.getUsedBranch();return null===i?this.left.hasEffectsWhenCalledAtPath(e,t,s)||this.right.hasEffectsWhenCalledAtPath(e,t,s):i.hasEffectsWhenCalledAtPath(e,t,s)}include(e,t){this.included=!0;const s=this.getUsedBranch();t||s===this.right&&this.left.shouldBeIncluded(e)||null===s?(this.left.include(e,t),this.right.include(e,t)):s.include(e,t)}render(e,t,{isCalleeOfRenderedParent:s,preventASI:i,renderedParentType:n,renderedSurroundingElement:r}=q){if(this.left.included&&this.right.included)this.left.render(e,t,{preventASI:i,renderedSurroundingElement:r}),this.right.render(e,t);else{const a=_e(e.original,this.operator,this.left.end);if(this.right.included){const t=Te(e.original,a+2);e.remove(this.start,t),i&&Le(e,t,this.right.start)}else e.remove(a,this.end);Ie(this,e),this.getUsedBranch().render(e,t,{isCalleeOfRenderedParent:s,preventASI:i,renderedParentType:n||this.parent.type,renderedSurroundingElement:r||this.parent.type})}}getUsedBranch(){if(!this.isBranchResolutionAnalysed){this.isBranchResolutionAnalysed=!0;const e=this.left.getLiteralValueAtPath(D,F,this);if(e===W)return null;this.usedBranch="||"===this.operator&&e||"&&"===this.operator&&!e||"??"===this.operator&&null!=e?this.left:this.right}return this.usedBranch}},MemberExpression:vs,MetaProperty:class extends ke{addAccessedGlobals(e,t){const s=this.metaProperty,i=(s&&(s.startsWith(ui)||s.startsWith(ci)||s.startsWith("ROLLUP_CHUNK_URL_"))?pi:di)[e];i.length>0&&this.scope.addAccessedGlobals(i,t)}getReferencedFileName(e){const t=this.metaProperty;return t&&t.startsWith(ui)?e.getFileName(t.substr(ui.length)):null}hasEffects(){return!1}hasEffectsWhenAccessedAtPath(e){return e.length>1}include(){if(!this.included&&(this.included=!0,"import"===this.meta.name)){this.context.addImportMeta(this);const e=this.parent;this.metaProperty=e instanceof vs&&"string"==typeof e.propertyKey?e.propertyKey:null}}renderFinalMechanism(e,t,s,i,n){var r;const a=this.parent,o=this.metaProperty;if(o&&(o.startsWith(ui)||o.startsWith(ci)||o.startsWith("ROLLUP_CHUNK_URL_"))){let i,r=null,h=null,l=null;o.startsWith(ui)?(r=o.substr(ui.length),i=n.getFileName(r)):o.startsWith(ci)?(hi(`Using the "${ci}" prefix to reference files is deprecated. Use the "${ui}" prefix instead.`,!0,this.context.options),h=o.substr(ci.length),i=n.getFileName(h)):(hi(`Using the "ROLLUP_CHUNK_URL_" prefix to reference files is deprecated. Use the "${ui}" prefix instead.`,!0,this.context.options),l=o.substr("ROLLUP_CHUNK_URL_".length),i=n.getFileName(l));const c=w(_(I(t),i));let u;return null!==h&&(u=n.hookFirstSync("resolveAssetUrl",[{assetFileName:i,chunkId:t,format:s,moduleId:this.context.module.id,relativeAssetPath:c}])),u||(u=n.hookFirstSync("resolveFileUrl",[{assetReferenceId:h,chunkId:t,chunkReferenceId:l,fileName:i,format:s,moduleId:this.context.module.id,referenceId:r||h||l,relativePath:c}])||Ei[s](c)),void e.overwrite(a.start,a.end,u,{contentOnly:!0})}const h=n.hookFirstSync("resolveImportMeta",[o,{chunkId:t,format:s,moduleId:this.context.module.id}])||(null===(r=xi[s])||void 0===r?void 0:r.call(xi,o,{chunkId:t,snippets:i}));"string"==typeof h&&(a instanceof vs?e.overwrite(a.start,a.end,h,{contentOnly:!0}):e.overwrite(this.start,this.end,h,{contentOnly:!0}))}},MethodDefinition:kt,NewExpression:class extends ke{constructor(){super(...arguments),this.deoptimized=!1}hasEffects(e){this.deoptimized||this.applyDeoptimizations();for(const t of this.arguments)if(t.hasEffects(e))return!0;return(!this.context.options.treeshake.annotations||!this.annotations)&&(this.callee.hasEffects(e)||this.callee.hasEffectsWhenCalledAtPath(D,this.callOptions,e))}hasEffectsWhenAccessedAtPath(e){return e.length>0}initialise(){this.callOptions={args:this.arguments,thisParam:null,withNew:!0}}applyDeoptimizations(){this.deoptimized=!0;for(const e of this.arguments)e.deoptimizePath(L);this.context.requestTreeshakingPass()}},ObjectExpression:class extends ke{constructor(){super(...arguments),this.objectEntity=null}deoptimizeCache(){this.getObjectEntity().deoptimizeAllProperties()}deoptimizePath(e){this.getObjectEntity().deoptimizePath(e)}deoptimizeThisOnEventAtPath(e,t,s,i){this.getObjectEntity().deoptimizeThisOnEventAtPath(e,t,s,i)}getLiteralValueAtPath(e,t,s){return this.getObjectEntity().getLiteralValueAtPath(e,t,s)}getReturnExpressionWhenCalledAtPath(e,t,s,i){return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(e,t,s,i)}hasEffectsWhenAccessedAtPath(e,t){return this.getObjectEntity().hasEffectsWhenAccessedAtPath(e,t)}hasEffectsWhenAssignedAtPath(e,t){return this.getObjectEntity().hasEffectsWhenAssignedAtPath(e,t)}hasEffectsWhenCalledAtPath(e,t,s){return this.getObjectEntity().hasEffectsWhenCalledAtPath(e,t,s)}render(e,t,{renderedSurroundingElement:s}=q){super.render(e,t),"ExpressionStatement"!==s&&"ArrowFunctionExpression"!==s||(e.appendRight(this.start,"("),e.prependLeft(this.end,")"))}getObjectEntity(){if(null!==this.objectEntity)return this.objectEntity;let e=Mt;const t=[];for(const s of this.properties){if(s instanceof Bt){t.push({key:R,kind:"init",property:s});continue}let i;if(s.computed){const e=s.key.getLiteralValueAtPath(D,F,this);if(e===W){t.push({key:R,kind:s.kind,property:s});continue}i=String(e)}else if(i=s.key instanceof St?s.key.name:String(s.key.value),"__proto__"===i&&"init"===s.kind){e=s.value instanceof qt&&null===s.value.value?null:s.value;continue}t.push({key:i,kind:s.kind,property:s})}return this.objectEntity=new Ct(t,e)}},ObjectPattern:ms,PrivateIdentifier:class extends ke{},Program:Kt,Property:class extends Pt{constructor(){super(...arguments),this.deoptimized=!1,this.declarationInit=null}declare(e,t){return this.declarationInit=t,this.value.declare(e,U)}hasEffects(e){this.deoptimized||this.applyDeoptimizations();const t=this.context.options.treeshake.propertyReadSideEffects;return"ObjectPattern"===this.parent.type&&"always"===t||this.key.hasEffects(e)||this.value.hasEffects(e)}markDeclarationReached(){this.value.markDeclarationReached()}render(e,t){this.shorthand||this.key.render(e,t),this.value.render(e,t,{isShorthandProperty:this.shorthand})}applyDeoptimizations(){this.deoptimized=!0,null!==this.declarationInit&&(this.declarationInit.deoptimizePath([R,R]),this.context.requestTreeshakingPass())}},PropertyDefinition:class extends ke{deoptimizePath(e){var t;null===(t=this.value)||void 0===t||t.deoptimizePath(e)}deoptimizeThisOnEventAtPath(e,t,s,i){var n;null===(n=this.value)||void 0===n||n.deoptimizeThisOnEventAtPath(e,t,s,i)}getLiteralValueAtPath(e,t,s){return this.value?this.value.getLiteralValueAtPath(e,t,s):W}getReturnExpressionWhenCalledAtPath(e,t,s,i){return this.value?this.value.getReturnExpressionWhenCalledAtPath(e,t,s,i):U}hasEffects(e){return this.key.hasEffects(e)||this.static&&null!==this.value&&this.value.hasEffects(e)}hasEffectsWhenAccessedAtPath(e,t){return!this.value||this.value.hasEffectsWhenAccessedAtPath(e,t)}hasEffectsWhenAssignedAtPath(e,t){return!this.value||this.value.hasEffectsWhenAssignedAtPath(e,t)}hasEffectsWhenCalledAtPath(e,t,s){return!this.value||this.value.hasEffectsWhenCalledAtPath(e,t,s)}},RestElement:jt,ReturnStatement:class extends ke{hasEffects(e){return!(e.ignore.returnYield&&(null===this.argument||!this.argument.hasEffects(e)))||(e.brokenFlow=2,!1)}include(e,t){this.included=!0,this.argument&&this.argument.include(e,t),e.brokenFlow=2}initialise(){this.scope.addReturnExpression(this.argument||U)}render(e,t){this.argument&&(this.argument.render(e,t,{preventASI:!0}),this.argument.start===this.start+6&&e.prependLeft(this.start+6," "))}},SequenceExpression:class extends ke{deoptimizePath(e){this.expressions[this.expressions.length-1].deoptimizePath(e)}deoptimizeThisOnEventAtPath(e,t,s,i){this.expressions[this.expressions.length-1].deoptimizeThisOnEventAtPath(e,t,s,i)}getLiteralValueAtPath(e,t,s){return this.expressions[this.expressions.length-1].getLiteralValueAtPath(e,t,s)}hasEffects(e){for(const t of this.expressions)if(t.hasEffects(e))return!0;return!1}hasEffectsWhenAccessedAtPath(e,t){return e.length>0&&this.expressions[this.expressions.length-1].hasEffectsWhenAccessedAtPath(e,t)}hasEffectsWhenAssignedAtPath(e,t){return this.expressions[this.expressions.length-1].hasEffectsWhenAssignedAtPath(e,t)}hasEffectsWhenCalledAtPath(e,t,s){return this.expressions[this.expressions.length-1].hasEffectsWhenCalledAtPath(e,t,s)}include(e,t){this.included=!0;const s=this.expressions[this.expressions.length-1];for(const i of this.expressions)(t||i===s&&!(this.parent instanceof ds)||i.shouldBeIncluded(e))&&i.include(e,t)}render(e,t,{renderedParentType:s,isCalleeOfRenderedParent:i,preventASI:n}=q){let r=0,a=null;const o=this.expressions[this.expressions.length-1];for(const{node:h,separator:l,start:c,end:u}of De(this.expressions,e,this.start,this.end))if(h.included)if(r++,a=l,1===r&&n&&Le(e,c,h.start),1===r){const n=s||this.parent.type;h.render(e,t,{isCalleeOfRenderedParent:i&&h===o,renderedParentType:n,renderedSurroundingElement:n})}else h.render(e,t);else Ce(h,e,c,u);a&&e.remove(a,this.end)}},SpreadElement:Bt,Super:class extends ke{bind(){this.variable=this.scope.findVariable("this")}deoptimizePath(e){this.variable.deoptimizePath(e)}include(){this.included||(this.included=!0,this.context.includeVariableInModule(this.variable))}},SwitchCase:vi,SwitchStatement:class extends ke{createScope(e){this.scope=new us(e)}hasEffects(e){if(this.discriminant.hasEffects(e))return!0;const{brokenFlow:t,ignore:{breaks:s}}=e;let i=1/0;e.ignore.breaks=!0;for(const s of this.cases){if(s.hasEffects(e))return!0;i=e.brokenFlow<i?e.brokenFlow:i,e.brokenFlow=t}return null!==this.defaultCase&&1!==i&&(e.brokenFlow=i),e.ignore.breaks=s,!1}include(e,t){this.included=!0,this.discriminant.include(e,t);const{brokenFlow:s}=e;let i=1/0,n=t||null!==this.defaultCase&&this.defaultCase<this.cases.length-1;for(let r=this.cases.length-1;r>=0;r--){const a=this.cases[r];if(a.included&&(n=!0),!n){const e=ue();e.ignore.breaks=!0,n=a.hasEffects(e)}n?(a.include(e,t),i=i<e.brokenFlow?i:e.brokenFlow,e.brokenFlow=s):i=s}n&&null!==this.defaultCase&&1!==i&&(e.brokenFlow=i)}initialise(){for(let e=0;e<this.cases.length;e++)if(null===this.cases[e].test)return void(this.defaultCase=e);this.defaultCase=null}render(e,t){this.discriminant.render(e,t),this.cases.length>0&&Me(this.cases,e,this.cases[0].start,this.end-1,t)}},TaggedTemplateExpression:class extends ke{bind(){if(super.bind(),"Identifier"===this.tag.type){const e=this.tag.name;this.scope.findVariable(e).isNamespace&&this.context.warn({code:"CANNOT_CALL_NAMESPACE",message:`Cannot call a namespace ('${e}')`},this.start)}}hasEffects(e){return super.hasEffects(e)||this.tag.hasEffectsWhenCalledAtPath(D,this.callOptions,e)}initialise(){this.callOptions={args:je,thisParam:null,withNew:!1}}render(e,t){this.tag.render(e,t,{isCalleeOfRenderedParent:!0}),this.quasi.render(e,t)}},TemplateElement:class extends ke{bind(){}hasEffects(){return!1}include(){this.included=!0}parseNode(e){this.value=e.value,super.parseNode(e)}render(){}},TemplateLiteral:Xt,ThisExpression:class extends ke{bind(){this.variable=this.scope.findVariable("this")}deoptimizePath(e){this.variable.deoptimizePath(e)}deoptimizeThisOnEventAtPath(e,t,s,i){this.variable.deoptimizeThisOnEventAtPath(e,t,s===this?this.variable:s,i)}hasEffectsWhenAccessedAtPath(e,t){return e.length>0&&this.variable.hasEffectsWhenAccessedAtPath(e,t)}hasEffectsWhenAssignedAtPath(e,t){return this.variable.hasEffectsWhenAssignedAtPath(e,t)}include(){this.included||(this.included=!0,this.context.includeVariableInModule(this.variable))}initialise(){this.alias=this.scope.findLexicalBoundary()instanceof Ai?this.context.moduleContext:null,"undefined"===this.alias&&this.context.warn({code:"THIS_IS_UNDEFINED",message:"The 'this' keyword is equivalent to 'undefined' at the top level of an ES module, and has been rewritten",url:"https://rollupjs.org/guide/en/#error-this-is-undefined"},this.start)}render(e){null!==this.alias&&e.overwrite(this.start,this.end,this.alias,{contentOnly:!1,storeName:!0})}},ThrowStatement:class extends ke{hasEffects(){return!0}include(e,t){this.included=!0,this.argument.include(e,t),e.brokenFlow=2}render(e,t){this.argument.render(e,t,{preventASI:!0}),this.argument.start===this.start+5&&e.prependLeft(this.start+5," ")}},TryStatement:class extends ke{constructor(){super(...arguments),this.directlyIncluded=!1,this.includedLabelsAfterBlock=null}hasEffects(e){return(this.context.options.treeshake.tryCatchDeoptimization?this.block.body.length>0:this.block.hasEffects(e))||null!==this.finalizer&&this.finalizer.hasEffects(e)}include(e,t){var s;const i=null===(s=this.context.options.treeshake)||void 0===s?void 0:s.tryCatchDeoptimization,{brokenFlow:n}=e;if(this.directlyIncluded&&i){if(this.includedLabelsAfterBlock)for(const t of this.includedLabelsAfterBlock)e.includedLabels.add(t)}else this.included=!0,this.directlyIncluded=!0,this.block.include(e,i?"variables":t),e.includedLabels.size>0&&(this.includedLabelsAfterBlock=[...e.includedLabels]),e.brokenFlow=n;null!==this.handler&&(this.handler.include(e,t),e.brokenFlow=n),null!==this.finalizer&&this.finalizer.include(e,t)}},UnaryExpression:class extends ke{constructor(){super(...arguments),this.deoptimized=!1}getLiteralValueAtPath(e,t,s){if(e.length>0)return W;const i=this.argument.getLiteralValueAtPath(D,t,s);return i===W?W:Pi[this.operator](i)}hasEffects(e){return this.deoptimized||this.applyDeoptimizations(),!("typeof"===this.operator&&this.argument instanceof St)&&(this.argument.hasEffects(e)||"delete"===this.operator&&this.argument.hasEffectsWhenAssignedAtPath(D,e))}hasEffectsWhenAccessedAtPath(e){return"void"===this.operator?e.length>0:e.length>1}applyDeoptimizations(){this.deoptimized=!0,"delete"===this.operator&&(this.argument.deoptimizePath(D),this.context.requestTreeshakingPass())}},UnknownNode:class extends ke{hasEffects(){return!0}include(e){super.include(e,!0)}},UpdateExpression:class extends ke{constructor(){super(...arguments),this.deoptimized=!1}hasEffects(e){return this.deoptimized||this.applyDeoptimizations(),this.argument.hasEffects(e)||this.argument.hasEffectsWhenAssignedAtPath(D,e)}hasEffectsWhenAccessedAtPath(e){return e.length>1}render(e,t){const{exportNamesByVariable:s,format:i,snippets:{_:n}}=t;if(this.argument.render(e,t),"system"===i){const i=this.argument.variable,r=s.get(i);if(r)if(this.prefix)1===r.length?Ve(i,this.start,this.end,e,t):Be(i,this.start,this.end,"ExpressionStatement"!==this.parent.type,e,t);else{const s=this.operator[0];!function(e,t,s,i,n,r,a){const{_:o}=r.snippets;n.prependRight(t,`${Oe([e],r,a)},${o}`),i&&(n.prependRight(t,"("),n.appendLeft(s,")"))}(i,this.start,this.end,"ExpressionStatement"!==this.parent.type,e,t,`${n}${s}${n}1`)}}}applyDeoptimizations(){if(this.deoptimized=!0,this.argument.deoptimizePath(D),this.argument instanceof St){this.scope.findVariable(this.argument.name).isReassigned=!0}this.context.requestTreeshakingPass()}},VariableDeclaration:Qt,VariableDeclarator:class extends ke{declareDeclarator(e){this.id.declare(e,this.init||Ge)}deoptimizePath(e){this.id.deoptimizePath(e)}hasEffects(e){const t=null!==this.init&&this.init.hasEffects(e);return this.id.markDeclarationReached(),t||this.id.hasEffects(e)}include(e,t){this.included=!0,this.init&&this.init.include(e,t),this.id.markDeclarationReached(),(t||this.id.shouldBeIncluded(e))&&this.id.include(e,t)}render(e,t){const{exportNamesByVariable:s,snippets:{_:i}}=t,n=this.id.included;if(n)this.id.render(e,t);else{const t=_e(e.original,"=",this.id.end);e.remove(this.start,Te(e.original,t+1))}this.init?this.init.render(e,t,n?q:{renderedSurroundingElement:"ExpressionStatement"}):this.id instanceof St&&Yt(this.id.variable,s)&&e.appendLeft(this.end,`${i}=${i}void 0`)}},WhileStatement:class extends ke{hasEffects(e){if(this.test.hasEffects(e))return!0;const{brokenFlow:t,ignore:{breaks:s,continues:i}}=e;return e.ignore.breaks=!0,e.ignore.continues=!0,!!this.body.hasEffects(e)||(e.ignore.breaks=s,e.ignore.continues=i,e.brokenFlow=t,!1)}include(e,t){this.included=!0,this.test.include(e,t);const{brokenFlow:s}=e;this.body.includeAsSingleStatement(e,t),e.brokenFlow=s}},YieldExpression:class extends ke{constructor(){super(...arguments),this.deoptimized=!1}hasEffects(e){return this.deoptimized||this.applyDeoptimizations(),!e.ignore.returnYield||null!==this.argument&&this.argument.hasEffects(e)}render(e,t){this.argument&&(this.argument.render(e,t,{preventASI:!0}),this.argument.start===this.start+5&&e.prependLeft(this.start+5," "))}applyDeoptimizations(){this.deoptimized=!0;const{argument:e}=this;e&&(e.deoptimizePath(L),this.context.requestTreeshakingPass())}}};class wi extends G{constructor(e){super("_missingExportShim"),this.module=e}include(){super.include(),this.module.needsExportShim=!0}}class Ci extends G{constructor(e){super(e.getModuleName()),this.memberVariables=null,this.mergedNamespaces=[],this.referencedEarly=!1,this.references=[],this.context=e,this.module=e.module}addReference(e){this.references.push(e),this.name=e.name}getMemberVariables(){if(this.memberVariables)return this.memberVariables;const e=Object.create(null);for(const t of this.context.getExports().concat(this.context.getReexports()))if("*"!==t[0]&&t!==this.module.info.syntheticNamedExports){const s=this.context.traceExport(t);s&&(e[t]=s)}return this.memberVariables=e}include(){this.included=!0,this.context.includeAllExports()}prepare(e){this.mergedNamespaces.length>0&&this.module.scope.addAccessedGlobals(["_mergeNamespaces"],e)}renderBlock(e){const{exportNamesByVariable:t,format:s,freeze:i,indent:n,namespaceToStringTag:r,snippets:{_:a,cnst:o,getObject:h,getPropertyAccess:l,n:c,s:u}}=e,d=this.getMemberVariables(),p=Object.entries(d).map((([e,t])=>this.referencedEarly||t.isReassigned?[null,`get ${e}${a}()${a}{${a}return ${t.getName(l)}${u}${a}}`]:[e,t.getName(l)]));r&&p.unshift([null,`[Symbol.toStringTag]:${a}'Module'`]),p.unshift([null,`__proto__:${a}null`]);let f=h(p,{lineBreakIndent:{base:"",t:n}});if(this.mergedNamespaces.length>0){f=`/*#__PURE__*/_mergeNamespaces(${f}, [${this.mergedNamespaces.map((e=>e.getName(l))).join(`,${a}`)}])`}i&&(f=`/*#__PURE__*/Object.freeze(${f})`);return f=`${o} ${this.getName(l)}${a}=${a}${f};`,"system"===s&&t.has(this)&&(f+=`${c}${Oe([this],e)};`),f}renderFirst(){return this.referencedEarly}setMergedNamespaces(e){this.mergedNamespaces=e;const t=this.context.getModuleExecIndex();for(const e of this.references)if(e.context.getModuleExecIndex()<=t){this.referencedEarly=!0;break}}}Ci.prototype.isNamespace=!0;class Ii extends G{constructor(e,t,s){super(t),this.baseVariable=null,this.context=e,this.module=e.module,this.syntheticNamespace=s}getBaseVariable(){if(this.baseVariable)return this.baseVariable;let e=this.syntheticNamespace;for(;e instanceof Si||e instanceof Ii;){if(e instanceof Si){const t=e.getOriginalVariable();if(t===e)break;e=t}e instanceof Ii&&(e=e.syntheticNamespace)}return this.baseVariable=e}getBaseVariableName(){return this.syntheticNamespace.getBaseVariableName()}getName(e){return`${this.syntheticNamespace.getName(e)}${e(this.name)}`}include(){this.included=!0,this.context.includeVariableInModule(this.syntheticNamespace)}setRenderNames(e,t){super.setRenderNames(e,t)}}function Ni(e){return e.id}const _i=()=>{};let $i=()=>[0,0],Ti=()=>0,Ri=()=>0,Mi={};function Di(e,t){switch(t){case 1:return`# ${e}`;case 2:return`## ${e}`;case 3:return e;default:return`${"  ".repeat(t-4)}- ${e}`}}function Li(e,t=3){e=Di(e,t),Mi.hasOwnProperty(e)||(Mi[e]={memory:0,startMemory:void 0,startTime:void 0,time:0,totalMemory:0});const s=Ri();Mi[e].startTime=$i(),Mi[e].startMemory=s}function Oi(e,t=3){if(e=Di(e,t),Mi.hasOwnProperty(e)){const t=Ri();Mi[e].time+=Ti(Mi[e].startTime),Mi[e].totalMemory=Math.max(Mi[e].totalMemory,t),Mi[e].memory+=t-Mi[e].startMemory}}function Vi(){const e={};for(const[t,{time:s,memory:i,totalMemory:n}]of Object.entries(Mi))e[t]=[s,i,n];return e}let Bi=_i,Fi=_i;const zi={load:!0,resolveDynamicImport:!0,resolveId:!0,transform:!0};function Wi(e,t){const s={};for(const i of Object.keys(e))if(!0===zi[i]){let n=`plugin ${t}`;e.name&&(n+=` (${e.name})`),n+=` - ${i}`,s[i]=function(...t){Bi(n,4);let r=e[i].apply(this===s?e:this,t);return Fi(n,4),r&&"function"==typeof r.then&&(Bi(`${n} (async)`,4),r=r.then((e=>(Fi(`${n} (async)`,4),e)))),r}}else s[i]=e[i];return s}function ji(e){e.perf?(Mi={},"undefined"!=typeof process&&"function"==typeof process.hrtime?($i=process.hrtime.bind(process),Ti=e=>{return 1e3*(t=process.hrtime(e))[0]+t[1]/1e6;var t}):"undefined"!=typeof performance&&"function"==typeof performance.now&&($i=()=>[performance.now(),0],Ti=e=>performance.now()-e[0]),"undefined"!=typeof process&&"function"==typeof process.memoryUsage&&(Ri=()=>process.memoryUsage().heapUsed),Bi=Li,Fi=Oi,e.plugins=e.plugins.map(Wi)):(Bi=_i,Fi=_i)}function Ui(e){e.isExecuted=!0;const t=[e],s=new Set;for(const e of t)for(const i of[...e.dependencies,...e.implicitlyLoadedBefore])i instanceof ae||i.isExecuted||!i.info.hasModuleSideEffects&&!e.implicitlyLoadedBefore.has(i)||s.has(i.id)||(i.isExecuted=!0,s.add(i.id),t.push(i))}const Gi={identifier:null,localName:"_missingExportShim"};function Hi(e,t,s,i,n=new Map,r){const a=n.get(t);if(a){if(a.has(e))return i?null:Ks((o=t,h=e.id,{code:Ys.CIRCULAR_REEXPORT,id:h,message:`"${o}" cannot be exported from ${ne(h)} as it is a reexport that references itself.`}));a.add(e)}else n.set(t,new Set([e]));var o,h;return e.getVariableForExportName(t,{importerForSideEffects:s,isExportAllSearch:i,searchedNamesAndModules:n,skipExternalNamespaceReexports:r})}class qi{constructor(e,t,s,i,n,r,a){this.graph=e,this.id=t,this.options=s,this.alternativeReexportModules=new Map,this.ast=null,this.chunkFileNames=new Set,this.chunkName=null,this.cycles=new Set,this.dependencies=new Set,this.dynamicDependencies=new Set,this.dynamicImporters=[],this.dynamicImports=[],this.execIndex=1/0,this.exportAllSources=new Set,this.exports=Object.create(null),this.exportsAll=Object.create(null),this.implicitlyLoadedAfter=new Set,this.implicitlyLoadedBefore=new Set,this.importDescriptions=Object.create(null),this.importMetas=[],this.importedFromNotTreeshaken=!1,this.importers=[],this.imports=new Set,this.includedDynamicImporters=[],this.isExecuted=!1,this.isUserDefinedEntryPoint=!1,this.needsExportShim=!1,this.preserveSignature=this.options.preserveEntrySignatures,this.reexportDescriptions=Object.create(null),this.sideEffectDependenciesByVariable=new Map,this.sources=new Set,this.userChunkNames=new Set,this.usesTopLevelAwait=!1,this.allExportNames=null,this.exportAllModules=[],this.exportNamesByVariable=null,this.exportShimVariable=new wi(this),this.namespaceReexportsByName=Object.create(null),this.relevantDependencies=null,this.syntheticExports=new Map,this.syntheticNamespace=null,this.transformDependencies=[],this.transitiveReexports=null,this.excludeFromSourcemap=/\0/.test(t),this.context=s.moduleContext(t);const o=this;this.info={ast:null,code:null,get dynamicallyImportedIds(){const e=[];for(const{id:t}of o.dynamicImports)t&&e.push(t);return e},get dynamicImporters(){return o.dynamicImporters.sort()},hasModuleSideEffects:n,id:t,get implicitlyLoadedAfterOneOf(){return Array.from(o.implicitlyLoadedAfter,Ni)},get implicitlyLoadedBefore(){return Array.from(o.implicitlyLoadedBefore,Ni)},get importedIds(){return Array.from(o.sources,(e=>o.resolvedIds[e].id))},get importers(){return o.importers.sort()},isEntry:i,isExternal:!1,meta:a,syntheticNamedExports:r}}basename(){const e=C(this.id),t=N(this.id);return te(t?e.slice(0,-t.length):e)}bindReferences(){this.ast.bind()}error(e,t){return this.addLocationToLogProps(e,t),Ks(e)}getAllExportNames(){if(this.allExportNames)return this.allExportNames;const e=this.allExportNames=new Set;for(const t of Object.keys(this.exports))e.add(t);for(const t of Object.keys(this.reexportDescriptions))e.add(t);for(const t of this.exportAllModules)if(t instanceof ae)e.add(`*${t.id}`);else for(const s of t.getAllExportNames())"default"!==s&&e.add(s);return e}getDependenciesToBeIncluded(){if(this.relevantDependencies)return this.relevantDependencies;const e=new Set,t=new Set,s=new Set;let i=this.imports.keys();if(this.info.isEntry||this.includedDynamicImporters.length>0||this.namespace.included||this.implicitlyLoadedAfter.size>0){i=new Set(i);for(const e of[...this.getReexports(),...this.getExports()]){const t=this.getVariableForExportName(e);t&&i.add(t)}}for(let e of i){const i=this.sideEffectDependenciesByVariable.get(e);if(i)for(const e of i)s.add(e);e instanceof Ii?e=e.getBaseVariable():e instanceof Si&&(e=e.getOriginalVariable()),t.add(e.module)}if(this.options.treeshake&&"no-treeshake"!==this.info.hasModuleSideEffects)this.addRelevantSideEffectDependencies(e,t,s);else for(const t of this.dependencies)e.add(t);for(const s of t)e.add(s);return this.relevantDependencies=e}getExportNamesByVariable(){if(this.exportNamesByVariable)return this.exportNamesByVariable;const e=new Map;for(const t of this.getAllExportNames()){if(t===this.info.syntheticNamedExports)continue;let s=this.getVariableForExportName(t);if(s instanceof Si&&(s=s.getOriginalVariable()),!s||!(s.included||s instanceof H))continue;const i=e.get(s);i?i.push(t):e.set(s,[t])}return this.exportNamesByVariable=e}getExports(){return Object.keys(this.exports)}getReexports(){if(this.transitiveReexports)return this.transitiveReexports;this.transitiveReexports=[];const e=new Set;for(const t in this.reexportDescriptions)e.add(t);for(const t of this.exportAllModules)if(t instanceof ae)e.add(`*${t.id}`);else for(const s of[...t.getReexports(),...t.getExports()])"default"!==s&&e.add(s);return this.transitiveReexports=[...e]}getRenderedExports(){const e=[],t=[];for(const s in this.exports){const i=this.getVariableForExportName(s);(i&&i.included?e:t).push(s)}return{removedExports:t,renderedExports:e}}getSyntheticNamespace(){return null===this.syntheticNamespace&&(this.syntheticNamespace=void 0,this.syntheticNamespace=this.getVariableForExportName("string"==typeof this.info.syntheticNamedExports?this.info.syntheticNamedExports:"default")),this.syntheticNamespace?this.syntheticNamespace:Ks((e=this.id,t=this.info.syntheticNamedExports,{code:Ys.SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT,id:e,message:`Module "${ne(e)}" that is marked with 'syntheticNamedExports: ${JSON.stringify(t)}' needs ${"string"==typeof t&&"default"!==t?`an export named "${t}"`:"a default export"} that does not reexport an unresolved named export of the same module.`}));var e,t}getVariableForExportName(e,{importerForSideEffects:t,isExportAllSearch:s,searchedNamesAndModules:i,skipExternalNamespaceReexports:n}=K){if("*"===e[0]){if(1===e.length)return this.namespace;return this.graph.modulesById.get(e.slice(1)).getVariableForExportName("*")}const r=this.reexportDescriptions[e];if(r){const e=Hi(r.module,r.localName,t,!1,i,!1);return e?(t&&Ki(e,t,this),e):this.error(ei(r.localName,this.id,r.module.id),r.start)}const a=this.exports[e];if(a){if(a===Gi)return this.exportShimVariable;const e=a.localName,s=this.traceVariable(e,t);return t&&(T(t.sideEffectDependenciesByVariable,s,(()=>new Set)).add(this),Ki(s,t,this)),s}if("default"!==e){const s=e in this.namespaceReexportsByName?this.namespaceReexportsByName[e]:this.getVariableFromNamespaceReexports(e,t,i,n);if(n||(this.namespaceReexportsByName[e]=s),s)return s}if(this.info.syntheticNamedExports){let t=this.syntheticExports.get(e);if(!t){const s=this.getSyntheticNamespace();return t=new Ii(this.astContext,e,s),this.syntheticExports.set(e,t),t}return t}return!s&&this.options.shimMissingExports?(this.shimMissingExport(e),this.exportShimVariable):null}hasEffects(){return"no-treeshake"===this.info.hasModuleSideEffects||this.ast.included&&this.ast.hasEffects(ue())}include(){const e=ce();this.ast.shouldBeIncluded(e)&&this.ast.include(e,!1)}includeAllExports(e){this.isExecuted||(Ui(this),this.graph.needsTreeshakingPass=!0);for(const t of this.getExports())if(e||t!==this.info.syntheticNamedExports){const e=this.getVariableForExportName(t);e.deoptimizePath(L),e.included||this.includeVariable(e)}for(const e of this.getReexports()){const t=this.getVariableForExportName(e);t&&(t.deoptimizePath(L),t.included||this.includeVariable(t),t instanceof H&&(t.module.reexported=!0))}e&&this.namespace.setMergedNamespaces(this.includeAndGetAdditionalMergedNamespaces())}includeAllInBundle(){this.ast.include(ce(),!0),this.includeAllExports(!1)}isIncluded(){return this.ast.included||this.namespace.included||this.importedFromNotTreeshaken}linkImports(){this.addModulesToImportDescriptions(this.importDescriptions),this.addModulesToImportDescriptions(this.reexportDescriptions);for(const e in this.exports)"default"!==e&&e!==this.info.syntheticNamedExports&&(this.exportsAll[e]=this.id);const e=[];for(const t of this.exportAllSources){const s=this.graph.modulesById.get(this.resolvedIds[t].id);if(s instanceof ae)e.push(s);else{this.exportAllModules.push(s);for(const e in s.exportsAll)e in this.exportsAll?this.options.onwarn(si(e,this,s)):this.exportsAll[e]=s.exportsAll[e]}}this.exportAllModules.push(...e)}render(e){const t=this.magicString.clone();return this.ast.render(t,e),this.usesTopLevelAwait=this.astContext.usesTopLevelAwait,t}setSource({ast:e,code:t,customTransformCache:s,originalCode:i,originalSourcemap:n,resolvedIds:r,sourcemapChain:a,transformDependencies:o,transformFiles:h,...l}){this.info.code=t,this.originalCode=i,this.originalSourcemap=n,this.sourcemapChain=a,h&&(this.transformFiles=h),this.transformDependencies=o,this.customTransformCache=s,this.updateOptions(l),Bi("generate ast",3),e||(e=this.tryParse()),Fi("generate ast",3),this.resolvedIds=r||Object.create(null);const c=this.id;this.magicString=new b(t,{filename:this.excludeFromSourcemap?null:c,indentExclusionRanges:[]}),Bi("analyse ast",3),this.astContext={addDynamicImport:this.addDynamicImport.bind(this),addExport:this.addExport.bind(this),addImport:this.addImport.bind(this),addImportMeta:this.addImportMeta.bind(this),code:t,deoptimizationTracker:this.graph.deoptimizationTracker,error:this.error.bind(this),fileName:c,getExports:this.getExports.bind(this),getModuleExecIndex:()=>this.execIndex,getModuleName:this.basename.bind(this),getReexports:this.getReexports.bind(this),importDescriptions:this.importDescriptions,includeAllExports:()=>this.includeAllExports(!0),includeDynamicImport:this.includeDynamicImport.bind(this),includeVariableInModule:this.includeVariableInModule.bind(this),magicString:this.magicString,module:this,moduleContext:this.context,nodeConstructors:ki,options:this.options,requestTreeshakingPass:()=>this.graph.needsTreeshakingPass=!0,traceExport:this.getVariableForExportName.bind(this),traceVariable:this.traceVariable.bind(this),usesTopLevelAwait:!1,warn:this.warn.bind(this)},this.scope=new Ai(this.graph.scope,this.astContext),this.namespace=new Ci(this.astContext),this.ast=new Kt(e,{context:this.astContext,type:"Module"},this.scope),this.info.ast=e,Fi("analyse ast",3)}toJSON(){return{ast:this.ast.esTreeNode,code:this.info.code,customTransformCache:this.customTransformCache,dependencies:Array.from(this.dependencies,Ni),id:this.id,meta:this.info.meta,moduleSideEffects:this.info.hasModuleSideEffects,originalCode:this.originalCode,originalSourcemap:this.originalSourcemap,resolvedIds:this.resolvedIds,sourcemapChain:this.sourcemapChain,syntheticNamedExports:this.info.syntheticNamedExports,transformDependencies:this.transformDependencies,transformFiles:this.transformFiles}}traceVariable(e,t){const s=this.scope.variables.get(e);if(s)return s;if(e in this.importDescriptions){const s=this.importDescriptions[e],i=s.module;if(i instanceof qi&&"*"===s.name)return i.namespace;const n=i.getVariableForExportName(s.name,{importerForSideEffects:t||this});return n||this.error(ei(s.name,this.id,i.id),s.start)}return null}tryParse(){try{return this.graph.contextParse(this.info.code)}catch(e){let t=e.message.replace(/ \(\d+:\d+\)$/,"");return this.id.endsWith(".json")?t+=" (Note that you need @rollup/plugin-json to import JSON files)":this.id.endsWith(".js")||(t+=" (Note that you need plugins to import files that are not JavaScript)"),this.error({code:"PARSE_ERROR",message:t,parserError:e},e.pos)}}updateOptions({meta:e,moduleSideEffects:t,syntheticNamedExports:s}){null!=t&&(this.info.hasModuleSideEffects=t),null!=s&&(this.info.syntheticNamedExports=s),null!=e&&(this.info.meta={...this.info.meta,...e})}warn(e,t){this.addLocationToLogProps(e,t),this.options.onwarn(e)}addDynamicImport(e){let t=e.source;t instanceof Xt?1===t.quasis.length&&t.quasis[0].value.cooked&&(t=t.quasis[0].value.cooked):t instanceof qt&&"string"==typeof t.value&&(t=t.value),this.dynamicImports.push({argument:t,id:null,node:e,resolution:null})}addExport(e){if(e instanceof Ht)this.exports.default={identifier:e.variable.getAssignedVariableName(),localName:"default"};else if(e instanceof we){const t=e.source.value;if(this.sources.add(t),e.exported){const s=e.exported.name;this.reexportDescriptions[s]={localName:"*",module:null,source:t,start:e.start}}else this.exportAllSources.add(t)}else if(e.source instanceof qt){const t=e.source.value;this.sources.add(t);for(const s of e.specifiers){const e=s.exported.name;this.reexportDescriptions[e]={localName:s.local.name,module:null,source:t,start:s.start}}}else if(e.declaration){const t=e.declaration;if(t instanceof Qt)for(const e of t.declarations)for(const t of he(e.id))this.exports[t]={identifier:null,localName:t};else{const e=t.id.name;this.exports[e]={identifier:null,localName:e}}}else for(const t of e.specifiers){const e=t.local.name,s=t.exported.name;this.exports[s]={identifier:null,localName:e}}}addImport(e){const t=e.source.value;this.sources.add(t);for(const s of e.specifiers){const e="ImportDefaultSpecifier"===s.type,i="ImportNamespaceSpecifier"===s.type,n=e?"default":i?"*":s.imported.name;this.importDescriptions[s.local.name]={module:null,name:n,source:t,start:s.start}}}addImportMeta(e){this.importMetas.push(e)}addLocationToLogProps(e,t){e.id=this.id,e.pos=t;let s=this.info.code;const i=le(s,t,{offsetLine:1});if(i){let{column:n,line:r}=i;try{({column:n,line:r}=function(e,t){const s=e.filter((e=>e.mappings));for(;s.length>0;){const e=s.pop(),i=e.mappings[t.line-1];let n=!1;if(void 0!==i)for(const s of i)if(s[0]>=t.column){if(1===s.length)break;t={column:s[3],line:s[2]+1,name:5===s.length?e.names[s[4]]:void 0,source:e.sources[s[1]]},n=!0;break}if(!n)throw new Error("Can't resolve original location of error.")}return t}(this.sourcemapChain,{column:n,line:r})),s=this.originalCode}catch(e){this.options.onwarn({code:"SOURCEMAP_ERROR",id:this.id,loc:{column:n,file:this.id,line:r},message:`Error when using sourcemap for reporting an error: ${e.message}`,pos:t})}Xs(e,{column:n,line:r},s,this.id)}}addModulesToImportDescriptions(e){for(const t of Object.values(e)){const e=this.resolvedIds[t.source].id;t.module=this.graph.modulesById.get(e)}}addRelevantSideEffectDependencies(e,t,s){const i=new Set,n=r=>{for(const a of r)i.has(a)||(i.add(a),t.has(a)?e.add(a):(a.info.hasModuleSideEffects||s.has(a))&&(a instanceof ae||a.hasEffects()?e.add(a):n(a.dependencies)))};n(this.dependencies),n(s)}getVariableFromNamespaceReexports(e,t,s,i=!1){let n=null;const r=[{searchedNamesAndModules:s,skipExternalNamespaces:!0}];if(!i){const e=new Map;for(const[t,i]of s||[])e.set(t,new Set(i));r.push({searchedNamesAndModules:e,skipExternalNamespaces:!1})}for(const{skipExternalNamespaces:s,searchedNamesAndModules:i}of r){const r=new Set;for(const a of this.exportAllModules)if(a instanceof qi||!s){const o=Hi(a,e,t,!0,i,s);o&&(o instanceof Ii?n||(n=o):r.add(o))}if(1===r.size)return[...r][0];if(r.size>1){if(s)return null;const t=[...r],i=t[0];return this.options.onwarn(ii(e,this.id,i.module.id,t.map((e=>e.module.id)))),i}}return n||null}includeAndGetAdditionalMergedNamespaces(){const e=new Set,t=new Set;for(const s of[this,...this.exportAllModules])if(s instanceof ae){const t=s.getVariableForExportName("*");t.include(),this.imports.add(t),e.add(t)}else if(s.info.syntheticNamedExports){const e=s.getSyntheticNamespace();e.include(),this.imports.add(e),t.add(e)}return[...t,...e]}includeDynamicImport(e){const t=this.dynamicImports.find((t=>t.node===e)).resolution;t instanceof qi&&(t.includedDynamicImporters.push(this),t.includeAllExports(!0))}includeVariable(e){if(!e.included){e.include(),this.graph.needsTreeshakingPass=!0;const t=e.module;if(t&&t instanceof qi&&(t.isExecuted||Ui(t),t!==this)){const t=function(e,t){const s=T(t.sideEffectDependenciesByVariable,e,(()=>new Set));let i=e;const n=new Set([i]);for(;;){const e=i.module;if(i=i instanceof Si?i.getDirectOriginalVariable():i instanceof Ii?i.syntheticNamespace:null,!i||n.has(i))break;n.add(i),s.add(e);const t=e.sideEffectDependenciesByVariable.get(i);if(t)for(const e of t)s.add(e)}return s}(e,this);for(const e of t)e.isExecuted||Ui(e)}}}includeVariableInModule(e){this.includeVariable(e);const t=e.module;t&&t!==this&&this.imports.add(e)}shimMissingExport(e){this.options.onwarn({code:"SHIMMED_EXPORT",exporter:ne(this.id),exportName:e,message:`Missing export "${e}" has been shimmed in module ${ne(this.id)}.`}),this.exports[e]=Gi}}function Ki(e,t,s){if(e.module instanceof qi&&e.module!==s){const i=e.module.cycles;if(i.size>0){const n=s.cycles;for(const r of n)if(i.has(r)){t.alternativeReexportModules.set(e,s);break}}}}function Xi(e){return e.endsWith(".js")?e.slice(0,-3):e}function Yi(e,t){return e.autoId?`${e.basePath?e.basePath+"/":""}${Xi(t)}`:e.id||""}function Qi(e,t,s,i,n,r,a,o="return "){const{_:h,cnst:l,getDirectReturnFunction:c,getFunctionIntro:u,getPropertyAccess:d,n:p,s:f}=n;if(!s)return`${p}${p}${o}${function(e,t,s,i,n){if(e.length>0)return e[0].local;for(const{defaultVariableName:e,id:r,isChunk:a,name:o,namedExportsMode:h,namespaceVariableName:l,reexports:c}of t)if(c)return Zi(o,c[0].imported,h,a,e,l,s,r,i,n)}(e,t,i,a,d)};`;let m="";for(const{defaultVariableName:e,id:n,isChunk:o,name:l,namedExportsMode:u,namespaceVariableName:f,reexports:g}of t)if(g&&s)for(const t of g)if("*"!==t.reexported){const s=Zi(l,t.imported,u,o,e,f,i,n,a,d);if(m&&(m+=p),"*"!==t.imported&&t.needsLiveBinding){const[e,i]=c([],{functionReturn:!0,lineBreakIndent:null,name:null});m+=`Object.defineProperty(exports,${h}'${t.reexported}',${h}{${p}${r}enumerable:${h}true,${p}${r}get:${h}${e}${s}${i}${p}});`}else m+=`exports${d(t.reexported)}${h}=${h}${s};`}for(const{exported:t,local:s}of e){const e=`exports${d(t)}`,i=s;e!==i&&(m&&(m+=p),m+=`${e}${h}=${h}${i};`)}for(const{name:e,reexports:i}of t)if(i&&s)for(const t of i)if("*"===t.reexported){m&&(m+=p);const s=`{${p}${r}if${h}(k${h}!==${h}'default'${h}&&${h}!exports.hasOwnProperty(k))${h}${en(e,t.needsLiveBinding,r,n)}${f}${p}}`;m+="var"===l&&t.needsLiveBinding?`Object.keys(${e}).forEach(${u(["k"],{isAsync:!1,name:null})}${s});`:`for${h}(${l} k in ${e})${h}${s}`}return m?`${p}${p}${m}`:""}function Zi(e,t,s,i,n,r,a,o,h,l){if("default"===t){if(!i){const t=String(a(o)),s=Ns[t]?n:e;return _s(t,h)?`${s}${l("default")}`:s}return s?`${e}${l("default")}`:e}return"*"===t?(i?!s:$s[String(a(o))])?r:e:`${e}${l(t)}`}function Ji(e,t,s,i,n){let r="";return e&&(t&&(r+=function(e){return`Object.defineProperty(exports,${e}'__esModule',${e}{${e}value:${e}true${e}});`}(i)),s&&(r&&(r+=n),r+=function(e){return`exports[Symbol.toStringTag]${e}=${e}'Module';`}(i))),r}const en=(e,t,s,{_:i,getDirectReturnFunction:n,n:r})=>{if(t){const[t,a]=n([],{functionReturn:!0,lineBreakIndent:null,name:null});return`Object.defineProperty(exports,${i}k,${i}{${r}${s}${s}enumerable:${i}true,${r}${s}${s}get:${i}${t}${e}[k]${a}${r}${s}})`}return`exports[k]${i}=${i}${e}[k]`};function tn(e,t,s,i,n,r,a,o){const{_:h,cnst:l,n:c}=o,u=new Set,d=[],p=(e,t,s)=>{u.add(t),d.push(`${l} ${e}${h}=${h}/*#__PURE__*/${t}(${s});`)};for(const{defaultVariableName:s,imports:i,id:n,isChunk:r,name:a,namedExportsMode:o,namespaceVariableName:h,reexports:l}of e)if(r){for(const{imported:e,reexported:t}of[...i||[],...l||[]])if("*"===e&&"*"!==t){o||p(h,"_interopNamespaceDefaultOnly",a);break}}else{const e=String(t(n));let r=!1,o=!1;for(const{imported:t,reexported:n}of[...i||[],...l||[]]){let i,l;"default"===t?r||(r=!0,s!==h&&(l=s,i=Ns[e])):"*"===t&&"*"!==n&&(o||(o=!0,i=$s[e],l=h)),i&&p(l,i,a)}}return`${Rs(u,r,a,o,s,i,n)}${d.length>0?`${d.join(c)}${c}${c}`:""}`}function sn(e){return"."===e[0]?Xi(e):e}const nn={assert:!0,buffer:!0,console:!0,constants:!0,domain:!0,events:!0,http:!0,https:!0,os:!0,path:!0,process:!0,punycode:!0,querystring:!0,stream:!0,string_decoder:!0,timers:!0,tty:!0,url:!0,util:!0,vm:!0,zlib:!0};function rn(e,t){const s=t.map((({id:e})=>e)).filter((e=>e in nn));s.length&&e({code:"MISSING_NODE_BUILTINS",message:`Creating a browser bundle that depends on Node.js built-in modules (${se(s)}). You might need to include https://github.com/snowpackjs/rollup-plugin-polyfill-node`,modules:s})}const an=(e,t)=>e.split(".").map(t).join("");function on(e,t,s,i,{_:n,getPropertyAccess:r}){const a=e.split(".");a[0]=("function"==typeof s?s(a[0]):s[a[0]])||a[0];const o=a.pop();let h=t,l=a.map((e=>(h+=r(e),`${h}${n}=${n}${h}${n}||${n}{}`))).concat(`${h}${r(o)}`).join(`,${n}`)+`${n}=${n}${i}`;return a.length>0&&(l=`(${l})`),l}function hn(e){let t=e.length;for(;t--;){const{imports:s,reexports:i}=e[t];if(s||i)return e.slice(0,t+1)}return[]}const ln=({dependencies:e,exports:t})=>{const s=new Set(t.map((e=>e.exported)));s.add("default");for(const{reexports:t}of e)if(t)for(const e of t)"*"!==e.reexported&&s.add(e.reexported);return s},cn=(e,t,{_:s,cnst:i,getObject:n,n:r})=>e?`${r}${t}${i} _starExcludes${s}=${s}${n([...e].map((e=>[e,"1"])),{lineBreakIndent:{base:t,t:t}})};`:"",un=(e,t,{_:s,n:i})=>e.length?`${i}${t}var ${e.join(`,${s}`)};`:"",dn=(e,t,s)=>pn(e.filter((e=>e.hoisted)).map((e=>({name:e.exported,value:e.local}))),t,s);function pn(e,t,{_:s,n:i}){return 0===e.length?"":1===e.length?`exports('${e[0].name}',${s}${e[0].value});${i}${i}`:`exports({${i}`+e.map((({name:e,value:i})=>`${t}${e}:${s}${i}`)).join(`,${i}`)+`${i}});${i}${i}`}const fn=(e,t,s)=>pn(e.filter((e=>e.expression)).map((e=>({name:e.exported,value:e.local}))),t,s),mn=(e,t,s)=>pn(e.filter((e=>"_missingExportShim"===e.local)).map((e=>({name:e.exported,value:"_missingExportShim"}))),t,s);function gn(e,t,s){return e?`${t}${an(e,s)}`:"null"}var yn={amd:function(e,{accessedGlobals:t,dependencies:s,exports:i,hasExports:n,id:r,indent:a,intro:o,isEntryFacade:h,isModuleFacade:l,namedExportsMode:c,outro:u,snippets:d,warn:p},{amd:f,esModule:m,externalLiveBindings:g,freeze:y,interop:E,namespaceToStringTag:x,strict:v}){rn(p,s);const b=s.map((e=>`'${sn(e.id)}'`)),S=s.map((e=>e.name)),{n:A,getNonArrowFunctionIntro:P,_:k}=d;c&&n&&(S.unshift("exports"),b.unshift("'exports'")),t.has("require")&&(S.unshift("require"),b.unshift("'require'")),t.has("module")&&(S.unshift("module"),b.unshift("'module'"));const w=Yi(f,r),C=(w?`'${w}',${k}`:"")+(b.length?`[${b.join(`,${k}`)}],${k}`:""),I=v?`${k}'use strict';`:"";e.prepend(`${o}${tn(s,E,g,y,x,t,a,d)}`);const N=Qi(i,s,c,E,d,a,g);let _=Ji(c&&n,h&&m,l&&x,k,A);return _&&(_=A+A+_),e.append(`${N}${_}${u}`),e.indent(a).prepend(`${f.define}(${C}(${P(S,{isAsync:!1,name:null})}{${I}${A}${A}`).append(`${A}${A}}));`)},cjs:function(e,{accessedGlobals:t,dependencies:s,exports:i,hasExports:n,indent:r,intro:a,isEntryFacade:o,isModuleFacade:h,namedExportsMode:l,outro:c,snippets:u},{compact:d,esModule:p,externalLiveBindings:f,freeze:m,interop:g,namespaceToStringTag:y,strict:E}){const{_:x,n:v}=u,b=E?`'use strict';${v}${v}`:"";let S=Ji(l&&n,o&&p,h&&y,x,v);S&&(S+=v+v);const A=function(e,{_:t,cnst:s,n:i},n){let r="",a=!1;for(const{id:o,name:h,reexports:l,imports:c}of e)l||c?(r+=n&&a?",":`${r?`;${i}`:""}${s} `,a=!0,r+=`${h}${t}=${t}require('${o}')`):(r&&(r+=n&&!a?",":`;${i}`),a=!1,r+=`require('${o}')`);if(r)return`${r};${i}${i}`;return""}(s,u,d),P=tn(s,g,f,m,y,t,r,u);e.prepend(`${b}${a}${S}${A}${P}`);const k=Qi(i,s,l,g,u,r,f,`module.exports${x}=${x}`);return e.append(`${k}${c}`)},es:function(e,{accessedGlobals:t,indent:s,intro:i,outro:n,dependencies:r,exports:a,snippets:o},{externalLiveBindings:h,freeze:l,namespaceToStringTag:c}){const{_:u,n:d}=o,p=function(e,t){const s=[];for(const{id:i,reexports:n,imports:r,name:a}of e)if(n||r){if(r){let e=null,n=null;const a=[];for(const t of r)"default"===t.imported?e=t:"*"===t.imported?n=t:a.push(t);n&&s.push(`import${t}*${t}as ${n.local} from${t}'${i}';`),e&&0===a.length?s.push(`import ${e.local} from${t}'${i}';`):a.length>0&&s.push(`import ${e?`${e.local},${t}`:""}{${t}${a.map((e=>e.imported===e.local?e.imported:`${e.imported} as ${e.local}`)).join(`,${t}`)}${t}}${t}from${t}'${i}';`)}if(n){let e=null;const o=[],h=[];for(const t of n)"*"===t.reexported?e=t:"*"===t.imported?o.push(t):h.push(t);if(e&&s.push(`export${t}*${t}from${t}'${i}';`),o.length>0){r&&r.some((e=>"*"===e.imported&&e.local===a))||s.push(`import${t}*${t}as ${a} from${t}'${i}';`);for(const e of o)s.push(`export${t}{${t}${a===e.reexported?a:`${a} as ${e.reexported}`} };`)}h.length>0&&s.push(`export${t}{${t}${h.map((e=>e.imported===e.reexported?e.imported:`${e.imported} as ${e.reexported}`)).join(`,${t}`)}${t}}${t}from${t}'${i}';`)}}else s.push(`import${t}'${i}';`);return s}(r,u);p.length>0&&(i+=p.join(d)+d+d),(i+=Rs(null,t,s,o,h,l,c))&&e.prepend(i);const f=function(e,{_:t,cnst:s}){const i=[],n=[];for(const r of e)r.expression&&i.push(`${s} ${r.local}${t}=${t}${r.expression};`),n.push(r.exported===r.local?r.local:`${r.local} as ${r.exported}`);n.length&&i.push(`export${t}{${t}${n.join(`,${t}`)}${t}};`);return i}(a,o);return f.length&&e.append(d+d+f.join(d).trim()),n&&e.append(n),e.trim()},iife:function(e,{accessedGlobals:t,dependencies:s,exports:i,hasExports:n,indent:r,intro:a,namedExportsMode:o,outro:h,snippets:l,warn:c},{compact:u,esModule:d,extend:p,freeze:f,externalLiveBindings:m,globals:g,interop:y,name:E,namespaceToStringTag:x,strict:v}){const{_:b,cnst:S,getNonArrowFunctionIntro:A,getPropertyAccess:P,n:k}=l,w=E&&-1!==E.indexOf("."),C=!p&&!w;if(E&&C&&(ee(I=E)||Z.has(I)||J.test(I)))return Ks({code:"ILLEGAL_IDENTIFIER_AS_NAME",message:`Given name "${E}" is not a legal JS identifier. If you need this, you can try "output.extend: true".`});var I;rn(c,s);const N=hn(s),_=N.map((e=>e.globalName||"null")),$=N.map((e=>e.name));n&&!E&&c({code:"MISSING_NAME_OPTION_FOR_IIFE_EXPORT",message:'If you do not supply "output.name", you may not be able to access the exports of an IIFE bundle.'}),o&&n&&(p?(_.unshift(`this${an(E,P)}${b}=${b}this${an(E,P)}${b}||${b}{}`),$.unshift("exports")):(_.unshift("{}"),$.unshift("exports")));const T=v?`${r}'use strict';${k}`:"",R=tn(s,y,m,f,x,t,r,l);e.prepend(`${a}${R}`);let M=`(${A($,{isAsync:!1,name:null})}{${k}${T}${k}`;n&&(!E||p&&o||(M=(C?`${S} ${E}`:`this${an(E,P)}`)+`${b}=${b}${M}`),w&&(M=function(e,t,s,{_:i,getPropertyAccess:n,s:r},a){const o=e.split(".");o[0]=("function"==typeof s?s(o[0]):s[o[0]])||o[0],o.pop();let h=t;return o.map((e=>(h+=n(e),`${h}${i}=${i}${h}${i}||${i}{}${r}`))).join(a?",":"\n")+(a&&o.length?";":"\n")}(E,"this",g,l,u)+M));let D=`${k}${k}})(${_.join(`,${b}`)});`;n&&!p&&o&&(D=`${k}${k}${r}return exports;${D}`);const L=Qi(i,s,o,y,l,r,m);let O=Ji(o&&n,d,x,b,k);return O&&(O=k+k+O),e.append(`${L}${O}${h}`),e.indent(r).prepend(M).append(D)},system:function(e,{accessedGlobals:t,dependencies:s,exports:i,hasExports:n,indent:r,intro:a,snippets:o,outro:h,usesTopLevelAwait:l},{externalLiveBindings:c,freeze:u,name:d,namespaceToStringTag:p,strict:f,systemNullSetters:m}){const{_:g,getFunctionIntro:y,getNonArrowFunctionIntro:E,n:x,s:v}=o,{importBindings:b,setters:S,starExcludes:A}=function(e,t,s,{_:i,cnst:n,getObject:r,getPropertyAccess:a,n:o}){const h=[],l=[];let c=null;for(const{imports:u,reexports:d}of e){const p=[];if(u)for(const e of u)h.push(e.local),"*"===e.imported?p.push(`${e.local}${i}=${i}module;`):p.push(`${e.local}${i}=${i}module${a(e.imported)};`);if(d){const o=[];let h=!1;for(const{imported:e,reexported:t}of d)"*"===t?h=!0:o.push([t,"*"===e?"module":`module${a(e)}`]);if(o.length>1||h){const a=r(o,{lineBreakIndent:null});h?(c||(c=ln({dependencies:e,exports:t})),p.push(`${n} setter${i}=${i}${a};`,`for${i}(${n} name in module)${i}{`,`${s}if${i}(!_starExcludes[name])${i}setter[name]${i}=${i}module[name];`,"}","exports(setter);")):p.push(`exports(${a});`)}else{const[e,t]=o[0];p.push(`exports('${e}',${i}${t});`)}}l.push(p.join(`${o}${s}${s}${s}`))}return{importBindings:h,setters:l,starExcludes:c}}(s,i,r,o),P=d?`'${d}',${g}`:"",k=t.has("module")?["exports","module"]:n?["exports"]:[];let w=`System.register(${P}[`+s.map((({id:e})=>`'${e}'`)).join(`,${g}`)+`],${g}(${E(k,{isAsync:!1,name:null})}{${x}${r}${f?"'use strict';":""}`+cn(A,r,o)+un(b,r,o)+`${x}${r}return${g}{${S.length?`${x}${r}${r}setters:${g}[${S.map((e=>e?`${y(["module"],{isAsync:!1,name:null})}{${x}${r}${r}${r}${e}${x}${r}${r}}`:m?"null":`${y([],{isAsync:!1,name:null})}{}`)).join(`,${g}`)}],`:""}${x}`;w+=`${r}${r}execute:${g}(${E([],{isAsync:l,name:null})}{${x}${x}`;const C=`${r}${r}})${x}${r}}${v}${x}}));`;return e.prepend(a+Rs(null,t,r,o,c,u,p)+dn(i,r,o)),e.append(`${h}${x}${x}`+fn(i,r,o)+mn(i,r,o)),e.indent(`${r}${r}${r}`).append(C).prepend(w)},umd:function(e,{accessedGlobals:t,dependencies:s,exports:i,hasExports:n,id:r,indent:a,intro:o,namedExportsMode:h,outro:l,snippets:c,warn:u},{amd:d,compact:p,esModule:f,extend:m,externalLiveBindings:g,freeze:y,interop:E,name:x,namespaceToStringTag:v,globals:b,noConflict:S,strict:A}){const{_:P,cnst:k,getFunctionIntro:w,getNonArrowFunctionIntro:C,getPropertyAccess:I,n:N,s:_}=c,$=p?"f":"factory",T=p?"g":"global";if(n&&!x)return Ks({code:"MISSING_NAME_OPTION_FOR_IIFE_EXPORT",message:'You must supply "output.name" for UMD bundles that have exports so that the exports are accessible in environments without a module loader.'});rn(u,s);const R=s.map((e=>`'${sn(e.id)}'`)),M=s.map((e=>`require('${e.id}')`)),D=hn(s),L=D.map((e=>gn(e.globalName,T,I))),O=D.map((e=>e.name));h&&(n||S)&&(R.unshift("'exports'"),M.unshift("exports"),L.unshift(on(x,T,b,(m?`${gn(x,T,I)}${P}||${P}`:"")+"{}",c)),O.unshift("exports"));const V=Yi(d,r),B=(V?`'${V}',${P}`:"")+(R.length?`[${R.join(`,${P}`)}],${P}`:""),F=d.define,z=!h&&n?`module.exports${P}=${P}`:"",W=A?`${P}'use strict';${N}`:"";let j;if(S){const e=p?"e":"exports";let t;if(!h&&n)t=`${k} ${e}${P}=${P}${on(x,T,b,`${$}(${L.join(`,${P}`)})`,c)};`;else{t=`${k} ${e}${P}=${P}${L.shift()};${N}${a}${a}${$}(${[e].concat(L).join(`,${P}`)});`}j=`(${w([],{isAsync:!1,name:null})}{${N}${a}${a}${k} current${P}=${P}${function(e,t,{_:s,getPropertyAccess:i}){let n=t;return e.split(".").map((e=>n+=i(e))).join(`${s}&&${s}`)}(x,T,c)};${N}${a}${a}${t}${N}${a}${a}${e}.noConflict${P}=${P}${w([],{isAsync:!1,name:null})}{${P}${gn(x,T,I)}${P}=${P}current;${P}return ${e}${_}${P}};${N}${a}})()`}else j=`${$}(${L.join(`,${P}`)})`,!h&&n&&(j=on(x,T,b,j,c));const U=n||S&&h||L.length>0,G=[$];U&&G.unshift(T);const H=U?`this,${P}`:"",q=U?`(${T}${P}=${P}typeof globalThis${P}!==${P}'undefined'${P}?${P}globalThis${P}:${P}${T}${P}||${P}self,${P}`:"",K=U?")":"",X=U?`${a}typeof exports${P}===${P}'object'${P}&&${P}typeof module${P}!==${P}'undefined'${P}?${P}${z}${$}(${M.join(`,${P}`)})${P}:${N}`:"",Y=`(${C(G,{isAsync:!1,name:null})}{${N}`+X+`${a}typeof ${F}${P}===${P}'function'${P}&&${P}${F}.amd${P}?${P}${F}(${B}${$})${P}:${N}`+`${a}${q}${j}${K};${N}`+`})(${H}(${C(O,{isAsync:!1,name:null})}{${W}${N}`,Q=N+N+"}));";e.prepend(`${o}${tn(s,E,g,y,v,t,a,c)}`);const Z=Qi(i,s,h,E,c,a,g);let J=Ji(h&&n,f,v,P,N);return J&&(J=N+N+J),e.append(`${Z}${J}${l}`),e.trim().indent(a).append(Q).prepend(Y)}};class En{constructor(e,t){this.isOriginal=!0,this.filename=e,this.content=t}traceSegment(e,t,s){return{column:t,line:e,name:s,source:this}}}class xn{constructor(e,t){this.sources=t,this.names=e.names,this.mappings=e.mappings}traceMappings(){const e=[],t=[],s=[],i=new Map,n=[];for(const r of this.mappings){const a=[];for(const n of r){if(1==n.length)continue;const r=this.sources[n[1]];if(!r)continue;const o=r.traceSegment(n[2],n[3],5===n.length?this.names[n[4]]:"");if(o){let r=e.lastIndexOf(o.source.filename);if(-1===r)r=e.length,e.push(o.source.filename),t[r]=o.source.content;else if(null==t[r])t[r]=o.source.content;else if(null!=o.source.content&&t[r]!==o.source.content)return Ks({message:`Multiple conflicting contents for sourcemap source ${o.source.filename}`});const h=[n[0],r,o.line,o.column];if(o.name){let e=i.get(o.name);void 0===e&&(e=s.length,s.push(o.name),i.set(o.name,e)),h[4]=e}a.push(h)}}n.push(a)}return{mappings:n,names:s,sources:e,sourcesContent:t}}traceSegment(e,t,s){const i=this.mappings[e];if(!i)return null;let n=0,r=i.length-1;for(;n<=r;){const e=n+r>>1,a=i[e];if(a[0]===t){if(1==a.length)return null;const e=this.sources[a[1]];return e?e.traceSegment(a[2],a[3],5===a.length?this.names[a[4]]:s):null}a[0]>t?r=e-1:n=e+1}return null}}function vn(e){return function(t,s){return s.mappings?new xn(s,[t]):(e({code:"SOURCEMAP_BROKEN",message:`Sourcemap is likely to be incorrect: a plugin (${s.plugin}) was used to transform files, but didn't generate a sourcemap for the transformation. Consult the plugin documentation for help`,plugin:s.plugin,url:"https://rollupjs.org/guide/en/#warning-sourcemap-is-likely-to-be-incorrect"}),new xn({mappings:[],names:[]},[t]))}}function bn(e,t,s,i,n){let r;if(s){const t=s.sources,i=s.sourcesContent||[],n=I(e)||".",a=s.sourceRoot||".",o=t.map(((e,t)=>new En($(n,a,e),i[t])));r=new xn(s,o)}else r=new En(e,t);return i.reduce(n,r)}var Sn={},An=Pn;function Pn(e,t){if(!e)throw new Error(t||"Assertion failed")}Pn.equal=function(e,t,s){if(e!=t)throw new Error(s||"Assertion failed: "+e+" != "+t)};var kn={exports:{}};"function"==typeof Object.create?kn.exports=function(e,t){t&&(e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}))}:kn.exports=function(e,t){if(t){e.super_=t;var s=function(){};s.prototype=t.prototype,e.prototype=new s,e.prototype.constructor=e}};var wn=An,Cn=kn.exports;function In(e,t){return 55296==(64512&e.charCodeAt(t))&&(!(t<0||t+1>=e.length)&&56320==(64512&e.charCodeAt(t+1)))}function Nn(e){return(e>>>24|e>>>8&65280|e<<8&16711680|(255&e)<<24)>>>0}function _n(e){return 1===e.length?"0"+e:e}function $n(e){return 7===e.length?"0"+e:6===e.length?"00"+e:5===e.length?"000"+e:4===e.length?"0000"+e:3===e.length?"00000"+e:2===e.length?"000000"+e:1===e.length?"0000000"+e:e}Sn.inherits=Cn,Sn.toArray=function(e,t){if(Array.isArray(e))return e.slice();if(!e)return[];var s=[];if("string"==typeof e)if(t){if("hex"===t)for((e=e.replace(/[^a-z0-9]+/gi,"")).length%2!=0&&(e="0"+e),n=0;n<e.length;n+=2)s.push(parseInt(e[n]+e[n+1],16))}else for(var i=0,n=0;n<e.length;n++){var r=e.charCodeAt(n);r<128?s[i++]=r:r<2048?(s[i++]=r>>6|192,s[i++]=63&r|128):In(e,n)?(r=65536+((1023&r)<<10)+(1023&e.charCodeAt(++n)),s[i++]=r>>18|240,s[i++]=r>>12&63|128,s[i++]=r>>6&63|128,s[i++]=63&r|128):(s[i++]=r>>12|224,s[i++]=r>>6&63|128,s[i++]=63&r|128)}else for(n=0;n<e.length;n++)s[n]=0|e[n];return s},Sn.toHex=function(e){for(var t="",s=0;s<e.length;s++)t+=_n(e[s].toString(16));return t},Sn.htonl=Nn,Sn.toHex32=function(e,t){for(var s="",i=0;i<e.length;i++){var n=e[i];"little"===t&&(n=Nn(n)),s+=$n(n.toString(16))}return s},Sn.zero2=_n,Sn.zero8=$n,Sn.join32=function(e,t,s,i){var n=s-t;wn(n%4==0);for(var r=new Array(n/4),a=0,o=t;a<r.length;a++,o+=4){var h;h="big"===i?e[o]<<24|e[o+1]<<16|e[o+2]<<8|e[o+3]:e[o+3]<<24|e[o+2]<<16|e[o+1]<<8|e[o],r[a]=h>>>0}return r},Sn.split32=function(e,t){for(var s=new Array(4*e.length),i=0,n=0;i<e.length;i++,n+=4){var r=e[i];"big"===t?(s[n]=r>>>24,s[n+1]=r>>>16&255,s[n+2]=r>>>8&255,s[n+3]=255&r):(s[n+3]=r>>>24,s[n+2]=r>>>16&255,s[n+1]=r>>>8&255,s[n]=255&r)}return s},Sn.rotr32=function(e,t){return e>>>t|e<<32-t},Sn.rotl32=function(e,t){return e<<t|e>>>32-t},Sn.sum32=function(e,t){return e+t>>>0},Sn.sum32_3=function(e,t,s){return e+t+s>>>0},Sn.sum32_4=function(e,t,s,i){return e+t+s+i>>>0},Sn.sum32_5=function(e,t,s,i,n){return e+t+s+i+n>>>0},Sn.sum64=function(e,t,s,i){var n=e[t],r=i+e[t+1]>>>0,a=(r<i?1:0)+s+n;e[t]=a>>>0,e[t+1]=r},Sn.sum64_hi=function(e,t,s,i){return(t+i>>>0<t?1:0)+e+s>>>0},Sn.sum64_lo=function(e,t,s,i){return t+i>>>0},Sn.sum64_4_hi=function(e,t,s,i,n,r,a,o){var h=0,l=t;return h+=(l=l+i>>>0)<t?1:0,h+=(l=l+r>>>0)<r?1:0,e+s+n+a+(h+=(l=l+o>>>0)<o?1:0)>>>0},Sn.sum64_4_lo=function(e,t,s,i,n,r,a,o){return t+i+r+o>>>0},Sn.sum64_5_hi=function(e,t,s,i,n,r,a,o,h,l){var c=0,u=t;return c+=(u=u+i>>>0)<t?1:0,c+=(u=u+r>>>0)<r?1:0,c+=(u=u+o>>>0)<o?1:0,e+s+n+a+h+(c+=(u=u+l>>>0)<l?1:0)>>>0},Sn.sum64_5_lo=function(e,t,s,i,n,r,a,o,h,l){return t+i+r+o+l>>>0},Sn.rotr64_hi=function(e,t,s){return(t<<32-s|e>>>s)>>>0},Sn.rotr64_lo=function(e,t,s){return(e<<32-s|t>>>s)>>>0},Sn.shr64_hi=function(e,t,s){return e>>>s},Sn.shr64_lo=function(e,t,s){return(e<<32-s|t>>>s)>>>0};var Tn={},Rn=Sn,Mn=An;function Dn(){this.pending=null,this.pendingTotal=0,this.blockSize=this.constructor.blockSize,this.outSize=this.constructor.outSize,this.hmacStrength=this.constructor.hmacStrength,this.padLength=this.constructor.padLength/8,this.endian="big",this._delta8=this.blockSize/8,this._delta32=this.blockSize/32}Tn.BlockHash=Dn,Dn.prototype.update=function(e,t){if(e=Rn.toArray(e,t),this.pending?this.pending=this.pending.concat(e):this.pending=e,this.pendingTotal+=e.length,this.pending.length>=this._delta8){var s=(e=this.pending).length%this._delta8;this.pending=e.slice(e.length-s,e.length),0===this.pending.length&&(this.pending=null),e=Rn.join32(e,0,e.length-s,this.endian);for(var i=0;i<e.length;i+=this._delta32)this._update(e,i,i+this._delta32)}return this},Dn.prototype.digest=function(e){return this.update(this._pad()),Mn(null===this.pending),this._digest(e)},Dn.prototype._pad=function(){var e=this.pendingTotal,t=this._delta8,s=t-(e+this.padLength)%t,i=new Array(s+this.padLength);i[0]=128;for(var n=1;n<s;n++)i[n]=0;if(e<<=3,"big"===this.endian){for(var r=8;r<this.padLength;r++)i[n++]=0;i[n++]=0,i[n++]=0,i[n++]=0,i[n++]=0,i[n++]=e>>>24&255,i[n++]=e>>>16&255,i[n++]=e>>>8&255,i[n++]=255&e}else for(i[n++]=255&e,i[n++]=e>>>8&255,i[n++]=e>>>16&255,i[n++]=e>>>24&255,i[n++]=0,i[n++]=0,i[n++]=0,i[n++]=0,r=8;r<this.padLength;r++)i[n++]=0;return i};var Ln={},On=Sn.rotr32;function Vn(e,t,s){return e&t^~e&s}function Bn(e,t,s){return e&t^e&s^t&s}function Fn(e,t,s){return e^t^s}Ln.ft_1=function(e,t,s,i){return 0===e?Vn(t,s,i):1===e||3===e?Fn(t,s,i):2===e?Bn(t,s,i):void 0},Ln.ch32=Vn,Ln.maj32=Bn,Ln.p32=Fn,Ln.s0_256=function(e){return On(e,2)^On(e,13)^On(e,22)},Ln.s1_256=function(e){return On(e,6)^On(e,11)^On(e,25)},Ln.g0_256=function(e){return On(e,7)^On(e,18)^e>>>3},Ln.g1_256=function(e){return On(e,17)^On(e,19)^e>>>10};var zn=Sn,Wn=Tn,jn=Ln,Un=An,Gn=zn.sum32,Hn=zn.sum32_4,qn=zn.sum32_5,Kn=jn.ch32,Xn=jn.maj32,Yn=jn.s0_256,Qn=jn.s1_256,Zn=jn.g0_256,Jn=jn.g1_256,er=Wn.BlockHash,tr=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298];function sr(){if(!(this instanceof sr))return new sr;er.call(this),this.h=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225],this.k=tr,this.W=new Array(64)}zn.inherits(sr,er);var ir=sr;sr.blockSize=512,sr.outSize=256,sr.hmacStrength=192,sr.padLength=64,sr.prototype._update=function(e,t){for(var s=this.W,i=0;i<16;i++)s[i]=e[t+i];for(;i<s.length;i++)s[i]=Hn(Jn(s[i-2]),s[i-7],Zn(s[i-15]),s[i-16]);var n=this.h[0],r=this.h[1],a=this.h[2],o=this.h[3],h=this.h[4],l=this.h[5],c=this.h[6],u=this.h[7];for(Un(this.k.length===s.length),i=0;i<s.length;i++){var d=qn(u,Qn(h),Kn(h,l,c),this.k[i],s[i]),p=Gn(Yn(n),Xn(n,r,a));u=c,c=l,l=h,h=Gn(o,d),o=a,a=r,r=n,n=Gn(d,p)}this.h[0]=Gn(this.h[0],n),this.h[1]=Gn(this.h[1],r),this.h[2]=Gn(this.h[2],a),this.h[3]=Gn(this.h[3],o),this.h[4]=Gn(this.h[4],h),this.h[5]=Gn(this.h[5],l),this.h[6]=Gn(this.h[6],c),this.h[7]=Gn(this.h[7],u)},sr.prototype._digest=function(e){return"hex"===e?zn.toHex32(this.h,"big"):zn.split32(this.h,"big")};var nr=ir;const rr=()=>nr(),ar={amd:lr,cjs:lr,es:hr,iife:lr,system:hr,umd:lr};function or(e,t,s,i,n,r,a,o,h,l,c,u,d){const p=e.slice().reverse();for(const e of p)e.scope.addUsedOutsideNames(i,n,c,u);!function(e,t,s){for(const i of t){for(const t of i.scope.variables.values())t.included&&!(t.renderBaseName||t instanceof Si&&t.getOriginalVariable()!==t)&&t.setRenderNames(null,We(t.name,e));if(s.has(i)){const t=i.namespace;t.setRenderNames(null,We(t.name,e))}}}(i,p,d),ar[n](i,s,t,r,a,o,h,l);for(const e of p)e.scope.deconflict(n,c,u)}function hr(e,t,s,i,n,r,a,o){for(const t of s.dependencies)(n||t instanceof ae)&&(t.variableName=We(t.suggestedVariableName,e));for(const s of t){const t=s.module,i=s.name;s.isNamespace&&(n||t instanceof ae)?s.setRenderNames(null,(t instanceof ae?t:a.get(t)).variableName):t instanceof ae&&"default"===i?s.setRenderNames(null,We([...t.exportedVariables].some((([e,t])=>"*"===t&&e.included))?t.suggestedVariableName+"__default":t.suggestedVariableName,e)):s.setRenderNames(null,We(i,e))}for(const t of o)t.setRenderNames(null,We(t.name,e))}function lr(e,t,{deconflictedDefault:s,deconflictedNamespace:i,dependencies:n},r,a,o,h){for(const t of n)t.variableName=We(t.suggestedVariableName,e);for(const t of i)t.namespaceVariableName=We(`${t.suggestedVariableName}__namespace`,e);for(const t of s)i.has(t)&&Ts(String(r(t.id)),o)?t.defaultVariableName=t.namespaceVariableName:t.defaultVariableName=We(`${t.suggestedVariableName}__default`,e);for(const e of t){const t=e.module;if(t instanceof ae){const s=e.name;if("default"===s){const s=String(r(t.id)),i=Ns[s]?t.defaultVariableName:t.variableName;_s(s,o)?e.setRenderNames(i,"default"):e.setRenderNames(null,i)}else"*"===s?e.setRenderNames(null,$s[String(r(t.id))]?t.namespaceVariableName:t.variableName):e.setRenderNames(t.variableName,null)}else{const s=h.get(t);a&&e.isNamespace?e.setRenderNames(null,"default"===s.exportMode?s.namespaceVariableName:s.variableName):"default"===s.exportMode?e.setRenderNames(null,s.variableName):e.setRenderNames(s.variableName,s.getVariableExportName(e))}}}const cr=/[\\'\r\n\u2028\u2029]/,ur=/(['\r\n\u2028\u2029])/g,dr=/\\/g;function pr(e){return e.match(cr)?e.replace(dr,"\\\\").replace(ur,"\\$1"):e}function fr(e,{exports:t,name:s,format:i},n,r,a){const o=e.getExportNames();if("default"===t){if(1!==o.length||"default"!==o[0])return Ks(Zs("default",o,r))}else if("none"===t&&o.length)return Ks(Zs("none",o,r));return"auto"===t&&(0===o.length?t="none":1===o.length&&"default"===o[0]?("cjs"===i&&n.has("exports")&&a(function(e){const t=ne(e);return{code:Ys.PREFER_NAMED_EXPORTS,id:e,message:`Entry module "${t}" is implicitly using "default" export mode, which means for CommonJS output that its default export is assigned to "module.exports". For many tools, such CommonJS output will not be interchangeable with the original ES module. If this is intended, explicitly set "output.exports" to either "auto" or "default", otherwise you might want to consider changing the signature of "${t}" to use named exports only.`,url:"https://rollupjs.org/guide/en/#outputexports"}}(r)),t="default"):("es"!==i&&"system"!==i&&-1!==o.indexOf("default")&&a(function(e,t){return{code:Ys.MIXED_EXPORTS,id:e,message:`Entry module "${ne(e)}" is using named and default exports together. Consumers of your bundle will have to use \`${t||"chunk"}["default"]\` to access the default export, which may not be what you want. Use \`output.exports: "named"\` to disable this warning`,url:"https://rollupjs.org/guide/en/#outputexports"}}(r,s)),t="named")),t}function mr(e){const t=e.split("\n"),s=t.filter((e=>/^\t+/.test(e))),i=t.filter((e=>/^ {2,}/.test(e)));if(0===s.length&&0===i.length)return null;if(s.length>=i.length)return"\t";const n=i.reduce(((e,t)=>{const s=/^ +/.exec(t)[0].length;return Math.min(s,e)}),1/0);return new Array(n+1).join(" ")}function gr(e,t,s,i,n){const r=e.getDependenciesToBeIncluded();for(const e of r){if(e instanceof ae){t.push(e);continue}const r=n.get(e);r===i?s.has(e)||(s.add(e),gr(e,t,s,i,n)):t.push(r)}}function yr(e){if(!e)return null;if("string"==typeof e&&(e=JSON.parse(e)),""===e.mappings)return{mappings:[],names:[],sources:[],version:3};let s;return s="string"==typeof e.mappings?function(e){for(var s=[],i=[],r=[0,0,0,0,0],a=0,o=0,h=0,l=0;o<e.length;o++){var c=e.charCodeAt(o);if(44===c)n(i,r,a),a=0;else if(59===c)n(i,r,a),a=0,s.push(i),i=[],r[0]=0;else{var u=t[c];if(void 0===u)throw new Error("Invalid character ("+String.fromCharCode(c)+")");var d=32&u;if(l+=(u&=31)<<h,d)h+=5;else{var p=1&l;l>>>=1,p&&(l=0===l?-2147483648:-l),r[a]+=l,a++,l=h=0}}}return n(i,r,a),s.push(i),s}(e.mappings):e.mappings,{...e,mappings:s}}function Er(e,t,s){return re(e)?Ks(ai(`Invalid pattern "${e}" for "${t}", patterns can be neither absolute nor relative paths.`)):e.replace(/\[(\w+)\]/g,((e,i)=>{if(!s.hasOwnProperty(i))return Ks(ai(`"[${i}]" is not a valid placeholder in "${t}" pattern.`));const n=s[i]();return re(n)?Ks(ai(`Invalid substitution "${n}" for placeholder "[${i}]" in "${t}" pattern, can be neither absolute nor relative path.`)):n}))}function xr(e,t){const s=new Set(Object.keys(t).map((e=>e.toLowerCase())));if(!s.has(e.toLocaleLowerCase()))return e;const i=N(e);e=e.substr(0,e.length-i.length);let n,r=1;for(;s.has((n=e+ ++r+i).toLowerCase()););return n}const vr=[".js",".jsx",".ts",".tsx"];function br(e,t,s,i){const n="function"==typeof t?t(e.id):t[e.id];return n||(s?(i({code:"MISSING_GLOBAL_NAME",guess:e.variableName,message:`No name was provided for external module '${e.id}' in output.globals – guessing '${e.variableName}'`,source:e.id}),e.variableName):void 0)}class Sr{constructor(e,t,s,i,n,r,a,o,h,l){this.orderedModules=e,this.inputOptions=t,this.outputOptions=s,this.unsetOptions=i,this.pluginDriver=n,this.modulesById=r,this.chunkByModule=a,this.facadeChunkByModule=o,this.includedNamespaces=h,this.manualChunkAlias=l,this.entryModules=[],this.exportMode="named",this.facadeModule=null,this.id=null,this.namespaceVariableName="",this.needsExportsShim=!1,this.variableName="",this.accessedGlobalsByScope=new Map,this.dependencies=new Set,this.dynamicDependencies=new Set,this.dynamicEntryModules=[],this.dynamicName=null,this.exportNamesByVariable=new Map,this.exports=new Set,this.exportsByName=Object.create(null),this.fileName=null,this.implicitEntryModules=[],this.implicitlyLoadedBefore=new Set,this.imports=new Set,this.indentString=void 0,this.isEmpty=!0,this.name=null,this.renderedDependencies=null,this.renderedExports=null,this.renderedHash=void 0,this.renderedModuleSources=new Map,this.renderedModules=Object.create(null),this.renderedSource=null,this.sortedExportNames=null,this.strictFacade=!1,this.usedModules=void 0,this.execIndex=e.length>0?e[0].execIndex:1/0;const c=new Set(e);for(const t of e){t.namespace.included&&h.add(t),this.isEmpty&&t.isIncluded()&&(this.isEmpty=!1),(t.info.isEntry||s.preserveModules)&&this.entryModules.push(t);for(const e of t.includedDynamicImporters)c.has(e)||(this.dynamicEntryModules.push(t),t.info.syntheticNamedExports&&!s.preserveModules&&(h.add(t),this.exports.add(t.namespace)));t.implicitlyLoadedAfter.size>0&&this.implicitEntryModules.push(t)}this.suggestedVariableName=te(this.generateVariableName())}static generateFacade(e,t,s,i,n,r,a,o,h,l){const c=new Sr([],e,t,s,i,n,r,a,o,null);c.assignFacadeName(l,h),a.has(h)||a.set(h,c);for(const e of h.getDependenciesToBeIncluded())c.dependencies.add(e instanceof qi?r.get(e):e);return!c.dependencies.has(r.get(h))&&h.info.hasModuleSideEffects&&h.hasEffects()&&c.dependencies.add(r.get(h)),c.ensureReexportsAreAvailableForModule(h),c.facadeModule=h,c.strictFacade=!0,c}canModuleBeFacade(e,t){const s=e.getExportNamesByVariable();for(const t of this.exports)if(!s.has(t))return 0===s.size&&e.isUserDefinedEntryPoint&&"strict"===e.preserveSignature&&this.unsetOptions.has("preserveEntrySignatures")&&this.inputOptions.onwarn({code:"EMPTY_FACADE",id:e.id,message:`To preserve the export signature of the entry module "${ne(e.id)}", an empty facade chunk was created. This often happens when creating a bundle for a web app where chunks are placed in script tags and exports are ignored. In this case it is recommended to set "preserveEntrySignatures: false" to avoid this and reduce the number of chunks. Otherwise if this is intentional, set "preserveEntrySignatures: 'strict'" explicitly to silence this warning.`,url:"https://rollupjs.org/guide/en/#preserveentrysignatures"}),!1;for(const i of t)if(!s.has(i)&&i.module!==e)return!1;return!0}generateExports(){this.sortedExportNames=null;const e=new Set(this.exports);if(null!==this.facadeModule&&(!1!==this.facadeModule.preserveSignature||this.strictFacade)){const t=this.facadeModule.getExportNamesByVariable();for(const[s,i]of t){this.exportNamesByVariable.set(s,[...i]);for(const e of i)this.exportsByName[e]=s;e.delete(s)}}this.outputOptions.minifyInternalExports?function(e,t,s){let i=0;for(const n of e){let e=n.name[0];if(t[e])do{e=Fe(++i),49===e.charCodeAt(0)&&(i+=9*64**(e.length-1),e=Fe(i))}while(ze[e]||t[e]);t[e]=n,s.set(n,[e])}}(e,this.exportsByName,this.exportNamesByVariable):function(e,t,s){for(const i of e){let e=0,n=i.name;for(;t[n];)n=i.name+"$"+ ++e;t[n]=i,s.set(i,[n])}}(e,this.exportsByName,this.exportNamesByVariable),(this.outputOptions.preserveModules||this.facadeModule&&this.facadeModule.info.isEntry)&&(this.exportMode=fr(this,this.outputOptions,this.unsetOptions,this.facadeModule.id,this.inputOptions.onwarn))}generateFacades(){var e;const t=[],s=new Set([...this.entryModules,...this.implicitEntryModules]),i=new Set(this.dynamicEntryModules.map((e=>e.namespace)));for(const e of s)if(e.preserveSignature)for(const t of e.getExportNamesByVariable().keys())i.add(t);for(const e of s){const s=Array.from(e.userChunkNames,(e=>({name:e})));if(0===s.length&&e.isUserDefinedEntryPoint&&s.push({}),s.push(...Array.from(e.chunkFileNames,(e=>({fileName:e})))),0===s.length&&s.push({}),!this.facadeModule){const t="strict"===e.preserveSignature||"exports-only"===e.preserveSignature&&0!==e.getExportNamesByVariable().size;(!t||this.outputOptions.preserveModules||this.canModuleBeFacade(e,i))&&(this.facadeModule=e,this.facadeChunkByModule.set(e,this),e.preserveSignature&&(this.strictFacade=t),this.assignFacadeName(s.shift(),e))}for(const i of s)t.push(Sr.generateFacade(this.inputOptions,this.outputOptions,this.unsetOptions,this.pluginDriver,this.modulesById,this.chunkByModule,this.facadeChunkByModule,this.includedNamespaces,e,i))}for(const t of this.dynamicEntryModules)t.info.syntheticNamedExports||(!this.facadeModule&&this.canModuleBeFacade(t,i)?(this.facadeModule=t,this.facadeChunkByModule.set(t,this),this.strictFacade=!0,this.dynamicName=Ar(t)):this.facadeModule===t&&!this.strictFacade&&this.canModuleBeFacade(t,i)?this.strictFacade=!0:(null===(e=this.facadeChunkByModule.get(t))||void 0===e?void 0:e.strictFacade)||(this.includedNamespaces.add(t),this.exports.add(t.namespace)));return t}generateId(e,t,s,i){if(null!==this.fileName)return this.fileName;const[n,r]=this.facadeModule&&this.facadeModule.isUserDefinedEntryPoint?[t.entryFileNames,"output.entryFileNames"]:[t.chunkFileNames,"output.chunkFileNames"];return xr(Er("function"==typeof n?n(this.getChunkInfo()):n,r,{format:()=>t.format,hash:()=>i?this.computeContentHashWithDependencies(e,t,s):"[hash]",name:()=>this.getChunkName()}),s)}generateIdPreserveModules(e,t,s,i){const n=this.orderedModules[0].id,r=this.outputOptions.sanitizeFileName(n);let a;if(P(n)){const s=N(n),o=i.has("entryFileNames")?"[name][assetExtname].js":t.entryFileNames,h=`${I(r)}/${Er("function"==typeof o?o(this.getChunkInfo()):o,"output.entryFileNames",{assetExtname:()=>vr.includes(s)?"":s,ext:()=>s.substr(1),extname:()=>s,format:()=>t.format,name:()=>this.getChunkName()})}`,{preserveModulesRoot:l}=t;a=l&&h.startsWith(l)?h.slice(l.length).replace(/^[\\/]/,""):_(e,h)}else a=`_virtual/${C(r)}`;return xr(w(a),s)}getChunkInfo(){const e=this.facadeModule,t=this.getChunkName.bind(this);return{exports:this.getExportNames(),facadeModuleId:e&&e.id,isDynamicEntry:this.dynamicEntryModules.length>0,isEntry:null!==e&&e.info.isEntry,isImplicitEntry:this.implicitEntryModules.length>0,modules:this.renderedModules,get name(){return t()},type:"chunk"}}getChunkInfoWithFileNames(){return Object.assign(this.getChunkInfo(),{code:void 0,dynamicImports:Array.from(this.dynamicDependencies,Ni),fileName:this.id,implicitlyLoadedBefore:Array.from(this.implicitlyLoadedBefore,Ni),importedBindings:this.getImportedBindingsPerDependency(),imports:Array.from(this.dependencies,Ni),map:void 0,referencedFiles:this.getReferencedFiles()})}getChunkName(){return this.name||(this.name=this.outputOptions.sanitizeFileName(this.getFallbackChunkName()))}getExportNames(){return this.sortedExportNames||(this.sortedExportNames=Object.keys(this.exportsByName).sort())}getRenderedHash(){if(this.renderedHash)return this.renderedHash;const e=rr(),t=this.pluginDriver.hookReduceValueSync("augmentChunkHash","",[this.getChunkInfo()],((e,t)=>(t&&(e+=t),e)));return e.update(t),e.update(this.renderedSource.toString()),e.update(this.getExportNames().map((e=>{const t=this.exportsByName[e];return`${ne(t.module.id).replace(/\\/g,"/")}:${t.name}:${e}`})).join(",")),this.renderedHash=e.digest("hex")}getVariableExportName(e){return this.outputOptions.preserveModules&&e instanceof Ci?"*":this.exportNamesByVariable.get(e)[0]}link(){this.dependencies=function(e,t,s){const i=[],n=new Set;for(let r=t.length-1;r>=0;r--){const a=t[r];if(!n.has(a)){const t=[];gr(a,t,n,e,s),i.unshift(t)}}const r=new Set;for(const e of i)for(const t of e)r.add(t);return r}(this,this.orderedModules,this.chunkByModule);for(const e of this.orderedModules)this.addDependenciesToChunk(e.dynamicDependencies,this.dynamicDependencies),this.addDependenciesToChunk(e.implicitlyLoadedBefore,this.implicitlyLoadedBefore),this.setUpChunkImportsAndExportsForModule(e)}preRender(e,t,s){const{_:i,getPropertyAccess:n,n:r}=s,a=new v({separator:`${r}${r}`});this.usedModules=[],this.indentString=function(e,t){if(!0!==t.indent)return t.indent;for(const t of e){const e=mr(t.originalCode);if(null!==e)return e}return"\t"}(this.orderedModules,e);const o={dynamicImportFunction:e.dynamicImportFunction,exportNamesByVariable:this.exportNamesByVariable,format:e.format,freeze:e.freeze,indent:this.indentString,namespaceToStringTag:e.namespaceToStringTag,outputPluginDriver:this.pluginDriver,snippets:s};if(e.hoistTransitiveImports&&!this.outputOptions.preserveModules&&null!==this.facadeModule)for(const e of this.dependencies)e instanceof Sr&&this.inlineChunkDependencies(e);this.prepareModulesForRendering(s),this.setIdentifierRenderResolutions(e);let h="";const l=this.renderedModules;for(const t of this.orderedModules){let s=0;if(t.isIncluded()||this.includedNamespaces.has(t)){const i=t.render(o).trim();s=i.length(),s&&(e.compact&&-1!==i.lastLine().indexOf("//")&&i.append("\n"),this.renderedModuleSources.set(t,i),a.addSource(i),this.usedModules.push(t));const n=t.namespace;if(this.includedNamespaces.has(t)&&!this.outputOptions.preserveModules){const e=n.renderBlock(o);n.renderFirst()?h+=r+e:a.addSource(new b(e))}}const{renderedExports:i,removedExports:n}=t.getRenderedExports(),{renderedModuleSources:c}=this;l[t.id]={get code(){var e,s;return null!==(s=null===(e=c.get(t))||void 0===e?void 0:e.toString())&&void 0!==s?s:null},originalLength:t.originalCode.length,removedExports:n,renderedExports:i,renderedLength:s}}if(h&&a.prepend(h+r+r),this.needsExportsShim&&a.prepend(`${r}${s.cnst} _missingExportShim${i}=${i}void 0;${r}${r}`),e.compact?this.renderedSource=a:this.renderedSource=a.trim(),this.renderedHash=void 0,this.isEmpty&&0===this.getExportNames().length&&0===this.dependencies.size){const e=this.getChunkName();this.inputOptions.onwarn({chunkName:e,code:"EMPTY_BUNDLE",message:`Generated an empty chunk: "${e}"`})}this.setExternalRenderPaths(e,t),this.renderedDependencies=this.getChunkDependencyDeclarations(e,n),this.renderedExports="none"===this.exportMode?[]:this.getChunkExportDeclarations(e.format,n)}async render(e,t,s,i){Bi("render format",2);const n=e.format,r=yn[n];e.dynamicImportFunction&&"es"!==n&&this.inputOptions.onwarn(Js("output.dynamicImportFunction","outputdynamicImportFunction",'this option is ignored for formats other than "es"'));for(const e of this.dependencies){const t=this.renderedDependencies.get(e);if(e instanceof ae){const s=e.renderPath;t.id=pr(e.renormalizeRenderPath?this.getRelativePath(s,!1):s)}else t.namedExportsMode="default"!==e.exportMode,t.id=pr(this.getRelativePath(e.id,!1))}this.finaliseDynamicImports(e,i),this.finaliseImportMetas(n,i);const a=0!==this.renderedExports.length||[...this.renderedDependencies.values()].some((e=>e.reexports&&0!==e.reexports.length));let o=!1;const h=new Set;for(const e of this.orderedModules){e.usesTopLevelAwait&&(o=!0);const t=this.accessedGlobalsByScope.get(e.scope);if(t)for(const e of t)h.add(e)}if(o&&"es"!==n&&"system"!==n)return Ks({code:"INVALID_TLA_FORMAT",message:`Module format ${n} does not support top-level await. Use the "es" or "system" output formats rather.`});if(!this.id)throw new Error("Internal Error: expecting chunk id");const c=r(this.renderedSource,{accessedGlobals:h,dependencies:[...this.renderedDependencies.values()],exports:this.renderedExports,hasExports:a,id:this.id,indent:this.indentString,intro:t.intro,isEntryFacade:this.outputOptions.preserveModules||null!==this.facadeModule&&this.facadeModule.info.isEntry,isModuleFacade:null!==this.facadeModule,namedExportsMode:"default"!==this.exportMode,outro:t.outro,snippets:i,usesTopLevelAwait:o,warn:this.inputOptions.onwarn},e);t.banner&&c.prepend(t.banner),t.footer&&c.append(t.footer);const u=c.toString();Fi("render format",2);let d=null;const p=[];let f=await function({code:e,options:t,outputPluginDriver:s,renderChunk:i,sourcemapChain:n}){return s.hookReduceArg0("renderChunk",[e,i,t],((e,t,s)=>{if(null==t)return e;if("string"==typeof t&&(t={code:t,map:void 0}),null!==t.map){const e=yr(t.map);n.push(e||{missing:!0,plugin:s.name})}return t.code}))}({code:u,options:e,outputPluginDriver:this.pluginDriver,renderChunk:s,sourcemapChain:p});if(e.sourcemap){let t;Bi("sourcemap",2),t=e.file?$(e.sourcemapFile||e.file):e.dir?$(e.dir,this.id):$(this.id);const s=c.generateDecodedMap({});d=function(e,t,s,i,n,r){const a=vn(r),o=s.filter((e=>!e.excludeFromSourcemap)).map((e=>bn(e.id,e.originalCode,e.originalSourcemap,e.sourcemapChain,a)));let h=new xn(t,o);h=i.reduce(a,h);let{sources:c,sourcesContent:u,names:d,mappings:p}=h.traceMappings();if(e){const t=I(e);c=c.map((e=>_(t,e))),e=C(e)}return u=n?null:u,new l({file:e,mappings:p,names:d,sources:c,sourcesContent:u})}(t,s,this.usedModules,p,e.sourcemapExcludeSources,this.inputOptions.onwarn),d.sources=d.sources.map((s=>{const{sourcemapPathTransform:i}=e;if(i){const e=i(s,`${t}.map`);return"string"!=typeof e&&Ks(ai("sourcemapPathTransform function must return a string.")),e}return s})).map(w),Fi("sourcemap",2)}return e.compact||"\n"===f[f.length-1]||(f+="\n"),{code:f,map:d}}addDependenciesToChunk(e,t){for(const s of e)if(s instanceof qi){const e=this.chunkByModule.get(s);e&&e!==this&&t.add(e)}else t.add(s)}assignFacadeName({fileName:e,name:t},s){e?this.fileName=e:this.name=this.outputOptions.sanitizeFileName(t||Ar(s))}checkCircularDependencyImport(e,t){const s=e.module;if(s instanceof qi){const o=this.chunkByModule.get(s);let h;do{if(h=t.alternativeReexportModules.get(e),h){const l=this.chunkByModule.get(h);l&&l!==o&&this.inputOptions.onwarn((i=s.getExportNamesByVariable().get(e)[0],n=s.id,r=h.id,a=t.id,{code:Ys.CYCLIC_CROSS_CHUNK_REEXPORT,exporter:n,importer:a,message:`Export "${i}" of module ${ne(n)} was reexported through module ${ne(r)} while both modules are dependencies of each other and will end up in different chunks by current Rollup settings. This scenario is not well supported at the moment as it will produce a circular dependency between chunks and will likely lead to broken execution order.\nEither change the import in ${ne(a)} to point directly to the exporting module or do not use "preserveModules" to ensure these modules end up in the same chunk.`,reexporter:r})),t=h}}while(h)}var i,n,r,a}computeContentHashWithDependencies(e,t,s){const i=rr();i.update([e.intro,e.outro,e.banner,e.footer].map((e=>e||"")).join(":")),i.update(t.format);const n=new Set([this]);for(const r of n)if(r instanceof ae?i.update(":"+r.renderPath):(i.update(r.getRenderedHash()),i.update(r.generateId(e,t,s,!1))),!(r instanceof ae))for(const e of[...r.dependencies,...r.dynamicDependencies])n.add(e);return i.digest("hex").substr(0,8)}ensureReexportsAreAvailableForModule(e){const t=e.getExportNamesByVariable();for(const s of t.keys()){const t=s instanceof Ii,i=t?s.getBaseVariable():s;if(!(i instanceof Ci&&this.outputOptions.preserveModules)){this.checkCircularDependencyImport(i,e);const s=i.module;if(s instanceof qi){const e=this.chunkByModule.get(s);e&&e!==this&&(e.exports.add(i),t&&this.imports.add(i))}}}}finaliseDynamicImports(e,t){const s="amd"===e.format;for(const[e,i]of this.renderedModuleSources)for(const{node:n,resolution:r}of e.dynamicImports){const e=this.chunkByModule.get(r),a=this.facadeChunkByModule.get(r);if(!r||!n.included||e===this)continue;const o=r instanceof qi?`'${this.getRelativePath((a||e).id,s)}'`:r instanceof ae?`'${r.renormalizeRenderPath?this.getRelativePath(r.renderPath,s):r.renderPath}'`:r;n.renderFinalResolution(i,o,r instanceof qi&&!(null==a?void 0:a.strictFacade)&&e.exportNamesByVariable.get(r.namespace)[0],t)}}finaliseImportMetas(e,t){for(const[s,i]of this.renderedModuleSources)for(const n of s.importMetas)n.renderFinalMechanism(i,this.id,e,t,this.pluginDriver)}generateVariableName(){if(this.manualChunkAlias)return this.manualChunkAlias;const e=this.entryModules[0]||this.implicitEntryModules[0]||this.dynamicEntryModules[0]||this.orderedModules[this.orderedModules.length-1];return e?e.chunkName||ie(e.id):"chunk"}getChunkDependencyDeclarations(e,t){const s=this.getImportSpecifiers(t),i=this.getReexportSpecifiers(),n=new Map;for(const t of this.dependencies){const r=s.get(t)||null,a=i.get(t)||null,o=t instanceof ae||"default"!==t.exportMode;n.set(t,{defaultVariableName:t.defaultVariableName,globalName:t instanceof ae&&("umd"===e.format||"iife"===e.format)&&br(t,e.globals,null!==(r||a),this.inputOptions.onwarn),id:void 0,imports:r,isChunk:t instanceof Sr,name:t.variableName,namedExportsMode:o,namespaceVariableName:t.namespaceVariableName,reexports:a})}return n}getChunkExportDeclarations(e,t){const s=[];for(const i of this.getExportNames()){if("*"===i[0])continue;const n=this.exportsByName[i];if(!(n instanceof Ii)){const e=n.module;if(e&&this.chunkByModule.get(e)!==this)continue}let r=null,a=!1,o=n.getName(t);if(n instanceof rt){for(const e of n.declarations)if(e.parent instanceof Gt||e instanceof Ht&&e.declaration instanceof Gt){a=!0;break}}else n instanceof Ii&&(r=o,"es"===e&&(o=n.renderName));s.push({exported:i,expression:r,hoisted:a,local:o})}return s}getDependenciesToBeDeconflicted(e,t,s){const i=new Set,n=new Set,r=new Set;for(const t of[...this.exportNamesByVariable.keys(),...this.imports])if(e||t.isNamespace){const a=t.module;if(a instanceof ae)i.add(a),e&&("default"===t.name?Ns[String(s(a.id))]&&n.add(a):"*"===t.name&&$s[String(s(a.id))]&&r.add(a));else{const s=this.chunkByModule.get(a);s!==this&&(i.add(s),e&&"default"===s.exportMode&&t.isNamespace&&r.add(s))}}if(t)for(const e of this.dependencies)i.add(e);return{deconflictedDefault:n,deconflictedNamespace:r,dependencies:i}}getFallbackChunkName(){return this.manualChunkAlias?this.manualChunkAlias:this.dynamicName?this.dynamicName:this.fileName?ie(this.fileName):ie(this.orderedModules[this.orderedModules.length-1].id)}getImportSpecifiers(e){const{interop:t}=this.outputOptions,s=new Map;for(const i of this.imports){const n=i.module;let r,a;if(n instanceof ae){if(r=n,a=i.name,"default"!==a&&"*"!==a&&"defaultOnly"===t(n.id))return Ks(ni(n.id,a,!1))}else r=this.chunkByModule.get(n),a=r.getVariableExportName(i);T(s,r,(()=>[])).push({imported:a,local:i.getName(e)})}return s}getImportedBindingsPerDependency(){const e={};for(const[t,s]of this.renderedDependencies){const i=new Set;if(s.imports)for(const{imported:e}of s.imports)i.add(e);if(s.reexports)for(const{imported:e}of s.reexports)i.add(e);e[t.id]=[...i]}return e}getReexportSpecifiers(){const{externalLiveBindings:e,interop:t}=this.outputOptions,s=new Map;for(let i of this.getExportNames()){let n,r,a=!1;if("*"===i[0]){const s=i.substr(1);"defaultOnly"===t(s)&&this.inputOptions.onwarn(ri(s)),a=e,n=this.modulesById.get(s),r=i="*"}else{const s=this.exportsByName[i];if(s instanceof Ii)continue;const o=s.module;if(o instanceof qi){if(n=this.chunkByModule.get(o),n===this)continue;r=n.getVariableExportName(s),a=s.isReassigned}else{if(n=o,r=s.name,"default"!==r&&"*"!==r&&"defaultOnly"===t(o.id))return Ks(ni(o.id,r,!0));a=e&&("default"!==r||_s(String(t(o.id)),!0))}}T(s,n,(()=>[])).push({imported:r,needsLiveBinding:a,reexported:i})}return s}getReferencedFiles(){const e=[];for(const t of this.orderedModules)for(const s of t.importMetas){const t=s.getReferencedFileName(this.pluginDriver);t&&e.push(t)}return e}getRelativePath(e,t){let s=w(_(I(this.id),e));return t&&s.endsWith(".js")&&(s=s.slice(0,-3)),".."===s?"../../"+C(e):""===s?"../"+C(e):s.startsWith("../")?s:"./"+s}inlineChunkDependencies(e){for(const t of e.dependencies)this.dependencies.has(t)||(this.dependencies.add(t),t instanceof Sr&&this.inlineChunkDependencies(t))}prepareModulesForRendering(e){var t;const s=this.accessedGlobalsByScope;for(const i of this.orderedModules){for(const{node:n,resolution:r}of i.dynamicImports)if(n.included)if(r instanceof qi){const i=this.chunkByModule.get(r);i===this?n.setInternalResolution(r.namespace):n.setExternalResolution((null===(t=this.facadeChunkByModule.get(r))||void 0===t?void 0:t.exportMode)||i.exportMode,r,this.outputOptions,e,this.pluginDriver,s)}else n.setExternalResolution("external",r,this.outputOptions,e,this.pluginDriver,s);for(const e of i.importMetas)e.addAccessedGlobals(this.outputOptions.format,s);this.includedNamespaces.has(i)&&!this.outputOptions.preserveModules&&i.namespace.prepare(s)}}setExternalRenderPaths(e,t){for(const s of[...this.dependencies,...this.dynamicDependencies])s instanceof ae&&s.setRenderPath(e,t)}setIdentifierRenderResolutions({format:e,interop:t,namespaceToStringTag:s}){const i=new Set;for(const t of this.getExportNames()){const s=this.exportsByName[t];"es"!==e&&"system"!==e&&s.isReassigned&&!s.isId?s.setRenderNames("exports",t):s instanceof Ii?i.add(s):s.setRenderNames(null,null)}for(const e of this.orderedModules)if(e.needsExportShim){this.needsExportsShim=!0;break}const n=new Set(["Object","Promise"]);switch(this.needsExportsShim&&n.add("_missingExportShim"),s&&n.add("Symbol"),e){case"system":n.add("module").add("exports");break;case"es":break;case"cjs":n.add("module").add("require").add("__filename").add("__dirname");default:n.add("exports");for(const e of Us)n.add(e)}or(this.orderedModules,this.getDependenciesToBeDeconflicted("es"!==e&&"system"!==e,"amd"===e||"umd"===e||"iife"===e,t),this.imports,n,e,t,this.outputOptions.preserveModules,this.outputOptions.externalLiveBindings,this.chunkByModule,i,this.exportNamesByVariable,this.accessedGlobalsByScope,this.includedNamespaces)}setUpChunkImportsAndExportsForModule(e){const t=new Set(e.imports);if(!this.outputOptions.preserveModules&&this.includedNamespaces.has(e)){const s=e.namespace.getMemberVariables();for(const e of Object.values(s))t.add(e)}for(let s of t){s instanceof Si&&(s=s.getOriginalVariable()),s instanceof Ii&&(s=s.getBaseVariable());const t=this.chunkByModule.get(s.module);t!==this&&(this.imports.add(s),!(s instanceof Ci&&this.outputOptions.preserveModules)&&s.module instanceof qi&&(t.exports.add(s),this.checkCircularDependencyImport(s,e)))}(this.includedNamespaces.has(e)||e.info.isEntry&&!1!==e.preserveSignature||e.includedDynamicImporters.some((e=>this.chunkByModule.get(e)!==this)))&&this.ensureReexportsAreAvailableForModule(e);for(const{node:t,resolution:s}of e.dynamicImports)t.included&&s instanceof qi&&this.chunkByModule.get(s)===this&&!this.includedNamespaces.has(s)&&(this.includedNamespaces.add(s),this.ensureReexportsAreAvailableForModule(s))}}function Ar(e){return e.chunkName||ie(e.id)}var Pr;function kr(e,t,s){e in t&&s(function(e){return{code:Ys.FILE_NAME_CONFLICT,message:`The emitted file "${e}" overwrites a previously emitted file of the same name.`}}(e)),t[e]=wr}!function(e){e[e.LOAD_AND_PARSE=0]="LOAD_AND_PARSE",e[e.ANALYSE=1]="ANALYSE",e[e.GENERATE=2]="GENERATE"}(Pr||(Pr={}));const wr={type:"placeholder"};function Cr(e,t,s){if(!("string"==typeof e||e instanceof Uint8Array)){const e=t.fileName||t.name||s;return Ks(ai(`Could not set source for ${"string"==typeof e?`asset "${e}"`:"unnamed asset"}, asset source needs to be a string, Uint8Array or Buffer.`))}return e}function Ir(e,t){return"string"!=typeof e.fileName?Ks((s=e.name||t,{code:Ys.ASSET_NOT_FINALISED,message:`Plugin error - Unable to get file name for asset "${s}". Ensure that the source is set and that generate is called first.`})):e.fileName;var s}function Nr(e,t){var s;const i=e.fileName||e.module&&(null===(s=null==t?void 0:t.get(e.module))||void 0===s?void 0:s.id);return i||Ks((n=e.fileName||e.name,{code:Ys.CHUNK_NOT_GENERATED,message:`Plugin error - Unable to get file name for chunk "${n}". Ensure that generate is called first.`}));var n}class _r{constructor(e,t,s){this.graph=e,this.options=t,this.bundle=null,this.facadeChunkByModule=null,this.outputOptions=null,this.assertAssetsFinalized=()=>{for(const[t,s]of this.filesByReferenceId.entries())if("asset"===s.type&&"string"!=typeof s.fileName)return Ks((e=s.name||t,{code:Ys.ASSET_SOURCE_MISSING,message:`Plugin error creating asset "${e}" - no asset source set.`}));var e},this.emitFile=e=>function(e){return Boolean(e&&("asset"===e.type||"chunk"===e.type))}(e)?function(e){const t=e.fileName||e.name;return!t||"string"==typeof t&&!re(t)}(e)?"chunk"===e.type?this.emitChunk(e):this.emitAsset(e):Ks(ai(`The "fileName" or "name" properties of emitted files must be strings that are neither absolute nor relative paths, received "${e.fileName||e.name}".`)):Ks(ai(`Emitted files must be of type "asset" or "chunk", received "${e&&e.type}".`)),this.getFileName=e=>{const t=this.filesByReferenceId.get(e);return t?"chunk"===t.type?Nr(t,this.facadeChunkByModule):Ir(t,e):Ks((s=e,{code:Ys.FILE_NOT_FOUND,message:`Plugin error - Unable to get file name for unknown file "${s}".`}));var s},this.setAssetSource=(e,t)=>{const s=this.filesByReferenceId.get(e);if(!s)return Ks((i=e,{code:Ys.ASSET_NOT_FOUND,message:`Plugin error - Unable to set the source for unknown asset "${i}".`}));var i,n;if("asset"!==s.type)return Ks(ai(`Asset sources can only be set for emitted assets but "${e}" is an emitted chunk.`));if(void 0!==s.source)return Ks((n=s.name||e,{code:Ys.ASSET_SOURCE_ALREADY_SET,message:`Unable to set the source for asset "${n}", source already set.`}));const r=Cr(t,s,e);this.bundle?this.finalizeAsset(s,r,e,this.bundle):s.source=r},this.setOutputBundle=(e,t,s)=>{this.outputOptions=t,this.bundle=e,this.facadeChunkByModule=s;for(const e of this.filesByReferenceId.values())e.fileName&&kr(e.fileName,this.bundle,this.options.onwarn);for(const[e,t]of this.filesByReferenceId.entries())"asset"===t.type&&void 0!==t.source&&this.finalizeAsset(t,t.source,e,this.bundle)},this.filesByReferenceId=s?new Map(s.filesByReferenceId):new Map}assignReferenceId(e,t){let s;do{const e=rr();s?e.update(s):e.update(t),s=e.digest("hex").substr(0,8)}while(this.filesByReferenceId.has(s));return this.filesByReferenceId.set(s,e),s}emitAsset(e){const t=void 0!==e.source?Cr(e.source,e,null):void 0,s={fileName:e.fileName,name:e.name,source:t,type:"asset"},i=this.assignReferenceId(s,e.fileName||e.name||e.type);return this.bundle&&(e.fileName&&kr(e.fileName,this.bundle,this.options.onwarn),void 0!==t&&this.finalizeAsset(s,t,i,this.bundle)),i}emitChunk(e){if(this.graph.phase>Pr.LOAD_AND_PARSE)return Ks({code:Ys.INVALID_ROLLUP_PHASE,message:"Cannot emit chunks after module loading has finished."});if("string"!=typeof e.id)return Ks(ai(`Emitted chunks need to have a valid string id, received "${e.id}"`));const t={fileName:e.fileName,module:null,name:e.name||e.id,type:"chunk"};return this.graph.moduleLoader.emitChunk(e).then((e=>t.module=e)).catch((()=>{})),this.assignReferenceId(t,e.id)}finalizeAsset(e,t,s,i){const n=e.fileName||function(e,t){for(const[s,i]of Object.entries(e))if("asset"===i.type&&$r(t,i.source))return s;return null}(i,t)||function(e,t,s,i){const n=s.sanitizeFileName(e||"asset");return xr(Er("function"==typeof s.assetFileNames?s.assetFileNames({name:e,source:t,type:"asset"}):s.assetFileNames,"output.assetFileNames",{ext:()=>N(n).substr(1),extname:()=>N(n),hash(){const e=rr();return e.update(n),e.update(":"),e.update(t),e.digest("hex").substr(0,8)},name:()=>n.substr(0,n.length-N(n).length)}),i)}(e.name,t,this.outputOptions,i),r={...e,fileName:n,source:t};this.filesByReferenceId.set(s,r);const{options:a}=this;i[n]={fileName:n,get isAsset(){return hi('Accessing "isAsset" on files in the bundle is deprecated, please use "type === \'asset\'" instead',!0,a),!0},name:e.name,source:t,type:"asset"}}}function $r(e,t){if("string"==typeof e)return e===t;if("string"==typeof t)return!1;if("equals"in e)return e.equals(t);if(e.length!==t.length)return!1;for(let s=0;s<e.length;s++)if(e[s]!==t[s])return!1;return!0}const Tr=(e,t)=>t?`${e}\n${t}`:e,Rr=(e,t)=>t?`${e}\n\n${t}`:e;function Mr(e,t){const s=[],i=new Set(t.keys()),n=Object.create(null);for(const[e,s]of t){Dr(e,n[s]=n[s]||[],i)}for(const[e,t]of Object.entries(n))s.push({alias:e,modules:t});const r=new Map,{dependentEntryPointsByModule:a,dynamicEntryModules:o}=function(e){const t=new Set,s=new Map,i=new Set(e);for(const e of i){const n=new Set([e]);for(const r of n){T(s,r,(()=>new Set)).add(e);for(const e of r.getDependenciesToBeIncluded())e instanceof ae||n.add(e);for(const{resolution:e}of r.dynamicImports)e instanceof qi&&e.includedDynamicImporters.length>0&&(t.add(e),i.add(e));for(const e of r.implicitlyLoadedBefore)t.add(e),i.add(e)}}return{dependentEntryPointsByModule:s,dynamicEntryModules:t}}(e),h=function(e,t){const s=new Map;for(const i of t){const t=T(s,i,(()=>new Set));for(const s of[...i.includedDynamicImporters,...i.implicitlyLoadedAfter])for(const i of e.get(s))t.add(i)}return s}(a,o),l=new Set(e);function c(e,t){const s=new Set([e]);for(const n of s){const o=T(r,n,(()=>new Set));if(!t||!u(t,a.get(n))){o.add(e);for(const e of n.getDependenciesToBeIncluded())e instanceof ae||i.has(e)||s.add(e)}}}function u(e,t){const s=new Set(e);for(const e of s)if(!t.has(e)){if(l.has(e))return!1;const t=h.get(e);for(const e of t)s.add(e)}return!0}for(const t of e)i.has(t)||c(t,null);for(const e of o)i.has(e)||c(e,h.get(e));return s.push(...function(e,t){const s=Object.create(null);for(const[i,n]of t){let t="";for(const s of e)t+=n.has(s)?"X":"_";const r=s[t];r?r.push(i):s[t]=[i]}return Object.values(s).map((e=>({alias:null,modules:e})))}([...e,...o],r)),s}function Dr(e,t,s){const i=new Set([e]);for(const e of i){s.add(e),t.push(e);for(const t of e.dependencies)t instanceof ae||s.has(t)||i.add(t)}}const Lr=(e,t)=>e.execIndex>t.execIndex?1:-1;function Or(e,t,s){const i=Symbol(e.id),n=[ne(e.id)];let r=t;for(e.cycles.add(i);r!==e;)r.cycles.add(i),n.push(ne(r.id)),r=s.get(r);return n.push(n[0]),n.reverse(),n}const Vr=(e,t)=>t?`(${e})`:e,Br=/^(?!\d)[\w$]+$/;class Fr{constructor(e,t,s,i,n){this.outputOptions=e,this.unsetOptions=t,this.inputOptions=s,this.pluginDriver=i,this.graph=n,this.facadeChunkByModule=new Map,this.includedNamespaces=new Set}async generate(e){Bi("GENERATE",1);const t=Object.create(null);this.pluginDriver.setOutputBundle(t,this.outputOptions,this.facadeChunkByModule);try{await this.pluginDriver.hookParallel("renderStart",[this.outputOptions,this.inputOptions]),Bi("generate chunks",2);const e=await this.generateChunks();e.length>1&&function(e,t){if("umd"===e.format||"iife"===e.format)return Ks(Js("output.format","outputformat","UMD and IIFE output formats are not supported for code-splitting builds",e.format));if("string"==typeof e.file)return Ks(Js("output.file","outputdir",'when building multiple chunks, the "output.dir" option must be used, not "output.file". To inline dynamic imports, set the "inlineDynamicImports" option'));if(e.sourcemapFile)return Ks(Js("output.sourcemapFile","outputsourcemapfile",'"output.sourcemapFile" is only supported for single-file builds'));!e.amd.autoId&&e.amd.id&&t(Js("output.amd.id","outputamd",'this option is only properly supported for single-file builds. Use "output.amd.autoId" and "output.amd.basePath" instead'))}(this.outputOptions,this.inputOptions.onwarn);const s=function(e){if(0===e.length)return"/";if(1===e.length)return I(e[0]);const t=e.slice(1).reduce(((e,t)=>{const s=t.split(/\/+|\\+/);let i;for(i=0;e[i]===s[i]&&i<Math.min(e.length,s.length);i++);return e.slice(0,i)}),e[0].split(/\/+|\\+/));return t.length>1?t.join("/"):"/"}(function(e){const t=[];for(const s of e)for(const e of s.entryModules)P(e.id)&&t.push(e.id);return t}(e));Fi("generate chunks",2),Bi("render modules",2);const i=await async function(e,t){try{let[s,i,n,r]=await Promise.all([t.hookReduceValue("banner",e.banner(),[],Tr),t.hookReduceValue("footer",e.footer(),[],Tr),t.hookReduceValue("intro",e.intro(),[],Rr),t.hookReduceValue("outro",e.outro(),[],Rr)]);return n&&(n+="\n\n"),r&&(r=`\n\n${r}`),s.length&&(s+="\n"),i.length&&(i="\n"+i),{banner:s,footer:i,intro:n,outro:r}}catch(e){return Ks({code:"ADDON_ERROR",message:`Could not retrieve ${e.hook}. Check configuration of plugin ${e.plugin}.\n\tError Message: ${e.message}`})}}(this.outputOptions,this.pluginDriver),n=function({compact:e,generatedCode:{arrowFunctions:t,constBindings:s,objectShorthand:i,reservedNamesAsProps:n}}){const{_:r,n:a,s:o}=e?{_:"",n:"",s:""}:{_:" ",n:"\n",s:";"},h=s?"const":"var",l=(e,{isAsync:t,name:s})=>`${t?"async ":""}function${s?` ${s}`:""}${r}(${e.join(`,${r}`)})${r}`,c=t?(e,{isAsync:t,name:s})=>{const i=1===e.length;return`${s?`${h} ${s}${r}=${r}`:""}${t?`async${i?" ":r}`:""}${i?e[0]:`(${e.join(`,${r}`)})`}${r}=>${r}`}:l,u=(e,{functionReturn:s,lineBreakIndent:i,name:n})=>[`${c(e,{isAsync:!1,name:n})}${t?i?`${a}${i.base}${i.t}`:"":`{${i?`${a}${i.base}${i.t}`:r}${s?"return ":""}`}`,t?`${n?";":""}${i?`${a}${i.base}`:""}`:`${o}${i?`${a}${i.base}`:r}}`],d=n?e=>Br.test(e):e=>!ze[e]&&Br.test(e);return{_:r,cnst:h,getDirectReturnFunction:u,getDirectReturnIifeLeft:(e,s,{needsArrowReturnParens:i,needsWrappedFunction:n})=>{const[r,a]=u(e,{functionReturn:!0,lineBreakIndent:null,name:null});return`${Vr(`${r}${Vr(s,t&&i)}${a}`,t||n)}(`},getFunctionIntro:c,getNonArrowFunctionIntro:l,getObject(e,{lineBreakIndent:t}){const s=t?`${a}${t.base}${t.t}`:r;return`{${e.map((([e,t])=>{if(null===e)return`${s}${t}`;const n=!d(e);return e===t&&i&&!n?s+e:`${s}${n?`'${e}'`:e}:${r}${t}`})).join(",")}${0===e.length?"":t?`${a}${t.base}`:r}}`},getPropertyAccess:e=>d(e)?`.${e}`:`[${JSON.stringify(e)}]`,n:a,s:o}}(this.outputOptions);this.prerenderChunks(e,s,n),Fi("render modules",2),await this.addFinalizedChunksToBundle(e,s,i,t,n)}catch(e){throw await this.pluginDriver.hookParallel("renderError",[e]),e}return await this.pluginDriver.hookSeq("generateBundle",[this.outputOptions,t,e]),this.finaliseAssets(t),Fi("GENERATE",1),t}async addFinalizedChunksToBundle(e,t,s,i,n){this.assignChunkIds(e,t,s,i);for(const t of e)i[t.id]=t.getChunkInfoWithFileNames();await Promise.all(e.map((async e=>{const t=i[e.id];Object.assign(t,await e.render(this.outputOptions,s,t,n))})))}async addManualChunks(e){const t=new Map,s=await Promise.all(Object.entries(e).map((async([e,t])=>({alias:e,entries:await this.graph.moduleLoader.addAdditionalModules(t)}))));for(const{alias:e,entries:i}of s)for(const s of i)Wr(e,s,t);return t}assignChunkIds(e,t,s,i){const n=[],r=[];for(const t of e)(t.facadeModule&&t.facadeModule.isUserDefinedEntryPoint?n:r).push(t);const a=n.concat(r);for(const e of a)this.outputOptions.file?e.id=C(this.outputOptions.file):this.outputOptions.preserveModules?e.id=e.generateIdPreserveModules(t,this.outputOptions,i,this.unsetOptions):e.id=e.generateId(s,this.outputOptions,i,!0),i[e.id]=wr}assignManualChunks(e){const t=new Map,s={getModuleIds:()=>this.graph.modulesById.keys(),getModuleInfo:this.graph.getModuleInfo};for(const i of this.graph.modulesById.values())if(i instanceof qi){const n=e(i.id,s);"string"==typeof n&&Wr(n,i,t)}return t}finaliseAssets(e){for(const t of Object.values(e))if(t.type||(hi('A plugin is directly adding properties to the bundle object in the "generateBundle" hook. This is deprecated and will be removed in a future Rollup version, please use "this.emitFile" instead.',!0,this.inputOptions),t.type="asset"),this.outputOptions.validate&&"string"==typeof t.code)try{this.graph.contextParse(t.code,{allowHashBang:!0,ecmaVersion:"latest"})}catch(e){this.inputOptions.onwarn(Qs(t,e))}this.pluginDriver.finaliseAssets()}async generateChunks(){const{manualChunks:e}=this.outputOptions,t="object"==typeof e?await this.addManualChunks(e):this.assignManualChunks(e),s=[],i=new Map;for(const{alias:e,modules:n}of this.outputOptions.inlineDynamicImports?[{alias:null,modules:zr(this.graph.modulesById)}]:this.outputOptions.preserveModules?zr(this.graph.modulesById).map((e=>({alias:null,modules:[e]}))):Mr(this.graph.entryModules,t)){n.sort(Lr);const t=new Sr(n,this.inputOptions,this.outputOptions,this.unsetOptions,this.pluginDriver,this.graph.modulesById,i,this.facadeChunkByModule,this.includedNamespaces,e);s.push(t);for(const e of n)i.set(e,t)}for(const e of s)e.link();const n=[];for(const e of s)n.push(...e.generateFacades());return[...s,...n]}prerenderChunks(e,t,s){for(const t of e)t.generateExports();for(const i of e)i.preRender(this.outputOptions,t,s)}}function zr(e){return[...e.values()].filter((e=>e instanceof qi&&(e.isIncluded()||e.info.isEntry||e.includedDynamicImporters.length>0)))}function Wr(e,t,s){const i=s.get(t);if("string"==typeof i&&i!==e)return Ks((n=t.id,r=e,a=i,{code:Ys.INVALID_CHUNK,message:`Cannot assign ${ne(n)} to the "${r}" chunk as it is already in the "${a}" chunk.`}));var n,r,a;s.set(t,e)}var jr={3:"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",5:"class enum extends super const export import",6:"enum",strict:"implements interface let package private protected public static yield",strictBind:"eval arguments"},Ur="break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this",Gr={5:Ur,"5module":Ur+" export import",6:Ur+" const class extends export import super"},Hr=/^in(stanceof)?$/,qr="ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࢠ-ࢴࢶ-ࣇऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-鿼ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞿꟂ-ꟊꟵ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",Kr="‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࣓-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿᫀᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷹᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿",Xr=new RegExp("["+qr+"]"),Yr=new RegExp("["+qr+Kr+"]");qr=Kr=null;var Qr=[0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,349,41,7,1,79,28,11,0,9,21,107,20,28,22,13,52,76,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,190,0,80,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,43,8,8952,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42717,35,4148,12,221,3,5761,15,7472,3104,541,1507,4938],Zr=[509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,370,1,154,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,82,0,12,1,19628,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,4759,9,787719,239];function Jr(e,t){for(var s=65536,i=0;i<t.length;i+=2){if((s+=t[i])>e)return!1;if((s+=t[i+1])>=e)return!0}}function ea(e,t){return e<65?36===e:e<91||(e<97?95===e:e<123||(e<=65535?e>=170&&Xr.test(String.fromCharCode(e)):!1!==t&&Jr(e,Qr)))}function ta(e,t){return e<48?36===e:e<58||!(e<65)&&(e<91||(e<97?95===e:e<123||(e<=65535?e>=170&&Yr.test(String.fromCharCode(e)):!1!==t&&(Jr(e,Qr)||Jr(e,Zr)))))}var sa=function(e,t){void 0===t&&(t={}),this.label=e,this.keyword=t.keyword,this.beforeExpr=!!t.beforeExpr,this.startsExpr=!!t.startsExpr,this.isLoop=!!t.isLoop,this.isAssign=!!t.isAssign,this.prefix=!!t.prefix,this.postfix=!!t.postfix,this.binop=t.binop||null,this.updateContext=null};function ia(e,t){return new sa(e,{beforeExpr:!0,binop:t})}var na={beforeExpr:!0},ra={startsExpr:!0},aa={};function oa(e,t){return void 0===t&&(t={}),t.keyword=e,aa[e]=new sa(e,t)}var ha={num:new sa("num",ra),regexp:new sa("regexp",ra),string:new sa("string",ra),name:new sa("name",ra),privateId:new sa("privateId",ra),eof:new sa("eof"),bracketL:new sa("[",{beforeExpr:!0,startsExpr:!0}),bracketR:new sa("]"),braceL:new sa("{",{beforeExpr:!0,startsExpr:!0}),braceR:new sa("}"),parenL:new sa("(",{beforeExpr:!0,startsExpr:!0}),parenR:new sa(")"),comma:new sa(",",na),semi:new sa(";",na),colon:new sa(":",na),dot:new sa("."),question:new sa("?",na),questionDot:new sa("?."),arrow:new sa("=>",na),template:new sa("template"),invalidTemplate:new sa("invalidTemplate"),ellipsis:new sa("...",na),backQuote:new sa("`",ra),dollarBraceL:new sa("${",{beforeExpr:!0,startsExpr:!0}),eq:new sa("=",{beforeExpr:!0,isAssign:!0}),assign:new sa("_=",{beforeExpr:!0,isAssign:!0}),incDec:new sa("++/--",{prefix:!0,postfix:!0,startsExpr:!0}),prefix:new sa("!/~",{beforeExpr:!0,prefix:!0,startsExpr:!0}),logicalOR:ia("||",1),logicalAND:ia("&&",2),bitwiseOR:ia("|",3),bitwiseXOR:ia("^",4),bitwiseAND:ia("&",5),equality:ia("==/!=/===/!==",6),relational:ia("</>/<=/>=",7),bitShift:ia("<</>>/>>>",8),plusMin:new sa("+/-",{beforeExpr:!0,binop:9,prefix:!0,startsExpr:!0}),modulo:ia("%",10),star:ia("*",10),slash:ia("/",10),starstar:new sa("**",{beforeExpr:!0}),coalesce:ia("??",1),_break:oa("break"),_case:oa("case",na),_catch:oa("catch"),_continue:oa("continue"),_debugger:oa("debugger"),_default:oa("default",na),_do:oa("do",{isLoop:!0,beforeExpr:!0}),_else:oa("else",na),_finally:oa("finally"),_for:oa("for",{isLoop:!0}),_function:oa("function",ra),_if:oa("if"),_return:oa("return",na),_switch:oa("switch"),_throw:oa("throw",na),_try:oa("try"),_var:oa("var"),_const:oa("const"),_while:oa("while",{isLoop:!0}),_with:oa("with"),_new:oa("new",{beforeExpr:!0,startsExpr:!0}),_this:oa("this",ra),_super:oa("super",ra),_class:oa("class",ra),_extends:oa("extends",na),_export:oa("export"),_import:oa("import",ra),_null:oa("null",ra),_true:oa("true",ra),_false:oa("false",ra),_in:oa("in",{beforeExpr:!0,binop:7}),_instanceof:oa("instanceof",{beforeExpr:!0,binop:7}),_typeof:oa("typeof",{beforeExpr:!0,prefix:!0,startsExpr:!0}),_void:oa("void",{beforeExpr:!0,prefix:!0,startsExpr:!0}),_delete:oa("delete",{beforeExpr:!0,prefix:!0,startsExpr:!0})},la=/\r\n?|\n|\u2028|\u2029/,ca=new RegExp(la.source,"g");function ua(e){return 10===e||13===e||8232===e||8233===e}var da=/[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/,pa=/(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,fa=Object.prototype,ma=fa.hasOwnProperty,ga=fa.toString;function ya(e,t){return ma.call(e,t)}var Ea=Array.isArray||function(e){return"[object Array]"===ga.call(e)};function xa(e){return new RegExp("^(?:"+e.replace(/ /g,"|")+")$")}var va=function(e,t){this.line=e,this.column=t};va.prototype.offset=function(e){return new va(this.line,this.column+e)};var ba=function(e,t,s){this.start=t,this.end=s,null!==e.sourceFile&&(this.source=e.sourceFile)};function Sa(e,t){for(var s=1,i=0;;){ca.lastIndex=i;var n=ca.exec(e);if(!(n&&n.index<t))return new va(s,t-i);++s,i=n.index+n[0].length}}var Aa={ecmaVersion:null,sourceType:"script",onInsertedSemicolon:null,onTrailingComma:null,allowReserved:null,allowReturnOutsideFunction:!1,allowImportExportEverywhere:!1,allowAwaitOutsideFunction:null,allowSuperOutsideMethod:null,allowHashBang:!1,locations:!1,onToken:null,onComment:null,ranges:!1,program:null,sourceFile:null,directSourceFile:null,preserveParens:!1},Pa=!1;function ka(e){var t={};for(var s in Aa)t[s]=e&&ya(e,s)?e[s]:Aa[s];if("latest"===t.ecmaVersion?t.ecmaVersion=1e8:null==t.ecmaVersion?(!Pa&&"object"==typeof console&&console.warn&&(Pa=!0,console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.")),t.ecmaVersion=11):t.ecmaVersion>=2015&&(t.ecmaVersion-=2009),null==t.allowReserved&&(t.allowReserved=t.ecmaVersion<5),Ea(t.onToken)){var i=t.onToken;t.onToken=function(e){return i.push(e)}}return Ea(t.onComment)&&(t.onComment=function(e,t){return function(s,i,n,r,a,o){var h={type:s?"Block":"Line",value:i,start:n,end:r};e.locations&&(h.loc=new ba(this,a,o)),e.ranges&&(h.range=[n,r]),t.push(h)}}(t,t.onComment)),t}function wa(e,t){return 2|(e?4:0)|(t?8:0)}var Ca=function(e,t,s){this.options=e=ka(e),this.sourceFile=e.sourceFile,this.keywords=xa(Gr[e.ecmaVersion>=6?6:"module"===e.sourceType?"5module":5]);var i="";!0!==e.allowReserved&&(i=jr[e.ecmaVersion>=6?6:5===e.ecmaVersion?5:3],"module"===e.sourceType&&(i+=" await")),this.reservedWords=xa(i);var n=(i?i+" ":"")+jr.strict;this.reservedWordsStrict=xa(n),this.reservedWordsStrictBind=xa(n+" "+jr.strictBind),this.input=String(t),this.containsEsc=!1,s?(this.pos=s,this.lineStart=this.input.lastIndexOf("\n",s-1)+1,this.curLine=this.input.slice(0,this.lineStart).split(la).length):(this.pos=this.lineStart=0,this.curLine=1),this.type=ha.eof,this.value=null,this.start=this.end=this.pos,this.startLoc=this.endLoc=this.curPosition(),this.lastTokEndLoc=this.lastTokStartLoc=null,this.lastTokStart=this.lastTokEnd=this.pos,this.context=this.initialContext(),this.exprAllowed=!0,this.inModule="module"===e.sourceType,this.strict=this.inModule||this.strictDirective(this.pos),this.potentialArrowAt=-1,this.potentialArrowInForAwait=!1,this.yieldPos=this.awaitPos=this.awaitIdentPos=0,this.labels=[],this.undefinedExports=Object.create(null),0===this.pos&&e.allowHashBang&&"#!"===this.input.slice(0,2)&&this.skipLineComment(2),this.scopeStack=[],this.enterScope(1),this.regexpState=null,this.privateNameStack=[]},Ia={inFunction:{configurable:!0},inGenerator:{configurable:!0},inAsync:{configurable:!0},canAwait:{configurable:!0},allowSuper:{configurable:!0},allowDirectSuper:{configurable:!0},treatFunctionsAsVar:{configurable:!0},allowNewDotTarget:{configurable:!0},inClassStaticBlock:{configurable:!0}};Ca.prototype.parse=function(){var e=this.options.program||this.startNode();return this.nextToken(),this.parseTopLevel(e)},Ia.inFunction.get=function(){return(2&this.currentVarScope().flags)>0},Ia.inGenerator.get=function(){return(8&this.currentVarScope().flags)>0&&!this.currentVarScope().inClassFieldInit},Ia.inAsync.get=function(){return(4&this.currentVarScope().flags)>0&&!this.currentVarScope().inClassFieldInit},Ia.canAwait.get=function(){for(var e=this.scopeStack.length-1;e>=0;e--){var t=this.scopeStack[e];if(t.inClassFieldInit||256&t.flags)return!1;if(2&t.flags)return(4&t.flags)>0}return this.inModule&&this.options.ecmaVersion>=13||this.options.allowAwaitOutsideFunction},Ia.allowSuper.get=function(){var e=this.currentThisScope(),t=e.flags,s=e.inClassFieldInit;return(64&t)>0||s||this.options.allowSuperOutsideMethod},Ia.allowDirectSuper.get=function(){return(128&this.currentThisScope().flags)>0},Ia.treatFunctionsAsVar.get=function(){return this.treatFunctionsAsVarInScope(this.currentScope())},Ia.allowNewDotTarget.get=function(){var e=this.currentThisScope(),t=e.flags,s=e.inClassFieldInit;return(258&t)>0||s},Ia.inClassStaticBlock.get=function(){return(256&this.currentVarScope().flags)>0},Ca.extend=function(){for(var e=[],t=arguments.length;t--;)e[t]=arguments[t];for(var s=this,i=0;i<e.length;i++)s=e[i](s);return s},Ca.parse=function(e,t){return new this(t,e).parse()},Ca.parseExpressionAt=function(e,t,s){var i=new this(s,e,t);return i.nextToken(),i.parseExpression()},Ca.tokenizer=function(e,t){return new this(t,e)},Object.defineProperties(Ca.prototype,Ia);var Na=Ca.prototype,_a=/^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;function $a(){this.shorthandAssign=this.trailingComma=this.parenthesizedAssign=this.parenthesizedBind=this.doubleProto=-1}Na.strictDirective=function(e){for(;;){pa.lastIndex=e,e+=pa.exec(this.input)[0].length;var t=_a.exec(this.input.slice(e));if(!t)return!1;if("use strict"===(t[1]||t[2])){pa.lastIndex=e+t[0].length;var s=pa.exec(this.input),i=s.index+s[0].length,n=this.input.charAt(i);return";"===n||"}"===n||la.test(s[0])&&!(/[(`.[+\-/*%<>=,?^&]/.test(n)||"!"===n&&"="===this.input.charAt(i+1))}e+=t[0].length,pa.lastIndex=e,e+=pa.exec(this.input)[0].length,";"===this.input[e]&&e++}},Na.eat=function(e){return this.type===e&&(this.next(),!0)},Na.isContextual=function(e){return this.type===ha.name&&this.value===e&&!this.containsEsc},Na.eatContextual=function(e){return!!this.isContextual(e)&&(this.next(),!0)},Na.expectContextual=function(e){this.eatContextual(e)||this.unexpected()},Na.canInsertSemicolon=function(){return this.type===ha.eof||this.type===ha.braceR||la.test(this.input.slice(this.lastTokEnd,this.start))},Na.insertSemicolon=function(){if(this.canInsertSemicolon())return this.options.onInsertedSemicolon&&this.options.onInsertedSemicolon(this.lastTokEnd,this.lastTokEndLoc),!0},Na.semicolon=function(){this.eat(ha.semi)||this.insertSemicolon()||this.unexpected()},Na.afterTrailingComma=function(e,t){if(this.type===e)return this.options.onTrailingComma&&this.options.onTrailingComma(this.lastTokStart,this.lastTokStartLoc),t||this.next(),!0},Na.expect=function(e){this.eat(e)||this.unexpected()},Na.unexpected=function(e){this.raise(null!=e?e:this.start,"Unexpected token")},Na.checkPatternErrors=function(e,t){if(e){e.trailingComma>-1&&this.raiseRecoverable(e.trailingComma,"Comma is not permitted after the rest element");var s=t?e.parenthesizedAssign:e.parenthesizedBind;s>-1&&this.raiseRecoverable(s,"Parenthesized pattern")}},Na.checkExpressionErrors=function(e,t){if(!e)return!1;var s=e.shorthandAssign,i=e.doubleProto;if(!t)return s>=0||i>=0;s>=0&&this.raise(s,"Shorthand property assignments are valid only in destructuring patterns"),i>=0&&this.raiseRecoverable(i,"Redefinition of __proto__ property")},Na.checkYieldAwaitInDefaultParams=function(){this.yieldPos&&(!this.awaitPos||this.yieldPos<this.awaitPos)&&this.raise(this.yieldPos,"Yield expression cannot be a default value"),this.awaitPos&&this.raise(this.awaitPos,"Await expression cannot be a default value")},Na.isSimpleAssignTarget=function(e){return"ParenthesizedExpression"===e.type?this.isSimpleAssignTarget(e.expression):"Identifier"===e.type||"MemberExpression"===e.type};var Ta=Ca.prototype;Ta.parseTopLevel=function(e){var t=Object.create(null);for(e.body||(e.body=[]);this.type!==ha.eof;){var s=this.parseStatement(null,!0,t);e.body.push(s)}if(this.inModule)for(var i=0,n=Object.keys(this.undefinedExports);i<n.length;i+=1){var r=n[i];this.raiseRecoverable(this.undefinedExports[r].start,"Export '"+r+"' is not defined")}return this.adaptDirectivePrologue(e.body),this.next(),e.sourceType=this.options.sourceType,this.finishNode(e,"Program")};var Ra={kind:"loop"},Ma={kind:"switch"};Ta.isLet=function(e){if(this.options.ecmaVersion<6||!this.isContextual("let"))return!1;pa.lastIndex=this.pos;var t=pa.exec(this.input),s=this.pos+t[0].length,i=this.input.charCodeAt(s);if(91===i||92===i||i>55295&&i<56320)return!0;if(e)return!1;if(123===i)return!0;if(ea(i,!0)){for(var n=s+1;ta(i=this.input.charCodeAt(n),!0);)++n;if(92===i||i>55295&&i<56320)return!0;var r=this.input.slice(s,n);if(!Hr.test(r))return!0}return!1},Ta.isAsyncFunction=function(){if(this.options.ecmaVersion<8||!this.isContextual("async"))return!1;pa.lastIndex=this.pos;var e,t=pa.exec(this.input),s=this.pos+t[0].length;return!(la.test(this.input.slice(this.pos,s))||"function"!==this.input.slice(s,s+8)||s+8!==this.input.length&&(ta(e=this.input.charCodeAt(s+8))||e>55295&&e<56320))},Ta.parseStatement=function(e,t,s){var i,n=this.type,r=this.startNode();switch(this.isLet(e)&&(n=ha._var,i="let"),n){case ha._break:case ha._continue:return this.parseBreakContinueStatement(r,n.keyword);case ha._debugger:return this.parseDebuggerStatement(r);case ha._do:return this.parseDoStatement(r);case ha._for:return this.parseForStatement(r);case ha._function:return e&&(this.strict||"if"!==e&&"label"!==e)&&this.options.ecmaVersion>=6&&this.unexpected(),this.parseFunctionStatement(r,!1,!e);case ha._class:return e&&this.unexpected(),this.parseClass(r,!0);case ha._if:return this.parseIfStatement(r);case ha._return:return this.parseReturnStatement(r);case ha._switch:return this.parseSwitchStatement(r);case ha._throw:return this.parseThrowStatement(r);case ha._try:return this.parseTryStatement(r);case ha._const:case ha._var:return i=i||this.value,e&&"var"!==i&&this.unexpected(),this.parseVarStatement(r,i);case ha._while:return this.parseWhileStatement(r);case ha._with:return this.parseWithStatement(r);case ha.braceL:return this.parseBlock(!0,r);case ha.semi:return this.parseEmptyStatement(r);case ha._export:case ha._import:if(this.options.ecmaVersion>10&&n===ha._import){pa.lastIndex=this.pos;var a=pa.exec(this.input),o=this.pos+a[0].length,h=this.input.charCodeAt(o);if(40===h||46===h)return this.parseExpressionStatement(r,this.parseExpression())}return this.options.allowImportExportEverywhere||(t||this.raise(this.start,"'import' and 'export' may only appear at the top level"),this.inModule||this.raise(this.start,"'import' and 'export' may appear only with 'sourceType: module'")),n===ha._import?this.parseImport(r):this.parseExport(r,s);default:if(this.isAsyncFunction())return e&&this.unexpected(),this.next(),this.parseFunctionStatement(r,!0,!e);var l=this.value,c=this.parseExpression();return n===ha.name&&"Identifier"===c.type&&this.eat(ha.colon)?this.parseLabeledStatement(r,l,c,e):this.parseExpressionStatement(r,c)}},Ta.parseBreakContinueStatement=function(e,t){var s="break"===t;this.next(),this.eat(ha.semi)||this.insertSemicolon()?e.label=null:this.type!==ha.name?this.unexpected():(e.label=this.parseIdent(),this.semicolon());for(var i=0;i<this.labels.length;++i){var n=this.labels[i];if(null==e.label||n.name===e.label.name){if(null!=n.kind&&(s||"loop"===n.kind))break;if(e.label&&s)break}}return i===this.labels.length&&this.raise(e.start,"Unsyntactic "+t),this.finishNode(e,s?"BreakStatement":"ContinueStatement")},Ta.parseDebuggerStatement=function(e){return this.next(),this.semicolon(),this.finishNode(e,"DebuggerStatement")},Ta.parseDoStatement=function(e){return this.next(),this.labels.push(Ra),e.body=this.parseStatement("do"),this.labels.pop(),this.expect(ha._while),e.test=this.parseParenExpression(),this.options.ecmaVersion>=6?this.eat(ha.semi):this.semicolon(),this.finishNode(e,"DoWhileStatement")},Ta.parseForStatement=function(e){this.next();var t=this.options.ecmaVersion>=9&&this.canAwait&&this.eatContextual("await")?this.lastTokStart:-1;if(this.labels.push(Ra),this.enterScope(0),this.expect(ha.parenL),this.type===ha.semi)return t>-1&&this.unexpected(t),this.parseFor(e,null);var s=this.isLet();if(this.type===ha._var||this.type===ha._const||s){var i=this.startNode(),n=s?"let":this.value;return this.next(),this.parseVar(i,!0,n),this.finishNode(i,"VariableDeclaration"),(this.type===ha._in||this.options.ecmaVersion>=6&&this.isContextual("of"))&&1===i.declarations.length?(this.options.ecmaVersion>=9&&(this.type===ha._in?t>-1&&this.unexpected(t):e.await=t>-1),this.parseForIn(e,i)):(t>-1&&this.unexpected(t),this.parseFor(e,i))}var r=this.isContextual("let"),a=!1,o=new $a,h=this.parseExpression(!(t>-1)||"await",o);return this.type===ha._in||(a=this.options.ecmaVersion>=6&&this.isContextual("of"))?(this.options.ecmaVersion>=9&&(this.type===ha._in?t>-1&&this.unexpected(t):e.await=t>-1),r&&a&&this.raise(h.start,"The left-hand side of a for-of loop may not start with 'let'."),this.toAssignable(h,!1,o),this.checkLValPattern(h),this.parseForIn(e,h)):(this.checkExpressionErrors(o,!0),t>-1&&this.unexpected(t),this.parseFor(e,h))},Ta.parseFunctionStatement=function(e,t,s){return this.next(),this.parseFunction(e,La|(s?0:Oa),!1,t)},Ta.parseIfStatement=function(e){return this.next(),e.test=this.parseParenExpression(),e.consequent=this.parseStatement("if"),e.alternate=this.eat(ha._else)?this.parseStatement("if"):null,this.finishNode(e,"IfStatement")},Ta.parseReturnStatement=function(e){return this.inFunction||this.options.allowReturnOutsideFunction||this.raise(this.start,"'return' outside of function"),this.next(),this.eat(ha.semi)||this.insertSemicolon()?e.argument=null:(e.argument=this.parseExpression(),this.semicolon()),this.finishNode(e,"ReturnStatement")},Ta.parseSwitchStatement=function(e){var t;this.next(),e.discriminant=this.parseParenExpression(),e.cases=[],this.expect(ha.braceL),this.labels.push(Ma),this.enterScope(0);for(var s=!1;this.type!==ha.braceR;)if(this.type===ha._case||this.type===ha._default){var i=this.type===ha._case;t&&this.finishNode(t,"SwitchCase"),e.cases.push(t=this.startNode()),t.consequent=[],this.next(),i?t.test=this.parseExpression():(s&&this.raiseRecoverable(this.lastTokStart,"Multiple default clauses"),s=!0,t.test=null),this.expect(ha.colon)}else t||this.unexpected(),t.consequent.push(this.parseStatement(null));return this.exitScope(),t&&this.finishNode(t,"SwitchCase"),this.next(),this.labels.pop(),this.finishNode(e,"SwitchStatement")},Ta.parseThrowStatement=function(e){return this.next(),la.test(this.input.slice(this.lastTokEnd,this.start))&&this.raise(this.lastTokEnd,"Illegal newline after throw"),e.argument=this.parseExpression(),this.semicolon(),this.finishNode(e,"ThrowStatement")};var Da=[];Ta.parseTryStatement=function(e){if(this.next(),e.block=this.parseBlock(),e.handler=null,this.type===ha._catch){var t=this.startNode();if(this.next(),this.eat(ha.parenL)){t.param=this.parseBindingAtom();var s="Identifier"===t.param.type;this.enterScope(s?32:0),this.checkLValPattern(t.param,s?4:2),this.expect(ha.parenR)}else this.options.ecmaVersion<10&&this.unexpected(),t.param=null,this.enterScope(0);t.body=this.parseBlock(!1),this.exitScope(),e.handler=this.finishNode(t,"CatchClause")}return e.finalizer=this.eat(ha._finally)?this.parseBlock():null,e.handler||e.finalizer||this.raise(e.start,"Missing catch or finally clause"),this.finishNode(e,"TryStatement")},Ta.parseVarStatement=function(e,t){return this.next(),this.parseVar(e,!1,t),this.semicolon(),this.finishNode(e,"VariableDeclaration")},Ta.parseWhileStatement=function(e){return this.next(),e.test=this.parseParenExpression(),this.labels.push(Ra),e.body=this.parseStatement("while"),this.labels.pop(),this.finishNode(e,"WhileStatement")},Ta.parseWithStatement=function(e){return this.strict&&this.raise(this.start,"'with' in strict mode"),this.next(),e.object=this.parseParenExpression(),e.body=this.parseStatement("with"),this.finishNode(e,"WithStatement")},Ta.parseEmptyStatement=function(e){return this.next(),this.finishNode(e,"EmptyStatement")},Ta.parseLabeledStatement=function(e,t,s,i){for(var n=0,r=this.labels;n<r.length;n+=1){r[n].name===t&&this.raise(s.start,"Label '"+t+"' is already declared")}for(var a=this.type.isLoop?"loop":this.type===ha._switch?"switch":null,o=this.labels.length-1;o>=0;o--){var h=this.labels[o];if(h.statementStart!==e.start)break;h.statementStart=this.start,h.kind=a}return this.labels.push({name:t,kind:a,statementStart:this.start}),e.body=this.parseStatement(i?-1===i.indexOf("label")?i+"label":i:"label"),this.labels.pop(),e.label=s,this.finishNode(e,"LabeledStatement")},Ta.parseExpressionStatement=function(e,t){return e.expression=t,this.semicolon(),this.finishNode(e,"ExpressionStatement")},Ta.parseBlock=function(e,t,s){for(void 0===e&&(e=!0),void 0===t&&(t=this.startNode()),t.body=[],this.expect(ha.braceL),e&&this.enterScope(0);this.type!==ha.braceR;){var i=this.parseStatement(null);t.body.push(i)}return s&&(this.strict=!1),this.next(),e&&this.exitScope(),this.finishNode(t,"BlockStatement")},Ta.parseFor=function(e,t){return e.init=t,this.expect(ha.semi),e.test=this.type===ha.semi?null:this.parseExpression(),this.expect(ha.semi),e.update=this.type===ha.parenR?null:this.parseExpression(),this.expect(ha.parenR),e.body=this.parseStatement("for"),this.exitScope(),this.labels.pop(),this.finishNode(e,"ForStatement")},Ta.parseForIn=function(e,t){var s=this.type===ha._in;return this.next(),"VariableDeclaration"===t.type&&null!=t.declarations[0].init&&(!s||this.options.ecmaVersion<8||this.strict||"var"!==t.kind||"Identifier"!==t.declarations[0].id.type)&&this.raise(t.start,(s?"for-in":"for-of")+" loop variable declaration may not have an initializer"),e.left=t,e.right=s?this.parseExpression():this.parseMaybeAssign(),this.expect(ha.parenR),e.body=this.parseStatement("for"),this.exitScope(),this.labels.pop(),this.finishNode(e,s?"ForInStatement":"ForOfStatement")},Ta.parseVar=function(e,t,s){for(e.declarations=[],e.kind=s;;){var i=this.startNode();if(this.parseVarId(i,s),this.eat(ha.eq)?i.init=this.parseMaybeAssign(t):"const"!==s||this.type===ha._in||this.options.ecmaVersion>=6&&this.isContextual("of")?"Identifier"===i.id.type||t&&(this.type===ha._in||this.isContextual("of"))?i.init=null:this.raise(this.lastTokEnd,"Complex binding patterns require an initialization value"):this.unexpected(),e.declarations.push(this.finishNode(i,"VariableDeclarator")),!this.eat(ha.comma))break}return e},Ta.parseVarId=function(e,t){e.id=this.parseBindingAtom(),this.checkLValPattern(e.id,"var"===t?1:2,!1)};var La=1,Oa=2;function Va(e,t){var s=t.key.name,i=e[s],n="true";return"MethodDefinition"!==t.type||"get"!==t.kind&&"set"!==t.kind||(n=(t.static?"s":"i")+t.kind),"iget"===i&&"iset"===n||"iset"===i&&"iget"===n||"sget"===i&&"sset"===n||"sset"===i&&"sget"===n?(e[s]="true",!1):!!i||(e[s]=n,!1)}function Ba(e,t){var s=e.computed,i=e.key;return!s&&("Identifier"===i.type&&i.name===t||"Literal"===i.type&&i.value===t)}Ta.parseFunction=function(e,t,s,i,n){this.initFunction(e),(this.options.ecmaVersion>=9||this.options.ecmaVersion>=6&&!i)&&(this.type===ha.star&&t&Oa&&this.unexpected(),e.generator=this.eat(ha.star)),this.options.ecmaVersion>=8&&(e.async=!!i),t&La&&(e.id=4&t&&this.type!==ha.name?null:this.parseIdent(),!e.id||t&Oa||this.checkLValSimple(e.id,this.strict||e.generator||e.async?this.treatFunctionsAsVar?1:2:3));var r=this.yieldPos,a=this.awaitPos,o=this.awaitIdentPos;return this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0,this.enterScope(wa(e.async,e.generator)),t&La||(e.id=this.type===ha.name?this.parseIdent():null),this.parseFunctionParams(e),this.parseFunctionBody(e,s,!1,n),this.yieldPos=r,this.awaitPos=a,this.awaitIdentPos=o,this.finishNode(e,t&La?"FunctionDeclaration":"FunctionExpression")},Ta.parseFunctionParams=function(e){this.expect(ha.parenL),e.params=this.parseBindingList(ha.parenR,!1,this.options.ecmaVersion>=8),this.checkYieldAwaitInDefaultParams()},Ta.parseClass=function(e,t){this.next();var s=this.strict;this.strict=!0,this.parseClassId(e,t),this.parseClassSuper(e);var i=this.enterClassBody(),n=this.startNode(),r=!1;for(n.body=[],this.expect(ha.braceL);this.type!==ha.braceR;){var a=this.parseClassElement(null!==e.superClass);a&&(n.body.push(a),"MethodDefinition"===a.type&&"constructor"===a.kind?(r&&this.raise(a.start,"Duplicate constructor in the same class"),r=!0):a.key&&"PrivateIdentifier"===a.key.type&&Va(i,a)&&this.raiseRecoverable(a.key.start,"Identifier '#"+a.key.name+"' has already been declared"))}return this.strict=s,this.next(),e.body=this.finishNode(n,"ClassBody"),this.exitClassBody(),this.finishNode(e,t?"ClassDeclaration":"ClassExpression")},Ta.parseClassElement=function(e){if(this.eat(ha.semi))return null;var t=this.options.ecmaVersion,s=this.startNode(),i="",n=!1,r=!1,a="method",o=!1;if(this.eatContextual("static")){if(t>=13&&this.eat(ha.braceL))return this.parseClassStaticBlock(s),s;this.isClassElementNameStart()||this.type===ha.star?o=!0:i="static"}if(s.static=o,!i&&t>=8&&this.eatContextual("async")&&(!this.isClassElementNameStart()&&this.type!==ha.star||this.canInsertSemicolon()?i="async":r=!0),!i&&(t>=9||!r)&&this.eat(ha.star)&&(n=!0),!i&&!r&&!n){var h=this.value;(this.eatContextual("get")||this.eatContextual("set"))&&(this.isClassElementNameStart()?a=h:i=h)}if(i?(s.computed=!1,s.key=this.startNodeAt(this.lastTokStart,this.lastTokStartLoc),s.key.name=i,this.finishNode(s.key,"Identifier")):this.parseClassElementName(s),t<13||this.type===ha.parenL||"method"!==a||n||r){var l=!s.static&&Ba(s,"constructor"),c=l&&e;l&&"method"!==a&&this.raise(s.key.start,"Constructor can't have get/set modifier"),s.kind=l?"constructor":a,this.parseClassMethod(s,n,r,c)}else this.parseClassField(s);return s},Ta.isClassElementNameStart=function(){return this.type===ha.name||this.type===ha.privateId||this.type===ha.num||this.type===ha.string||this.type===ha.bracketL||this.type.keyword},Ta.parseClassElementName=function(e){this.type===ha.privateId?("constructor"===this.value&&this.raise(this.start,"Classes can't have an element named '#constructor'"),e.computed=!1,e.key=this.parsePrivateIdent()):this.parsePropertyName(e)},Ta.parseClassMethod=function(e,t,s,i){var n=e.key;"constructor"===e.kind?(t&&this.raise(n.start,"Constructor can't be a generator"),s&&this.raise(n.start,"Constructor can't be an async method")):e.static&&Ba(e,"prototype")&&this.raise(n.start,"Classes may not have a static property named prototype");var r=e.value=this.parseMethod(t,s,i);return"get"===e.kind&&0!==r.params.length&&this.raiseRecoverable(r.start,"getter should have no params"),"set"===e.kind&&1!==r.params.length&&this.raiseRecoverable(r.start,"setter should have exactly one param"),"set"===e.kind&&"RestElement"===r.params[0].type&&this.raiseRecoverable(r.params[0].start,"Setter cannot use rest params"),this.finishNode(e,"MethodDefinition")},Ta.parseClassField=function(e){if(Ba(e,"constructor")?this.raise(e.key.start,"Classes can't have a field named 'constructor'"):e.static&&Ba(e,"prototype")&&this.raise(e.key.start,"Classes can't have a static field named 'prototype'"),this.eat(ha.eq)){var t=this.currentThisScope(),s=t.inClassFieldInit;t.inClassFieldInit=!0,e.value=this.parseMaybeAssign(),t.inClassFieldInit=s}else e.value=null;return this.semicolon(),this.finishNode(e,"PropertyDefinition")},Ta.parseClassStaticBlock=function(e){e.body=[];var t=this.labels;for(this.labels=[],this.enterScope(320);this.type!==ha.braceR;){var s=this.parseStatement(null);e.body.push(s)}return this.next(),this.exitScope(),this.labels=t,this.finishNode(e,"StaticBlock")},Ta.parseClassId=function(e,t){this.type===ha.name?(e.id=this.parseIdent(),t&&this.checkLValSimple(e.id,2,!1)):(!0===t&&this.unexpected(),e.id=null)},Ta.parseClassSuper=function(e){e.superClass=this.eat(ha._extends)?this.parseExprSubscripts(!1):null},Ta.enterClassBody=function(){var e={declared:Object.create(null),used:[]};return this.privateNameStack.push(e),e.declared},Ta.exitClassBody=function(){for(var e=this.privateNameStack.pop(),t=e.declared,s=e.used,i=this.privateNameStack.length,n=0===i?null:this.privateNameStack[i-1],r=0;r<s.length;++r){var a=s[r];ya(t,a.name)||(n?n.used.push(a):this.raiseRecoverable(a.start,"Private field '#"+a.name+"' must be declared in an enclosing class"))}},Ta.parseExport=function(e,t){if(this.next(),this.eat(ha.star))return this.options.ecmaVersion>=11&&(this.eatContextual("as")?(e.exported=this.parseIdent(!0),this.checkExport(t,e.exported.name,this.lastTokStart)):e.exported=null),this.expectContextual("from"),this.type!==ha.string&&this.unexpected(),e.source=this.parseExprAtom(),this.semicolon(),this.finishNode(e,"ExportAllDeclaration");if(this.eat(ha._default)){var s;if(this.checkExport(t,"default",this.lastTokStart),this.type===ha._function||(s=this.isAsyncFunction())){var i=this.startNode();this.next(),s&&this.next(),e.declaration=this.parseFunction(i,4|La,!1,s)}else if(this.type===ha._class){var n=this.startNode();e.declaration=this.parseClass(n,"nullableID")}else e.declaration=this.parseMaybeAssign(),this.semicolon();return this.finishNode(e,"ExportDefaultDeclaration")}if(this.shouldParseExportStatement())e.declaration=this.parseStatement(null),"VariableDeclaration"===e.declaration.type?this.checkVariableExport(t,e.declaration.declarations):this.checkExport(t,e.declaration.id.name,e.declaration.id.start),e.specifiers=[],e.source=null;else{if(e.declaration=null,e.specifiers=this.parseExportSpecifiers(t),this.eatContextual("from"))this.type!==ha.string&&this.unexpected(),e.source=this.parseExprAtom();else{for(var r=0,a=e.specifiers;r<a.length;r+=1){var o=a[r];this.checkUnreserved(o.local),this.checkLocalExport(o.local)}e.source=null}this.semicolon()}return this.finishNode(e,"ExportNamedDeclaration")},Ta.checkExport=function(e,t,s){e&&(ya(e,t)&&this.raiseRecoverable(s,"Duplicate export '"+t+"'"),e[t]=!0)},Ta.checkPatternExport=function(e,t){var s=t.type;if("Identifier"===s)this.checkExport(e,t.name,t.start);else if("ObjectPattern"===s)for(var i=0,n=t.properties;i<n.length;i+=1){var r=n[i];this.checkPatternExport(e,r)}else if("ArrayPattern"===s)for(var a=0,o=t.elements;a<o.length;a+=1){var h=o[a];h&&this.checkPatternExport(e,h)}else"Property"===s?this.checkPatternExport(e,t.value):"AssignmentPattern"===s?this.checkPatternExport(e,t.left):"RestElement"===s?this.checkPatternExport(e,t.argument):"ParenthesizedExpression"===s&&this.checkPatternExport(e,t.expression)},Ta.checkVariableExport=function(e,t){if(e)for(var s=0,i=t;s<i.length;s+=1){var n=i[s];this.checkPatternExport(e,n.id)}},Ta.shouldParseExportStatement=function(){return"var"===this.type.keyword||"const"===this.type.keyword||"class"===this.type.keyword||"function"===this.type.keyword||this.isLet()||this.isAsyncFunction()},Ta.parseExportSpecifiers=function(e){var t=[],s=!0;for(this.expect(ha.braceL);!this.eat(ha.braceR);){if(s)s=!1;else if(this.expect(ha.comma),this.afterTrailingComma(ha.braceR))break;var i=this.startNode();i.local=this.parseIdent(!0),i.exported=this.eatContextual("as")?this.parseIdent(!0):i.local,this.checkExport(e,i.exported.name,i.exported.start),t.push(this.finishNode(i,"ExportSpecifier"))}return t},Ta.parseImport=function(e){return this.next(),this.type===ha.string?(e.specifiers=Da,e.source=this.parseExprAtom()):(e.specifiers=this.parseImportSpecifiers(),this.expectContextual("from"),e.source=this.type===ha.string?this.parseExprAtom():this.unexpected()),this.semicolon(),this.finishNode(e,"ImportDeclaration")},Ta.parseImportSpecifiers=function(){var e=[],t=!0;if(this.type===ha.name){var s=this.startNode();if(s.local=this.parseIdent(),this.checkLValSimple(s.local,2),e.push(this.finishNode(s,"ImportDefaultSpecifier")),!this.eat(ha.comma))return e}if(this.type===ha.star){var i=this.startNode();return this.next(),this.expectContextual("as"),i.local=this.parseIdent(),this.checkLValSimple(i.local,2),e.push(this.finishNode(i,"ImportNamespaceSpecifier")),e}for(this.expect(ha.braceL);!this.eat(ha.braceR);){if(t)t=!1;else if(this.expect(ha.comma),this.afterTrailingComma(ha.braceR))break;var n=this.startNode();n.imported=this.parseIdent(!0),this.eatContextual("as")?n.local=this.parseIdent():(this.checkUnreserved(n.imported),n.local=n.imported),this.checkLValSimple(n.local,2),e.push(this.finishNode(n,"ImportSpecifier"))}return e},Ta.adaptDirectivePrologue=function(e){for(var t=0;t<e.length&&this.isDirectiveCandidate(e[t]);++t)e[t].directive=e[t].expression.raw.slice(1,-1)},Ta.isDirectiveCandidate=function(e){return"ExpressionStatement"===e.type&&"Literal"===e.expression.type&&"string"==typeof e.expression.value&&('"'===this.input[e.start]||"'"===this.input[e.start])};var Fa=Ca.prototype;Fa.toAssignable=function(e,t,s){if(this.options.ecmaVersion>=6&&e)switch(e.type){case"Identifier":this.inAsync&&"await"===e.name&&this.raise(e.start,"Cannot use 'await' as identifier inside an async function");break;case"ObjectPattern":case"ArrayPattern":case"AssignmentPattern":case"RestElement":break;case"ObjectExpression":e.type="ObjectPattern",s&&this.checkPatternErrors(s,!0);for(var i=0,n=e.properties;i<n.length;i+=1){var r=n[i];this.toAssignable(r,t),"RestElement"!==r.type||"ArrayPattern"!==r.argument.type&&"ObjectPattern"!==r.argument.type||this.raise(r.argument.start,"Unexpected token")}break;case"Property":"init"!==e.kind&&this.raise(e.key.start,"Object pattern can't contain getter or setter"),this.toAssignable(e.value,t);break;case"ArrayExpression":e.type="ArrayPattern",s&&this.checkPatternErrors(s,!0),this.toAssignableList(e.elements,t);break;case"SpreadElement":e.type="RestElement",this.toAssignable(e.argument,t),"AssignmentPattern"===e.argument.type&&this.raise(e.argument.start,"Rest elements cannot have a default value");break;case"AssignmentExpression":"="!==e.operator&&this.raise(e.left.end,"Only '=' operator can be used for specifying default value."),e.type="AssignmentPattern",delete e.operator,this.toAssignable(e.left,t);break;case"ParenthesizedExpression":this.toAssignable(e.expression,t,s);break;case"ChainExpression":this.raiseRecoverable(e.start,"Optional chaining cannot appear in left-hand side");break;case"MemberExpression":if(!t)break;default:this.raise(e.start,"Assigning to rvalue")}else s&&this.checkPatternErrors(s,!0);return e},Fa.toAssignableList=function(e,t){for(var s=e.length,i=0;i<s;i++){var n=e[i];n&&this.toAssignable(n,t)}if(s){var r=e[s-1];6===this.options.ecmaVersion&&t&&r&&"RestElement"===r.type&&"Identifier"!==r.argument.type&&this.unexpected(r.argument.start)}return e},Fa.parseSpread=function(e){var t=this.startNode();return this.next(),t.argument=this.parseMaybeAssign(!1,e),this.finishNode(t,"SpreadElement")},Fa.parseRestBinding=function(){var e=this.startNode();return this.next(),6===this.options.ecmaVersion&&this.type!==ha.name&&this.unexpected(),e.argument=this.parseBindingAtom(),this.finishNode(e,"RestElement")},Fa.parseBindingAtom=function(){if(this.options.ecmaVersion>=6)switch(this.type){case ha.bracketL:var e=this.startNode();return this.next(),e.elements=this.parseBindingList(ha.bracketR,!0,!0),this.finishNode(e,"ArrayPattern");case ha.braceL:return this.parseObj(!0)}return this.parseIdent()},Fa.parseBindingList=function(e,t,s){for(var i=[],n=!0;!this.eat(e);)if(n?n=!1:this.expect(ha.comma),t&&this.type===ha.comma)i.push(null);else{if(s&&this.afterTrailingComma(e))break;if(this.type===ha.ellipsis){var r=this.parseRestBinding();this.parseBindingListItem(r),i.push(r),this.type===ha.comma&&this.raise(this.start,"Comma is not permitted after the rest element"),this.expect(e);break}var a=this.parseMaybeDefault(this.start,this.startLoc);this.parseBindingListItem(a),i.push(a)}return i},Fa.parseBindingListItem=function(e){return e},Fa.parseMaybeDefault=function(e,t,s){if(s=s||this.parseBindingAtom(),this.options.ecmaVersion<6||!this.eat(ha.eq))return s;var i=this.startNodeAt(e,t);return i.left=s,i.right=this.parseMaybeAssign(),this.finishNode(i,"AssignmentPattern")},Fa.checkLValSimple=function(e,t,s){void 0===t&&(t=0);var i=0!==t;switch(e.type){case"Identifier":this.strict&&this.reservedWordsStrictBind.test(e.name)&&this.raiseRecoverable(e.start,(i?"Binding ":"Assigning to ")+e.name+" in strict mode"),i&&(2===t&&"let"===e.name&&this.raiseRecoverable(e.start,"let is disallowed as a lexically bound name"),s&&(ya(s,e.name)&&this.raiseRecoverable(e.start,"Argument name clash"),s[e.name]=!0),5!==t&&this.declareName(e.name,t,e.start));break;case"ChainExpression":this.raiseRecoverable(e.start,"Optional chaining cannot appear in left-hand side");break;case"MemberExpression":i&&this.raiseRecoverable(e.start,"Binding member expression");break;case"ParenthesizedExpression":return i&&this.raiseRecoverable(e.start,"Binding parenthesized expression"),this.checkLValSimple(e.expression,t,s);default:this.raise(e.start,(i?"Binding":"Assigning to")+" rvalue")}},Fa.checkLValPattern=function(e,t,s){switch(void 0===t&&(t=0),e.type){case"ObjectPattern":for(var i=0,n=e.properties;i<n.length;i+=1){var r=n[i];this.checkLValInnerPattern(r,t,s)}break;case"ArrayPattern":for(var a=0,o=e.elements;a<o.length;a+=1){var h=o[a];h&&this.checkLValInnerPattern(h,t,s)}break;default:this.checkLValSimple(e,t,s)}},Fa.checkLValInnerPattern=function(e,t,s){switch(void 0===t&&(t=0),e.type){case"Property":this.checkLValInnerPattern(e.value,t,s);break;case"AssignmentPattern":this.checkLValPattern(e.left,t,s);break;case"RestElement":this.checkLValPattern(e.argument,t,s);break;default:this.checkLValPattern(e,t,s)}};var za=function(e,t,s,i,n){this.token=e,this.isExpr=!!t,this.preserveSpace=!!s,this.override=i,this.generator=!!n},Wa={b_stat:new za("{",!1),b_expr:new za("{",!0),b_tmpl:new za("${",!1),p_stat:new za("(",!1),p_expr:new za("(",!0),q_tmpl:new za("`",!0,!0,(function(e){return e.tryReadTemplateToken()})),f_stat:new za("function",!1),f_expr:new za("function",!0),f_expr_gen:new za("function",!0,!1,null,!0),f_gen:new za("function",!1,!1,null,!0)},ja=Ca.prototype;ja.initialContext=function(){return[Wa.b_stat]},ja.curContext=function(){return this.context[this.context.length-1]},ja.braceIsBlock=function(e){var t=this.curContext();return t===Wa.f_expr||t===Wa.f_stat||(e!==ha.colon||t!==Wa.b_stat&&t!==Wa.b_expr?e===ha._return||e===ha.name&&this.exprAllowed?la.test(this.input.slice(this.lastTokEnd,this.start)):e===ha._else||e===ha.semi||e===ha.eof||e===ha.parenR||e===ha.arrow||(e===ha.braceL?t===Wa.b_stat:e!==ha._var&&e!==ha._const&&e!==ha.name&&!this.exprAllowed):!t.isExpr)},ja.inGeneratorContext=function(){for(var e=this.context.length-1;e>=1;e--){var t=this.context[e];if("function"===t.token)return t.generator}return!1},ja.updateContext=function(e){var t,s=this.type;s.keyword&&e===ha.dot?this.exprAllowed=!1:(t=s.updateContext)?t.call(this,e):this.exprAllowed=s.beforeExpr},ja.overrideContext=function(e){this.curContext()!==e&&(this.context[this.context.length-1]=e)},ha.parenR.updateContext=ha.braceR.updateContext=function(){if(1!==this.context.length){var e=this.context.pop();e===Wa.b_stat&&"function"===this.curContext().token&&(e=this.context.pop()),this.exprAllowed=!e.isExpr}else this.exprAllowed=!0},ha.braceL.updateContext=function(e){this.context.push(this.braceIsBlock(e)?Wa.b_stat:Wa.b_expr),this.exprAllowed=!0},ha.dollarBraceL.updateContext=function(){this.context.push(Wa.b_tmpl),this.exprAllowed=!0},ha.parenL.updateContext=function(e){var t=e===ha._if||e===ha._for||e===ha._with||e===ha._while;this.context.push(t?Wa.p_stat:Wa.p_expr),this.exprAllowed=!0},ha.incDec.updateContext=function(){},ha._function.updateContext=ha._class.updateContext=function(e){!e.beforeExpr||e===ha._else||e===ha.semi&&this.curContext()!==Wa.p_stat||e===ha._return&&la.test(this.input.slice(this.lastTokEnd,this.start))||(e===ha.colon||e===ha.braceL)&&this.curContext()===Wa.b_stat?this.context.push(Wa.f_stat):this.context.push(Wa.f_expr),this.exprAllowed=!1},ha.backQuote.updateContext=function(){this.curContext()===Wa.q_tmpl?this.context.pop():this.context.push(Wa.q_tmpl),this.exprAllowed=!1},ha.star.updateContext=function(e){if(e===ha._function){var t=this.context.length-1;this.context[t]===Wa.f_expr?this.context[t]=Wa.f_expr_gen:this.context[t]=Wa.f_gen}this.exprAllowed=!0},ha.name.updateContext=function(e){var t=!1;this.options.ecmaVersion>=6&&e!==ha.dot&&("of"===this.value&&!this.exprAllowed||"yield"===this.value&&this.inGeneratorContext())&&(t=!0),this.exprAllowed=t};var Ua=Ca.prototype;function Ga(e){return"MemberExpression"===e.type&&"PrivateIdentifier"===e.property.type||"ChainExpression"===e.type&&Ga(e.expression)}Ua.checkPropClash=function(e,t,s){if(!(this.options.ecmaVersion>=9&&"SpreadElement"===e.type||this.options.ecmaVersion>=6&&(e.computed||e.method||e.shorthand))){var i,n=e.key;switch(n.type){case"Identifier":i=n.name;break;case"Literal":i=String(n.value);break;default:return}var r=e.kind;if(this.options.ecmaVersion>=6)"__proto__"===i&&"init"===r&&(t.proto&&(s?s.doubleProto<0&&(s.doubleProto=n.start):this.raiseRecoverable(n.start,"Redefinition of __proto__ property")),t.proto=!0);else{var a=t[i="$"+i];if(a)("init"===r?this.strict&&a.init||a.get||a.set:a.init||a[r])&&this.raiseRecoverable(n.start,"Redefinition of property");else a=t[i]={init:!1,get:!1,set:!1};a[r]=!0}}},Ua.parseExpression=function(e,t){var s=this.start,i=this.startLoc,n=this.parseMaybeAssign(e,t);if(this.type===ha.comma){var r=this.startNodeAt(s,i);for(r.expressions=[n];this.eat(ha.comma);)r.expressions.push(this.parseMaybeAssign(e,t));return this.finishNode(r,"SequenceExpression")}return n},Ua.parseMaybeAssign=function(e,t,s){if(this.isContextual("yield")){if(this.inGenerator)return this.parseYield(e);this.exprAllowed=!1}var i=!1,n=-1,r=-1;t?(n=t.parenthesizedAssign,r=t.trailingComma,t.parenthesizedAssign=t.trailingComma=-1):(t=new $a,i=!0);var a=this.start,o=this.startLoc;this.type!==ha.parenL&&this.type!==ha.name||(this.potentialArrowAt=this.start,this.potentialArrowInForAwait="await"===e);var h=this.parseMaybeConditional(e,t);if(s&&(h=s.call(this,h,a,o)),this.type.isAssign){var l=this.startNodeAt(a,o);return l.operator=this.value,this.type===ha.eq&&(h=this.toAssignable(h,!1,t)),i||(t.parenthesizedAssign=t.trailingComma=t.doubleProto=-1),t.shorthandAssign>=h.start&&(t.shorthandAssign=-1),this.type===ha.eq?this.checkLValPattern(h):this.checkLValSimple(h),l.left=h,this.next(),l.right=this.parseMaybeAssign(e),this.finishNode(l,"AssignmentExpression")}return i&&this.checkExpressionErrors(t,!0),n>-1&&(t.parenthesizedAssign=n),r>-1&&(t.trailingComma=r),h},Ua.parseMaybeConditional=function(e,t){var s=this.start,i=this.startLoc,n=this.parseExprOps(e,t);if(this.checkExpressionErrors(t))return n;if(this.eat(ha.question)){var r=this.startNodeAt(s,i);return r.test=n,r.consequent=this.parseMaybeAssign(),this.expect(ha.colon),r.alternate=this.parseMaybeAssign(e),this.finishNode(r,"ConditionalExpression")}return n},Ua.parseExprOps=function(e,t){var s=this.start,i=this.startLoc,n=this.parseMaybeUnary(t,!1,!1,e);return this.checkExpressionErrors(t)||n.start===s&&"ArrowFunctionExpression"===n.type?n:this.parseExprOp(n,s,i,-1,e)},Ua.parseExprOp=function(e,t,s,i,n){var r=this.type.binop;if(null!=r&&(!n||this.type!==ha._in)&&r>i){var a=this.type===ha.logicalOR||this.type===ha.logicalAND,o=this.type===ha.coalesce;o&&(r=ha.logicalAND.binop);var h=this.value;this.next();var l=this.start,c=this.startLoc,u=this.parseExprOp(this.parseMaybeUnary(null,!1,!1,n),l,c,r,n),d=this.buildBinary(t,s,e,u,h,a||o);return(a&&this.type===ha.coalesce||o&&(this.type===ha.logicalOR||this.type===ha.logicalAND))&&this.raiseRecoverable(this.start,"Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"),this.parseExprOp(d,t,s,i,n)}return e},Ua.buildBinary=function(e,t,s,i,n,r){var a=this.startNodeAt(e,t);return a.left=s,a.operator=n,a.right=i,this.finishNode(a,r?"LogicalExpression":"BinaryExpression")},Ua.parseMaybeUnary=function(e,t,s,i){var n,r=this.start,a=this.startLoc;if(this.isContextual("await")&&this.canAwait)n=this.parseAwait(i),t=!0;else if(this.type.prefix){var o=this.startNode(),h=this.type===ha.incDec;o.operator=this.value,o.prefix=!0,this.next(),o.argument=this.parseMaybeUnary(null,!0,h,i),this.checkExpressionErrors(e,!0),h?this.checkLValSimple(o.argument):this.strict&&"delete"===o.operator&&"Identifier"===o.argument.type?this.raiseRecoverable(o.start,"Deleting local variable in strict mode"):"delete"===o.operator&&Ga(o.argument)?this.raiseRecoverable(o.start,"Private fields can not be deleted"):t=!0,n=this.finishNode(o,h?"UpdateExpression":"UnaryExpression")}else{if(n=this.parseExprSubscripts(e,i),this.checkExpressionErrors(e))return n;for(;this.type.postfix&&!this.canInsertSemicolon();){var l=this.startNodeAt(r,a);l.operator=this.value,l.prefix=!1,l.argument=n,this.checkLValSimple(n),this.next(),n=this.finishNode(l,"UpdateExpression")}}return s||!this.eat(ha.starstar)?n:t?void this.unexpected(this.lastTokStart):this.buildBinary(r,a,n,this.parseMaybeUnary(null,!1,!1,i),"**",!1)},Ua.parseExprSubscripts=function(e,t){var s=this.start,i=this.startLoc,n=this.parseExprAtom(e,t);if("ArrowFunctionExpression"===n.type&&")"!==this.input.slice(this.lastTokStart,this.lastTokEnd))return n;var r=this.parseSubscripts(n,s,i,!1,t);return e&&"MemberExpression"===r.type&&(e.parenthesizedAssign>=r.start&&(e.parenthesizedAssign=-1),e.parenthesizedBind>=r.start&&(e.parenthesizedBind=-1),e.trailingComma>=r.start&&(e.trailingComma=-1)),r},Ua.parseSubscripts=function(e,t,s,i,n){for(var r=this.options.ecmaVersion>=8&&"Identifier"===e.type&&"async"===e.name&&this.lastTokEnd===e.end&&!this.canInsertSemicolon()&&e.end-e.start==5&&this.potentialArrowAt===e.start,a=!1;;){var o=this.parseSubscript(e,t,s,i,r,a,n);if(o.optional&&(a=!0),o===e||"ArrowFunctionExpression"===o.type){if(a){var h=this.startNodeAt(t,s);h.expression=o,o=this.finishNode(h,"ChainExpression")}return o}e=o}},Ua.parseSubscript=function(e,t,s,i,n,r,a){var o=this.options.ecmaVersion>=11,h=o&&this.eat(ha.questionDot);i&&h&&this.raise(this.lastTokStart,"Optional chaining cannot appear in the callee of new expressions");var l=this.eat(ha.bracketL);if(l||h&&this.type!==ha.parenL&&this.type!==ha.backQuote||this.eat(ha.dot)){var c=this.startNodeAt(t,s);c.object=e,l?(c.property=this.parseExpression(),this.expect(ha.bracketR)):this.type===ha.privateId&&"Super"!==e.type?c.property=this.parsePrivateIdent():c.property=this.parseIdent("never"!==this.options.allowReserved),c.computed=!!l,o&&(c.optional=h),e=this.finishNode(c,"MemberExpression")}else if(!i&&this.eat(ha.parenL)){var u=new $a,d=this.yieldPos,p=this.awaitPos,f=this.awaitIdentPos;this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0;var m=this.parseExprList(ha.parenR,this.options.ecmaVersion>=8,!1,u);if(n&&!h&&!this.canInsertSemicolon()&&this.eat(ha.arrow))return this.checkPatternErrors(u,!1),this.checkYieldAwaitInDefaultParams(),this.awaitIdentPos>0&&this.raise(this.awaitIdentPos,"Cannot use 'await' as identifier inside an async function"),this.yieldPos=d,this.awaitPos=p,this.awaitIdentPos=f,this.parseArrowExpression(this.startNodeAt(t,s),m,!0,a);this.checkExpressionErrors(u,!0),this.yieldPos=d||this.yieldPos,this.awaitPos=p||this.awaitPos,this.awaitIdentPos=f||this.awaitIdentPos;var g=this.startNodeAt(t,s);g.callee=e,g.arguments=m,o&&(g.optional=h),e=this.finishNode(g,"CallExpression")}else if(this.type===ha.backQuote){(h||r)&&this.raise(this.start,"Optional chaining cannot appear in the tag of tagged template expressions");var y=this.startNodeAt(t,s);y.tag=e,y.quasi=this.parseTemplate({isTagged:!0}),e=this.finishNode(y,"TaggedTemplateExpression")}return e},Ua.parseExprAtom=function(e,t){this.type===ha.slash&&this.readRegexp();var s,i=this.potentialArrowAt===this.start;switch(this.type){case ha._super:return this.allowSuper||this.raise(this.start,"'super' keyword outside a method"),s=this.startNode(),this.next(),this.type!==ha.parenL||this.allowDirectSuper||this.raise(s.start,"super() call outside constructor of a subclass"),this.type!==ha.dot&&this.type!==ha.bracketL&&this.type!==ha.parenL&&this.unexpected(),this.finishNode(s,"Super");case ha._this:return s=this.startNode(),this.next(),this.finishNode(s,"ThisExpression");case ha.name:var n=this.start,r=this.startLoc,a=this.containsEsc,o=this.parseIdent(!1);if(this.options.ecmaVersion>=8&&!a&&"async"===o.name&&!this.canInsertSemicolon()&&this.eat(ha._function))return this.overrideContext(Wa.f_expr),this.parseFunction(this.startNodeAt(n,r),0,!1,!0,t);if(i&&!this.canInsertSemicolon()){if(this.eat(ha.arrow))return this.parseArrowExpression(this.startNodeAt(n,r),[o],!1,t);if(this.options.ecmaVersion>=8&&"async"===o.name&&this.type===ha.name&&!a&&(!this.potentialArrowInForAwait||"of"!==this.value||this.containsEsc))return o=this.parseIdent(!1),!this.canInsertSemicolon()&&this.eat(ha.arrow)||this.unexpected(),this.parseArrowExpression(this.startNodeAt(n,r),[o],!0,t)}return o;case ha.regexp:var h=this.value;return(s=this.parseLiteral(h.value)).regex={pattern:h.pattern,flags:h.flags},s;case ha.num:case ha.string:return this.parseLiteral(this.value);case ha._null:case ha._true:case ha._false:return(s=this.startNode()).value=this.type===ha._null?null:this.type===ha._true,s.raw=this.type.keyword,this.next(),this.finishNode(s,"Literal");case ha.parenL:var l=this.start,c=this.parseParenAndDistinguishExpression(i,t);return e&&(e.parenthesizedAssign<0&&!this.isSimpleAssignTarget(c)&&(e.parenthesizedAssign=l),e.parenthesizedBind<0&&(e.parenthesizedBind=l)),c;case ha.bracketL:return s=this.startNode(),this.next(),s.elements=this.parseExprList(ha.bracketR,!0,!0,e),this.finishNode(s,"ArrayExpression");case ha.braceL:return this.overrideContext(Wa.b_expr),this.parseObj(!1,e);case ha._function:return s=this.startNode(),this.next(),this.parseFunction(s,0);case ha._class:return this.parseClass(this.startNode(),!1);case ha._new:return this.parseNew();case ha.backQuote:return this.parseTemplate();case ha._import:return this.options.ecmaVersion>=11?this.parseExprImport():this.unexpected();default:this.unexpected()}},Ua.parseExprImport=function(){var e=this.startNode();this.containsEsc&&this.raiseRecoverable(this.start,"Escape sequence in keyword import");var t=this.parseIdent(!0);switch(this.type){case ha.parenL:return this.parseDynamicImport(e);case ha.dot:return e.meta=t,this.parseImportMeta(e);default:this.unexpected()}},Ua.parseDynamicImport=function(e){if(this.next(),e.source=this.parseMaybeAssign(),!this.eat(ha.parenR)){var t=this.start;this.eat(ha.comma)&&this.eat(ha.parenR)?this.raiseRecoverable(t,"Trailing comma is not allowed in import()"):this.unexpected(t)}return this.finishNode(e,"ImportExpression")},Ua.parseImportMeta=function(e){this.next();var t=this.containsEsc;return e.property=this.parseIdent(!0),"meta"!==e.property.name&&this.raiseRecoverable(e.property.start,"The only valid meta property for import is 'import.meta'"),t&&this.raiseRecoverable(e.start,"'import.meta' must not contain escaped characters"),"module"===this.options.sourceType||this.options.allowImportExportEverywhere||this.raiseRecoverable(e.start,"Cannot use 'import.meta' outside a module"),this.finishNode(e,"MetaProperty")},Ua.parseLiteral=function(e){var t=this.startNode();return t.value=e,t.raw=this.input.slice(this.start,this.end),110===t.raw.charCodeAt(t.raw.length-1)&&(t.bigint=t.raw.slice(0,-1).replace(/_/g,"")),this.next(),this.finishNode(t,"Literal")},Ua.parseParenExpression=function(){this.expect(ha.parenL);var e=this.parseExpression();return this.expect(ha.parenR),e},Ua.parseParenAndDistinguishExpression=function(e,t){var s,i=this.start,n=this.startLoc,r=this.options.ecmaVersion>=8;if(this.options.ecmaVersion>=6){this.next();var a,o=this.start,h=this.startLoc,l=[],c=!0,u=!1,d=new $a,p=this.yieldPos,f=this.awaitPos;for(this.yieldPos=0,this.awaitPos=0;this.type!==ha.parenR;){if(c?c=!1:this.expect(ha.comma),r&&this.afterTrailingComma(ha.parenR,!0)){u=!0;break}if(this.type===ha.ellipsis){a=this.start,l.push(this.parseParenItem(this.parseRestBinding())),this.type===ha.comma&&this.raise(this.start,"Comma is not permitted after the rest element");break}l.push(this.parseMaybeAssign(!1,d,this.parseParenItem))}var m=this.lastTokEnd,g=this.lastTokEndLoc;if(this.expect(ha.parenR),e&&!this.canInsertSemicolon()&&this.eat(ha.arrow))return this.checkPatternErrors(d,!1),this.checkYieldAwaitInDefaultParams(),this.yieldPos=p,this.awaitPos=f,this.parseParenArrowList(i,n,l,t);l.length&&!u||this.unexpected(this.lastTokStart),a&&this.unexpected(a),this.checkExpressionErrors(d,!0),this.yieldPos=p||this.yieldPos,this.awaitPos=f||this.awaitPos,l.length>1?((s=this.startNodeAt(o,h)).expressions=l,this.finishNodeAt(s,"SequenceExpression",m,g)):s=l[0]}else s=this.parseParenExpression();if(this.options.preserveParens){var y=this.startNodeAt(i,n);return y.expression=s,this.finishNode(y,"ParenthesizedExpression")}return s},Ua.parseParenItem=function(e){return e},Ua.parseParenArrowList=function(e,t,s,i){return this.parseArrowExpression(this.startNodeAt(e,t),s,i)};var Ha=[];Ua.parseNew=function(){this.containsEsc&&this.raiseRecoverable(this.start,"Escape sequence in keyword new");var e=this.startNode(),t=this.parseIdent(!0);if(this.options.ecmaVersion>=6&&this.eat(ha.dot)){e.meta=t;var s=this.containsEsc;return e.property=this.parseIdent(!0),"target"!==e.property.name&&this.raiseRecoverable(e.property.start,"The only valid meta property for new is 'new.target'"),s&&this.raiseRecoverable(e.start,"'new.target' must not contain escaped characters"),this.allowNewDotTarget||this.raiseRecoverable(e.start,"'new.target' can only be used in functions and class static block"),this.finishNode(e,"MetaProperty")}var i=this.start,n=this.startLoc,r=this.type===ha._import;return e.callee=this.parseSubscripts(this.parseExprAtom(),i,n,!0,!1),r&&"ImportExpression"===e.callee.type&&this.raise(i,"Cannot use new with import()"),this.eat(ha.parenL)?e.arguments=this.parseExprList(ha.parenR,this.options.ecmaVersion>=8,!1):e.arguments=Ha,this.finishNode(e,"NewExpression")},Ua.parseTemplateElement=function(e){var t=e.isTagged,s=this.startNode();return this.type===ha.invalidTemplate?(t||this.raiseRecoverable(this.start,"Bad escape sequence in untagged template literal"),s.value={raw:this.value,cooked:null}):s.value={raw:this.input.slice(this.start,this.end).replace(/\r\n?/g,"\n"),cooked:this.value},this.next(),s.tail=this.type===ha.backQuote,this.finishNode(s,"TemplateElement")},Ua.parseTemplate=function(e){void 0===e&&(e={});var t=e.isTagged;void 0===t&&(t=!1);var s=this.startNode();this.next(),s.expressions=[];var i=this.parseTemplateElement({isTagged:t});for(s.quasis=[i];!i.tail;)this.type===ha.eof&&this.raise(this.pos,"Unterminated template literal"),this.expect(ha.dollarBraceL),s.expressions.push(this.parseExpression()),this.expect(ha.braceR),s.quasis.push(i=this.parseTemplateElement({isTagged:t}));return this.next(),this.finishNode(s,"TemplateLiteral")},Ua.isAsyncProp=function(e){return!e.computed&&"Identifier"===e.key.type&&"async"===e.key.name&&(this.type===ha.name||this.type===ha.num||this.type===ha.string||this.type===ha.bracketL||this.type.keyword||this.options.ecmaVersion>=9&&this.type===ha.star)&&!la.test(this.input.slice(this.lastTokEnd,this.start))},Ua.parseObj=function(e,t){var s=this.startNode(),i=!0,n={};for(s.properties=[],this.next();!this.eat(ha.braceR);){if(i)i=!1;else if(this.expect(ha.comma),this.options.ecmaVersion>=5&&this.afterTrailingComma(ha.braceR))break;var r=this.parseProperty(e,t);e||this.checkPropClash(r,n,t),s.properties.push(r)}return this.finishNode(s,e?"ObjectPattern":"ObjectExpression")},Ua.parseProperty=function(e,t){var s,i,n,r,a=this.startNode();if(this.options.ecmaVersion>=9&&this.eat(ha.ellipsis))return e?(a.argument=this.parseIdent(!1),this.type===ha.comma&&this.raise(this.start,"Comma is not permitted after the rest element"),this.finishNode(a,"RestElement")):(this.type===ha.parenL&&t&&(t.parenthesizedAssign<0&&(t.parenthesizedAssign=this.start),t.parenthesizedBind<0&&(t.parenthesizedBind=this.start)),a.argument=this.parseMaybeAssign(!1,t),this.type===ha.comma&&t&&t.trailingComma<0&&(t.trailingComma=this.start),this.finishNode(a,"SpreadElement"));this.options.ecmaVersion>=6&&(a.method=!1,a.shorthand=!1,(e||t)&&(n=this.start,r=this.startLoc),e||(s=this.eat(ha.star)));var o=this.containsEsc;return this.parsePropertyName(a),!e&&!o&&this.options.ecmaVersion>=8&&!s&&this.isAsyncProp(a)?(i=!0,s=this.options.ecmaVersion>=9&&this.eat(ha.star),this.parsePropertyName(a,t)):i=!1,this.parsePropertyValue(a,e,s,i,n,r,t,o),this.finishNode(a,"Property")},Ua.parsePropertyValue=function(e,t,s,i,n,r,a,o){if((s||i)&&this.type===ha.colon&&this.unexpected(),this.eat(ha.colon))e.value=t?this.parseMaybeDefault(this.start,this.startLoc):this.parseMaybeAssign(!1,a),e.kind="init";else if(this.options.ecmaVersion>=6&&this.type===ha.parenL)t&&this.unexpected(),e.kind="init",e.method=!0,e.value=this.parseMethod(s,i);else if(t||o||!(this.options.ecmaVersion>=5)||e.computed||"Identifier"!==e.key.type||"get"!==e.key.name&&"set"!==e.key.name||this.type===ha.comma||this.type===ha.braceR||this.type===ha.eq)this.options.ecmaVersion>=6&&!e.computed&&"Identifier"===e.key.type?((s||i)&&this.unexpected(),this.checkUnreserved(e.key),"await"!==e.key.name||this.awaitIdentPos||(this.awaitIdentPos=n),e.kind="init",t?e.value=this.parseMaybeDefault(n,r,this.copyNode(e.key)):this.type===ha.eq&&a?(a.shorthandAssign<0&&(a.shorthandAssign=this.start),e.value=this.parseMaybeDefault(n,r,this.copyNode(e.key))):e.value=this.copyNode(e.key),e.shorthand=!0):this.unexpected();else{(s||i)&&this.unexpected(),e.kind=e.key.name,this.parsePropertyName(e),e.value=this.parseMethod(!1);var h="get"===e.kind?0:1;if(e.value.params.length!==h){var l=e.value.start;"get"===e.kind?this.raiseRecoverable(l,"getter should have no params"):this.raiseRecoverable(l,"setter should have exactly one param")}else"set"===e.kind&&"RestElement"===e.value.params[0].type&&this.raiseRecoverable(e.value.params[0].start,"Setter cannot use rest params")}},Ua.parsePropertyName=function(e){if(this.options.ecmaVersion>=6){if(this.eat(ha.bracketL))return e.computed=!0,e.key=this.parseMaybeAssign(),this.expect(ha.bracketR),e.key;e.computed=!1}return e.key=this.type===ha.num||this.type===ha.string?this.parseExprAtom():this.parseIdent("never"!==this.options.allowReserved)},Ua.initFunction=function(e){e.id=null,this.options.ecmaVersion>=6&&(e.generator=e.expression=!1),this.options.ecmaVersion>=8&&(e.async=!1)},Ua.parseMethod=function(e,t,s){var i=this.startNode(),n=this.yieldPos,r=this.awaitPos,a=this.awaitIdentPos;return this.initFunction(i),this.options.ecmaVersion>=6&&(i.generator=e),this.options.ecmaVersion>=8&&(i.async=!!t),this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0,this.enterScope(64|wa(t,i.generator)|(s?128:0)),this.expect(ha.parenL),i.params=this.parseBindingList(ha.parenR,!1,this.options.ecmaVersion>=8),this.checkYieldAwaitInDefaultParams(),this.parseFunctionBody(i,!1,!0,!1),this.yieldPos=n,this.awaitPos=r,this.awaitIdentPos=a,this.finishNode(i,"FunctionExpression")},Ua.parseArrowExpression=function(e,t,s,i){var n=this.yieldPos,r=this.awaitPos,a=this.awaitIdentPos;return this.enterScope(16|wa(s,!1)),this.initFunction(e),this.options.ecmaVersion>=8&&(e.async=!!s),this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0,e.params=this.toAssignableList(t,!0),this.parseFunctionBody(e,!0,!1,i),this.yieldPos=n,this.awaitPos=r,this.awaitIdentPos=a,this.finishNode(e,"ArrowFunctionExpression")},Ua.parseFunctionBody=function(e,t,s,i){var n=t&&this.type!==ha.braceL,r=this.strict,a=!1;if(n)e.body=this.parseMaybeAssign(i),e.expression=!0,this.checkParams(e,!1);else{var o=this.options.ecmaVersion>=7&&!this.isSimpleParamList(e.params);r&&!o||(a=this.strictDirective(this.end))&&o&&this.raiseRecoverable(e.start,"Illegal 'use strict' directive in function with non-simple parameter list");var h=this.labels;this.labels=[],a&&(this.strict=!0),this.checkParams(e,!r&&!a&&!t&&!s&&this.isSimpleParamList(e.params)),this.strict&&e.id&&this.checkLValSimple(e.id,5),e.body=this.parseBlock(!1,void 0,a&&!r),e.expression=!1,this.adaptDirectivePrologue(e.body.body),this.labels=h}this.exitScope()},Ua.isSimpleParamList=function(e){for(var t=0,s=e;t<s.length;t+=1){if("Identifier"!==s[t].type)return!1}return!0},Ua.checkParams=function(e,t){for(var s=Object.create(null),i=0,n=e.params;i<n.length;i+=1){var r=n[i];this.checkLValInnerPattern(r,1,t?null:s)}},Ua.parseExprList=function(e,t,s,i){for(var n=[],r=!0;!this.eat(e);){if(r)r=!1;else if(this.expect(ha.comma),t&&this.afterTrailingComma(e))break;var a=void 0;s&&this.type===ha.comma?a=null:this.type===ha.ellipsis?(a=this.parseSpread(i),i&&this.type===ha.comma&&i.trailingComma<0&&(i.trailingComma=this.start)):a=this.parseMaybeAssign(!1,i),n.push(a)}return n},Ua.checkUnreserved=function(e){var t=e.start,s=e.end,i=e.name;(this.inGenerator&&"yield"===i&&this.raiseRecoverable(t,"Cannot use 'yield' as identifier inside a generator"),this.inAsync&&"await"===i&&this.raiseRecoverable(t,"Cannot use 'await' as identifier inside an async function"),this.currentThisScope().inClassFieldInit&&"arguments"===i&&this.raiseRecoverable(t,"Cannot use 'arguments' in class field initializer"),!this.inClassStaticBlock||"arguments"!==i&&"await"!==i||this.raise(t,"Cannot use "+i+" in class static initialization block"),this.keywords.test(i)&&this.raise(t,"Unexpected keyword '"+i+"'"),this.options.ecmaVersion<6&&-1!==this.input.slice(t,s).indexOf("\\"))||(this.strict?this.reservedWordsStrict:this.reservedWords).test(i)&&(this.inAsync||"await"!==i||this.raiseRecoverable(t,"Cannot use keyword 'await' outside an async function"),this.raiseRecoverable(t,"The keyword '"+i+"' is reserved"))},Ua.parseIdent=function(e,t){var s=this.startNode();return this.type===ha.name?s.name=this.value:this.type.keyword?(s.name=this.type.keyword,"class"!==s.name&&"function"!==s.name||this.lastTokEnd===this.lastTokStart+1&&46===this.input.charCodeAt(this.lastTokStart)||this.context.pop()):this.unexpected(),this.next(!!e),this.finishNode(s,"Identifier"),e||(this.checkUnreserved(s),"await"!==s.name||this.awaitIdentPos||(this.awaitIdentPos=s.start)),s},Ua.parsePrivateIdent=function(){var e=this.startNode();return this.type===ha.privateId?e.name=this.value:this.unexpected(),this.next(),this.finishNode(e,"PrivateIdentifier"),0===this.privateNameStack.length?this.raise(e.start,"Private field '#"+e.name+"' must be declared in an enclosing class"):this.privateNameStack[this.privateNameStack.length-1].used.push(e),e},Ua.parseYield=function(e){this.yieldPos||(this.yieldPos=this.start);var t=this.startNode();return this.next(),this.type===ha.semi||this.canInsertSemicolon()||this.type!==ha.star&&!this.type.startsExpr?(t.delegate=!1,t.argument=null):(t.delegate=this.eat(ha.star),t.argument=this.parseMaybeAssign(e)),this.finishNode(t,"YieldExpression")},Ua.parseAwait=function(e){this.awaitPos||(this.awaitPos=this.start);var t=this.startNode();return this.next(),t.argument=this.parseMaybeUnary(null,!0,!1,e),this.finishNode(t,"AwaitExpression")};var qa=Ca.prototype;qa.raise=function(e,t){var s=Sa(this.input,e);t+=" ("+s.line+":"+s.column+")";var i=new SyntaxError(t);throw i.pos=e,i.loc=s,i.raisedAt=this.pos,i},qa.raiseRecoverable=qa.raise,qa.curPosition=function(){if(this.options.locations)return new va(this.curLine,this.pos-this.lineStart)};var Ka=Ca.prototype,Xa=function(e){this.flags=e,this.var=[],this.lexical=[],this.functions=[],this.inClassFieldInit=!1};Ka.enterScope=function(e){this.scopeStack.push(new Xa(e))},Ka.exitScope=function(){this.scopeStack.pop()},Ka.treatFunctionsAsVarInScope=function(e){return 2&e.flags||!this.inModule&&1&e.flags},Ka.declareName=function(e,t,s){var i=!1;if(2===t){var n=this.currentScope();i=n.lexical.indexOf(e)>-1||n.functions.indexOf(e)>-1||n.var.indexOf(e)>-1,n.lexical.push(e),this.inModule&&1&n.flags&&delete this.undefinedExports[e]}else if(4===t){this.currentScope().lexical.push(e)}else if(3===t){var r=this.currentScope();i=this.treatFunctionsAsVar?r.lexical.indexOf(e)>-1:r.lexical.indexOf(e)>-1||r.var.indexOf(e)>-1,r.functions.push(e)}else for(var a=this.scopeStack.length-1;a>=0;--a){var o=this.scopeStack[a];if(o.lexical.indexOf(e)>-1&&!(32&o.flags&&o.lexical[0]===e)||!this.treatFunctionsAsVarInScope(o)&&o.functions.indexOf(e)>-1){i=!0;break}if(o.var.push(e),this.inModule&&1&o.flags&&delete this.undefinedExports[e],259&o.flags)break}i&&this.raiseRecoverable(s,"Identifier '"+e+"' has already been declared")},Ka.checkLocalExport=function(e){-1===this.scopeStack[0].lexical.indexOf(e.name)&&-1===this.scopeStack[0].var.indexOf(e.name)&&(this.undefinedExports[e.name]=e)},Ka.currentScope=function(){return this.scopeStack[this.scopeStack.length-1]},Ka.currentVarScope=function(){for(var e=this.scopeStack.length-1;;e--){var t=this.scopeStack[e];if(259&t.flags)return t}},Ka.currentThisScope=function(){for(var e=this.scopeStack.length-1;;e--){var t=this.scopeStack[e];if(259&t.flags&&!(16&t.flags))return t}};var Ya=function(e,t,s){this.type="",this.start=t,this.end=0,e.options.locations&&(this.loc=new ba(e,s)),e.options.directSourceFile&&(this.sourceFile=e.options.directSourceFile),e.options.ranges&&(this.range=[t,0])},Qa=Ca.prototype;function Za(e,t,s,i){return e.type=t,e.end=s,this.options.locations&&(e.loc.end=i),this.options.ranges&&(e.range[1]=s),e}Qa.startNode=function(){return new Ya(this,this.start,this.startLoc)},Qa.startNodeAt=function(e,t){return new Ya(this,e,t)},Qa.finishNode=function(e,t){return Za.call(this,e,t,this.lastTokEnd,this.lastTokEndLoc)},Qa.finishNodeAt=function(e,t,s,i){return Za.call(this,e,t,s,i)},Qa.copyNode=function(e){var t=new Ya(this,e.start,this.startLoc);for(var s in e)t[s]=e[s];return t};var Ja="ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS",eo=Ja+" Extended_Pictographic",to={9:Ja,10:eo,11:eo,12:"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS Extended_Pictographic EBase EComp EMod EPres ExtPict"},so="Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu",io="Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb",no=io+" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd",ro=no+" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho",ao={9:io,10:no,11:ro,12:"Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi"},oo={};function ho(e){var t=oo[e]={binary:xa(to[e]+" "+so),nonBinary:{General_Category:xa(so),Script:xa(ao[e])}};t.nonBinary.Script_Extensions=t.nonBinary.Script,t.nonBinary.gc=t.nonBinary.General_Category,t.nonBinary.sc=t.nonBinary.Script,t.nonBinary.scx=t.nonBinary.Script_Extensions}ho(9),ho(10),ho(11),ho(12);var lo=Ca.prototype,co=function(e){this.parser=e,this.validFlags="gim"+(e.options.ecmaVersion>=6?"uy":"")+(e.options.ecmaVersion>=9?"s":"")+(e.options.ecmaVersion>=13?"d":""),this.unicodeProperties=oo[e.options.ecmaVersion>=12?12:e.options.ecmaVersion],this.source="",this.flags="",this.start=0,this.switchU=!1,this.switchN=!1,this.pos=0,this.lastIntValue=0,this.lastStringValue="",this.lastAssertionIsQuantifiable=!1,this.numCapturingParens=0,this.maxBackReference=0,this.groupNames=[],this.backReferenceNames=[]};function uo(e){return e<=65535?String.fromCharCode(e):(e-=65536,String.fromCharCode(55296+(e>>10),56320+(1023&e)))}function po(e){return 36===e||e>=40&&e<=43||46===e||63===e||e>=91&&e<=94||e>=123&&e<=125}function fo(e){return e>=65&&e<=90||e>=97&&e<=122}function mo(e){return fo(e)||95===e}function go(e){return mo(e)||yo(e)}function yo(e){return e>=48&&e<=57}function Eo(e){return e>=48&&e<=57||e>=65&&e<=70||e>=97&&e<=102}function xo(e){return e>=65&&e<=70?e-65+10:e>=97&&e<=102?e-97+10:e-48}function vo(e){return e>=48&&e<=55}co.prototype.reset=function(e,t,s){var i=-1!==s.indexOf("u");this.start=0|e,this.source=t+"",this.flags=s,this.switchU=i&&this.parser.options.ecmaVersion>=6,this.switchN=i&&this.parser.options.ecmaVersion>=9},co.prototype.raise=function(e){this.parser.raiseRecoverable(this.start,"Invalid regular expression: /"+this.source+"/: "+e)},co.prototype.at=function(e,t){void 0===t&&(t=!1);var s=this.source,i=s.length;if(e>=i)return-1;var n=s.charCodeAt(e);if(!t&&!this.switchU||n<=55295||n>=57344||e+1>=i)return n;var r=s.charCodeAt(e+1);return r>=56320&&r<=57343?(n<<10)+r-56613888:n},co.prototype.nextIndex=function(e,t){void 0===t&&(t=!1);var s=this.source,i=s.length;if(e>=i)return i;var n,r=s.charCodeAt(e);return!t&&!this.switchU||r<=55295||r>=57344||e+1>=i||(n=s.charCodeAt(e+1))<56320||n>57343?e+1:e+2},co.prototype.current=function(e){return void 0===e&&(e=!1),this.at(this.pos,e)},co.prototype.lookahead=function(e){return void 0===e&&(e=!1),this.at(this.nextIndex(this.pos,e),e)},co.prototype.advance=function(e){void 0===e&&(e=!1),this.pos=this.nextIndex(this.pos,e)},co.prototype.eat=function(e,t){return void 0===t&&(t=!1),this.current(t)===e&&(this.advance(t),!0)},lo.validateRegExpFlags=function(e){for(var t=e.validFlags,s=e.flags,i=0;i<s.length;i++){var n=s.charAt(i);-1===t.indexOf(n)&&this.raise(e.start,"Invalid regular expression flag"),s.indexOf(n,i+1)>-1&&this.raise(e.start,"Duplicate regular expression flag")}},lo.validateRegExpPattern=function(e){this.regexp_pattern(e),!e.switchN&&this.options.ecmaVersion>=9&&e.groupNames.length>0&&(e.switchN=!0,this.regexp_pattern(e))},lo.regexp_pattern=function(e){e.pos=0,e.lastIntValue=0,e.lastStringValue="",e.lastAssertionIsQuantifiable=!1,e.numCapturingParens=0,e.maxBackReference=0,e.groupNames.length=0,e.backReferenceNames.length=0,this.regexp_disjunction(e),e.pos!==e.source.length&&(e.eat(41)&&e.raise("Unmatched ')'"),(e.eat(93)||e.eat(125))&&e.raise("Lone quantifier brackets")),e.maxBackReference>e.numCapturingParens&&e.raise("Invalid escape");for(var t=0,s=e.backReferenceNames;t<s.length;t+=1){var i=s[t];-1===e.groupNames.indexOf(i)&&e.raise("Invalid named capture referenced")}},lo.regexp_disjunction=function(e){for(this.regexp_alternative(e);e.eat(124);)this.regexp_alternative(e);this.regexp_eatQuantifier(e,!0)&&e.raise("Nothing to repeat"),e.eat(123)&&e.raise("Lone quantifier brackets")},lo.regexp_alternative=function(e){for(;e.pos<e.source.length&&this.regexp_eatTerm(e););},lo.regexp_eatTerm=function(e){return this.regexp_eatAssertion(e)?(e.lastAssertionIsQuantifiable&&this.regexp_eatQuantifier(e)&&e.switchU&&e.raise("Invalid quantifier"),!0):!!(e.switchU?this.regexp_eatAtom(e):this.regexp_eatExtendedAtom(e))&&(this.regexp_eatQuantifier(e),!0)},lo.regexp_eatAssertion=function(e){var t=e.pos;if(e.lastAssertionIsQuantifiable=!1,e.eat(94)||e.eat(36))return!0;if(e.eat(92)){if(e.eat(66)||e.eat(98))return!0;e.pos=t}if(e.eat(40)&&e.eat(63)){var s=!1;if(this.options.ecmaVersion>=9&&(s=e.eat(60)),e.eat(61)||e.eat(33))return this.regexp_disjunction(e),e.eat(41)||e.raise("Unterminated group"),e.lastAssertionIsQuantifiable=!s,!0}return e.pos=t,!1},lo.regexp_eatQuantifier=function(e,t){return void 0===t&&(t=!1),!!this.regexp_eatQuantifierPrefix(e,t)&&(e.eat(63),!0)},lo.regexp_eatQuantifierPrefix=function(e,t){return e.eat(42)||e.eat(43)||e.eat(63)||this.regexp_eatBracedQuantifier(e,t)},lo.regexp_eatBracedQuantifier=function(e,t){var s=e.pos;if(e.eat(123)){var i=0,n=-1;if(this.regexp_eatDecimalDigits(e)&&(i=e.lastIntValue,e.eat(44)&&this.regexp_eatDecimalDigits(e)&&(n=e.lastIntValue),e.eat(125)))return-1!==n&&n<i&&!t&&e.raise("numbers out of order in {} quantifier"),!0;e.switchU&&!t&&e.raise("Incomplete quantifier"),e.pos=s}return!1},lo.regexp_eatAtom=function(e){return this.regexp_eatPatternCharacters(e)||e.eat(46)||this.regexp_eatReverseSolidusAtomEscape(e)||this.regexp_eatCharacterClass(e)||this.regexp_eatUncapturingGroup(e)||this.regexp_eatCapturingGroup(e)},lo.regexp_eatReverseSolidusAtomEscape=function(e){var t=e.pos;if(e.eat(92)){if(this.regexp_eatAtomEscape(e))return!0;e.pos=t}return!1},lo.regexp_eatUncapturingGroup=function(e){var t=e.pos;if(e.eat(40)){if(e.eat(63)&&e.eat(58)){if(this.regexp_disjunction(e),e.eat(41))return!0;e.raise("Unterminated group")}e.pos=t}return!1},lo.regexp_eatCapturingGroup=function(e){if(e.eat(40)){if(this.options.ecmaVersion>=9?this.regexp_groupSpecifier(e):63===e.current()&&e.raise("Invalid group"),this.regexp_disjunction(e),e.eat(41))return e.numCapturingParens+=1,!0;e.raise("Unterminated group")}return!1},lo.regexp_eatExtendedAtom=function(e){return e.eat(46)||this.regexp_eatReverseSolidusAtomEscape(e)||this.regexp_eatCharacterClass(e)||this.regexp_eatUncapturingGroup(e)||this.regexp_eatCapturingGroup(e)||this.regexp_eatInvalidBracedQuantifier(e)||this.regexp_eatExtendedPatternCharacter(e)},lo.regexp_eatInvalidBracedQuantifier=function(e){return this.regexp_eatBracedQuantifier(e,!0)&&e.raise("Nothing to repeat"),!1},lo.regexp_eatSyntaxCharacter=function(e){var t=e.current();return!!po(t)&&(e.lastIntValue=t,e.advance(),!0)},lo.regexp_eatPatternCharacters=function(e){for(var t=e.pos,s=0;-1!==(s=e.current())&&!po(s);)e.advance();return e.pos!==t},lo.regexp_eatExtendedPatternCharacter=function(e){var t=e.current();return!(-1===t||36===t||t>=40&&t<=43||46===t||63===t||91===t||94===t||124===t)&&(e.advance(),!0)},lo.regexp_groupSpecifier=function(e){if(e.eat(63)){if(this.regexp_eatGroupName(e))return-1!==e.groupNames.indexOf(e.lastStringValue)&&e.raise("Duplicate capture group name"),void e.groupNames.push(e.lastStringValue);e.raise("Invalid group")}},lo.regexp_eatGroupName=function(e){if(e.lastStringValue="",e.eat(60)){if(this.regexp_eatRegExpIdentifierName(e)&&e.eat(62))return!0;e.raise("Invalid capture group name")}return!1},lo.regexp_eatRegExpIdentifierName=function(e){if(e.lastStringValue="",this.regexp_eatRegExpIdentifierStart(e)){for(e.lastStringValue+=uo(e.lastIntValue);this.regexp_eatRegExpIdentifierPart(e);)e.lastStringValue+=uo(e.lastIntValue);return!0}return!1},lo.regexp_eatRegExpIdentifierStart=function(e){var t=e.pos,s=this.options.ecmaVersion>=11,i=e.current(s);return e.advance(s),92===i&&this.regexp_eatRegExpUnicodeEscapeSequence(e,s)&&(i=e.lastIntValue),function(e){return ea(e,!0)||36===e||95===e}(i)?(e.lastIntValue=i,!0):(e.pos=t,!1)},lo.regexp_eatRegExpIdentifierPart=function(e){var t=e.pos,s=this.options.ecmaVersion>=11,i=e.current(s);return e.advance(s),92===i&&this.regexp_eatRegExpUnicodeEscapeSequence(e,s)&&(i=e.lastIntValue),function(e){return ta(e,!0)||36===e||95===e||8204===e||8205===e}(i)?(e.lastIntValue=i,!0):(e.pos=t,!1)},lo.regexp_eatAtomEscape=function(e){return!!(this.regexp_eatBackReference(e)||this.regexp_eatCharacterClassEscape(e)||this.regexp_eatCharacterEscape(e)||e.switchN&&this.regexp_eatKGroupName(e))||(e.switchU&&(99===e.current()&&e.raise("Invalid unicode escape"),e.raise("Invalid escape")),!1)},lo.regexp_eatBackReference=function(e){var t=e.pos;if(this.regexp_eatDecimalEscape(e)){var s=e.lastIntValue;if(e.switchU)return s>e.maxBackReference&&(e.maxBackReference=s),!0;if(s<=e.numCapturingParens)return!0;e.pos=t}return!1},lo.regexp_eatKGroupName=function(e){if(e.eat(107)){if(this.regexp_eatGroupName(e))return e.backReferenceNames.push(e.lastStringValue),!0;e.raise("Invalid named reference")}return!1},lo.regexp_eatCharacterEscape=function(e){return this.regexp_eatControlEscape(e)||this.regexp_eatCControlLetter(e)||this.regexp_eatZero(e)||this.regexp_eatHexEscapeSequence(e)||this.regexp_eatRegExpUnicodeEscapeSequence(e,!1)||!e.switchU&&this.regexp_eatLegacyOctalEscapeSequence(e)||this.regexp_eatIdentityEscape(e)},lo.regexp_eatCControlLetter=function(e){var t=e.pos;if(e.eat(99)){if(this.regexp_eatControlLetter(e))return!0;e.pos=t}return!1},lo.regexp_eatZero=function(e){return 48===e.current()&&!yo(e.lookahead())&&(e.lastIntValue=0,e.advance(),!0)},lo.regexp_eatControlEscape=function(e){var t=e.current();return 116===t?(e.lastIntValue=9,e.advance(),!0):110===t?(e.lastIntValue=10,e.advance(),!0):118===t?(e.lastIntValue=11,e.advance(),!0):102===t?(e.lastIntValue=12,e.advance(),!0):114===t&&(e.lastIntValue=13,e.advance(),!0)},lo.regexp_eatControlLetter=function(e){var t=e.current();return!!fo(t)&&(e.lastIntValue=t%32,e.advance(),!0)},lo.regexp_eatRegExpUnicodeEscapeSequence=function(e,t){void 0===t&&(t=!1);var s,i=e.pos,n=t||e.switchU;if(e.eat(117)){if(this.regexp_eatFixedHexDigits(e,4)){var r=e.lastIntValue;if(n&&r>=55296&&r<=56319){var a=e.pos;if(e.eat(92)&&e.eat(117)&&this.regexp_eatFixedHexDigits(e,4)){var o=e.lastIntValue;if(o>=56320&&o<=57343)return e.lastIntValue=1024*(r-55296)+(o-56320)+65536,!0}e.pos=a,e.lastIntValue=r}return!0}if(n&&e.eat(123)&&this.regexp_eatHexDigits(e)&&e.eat(125)&&((s=e.lastIntValue)>=0&&s<=1114111))return!0;n&&e.raise("Invalid unicode escape"),e.pos=i}return!1},lo.regexp_eatIdentityEscape=function(e){if(e.switchU)return!!this.regexp_eatSyntaxCharacter(e)||!!e.eat(47)&&(e.lastIntValue=47,!0);var t=e.current();return!(99===t||e.switchN&&107===t)&&(e.lastIntValue=t,e.advance(),!0)},lo.regexp_eatDecimalEscape=function(e){e.lastIntValue=0;var t=e.current();if(t>=49&&t<=57){do{e.lastIntValue=10*e.lastIntValue+(t-48),e.advance()}while((t=e.current())>=48&&t<=57);return!0}return!1},lo.regexp_eatCharacterClassEscape=function(e){var t=e.current();if(function(e){return 100===e||68===e||115===e||83===e||119===e||87===e}(t))return e.lastIntValue=-1,e.advance(),!0;if(e.switchU&&this.options.ecmaVersion>=9&&(80===t||112===t)){if(e.lastIntValue=-1,e.advance(),e.eat(123)&&this.regexp_eatUnicodePropertyValueExpression(e)&&e.eat(125))return!0;e.raise("Invalid property name")}return!1},lo.regexp_eatUnicodePropertyValueExpression=function(e){var t=e.pos;if(this.regexp_eatUnicodePropertyName(e)&&e.eat(61)){var s=e.lastStringValue;if(this.regexp_eatUnicodePropertyValue(e)){var i=e.lastStringValue;return this.regexp_validateUnicodePropertyNameAndValue(e,s,i),!0}}if(e.pos=t,this.regexp_eatLoneUnicodePropertyNameOrValue(e)){var n=e.lastStringValue;return this.regexp_validateUnicodePropertyNameOrValue(e,n),!0}return!1},lo.regexp_validateUnicodePropertyNameAndValue=function(e,t,s){ya(e.unicodeProperties.nonBinary,t)||e.raise("Invalid property name"),e.unicodeProperties.nonBinary[t].test(s)||e.raise("Invalid property value")},lo.regexp_validateUnicodePropertyNameOrValue=function(e,t){e.unicodeProperties.binary.test(t)||e.raise("Invalid property name")},lo.regexp_eatUnicodePropertyName=function(e){var t=0;for(e.lastStringValue="";mo(t=e.current());)e.lastStringValue+=uo(t),e.advance();return""!==e.lastStringValue},lo.regexp_eatUnicodePropertyValue=function(e){var t=0;for(e.lastStringValue="";go(t=e.current());)e.lastStringValue+=uo(t),e.advance();return""!==e.lastStringValue},lo.regexp_eatLoneUnicodePropertyNameOrValue=function(e){return this.regexp_eatUnicodePropertyValue(e)},lo.regexp_eatCharacterClass=function(e){if(e.eat(91)){if(e.eat(94),this.regexp_classRanges(e),e.eat(93))return!0;e.raise("Unterminated character class")}return!1},lo.regexp_classRanges=function(e){for(;this.regexp_eatClassAtom(e);){var t=e.lastIntValue;if(e.eat(45)&&this.regexp_eatClassAtom(e)){var s=e.lastIntValue;!e.switchU||-1!==t&&-1!==s||e.raise("Invalid character class"),-1!==t&&-1!==s&&t>s&&e.raise("Range out of order in character class")}}},lo.regexp_eatClassAtom=function(e){var t=e.pos;if(e.eat(92)){if(this.regexp_eatClassEscape(e))return!0;if(e.switchU){var s=e.current();(99===s||vo(s))&&e.raise("Invalid class escape"),e.raise("Invalid escape")}e.pos=t}var i=e.current();return 93!==i&&(e.lastIntValue=i,e.advance(),!0)},lo.regexp_eatClassEscape=function(e){var t=e.pos;if(e.eat(98))return e.lastIntValue=8,!0;if(e.switchU&&e.eat(45))return e.lastIntValue=45,!0;if(!e.switchU&&e.eat(99)){if(this.regexp_eatClassControlLetter(e))return!0;e.pos=t}return this.regexp_eatCharacterClassEscape(e)||this.regexp_eatCharacterEscape(e)},lo.regexp_eatClassControlLetter=function(e){var t=e.current();return!(!yo(t)&&95!==t)&&(e.lastIntValue=t%32,e.advance(),!0)},lo.regexp_eatHexEscapeSequence=function(e){var t=e.pos;if(e.eat(120)){if(this.regexp_eatFixedHexDigits(e,2))return!0;e.switchU&&e.raise("Invalid escape"),e.pos=t}return!1},lo.regexp_eatDecimalDigits=function(e){var t=e.pos,s=0;for(e.lastIntValue=0;yo(s=e.current());)e.lastIntValue=10*e.lastIntValue+(s-48),e.advance();return e.pos!==t},lo.regexp_eatHexDigits=function(e){var t=e.pos,s=0;for(e.lastIntValue=0;Eo(s=e.current());)e.lastIntValue=16*e.lastIntValue+xo(s),e.advance();return e.pos!==t},lo.regexp_eatLegacyOctalEscapeSequence=function(e){if(this.regexp_eatOctalDigit(e)){var t=e.lastIntValue;if(this.regexp_eatOctalDigit(e)){var s=e.lastIntValue;t<=3&&this.regexp_eatOctalDigit(e)?e.lastIntValue=64*t+8*s+e.lastIntValue:e.lastIntValue=8*t+s}else e.lastIntValue=t;return!0}return!1},lo.regexp_eatOctalDigit=function(e){var t=e.current();return vo(t)?(e.lastIntValue=t-48,e.advance(),!0):(e.lastIntValue=0,!1)},lo.regexp_eatFixedHexDigits=function(e,t){var s=e.pos;e.lastIntValue=0;for(var i=0;i<t;++i){var n=e.current();if(!Eo(n))return e.pos=s,!1;e.lastIntValue=16*e.lastIntValue+xo(n),e.advance()}return!0};var bo=function(e){this.type=e.type,this.value=e.value,this.start=e.start,this.end=e.end,e.options.locations&&(this.loc=new ba(e,e.startLoc,e.endLoc)),e.options.ranges&&(this.range=[e.start,e.end])},So=Ca.prototype;function Ao(e){return"function"!=typeof BigInt?null:BigInt(e.replace(/_/g,""))}function Po(e){return e<=65535?String.fromCharCode(e):(e-=65536,String.fromCharCode(55296+(e>>10),56320+(1023&e)))}So.next=function(e){!e&&this.type.keyword&&this.containsEsc&&this.raiseRecoverable(this.start,"Escape sequence in keyword "+this.type.keyword),this.options.onToken&&this.options.onToken(new bo(this)),this.lastTokEnd=this.end,this.lastTokStart=this.start,this.lastTokEndLoc=this.endLoc,this.lastTokStartLoc=this.startLoc,this.nextToken()},So.getToken=function(){return this.next(),new bo(this)},"undefined"!=typeof Symbol&&(So[Symbol.iterator]=function(){var e=this;return{next:function(){var t=e.getToken();return{done:t.type===ha.eof,value:t}}}}),So.nextToken=function(){var e=this.curContext();return e&&e.preserveSpace||this.skipSpace(),this.start=this.pos,this.options.locations&&(this.startLoc=this.curPosition()),this.pos>=this.input.length?this.finishToken(ha.eof):e.override?e.override(this):void this.readToken(this.fullCharCodeAtPos())},So.readToken=function(e){return ea(e,this.options.ecmaVersion>=6)||92===e?this.readWord():this.getTokenFromCode(e)},So.fullCharCodeAtPos=function(){var e=this.input.charCodeAt(this.pos);if(e<=55295||e>=56320)return e;var t=this.input.charCodeAt(this.pos+1);return t<=56319||t>=57344?e:(e<<10)+t-56613888},So.skipBlockComment=function(){var e,t=this.options.onComment&&this.curPosition(),s=this.pos,i=this.input.indexOf("*/",this.pos+=2);if(-1===i&&this.raise(this.pos-2,"Unterminated comment"),this.pos=i+2,this.options.locations)for(ca.lastIndex=s;(e=ca.exec(this.input))&&e.index<this.pos;)++this.curLine,this.lineStart=e.index+e[0].length;this.options.onComment&&this.options.onComment(!0,this.input.slice(s+2,i),s,this.pos,t,this.curPosition())},So.skipLineComment=function(e){for(var t=this.pos,s=this.options.onComment&&this.curPosition(),i=this.input.charCodeAt(this.pos+=e);this.pos<this.input.length&&!ua(i);)i=this.input.charCodeAt(++this.pos);this.options.onComment&&this.options.onComment(!1,this.input.slice(t+e,this.pos),t,this.pos,s,this.curPosition())},So.skipSpace=function(){e:for(;this.pos<this.input.length;){var e=this.input.charCodeAt(this.pos);switch(e){case 32:case 160:++this.pos;break;case 13:10===this.input.charCodeAt(this.pos+1)&&++this.pos;case 10:case 8232:case 8233:++this.pos,this.options.locations&&(++this.curLine,this.lineStart=this.pos);break;case 47:switch(this.input.charCodeAt(this.pos+1)){case 42:this.skipBlockComment();break;case 47:this.skipLineComment(2);break;default:break e}break;default:if(!(e>8&&e<14||e>=5760&&da.test(String.fromCharCode(e))))break e;++this.pos}}},So.finishToken=function(e,t){this.end=this.pos,this.options.locations&&(this.endLoc=this.curPosition());var s=this.type;this.type=e,this.value=t,this.updateContext(s)},So.readToken_dot=function(){var e=this.input.charCodeAt(this.pos+1);if(e>=48&&e<=57)return this.readNumber(!0);var t=this.input.charCodeAt(this.pos+2);return this.options.ecmaVersion>=6&&46===e&&46===t?(this.pos+=3,this.finishToken(ha.ellipsis)):(++this.pos,this.finishToken(ha.dot))},So.readToken_slash=function(){var e=this.input.charCodeAt(this.pos+1);return this.exprAllowed?(++this.pos,this.readRegexp()):61===e?this.finishOp(ha.assign,2):this.finishOp(ha.slash,1)},So.readToken_mult_modulo_exp=function(e){var t=this.input.charCodeAt(this.pos+1),s=1,i=42===e?ha.star:ha.modulo;return this.options.ecmaVersion>=7&&42===e&&42===t&&(++s,i=ha.starstar,t=this.input.charCodeAt(this.pos+2)),61===t?this.finishOp(ha.assign,s+1):this.finishOp(i,s)},So.readToken_pipe_amp=function(e){var t=this.input.charCodeAt(this.pos+1);if(t===e){if(this.options.ecmaVersion>=12)if(61===this.input.charCodeAt(this.pos+2))return this.finishOp(ha.assign,3);return this.finishOp(124===e?ha.logicalOR:ha.logicalAND,2)}return 61===t?this.finishOp(ha.assign,2):this.finishOp(124===e?ha.bitwiseOR:ha.bitwiseAND,1)},So.readToken_caret=function(){return 61===this.input.charCodeAt(this.pos+1)?this.finishOp(ha.assign,2):this.finishOp(ha.bitwiseXOR,1)},So.readToken_plus_min=function(e){var t=this.input.charCodeAt(this.pos+1);return t===e?45!==t||this.inModule||62!==this.input.charCodeAt(this.pos+2)||0!==this.lastTokEnd&&!la.test(this.input.slice(this.lastTokEnd,this.pos))?this.finishOp(ha.incDec,2):(this.skipLineComment(3),this.skipSpace(),this.nextToken()):61===t?this.finishOp(ha.assign,2):this.finishOp(ha.plusMin,1)},So.readToken_lt_gt=function(e){var t=this.input.charCodeAt(this.pos+1),s=1;return t===e?(s=62===e&&62===this.input.charCodeAt(this.pos+2)?3:2,61===this.input.charCodeAt(this.pos+s)?this.finishOp(ha.assign,s+1):this.finishOp(ha.bitShift,s)):33!==t||60!==e||this.inModule||45!==this.input.charCodeAt(this.pos+2)||45!==this.input.charCodeAt(this.pos+3)?(61===t&&(s=2),this.finishOp(ha.relational,s)):(this.skipLineComment(4),this.skipSpace(),this.nextToken())},So.readToken_eq_excl=function(e){var t=this.input.charCodeAt(this.pos+1);return 61===t?this.finishOp(ha.equality,61===this.input.charCodeAt(this.pos+2)?3:2):61===e&&62===t&&this.options.ecmaVersion>=6?(this.pos+=2,this.finishToken(ha.arrow)):this.finishOp(61===e?ha.eq:ha.prefix,1)},So.readToken_question=function(){var e=this.options.ecmaVersion;if(e>=11){var t=this.input.charCodeAt(this.pos+1);if(46===t){var s=this.input.charCodeAt(this.pos+2);if(s<48||s>57)return this.finishOp(ha.questionDot,2)}if(63===t){if(e>=12)if(61===this.input.charCodeAt(this.pos+2))return this.finishOp(ha.assign,3);return this.finishOp(ha.coalesce,2)}}return this.finishOp(ha.question,1)},So.readToken_numberSign=function(){var e=35;if(this.options.ecmaVersion>=13&&(++this.pos,ea(e=this.fullCharCodeAtPos(),!0)||92===e))return this.finishToken(ha.privateId,this.readWord1());this.raise(this.pos,"Unexpected character '"+Po(e)+"'")},So.getTokenFromCode=function(e){switch(e){case 46:return this.readToken_dot();case 40:return++this.pos,this.finishToken(ha.parenL);case 41:return++this.pos,this.finishToken(ha.parenR);case 59:return++this.pos,this.finishToken(ha.semi);case 44:return++this.pos,this.finishToken(ha.comma);case 91:return++this.pos,this.finishToken(ha.bracketL);case 93:return++this.pos,this.finishToken(ha.bracketR);case 123:return++this.pos,this.finishToken(ha.braceL);case 125:return++this.pos,this.finishToken(ha.braceR);case 58:return++this.pos,this.finishToken(ha.colon);case 96:if(this.options.ecmaVersion<6)break;return++this.pos,this.finishToken(ha.backQuote);case 48:var t=this.input.charCodeAt(this.pos+1);if(120===t||88===t)return this.readRadixNumber(16);if(this.options.ecmaVersion>=6){if(111===t||79===t)return this.readRadixNumber(8);if(98===t||66===t)return this.readRadixNumber(2)}case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return this.readNumber(!1);case 34:case 39:return this.readString(e);case 47:return this.readToken_slash();case 37:case 42:return this.readToken_mult_modulo_exp(e);case 124:case 38:return this.readToken_pipe_amp(e);case 94:return this.readToken_caret();case 43:case 45:return this.readToken_plus_min(e);case 60:case 62:return this.readToken_lt_gt(e);case 61:case 33:return this.readToken_eq_excl(e);case 63:return this.readToken_question();case 126:return this.finishOp(ha.prefix,1);case 35:return this.readToken_numberSign()}this.raise(this.pos,"Unexpected character '"+Po(e)+"'")},So.finishOp=function(e,t){var s=this.input.slice(this.pos,this.pos+t);return this.pos+=t,this.finishToken(e,s)},So.readRegexp=function(){for(var e,t,s=this.pos;;){this.pos>=this.input.length&&this.raise(s,"Unterminated regular expression");var i=this.input.charAt(this.pos);if(la.test(i)&&this.raise(s,"Unterminated regular expression"),e)e=!1;else{if("["===i)t=!0;else if("]"===i&&t)t=!1;else if("/"===i&&!t)break;e="\\"===i}++this.pos}var n=this.input.slice(s,this.pos);++this.pos;var r=this.pos,a=this.readWord1();this.containsEsc&&this.unexpected(r);var o=this.regexpState||(this.regexpState=new co(this));o.reset(s,n,a),this.validateRegExpFlags(o),this.validateRegExpPattern(o);var h=null;try{h=new RegExp(n,a)}catch(e){}return this.finishToken(ha.regexp,{pattern:n,flags:a,value:h})},So.readInt=function(e,t,s){for(var i=this.options.ecmaVersion>=12&&void 0===t,n=s&&48===this.input.charCodeAt(this.pos),r=this.pos,a=0,o=0,h=0,l=null==t?1/0:t;h<l;++h,++this.pos){var c=this.input.charCodeAt(this.pos),u=void 0;if(i&&95===c)n&&this.raiseRecoverable(this.pos,"Numeric separator is not allowed in legacy octal numeric literals"),95===o&&this.raiseRecoverable(this.pos,"Numeric separator must be exactly one underscore"),0===h&&this.raiseRecoverable(this.pos,"Numeric separator is not allowed at the first of digits"),o=c;else{if((u=c>=97?c-97+10:c>=65?c-65+10:c>=48&&c<=57?c-48:1/0)>=e)break;o=c,a=a*e+u}}return i&&95===o&&this.raiseRecoverable(this.pos-1,"Numeric separator is not allowed at the last of digits"),this.pos===r||null!=t&&this.pos-r!==t?null:a},So.readRadixNumber=function(e){var t=this.pos;this.pos+=2;var s=this.readInt(e);return null==s&&this.raise(this.start+2,"Expected number in radix "+e),this.options.ecmaVersion>=11&&110===this.input.charCodeAt(this.pos)?(s=Ao(this.input.slice(t,this.pos)),++this.pos):ea(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number"),this.finishToken(ha.num,s)},So.readNumber=function(e){var t=this.pos;e||null!==this.readInt(10,void 0,!0)||this.raise(t,"Invalid number");var s=this.pos-t>=2&&48===this.input.charCodeAt(t);s&&this.strict&&this.raise(t,"Invalid number");var i=this.input.charCodeAt(this.pos);if(!s&&!e&&this.options.ecmaVersion>=11&&110===i){var n=Ao(this.input.slice(t,this.pos));return++this.pos,ea(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number"),this.finishToken(ha.num,n)}s&&/[89]/.test(this.input.slice(t,this.pos))&&(s=!1),46!==i||s||(++this.pos,this.readInt(10),i=this.input.charCodeAt(this.pos)),69!==i&&101!==i||s||(43!==(i=this.input.charCodeAt(++this.pos))&&45!==i||++this.pos,null===this.readInt(10)&&this.raise(t,"Invalid number")),ea(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number");var r,a=(r=this.input.slice(t,this.pos),s?parseInt(r,8):parseFloat(r.replace(/_/g,"")));return this.finishToken(ha.num,a)},So.readCodePoint=function(){var e;if(123===this.input.charCodeAt(this.pos)){this.options.ecmaVersion<6&&this.unexpected();var t=++this.pos;e=this.readHexChar(this.input.indexOf("}",this.pos)-this.pos),++this.pos,e>1114111&&this.invalidStringToken(t,"Code point out of bounds")}else e=this.readHexChar(4);return e},So.readString=function(e){for(var t="",s=++this.pos;;){this.pos>=this.input.length&&this.raise(this.start,"Unterminated string constant");var i=this.input.charCodeAt(this.pos);if(i===e)break;92===i?(t+=this.input.slice(s,this.pos),t+=this.readEscapedChar(!1),s=this.pos):8232===i||8233===i?(this.options.ecmaVersion<10&&this.raise(this.start,"Unterminated string constant"),++this.pos,this.options.locations&&(this.curLine++,this.lineStart=this.pos)):(ua(i)&&this.raise(this.start,"Unterminated string constant"),++this.pos)}return t+=this.input.slice(s,this.pos++),this.finishToken(ha.string,t)};var ko={};So.tryReadTemplateToken=function(){this.inTemplateElement=!0;try{this.readTmplToken()}catch(e){if(e!==ko)throw e;this.readInvalidTemplateToken()}this.inTemplateElement=!1},So.invalidStringToken=function(e,t){if(this.inTemplateElement&&this.options.ecmaVersion>=9)throw ko;this.raise(e,t)},So.readTmplToken=function(){for(var e="",t=this.pos;;){this.pos>=this.input.length&&this.raise(this.start,"Unterminated template");var s=this.input.charCodeAt(this.pos);if(96===s||36===s&&123===this.input.charCodeAt(this.pos+1))return this.pos!==this.start||this.type!==ha.template&&this.type!==ha.invalidTemplate?(e+=this.input.slice(t,this.pos),this.finishToken(ha.template,e)):36===s?(this.pos+=2,this.finishToken(ha.dollarBraceL)):(++this.pos,this.finishToken(ha.backQuote));if(92===s)e+=this.input.slice(t,this.pos),e+=this.readEscapedChar(!0),t=this.pos;else if(ua(s)){switch(e+=this.input.slice(t,this.pos),++this.pos,s){case 13:10===this.input.charCodeAt(this.pos)&&++this.pos;case 10:e+="\n";break;default:e+=String.fromCharCode(s)}this.options.locations&&(++this.curLine,this.lineStart=this.pos),t=this.pos}else++this.pos}},So.readInvalidTemplateToken=function(){for(;this.pos<this.input.length;this.pos++)switch(this.input[this.pos]){case"\\":++this.pos;break;case"$":if("{"!==this.input[this.pos+1])break;case"`":return this.finishToken(ha.invalidTemplate,this.input.slice(this.start,this.pos))}this.raise(this.start,"Unterminated template")},So.readEscapedChar=function(e){var t=this.input.charCodeAt(++this.pos);switch(++this.pos,t){case 110:return"\n";case 114:return"\r";case 120:return String.fromCharCode(this.readHexChar(2));case 117:return Po(this.readCodePoint());case 116:return"\t";case 98:return"\b";case 118:return"\v";case 102:return"\f";case 13:10===this.input.charCodeAt(this.pos)&&++this.pos;case 10:return this.options.locations&&(this.lineStart=this.pos,++this.curLine),"";case 56:case 57:if(this.strict&&this.invalidStringToken(this.pos-1,"Invalid escape sequence"),e){var s=this.pos-1;return this.invalidStringToken(s,"Invalid escape sequence in template string"),null}default:if(t>=48&&t<=55){var i=this.input.substr(this.pos-1,3).match(/^[0-7]+/)[0],n=parseInt(i,8);return n>255&&(i=i.slice(0,-1),n=parseInt(i,8)),this.pos+=i.length-1,t=this.input.charCodeAt(this.pos),"0"===i&&56!==t&&57!==t||!this.strict&&!e||this.invalidStringToken(this.pos-1-i.length,e?"Octal literal in template string":"Octal literal in strict mode"),String.fromCharCode(n)}return ua(t)?"":String.fromCharCode(t)}},So.readHexChar=function(e){var t=this.pos,s=this.readInt(16,e);return null===s&&this.invalidStringToken(t,"Bad character escape sequence"),s},So.readWord1=function(){this.containsEsc=!1;for(var e="",t=!0,s=this.pos,i=this.options.ecmaVersion>=6;this.pos<this.input.length;){var n=this.fullCharCodeAtPos();if(ta(n,i))this.pos+=n<=65535?1:2;else{if(92!==n)break;this.containsEsc=!0,e+=this.input.slice(s,this.pos);var r=this.pos;117!==this.input.charCodeAt(++this.pos)&&this.invalidStringToken(this.pos,"Expecting Unicode escape sequence \\uXXXX"),++this.pos;var a=this.readCodePoint();(t?ea:ta)(a,i)||this.invalidStringToken(r,"Invalid Unicode escape"),e+=Po(a),s=this.pos}t=!1}return e+this.input.slice(s,this.pos)},So.readWord=function(){var e=this.readWord1(),t=ha.name;return this.keywords.test(e)&&(t=aa[e]),this.finishToken(t,e)};Ca.acorn={Parser:Ca,version:"8.5.0",defaultOptions:Aa,Position:va,SourceLocation:ba,getLineInfo:Sa,Node:Ya,TokenType:sa,tokTypes:ha,keywordTypes:aa,TokContext:za,tokContexts:Wa,isIdentifierChar:ta,isIdentifierStart:ea,Token:bo,isNewLine:ua,lineBreak:la,lineBreakG:ca,nonASCIIwhitespace:da};const wo=e=>()=>{Ks({code:"NO_FS_IN_BROWSER",message:`Cannot access the file system (via "${e}") when using the browser build of Rollup. Make sure you supply a plugin with custom resolveId and load hooks to Rollup.`,url:"https://rollupjs.org/guide/en/#a-simple-example"})},Co=wo("fs.readFile"),Io=wo("fs.writeFile");class No{constructor(e=1){this.maxParallel=e,this.queue=new Array,this.workerCount=0}run(e){return new Promise(((t,s)=>{this.queue.push({reject:s,resolve:t,task:e}),this.work()}))}async work(){if(this.workerCount>=this.maxParallel)return;let e;for(this.workerCount++;e=this.queue.shift();){const{reject:t,resolve:s,task:i}=e;try{s(await i())}catch(e){t(e)}}this.workerCount--}}async function _o(e,t,s,i,n,r,a,o){const h=await function(e,t,s,i,n,r,a){let o=null,h=null;if(n){o=new Set;for(const s of n)e===s.source&&t===s.importer&&o.add(s.plugin);h=(e,t)=>({...e,resolve:(e,s,{custom:r,isEntry:a,skipSelf:o}=q)=>i(e,s,r,a,o?[...n,{importer:s,plugin:t,source:e}]:n)})}return s.hookFirst("resolveId",[e,t,{custom:r,isEntry:a}],h,o)}(e,t,i,n,r,a,o);return h}function $o(e,t,{hook:s,id:i}={}){return"string"==typeof e&&(e={message:e}),e.code&&e.code!==Ys.PLUGIN_ERROR&&(e.pluginCode=e.code),e.code=Ys.PLUGIN_ERROR,e.plugin=t,s&&(e.hook=s),i&&(e.id=i),Ks(e)}const To=[{active:!0,deprecated:"resolveAssetUrl",replacement:"resolveFileUrl"}];const Ro={delete:()=>!1,get(){},has:()=>!1,set(){}};function Mo(e){return e.startsWith("at position ")||e.startsWith("at output position ")?Ks({code:"ANONYMOUS_PLUGIN_CACHE",message:"A plugin is trying to use the Rollup cache but is not declaring a plugin name or cacheKey."}):Ks({code:"DUPLICATE_PLUGIN_NAME",message:`The plugin name ${e} is being used twice in the same build. Plugin names must be distinct or provide a cacheKey (please post an issue to the plugin if you are a plugin user).`})}function Do(e,t,s,i){const n=t.id,r=[];let a=null===e.map?null:yr(e.map);const o=e.code;let h=e.ast;const c=[],u=[];let d=!1;const p=()=>d=!0;let f;const m=e.code;return s.hookReduceArg0("transform",[m,n],(function(e,s,n){let a,o;if("string"==typeof s)a=s;else{if(!s||"object"!=typeof s)return e;if(t.updateOptions(s),null==s.code)return(s.map||s.ast)&&i((l=n.name,{code:Ys.NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE,message:`The plugin "${l}" returned a "map" or "ast" without returning a "code". This will be ignored.`})),e;({code:a,map:o,ast:h}=s)}var l;return null!==o&&r.push(yr("string"==typeof o?JSON.parse(o):o)||{missing:!0,plugin:n.name}),a}),((e,t)=>{return f=t,{...e,addWatchFile(t){c.push(t),e.addWatchFile(t)},cache:d?e.cache:(h=e.cache,g=p,{delete:e=>(g(),h.delete(e)),get:e=>(g(),h.get(e)),has:e=>(g(),h.has(e)),set:(e,t)=>(g(),h.set(e,t))}),emitAsset:(t,s)=>(u.push({name:t,source:s,type:"asset"}),e.emitAsset(t,s)),emitChunk:(t,s)=>(u.push({id:t,name:s&&s.name,type:"chunk"}),e.emitChunk(t,s)),emitFile:e=>(u.push(e),s.emitFile(e)),error:(t,s)=>("string"==typeof t&&(t={message:t}),s&&Xs(t,s,m,n),t.id=n,t.hook="transform",e.error(t)),getCombinedSourcemap(){const e=function(e,t,s,i,n){return i.length?{version:3,...bn(e,t,s,i,vn(n)).traceMappings()}:s}(n,o,a,r,i);if(!e){return new b(o).generateMap({hires:!0,includeContent:!0,source:n})}return a!==e&&(a=e,r.length=0),new l({...e,file:null,sourcesContent:e.sourcesContent})},setAssetSource(){return this.error({code:"INVALID_SETASSETSOURCE",message:"setAssetSource cannot be called in transform for caching reasons. Use emitFile with a source, or call setAssetSource in another hook."})},warn(t,s){"string"==typeof t&&(t={message:t}),s&&Xs(t,s,m,n),t.id=n,t.hook="transform",e.warn(t)}};var h,g})).catch((e=>$o(e,f.name,{hook:"transform",id:n}))).then((e=>(d||u.length&&(t.transformFiles=u),{ast:h,code:e,customTransformCache:d,meta:t.info.meta,originalCode:o,originalSourcemap:a,sourcemapChain:r,transformDependencies:c})))}class Lo{constructor(e,t,s,i){this.graph=e,this.modulesById=t,this.options=s,this.pluginDriver=i,this.implicitEntryModules=new Set,this.indexedEntryModules=[],this.latestLoadModulesPromise=Promise.resolve(),this.nextEntryModuleIndex=0,this.readQueue=new No,this.resolveId=async(e,t,s,i,n=null)=>this.addDefaultsToResolvedId(this.getNormalizedResolvedIdWithoutDefaults(!this.options.external(e,t,!1)&&await _o(e,t,this.options.preserveSymlinks,this.pluginDriver,this.resolveId,n,s,"boolean"==typeof i?i:!t),t,e)),this.hasModuleSideEffects=s.treeshake?s.treeshake.moduleSideEffects:()=>!0,this.readQueue.maxParallel=s.maxParallelFileReads}async addAdditionalModules(e){const t=this.extendLoadModulesPromise(Promise.all(e.map((e=>this.loadEntryModule(e,!1,void 0,null)))));return await this.awaitLoadModulesPromise(),t}async addEntryModules(e,t){const s=this.nextEntryModuleIndex;this.nextEntryModuleIndex+=e.length;const i=await this.extendLoadModulesPromise(Promise.all(e.map((({id:e,importer:t})=>this.loadEntryModule(e,!0,t,null)))).then((i=>{let n=s;for(let s=0;s<i.length;s++){const r=i[s];r.isUserDefinedEntryPoint=r.isUserDefinedEntryPoint||t,Vo(r,e[s],t);const a=this.indexedEntryModules.find((e=>e.module===r));a?a.index=Math.min(a.index,n):this.indexedEntryModules.push({index:n,module:r}),n++}return this.indexedEntryModules.sort((({index:e},{index:t})=>e>t?1:-1)),i})));return await this.awaitLoadModulesPromise(),{entryModules:this.indexedEntryModules.map((({module:e})=>e)),implicitEntryModules:[...this.implicitEntryModules],newEntryModules:i}}async emitChunk({fileName:e,id:t,importer:s,name:i,implicitlyLoadedAfterOneOf:n,preserveSignature:r}){const a={fileName:e||null,id:t,importer:s,name:i||null},o=n?await this.addEntryWithImplicitDependants(a,n):(await this.addEntryModules([a],!1)).newEntryModules[0];return null!=r&&(o.preserveSignature=r),o}addDefaultsToResolvedId(e){var t,s;if(!e)return null;const i=e.external||!1;return{external:i,id:e.id,meta:e.meta||K,moduleSideEffects:null!==(t=e.moduleSideEffects)&&void 0!==t?t:this.hasModuleSideEffects(e.id,!!i),syntheticNamedExports:null!==(s=e.syntheticNamedExports)&&void 0!==s&&s}}addEntryWithImplicitDependants(e,t){return this.extendLoadModulesPromise(this.loadEntryModule(e.id,!1,e.importer,null).then((async s=>{if(Vo(s,e,!1),!s.info.isEntry){this.implicitEntryModules.add(s);const i=await Promise.all(t.map((t=>this.loadEntryModule(t,!1,e.importer,s.id))));for(const e of i)s.implicitlyLoadedAfter.add(e);for(const e of s.implicitlyLoadedAfter)e.implicitlyLoadedBefore.add(s)}return s})))}async addModuleSource(e,t,s){let i;Bi("load modules",3);try{i=await this.readQueue.run((async()=>{var t;return null!==(t=await this.pluginDriver.hookFirst("load",[e]))&&void 0!==t?t:await Co(e)}))}catch(s){Fi("load modules",3);let i=`Could not load ${e}`;throw t&&(i+=` (imported by ${ne(t)})`),i+=`: ${s.message}`,s.message=i,s}Fi("load modules",3);const n="string"==typeof i?{code:i}:"object"==typeof i&&"string"==typeof i.code?i:Ks(function(e){return{code:Ys.BAD_LOADER,message:`Error loading ${ne(e)}: plugin load hook should return a string, a { code, map } object, or nothing/null`}}(e)),r=this.graph.cachedModules.get(e);if(r&&!r.customTransformCache&&r.originalCode===n.code){if(r.transformFiles)for(const e of r.transformFiles)this.pluginDriver.emitFile(e);s.setSource(r)}else s.updateOptions(n),s.setSource(await Do(n,s,this.pluginDriver,this.options.onwarn))}async awaitLoadModulesPromise(){let e;do{e=this.latestLoadModulesPromise,await e}while(e!==this.latestLoadModulesPromise)}extendLoadModulesPromise(e){return this.latestLoadModulesPromise=Promise.all([e,this.latestLoadModulesPromise]),this.latestLoadModulesPromise.catch((()=>{})),e}async fetchDynamicDependencies(e,t){const s=await Promise.all(t.map((t=>t.then((async([t,s])=>null===s?null:"string"==typeof s?(t.resolution=s,null):t.resolution=await this.fetchResolvedDependency(ne(s.id),e.id,s))))));for(const t of s)t&&(e.dynamicDependencies.add(t),t.dynamicImporters.push(e.id))}async fetchModule({id:e,meta:t,moduleSideEffects:s,syntheticNamedExports:i},n,r){const a=this.modulesById.get(e);if(a instanceof qi){if(r){a.info.isEntry=!0,this.implicitEntryModules.delete(a);for(const e of a.implicitlyLoadedAfter)e.implicitlyLoadedBefore.delete(a);a.implicitlyLoadedAfter.clear()}return a}const o=new qi(this.graph,e,this.options,r,s,i,t);this.modulesById.set(e,o),this.graph.watchFiles[e]=!0,await this.addModuleSource(e,n,o);const h=this.getResolveStaticDependencyPromises(o),l=this.getResolveDynamicImportPromises(o);return Promise.all([...h,...l]).then((()=>this.pluginDriver.hookParallel("moduleParsed",[o.info]))).catch((()=>{})),await Promise.all([this.fetchStaticDependencies(o,h),this.fetchDynamicDependencies(o,l)]),o.linkImports(),o}fetchResolvedDependency(e,t,s){if(s.external){const{external:i,id:n,moduleSideEffects:r,meta:a}=s;this.modulesById.has(n)||this.modulesById.set(n,new ae(this.options,n,r,a,"absolute"!==i&&P(n)));const o=this.modulesById.get(n);return o instanceof ae?Promise.resolve(o):Ks(function(e,t){return{code:Ys.INVALID_EXTERNAL_ID,message:`'${e}' is imported as an external by ${ne(t)}, but is already an existing non-external module id.`}}(e,t))}return this.fetchModule(s,t,!1)}async fetchStaticDependencies(e,t){for(const s of await Promise.all(t.map((t=>t.then((([t,s])=>this.fetchResolvedDependency(t,e.id,s)))))))e.dependencies.add(s),s.importers.push(e.id);if(!this.options.treeshake||"no-treeshake"===e.info.hasModuleSideEffects)for(const t of e.dependencies)t instanceof qi&&(t.importedFromNotTreeshaken=!0)}getNormalizedResolvedIdWithoutDefaults(e,t,s){const{makeAbsoluteExternalsRelative:i}=this.options;if(e){if("object"==typeof e){const n=e.external||this.options.external(e.id,t,!0);return{...e,external:n&&("relative"===n||!P(e.id)||!0===n&&Bo(e.id,s,i)||"absolute")}}const n=this.options.external(e,t,!0);return{external:n&&(Bo(e,s,i)||"absolute"),id:n&&i?Oo(e,t):e}}const n=i?Oo(s,t):s;return!1===e||this.options.external(n,t,!0)?{external:Bo(n,s,i)||"absolute",id:n}:null}getResolveDynamicImportPromises(e){return e.dynamicImports.map((async t=>{const s=await this.resolveDynamicImport(e,"string"==typeof t.argument?t.argument:t.argument.esTreeNode,e.id);return s&&"object"==typeof s&&(t.id=s.id),[t,s]}))}getResolveStaticDependencyPromises(e){return Array.from(e.sources,(async t=>[t,e.resolvedIds[t]=e.resolvedIds[t]||this.handleResolveId(await this.resolveId(t,e.id,K,!1),t,e.id)]))}handleResolveId(e,t,s){return null===e?k(t)?Ks(function(e,t){return{code:Ys.UNRESOLVED_IMPORT,message:`Could not resolve '${e}' from ${ne(t)}`}}(t,s)):(this.options.onwarn(function(e,t){return{code:Ys.UNRESOLVED_IMPORT,importer:ne(t),message:`'${e}' is imported by ${ne(t)}, but could not be resolved – treating it as an external dependency`,source:e,url:"https://rollupjs.org/guide/en/#warning-treating-module-as-external-dependency"}}(t,s)),{external:!0,id:t,meta:K,moduleSideEffects:this.hasModuleSideEffects(t,!0),syntheticNamedExports:!1}):(e.external&&e.syntheticNamedExports&&this.options.onwarn(function(e,t){return{code:Ys.EXTERNAL_SYNTHETIC_EXPORTS,importer:ne(t),message:`External '${e}' can not have 'syntheticNamedExports' enabled.`,source:e}}(t,s)),e)}async loadEntryModule(e,t,s,i){const n=await _o(e,s,this.options.preserveSymlinks,this.pluginDriver,this.resolveId,null,K,!0);return null==n?Ks(null===i?function(e){return{code:Ys.UNRESOLVED_ENTRY,message:`Could not resolve entry module (${ne(e)}).`}}(e):function(e,t){return{code:Ys.MISSING_IMPLICIT_DEPENDANT,message:`Module "${ne(e)}" that should be implicitly loaded before "${ne(t)}" could not be resolved.`}}(e,i)):!1===n||"object"==typeof n&&n.external?Ks(null===i?function(e){return{code:Ys.UNRESOLVED_ENTRY,message:`Entry module cannot be external (${ne(e)}).`}}(e):function(e,t){return{code:Ys.MISSING_IMPLICIT_DEPENDANT,message:`Module "${ne(e)}" that should be implicitly loaded before "${ne(t)}" cannot be external.`}}(e,i)):this.fetchModule(this.addDefaultsToResolvedId("object"==typeof n?n:{id:n}),void 0,t)}async resolveDynamicImport(e,t,s){const i=await this.pluginDriver.hookFirst("resolveDynamicImport",[t,s]);return"string"!=typeof t?"string"==typeof i?i:i?{external:!1,moduleSideEffects:!0,...i}:null:null==i?e.resolvedIds[t]=e.resolvedIds[t]||this.handleResolveId(await this.resolveId(t,e.id,K,!1),t,e.id):this.handleResolveId(this.addDefaultsToResolvedId(this.getNormalizedResolvedIdWithoutDefaults(i,s,t)),t,s)}}function Oo(e,t){return k(e)?t?$(t,"..",e):$(e):e}function Vo(e,{fileName:t,name:s},i){null!==t?e.chunkFileNames.add(t):null!==s&&(null===e.chunkName&&(e.chunkName=s),i&&e.userChunkNames.add(s))}function Bo(e,t,s){return!0===s||"ifRelativeSource"===s&&k(t)||!P(e)}class Fo extends at{constructor(){super(),this.parent=null,this.variables.set("undefined",new bi)}findVariable(e){let t=this.variables.get(e);return t||(t=new vt(e),this.variables.set(e,t)),t}}function zo(e,t,s,i,n,r){let a=!1;return(...o)=>(a||(a=!0,hi({message:`The "this.${t}" plugin context function used by plugin ${i} is deprecated. The "this.${s}" plugin context function should be used instead.`,plugin:i},n,r)),e(...o))}function Wo(e,t,s,i,n,r){let a,o=!0;if("string"!=typeof e.cacheKey&&(e.name.startsWith("at position ")||e.name.startsWith("at output position ")||r.has(e.name)?o=!1:r.add(e.name)),t)if(o){const s=e.cacheKey||e.name;l=t[s]||(t[s]=Object.create(null)),a={delete:e=>delete l[e],get(e){const t=l[e];if(t)return t[0]=0,t[1]},has(e){const t=l[e];return!!t&&(t[0]=0,!0)},set(e,t){l[e]=[0,t]}}}else h=e.name,a={delete:()=>Mo(h),get:()=>Mo(h),has:()=>Mo(h),set:()=>Mo(h)};else a=Ro;var h,l;const c={addWatchFile(e){if(s.phase>=Pr.GENERATE)return this.error({code:Ys.INVALID_ROLLUP_PHASE,message:"Cannot call addWatchFile after the build has finished."});s.watchFiles[e]=!0},cache:a,emitAsset:zo(((e,t)=>n.emitFile({name:e,source:t,type:"asset"})),"emitAsset","emitFile",e.name,!0,i),emitChunk:zo(((e,t)=>n.emitFile({id:e,name:t&&t.name,type:"chunk"})),"emitChunk","emitFile",e.name,!0,i),emitFile:n.emitFile.bind(n),error:t=>$o(t,e.name),getAssetFileName:zo(n.getFileName,"getAssetFileName","getFileName",e.name,!0,i),getChunkFileName:zo(n.getFileName,"getChunkFileName","getFileName",e.name,!0,i),getFileName:n.getFileName,getModuleIds:()=>s.modulesById.keys(),getModuleInfo:s.getModuleInfo,getWatchFiles:()=>Object.keys(s.watchFiles),isExternal:zo(((e,t,s=!1)=>i.external(e,t,s)),"isExternal","resolve",e.name,!0,i),meta:{rollupVersion:"2.58.0",watchMode:s.watchMode},get moduleIds(){const t=s.modulesById.keys();return function*(){hi({message:`Accessing "this.moduleIds" on the plugin context by plugin ${e.name} is deprecated. The "this.getModuleIds" plugin context function should be used instead.`,plugin:e.name},!1,i),yield*t}()},parse:s.contextParse.bind(s),resolve:(t,i,{custom:n,isEntry:r,skipSelf:a}=q)=>s.moduleLoader.resolveId(t,i,n,r,a?[{importer:i,plugin:e,source:t}]:null),resolveId:zo(((e,t)=>s.moduleLoader.resolveId(e,t,q,void 0).then((e=>e&&e.id))),"resolveId","resolve",e.name,!0,i),setAssetSource:n.setAssetSource,warn(t){"string"==typeof t&&(t={message:t}),t.code&&(t.pluginCode=t.code),t.code="PLUGIN_WARNING",t.plugin=e.name,i.onwarn(t)}};return c}const jo=Object.keys({buildEnd:1,buildStart:1,closeBundle:1,closeWatcher:1,load:1,moduleParsed:1,options:1,resolveDynamicImport:1,resolveId:1,transform:1,watchChange:1});function Uo(e,t){return Ks({code:"INVALID_PLUGIN_HOOK",message:`Error running plugin hook ${e} for ${t}, expected a function hook.`})}class Go{constructor(e,t,s,i,n){this.graph=e,this.options=t,this.pluginContexts=new Map,function(e,t){for(const{active:s,deprecated:i,replacement:n}of To)for(const r of e)i in r&&hi({message:`The "${i}" hook used by plugin ${r.name} is deprecated. The "${n}" hook should be used instead.`,plugin:r.name},s,t)}(s,t),this.pluginCache=i,this.fileEmitter=new _r(e,t,n&&n.fileEmitter),this.emitFile=this.fileEmitter.emitFile.bind(this.fileEmitter),this.getFileName=this.fileEmitter.getFileName.bind(this.fileEmitter),this.finaliseAssets=this.fileEmitter.assertAssetsFinalized.bind(this.fileEmitter),this.setOutputBundle=this.fileEmitter.setOutputBundle.bind(this.fileEmitter),this.plugins=s.concat(n?n.plugins:[]);const r=new Set;for(const s of this.plugins)this.pluginContexts.set(s,Wo(s,i,e,t,this.fileEmitter,r));if(n)for(const e of s)for(const s of jo)s in e&&t.onwarn((a=e.name,o=s,{code:Ys.INPUT_HOOK_IN_OUTPUT_PLUGIN,message:`The "${o}" hook used by the output plugin ${a} is a build time hook and will not be run for that plugin. Either this plugin cannot be used as an output plugin, or it should have an option to configure it as an output plugin.`}));var a,o}createOutputPluginDriver(e){return new Go(this.graph,this.options,e,this.pluginCache,this)}hookFirst(e,t,s,i){let n=Promise.resolve(void 0);for(const r of this.plugins)i&&i.has(r)||(n=n.then((i=>null!=i?i:this.runHook(e,t,r,!1,s))));return n}hookFirstSync(e,t,s){for(const i of this.plugins){const n=this.runHookSync(e,t,i,s);if(null!=n)return n}return null}hookParallel(e,t,s){const i=[];for(const n of this.plugins){const r=this.runHook(e,t,n,!1,s);r&&i.push(r)}return Promise.all(i).then((()=>{}))}hookReduceArg0(e,[t,...s],i,n){let r=Promise.resolve(t);for(const t of this.plugins)r=r.then((r=>{const a=[r,...s],o=this.runHook(e,a,t,!1,n);return o?o.then((e=>i.call(this.pluginContexts.get(t),r,e,t))):r}));return r}hookReduceArg0Sync(e,[t,...s],i,n){for(const r of this.plugins){const a=[t,...s],o=this.runHookSync(e,a,r,n);t=i.call(this.pluginContexts.get(r),t,o,r)}return t}hookReduceValue(e,t,s,i,n){let r=Promise.resolve(t);for(const t of this.plugins)r=r.then((r=>{const a=this.runHook(e,s,t,!0,n);return a?a.then((e=>i.call(this.pluginContexts.get(t),r,e,t))):r}));return r}hookReduceValueSync(e,t,s,i,n){let r=t;for(const t of this.plugins){const a=this.runHookSync(e,s,t,n);r=i.call(this.pluginContexts.get(t),r,a,t)}return r}hookSeq(e,t,s){let i=Promise.resolve();for(const n of this.plugins)i=i.then((()=>this.runHook(e,t,n,!1,s)));return i}hookSeqSync(e,t,s){for(const i of this.plugins)this.runHookSync(e,t,i,s)}runHook(e,t,s,i,n){const r=s[e];if(!r)return;let a=this.pluginContexts.get(s);return n&&(a=n(a,s)),Promise.resolve().then((()=>"function"!=typeof r?i?r:Uo(e,s.name):r.apply(a,t))).catch((t=>$o(t,s.name,{hook:e})))}runHookSync(e,t,s,i){const n=s[e];if(!n)return;let r=this.pluginContexts.get(s);i&&(r=i(r,s));try{return"function"!=typeof n?Uo(e,s.name):n.apply(r,t)}catch(t){return $o(t,s.name,{hook:e})}}}class Ho{constructor(e,t){var s,i;if(this.options=e,this.cachedModules=new Map,this.deoptimizationTracker=new B,this.entryModules=[],this.modulesById=new Map,this.needsTreeshakingPass=!1,this.phase=Pr.LOAD_AND_PARSE,this.scope=new Fo,this.watchFiles=Object.create(null),this.watchMode=!1,this.externalModules=[],this.implicitEntryModules=[],this.modules=[],this.getModuleInfo=e=>{const t=this.modulesById.get(e);return t?t.info:null},!1!==e.cache){if(null===(s=e.cache)||void 0===s?void 0:s.modules)for(const t of e.cache.modules)this.cachedModules.set(t.id,t);this.pluginCache=(null===(i=e.cache)||void 0===i?void 0:i.plugins)||Object.create(null);for(const e in this.pluginCache){const t=this.pluginCache[e];for(const e of Object.values(t))e[0]++}}if(t){this.watchMode=!0;const e=(...e)=>this.pluginDriver.hookSeqSync("watchChange",e),s=()=>this.pluginDriver.hookSeqSync("closeWatcher",[]);t.on("change",e),t.on("close",s),t.once("restart",(()=>{t.removeListener("change",e),t.removeListener("close",s)}))}this.pluginDriver=new Go(this,e,e.plugins,this.pluginCache),this.acornParser=Ca.extend(...e.acornInjectPlugins),this.moduleLoader=new Lo(this,this.modulesById,this.options,this.pluginDriver)}async build(){Bi("generate module graph",2),await this.generateModuleGraph(),Fi("generate module graph",2),Bi("sort modules",2),this.phase=Pr.ANALYSE,this.sortModules(),Fi("sort modules",2),Bi("mark included statements",2),this.includeStatements(),Fi("mark included statements",2),this.phase=Pr.GENERATE}contextParse(e,t={}){const s=t.onComment,i=[];t.onComment=s&&"function"==typeof s?(e,n,r,a,...o)=>(i.push({end:a,start:r,type:e?"Block":"Line",value:n}),s.call(t,e,n,r,a,...o)):i;const n=this.acornParser.parse(e,{...this.options.acorn,...t});return"object"==typeof s&&s.push(...i),t.onComment=s,function(e,t,s){const i=[],n=[];for(const t of e)Se.test(t.value)?i.push(t):ge.test(t.value)&&n.push(t);for(const e of n)Ae(t,e,!1);ye(t,{annotationIndex:0,annotations:i,code:s})}(i,n,e),n}getCache(){for(const e in this.pluginCache){const t=this.pluginCache[e];let s=!0;for(const[e,i]of Object.entries(t))i[0]>=this.options.experimentalCacheExpiry?delete t[e]:s=!1;s&&delete this.pluginCache[e]}return{modules:this.modules.map((e=>e.toJSON())),plugins:this.pluginCache}}async generateModuleGraph(){var e;if(({entryModules:this.entryModules,implicitEntryModules:this.implicitEntryModules}=await this.moduleLoader.addEntryModules((e=this.options.input,Array.isArray(e)?e.map((e=>({fileName:null,id:e,implicitlyLoadedAfter:[],importer:void 0,name:null}))):Object.entries(e).map((([e,t])=>({fileName:null,id:t,implicitlyLoadedAfter:[],importer:void 0,name:e})))),!0)),0===this.entryModules.length)throw new Error("You must supply options.input to rollup");for(const e of this.modulesById.values())e instanceof qi?this.modules.push(e):this.externalModules.push(e)}includeStatements(){for(const e of[...this.entryModules,...this.implicitEntryModules])Ui(e);if(this.options.treeshake){let e=1;do{Bi(`treeshaking pass ${e}`,3),this.needsTreeshakingPass=!1;for(const e of this.modules)e.isExecuted&&("no-treeshake"===e.info.hasModuleSideEffects?e.includeAllInBundle():e.include());if(1===e)for(const e of[...this.entryModules,...this.implicitEntryModules])!1!==e.preserveSignature&&(e.includeAllExports(!1),this.needsTreeshakingPass=!0);Fi("treeshaking pass "+e++,3)}while(this.needsTreeshakingPass)}else for(const e of this.modules)e.includeAllInBundle();for(const e of this.externalModules)e.warnUnusedImports();for(const e of this.implicitEntryModules)for(const t of e.implicitlyLoadedAfter)t.info.isEntry||t.isIncluded()||Ks(ti(t))}sortModules(){const{orderedModules:e,cyclePaths:t}=function(e){let t=0;const s=[],i=new Set,n=new Set,r=new Map,a=[],o=e=>{if(e instanceof qi){for(const t of e.dependencies)r.has(t)?i.has(t)||s.push(Or(t,e,r)):(r.set(t,e),o(t));for(const t of e.implicitlyLoadedBefore)n.add(t);for(const{resolution:t}of e.dynamicImports)t instanceof qi&&n.add(t);a.push(e)}e.execIndex=t++,i.add(e)};for(const t of e)r.has(t)||(r.set(t,null),o(t));for(const e of n)r.has(e)||(r.set(e,null),o(e));return{cyclePaths:s,orderedModules:a}}(this.entryModules);for(const e of t)this.options.onwarn({code:"CIRCULAR_DEPENDENCY",cycle:e,importer:e[0],message:`Circular dependency: ${e.join(" -> ")}`});this.modules=e;for(const e of this.modules)e.bindReferences();this.warnForMissingExports()}warnForMissingExports(){for(const e of this.modules)for(const t of Object.values(e.importDescriptions))"*"===t.name||t.module.getVariableForExportName(t.name)||e.warn({code:"NON_EXISTENT_EXPORT",message:`Non-existent export '${t.name}' is imported from ${ne(t.module.id)}`,name:t.name,source:t.module.id},t.start)}}function qo(e){return Array.isArray(e)?e.filter(Boolean):e?[e]:[]}const Ko=e=>console.warn(e.message||e);function Xo(e,t,s,i,n=/$./){const r=new Set(t),a=Object.keys(e).filter((e=>!(r.has(e)||n.test(e))));a.length>0&&i({code:"UNKNOWN_OPTION",message:`Unknown ${s}: ${a.join(", ")}. Allowed options: ${[...r].sort().join(", ")}`})}const Yo={recommended:{annotations:!0,correctVarValueBeforeDeclaration:!1,moduleSideEffects:()=>!0,propertyReadSideEffects:!0,tryCatchDeoptimization:!0,unknownGlobalSideEffects:!1},safest:{annotations:!0,correctVarValueBeforeDeclaration:!0,moduleSideEffects:()=>!0,propertyReadSideEffects:!0,tryCatchDeoptimization:!0,unknownGlobalSideEffects:!0},smallest:{annotations:!0,correctVarValueBeforeDeclaration:!1,moduleSideEffects:()=>!1,propertyReadSideEffects:!1,tryCatchDeoptimization:!1,unknownGlobalSideEffects:!1}},Qo={es2015:{arrowFunctions:!0,constBindings:!0,objectShorthand:!0,reservedNamesAsProps:!0},es5:{arrowFunctions:!1,constBindings:!1,objectShorthand:!1,reservedNamesAsProps:!0}},Zo=(e,t,s,i)=>{var n;const r=null===(n=e)||void 0===n?void 0:n.preset;if(r){const i=t[r];if(i)return{...i,...e};Ks(Js(`${s}.preset`,Jo(s),`valid values are ${se(Object.keys(t))}`,r))}return((e,t,s)=>i=>{if("string"==typeof i){const n=e[i];if(n)return n;Ks(Js(t,Jo(t),`valid values are ${s}${se(Object.keys(e))}. You can also supply an object for more fine-grained control`,i))}return i&&"object"==typeof i?i:{}})(t,s,i)(e)},Jo=e=>e.split(".").join("").toLowerCase();const eh=e=>{const{onwarn:t}=e;return t?e=>{e.toString=()=>{let t="";return e.plugin&&(t+=`(${e.plugin} plugin) `),e.loc&&(t+=`${ne(e.loc.file)} (${e.loc.line}:${e.loc.column}) `),t+=e.message,t},t(e,Ko)}:Ko},th=e=>({allowAwaitOutsideFunction:!0,ecmaVersion:"latest",preserveParens:!1,sourceType:"module",...e.acorn}),sh=e=>qo(e.acornInjectPlugins),ih=e=>{var t;return(null===(t=e.cache)||void 0===t?void 0:t.cache)||e.cache},nh=e=>{if(!0===e)return()=>!0;if("function"==typeof e)return(t,...s)=>!t.startsWith("\0")&&e(t,...s)||!1;if(e){const t=new Set,s=[];for(const i of qo(e))i instanceof RegExp?s.push(i):t.add(i);return(e,...i)=>t.has(e)||s.some((t=>t.test(e)))}return()=>!1},rh=(e,t,s)=>{const i=e.inlineDynamicImports;return i&&li('The "inlineDynamicImports" option is deprecated. Use the "output.inlineDynamicImports" option instead.',!1,t,s),i},ah=e=>{const t=e.input;return null==t?[]:"string"==typeof t?[t]:t},oh=(e,t,s)=>{const i=e.manualChunks;return i&&li('The "manualChunks" option is deprecated. Use the "output.manualChunks" option instead.',!1,t,s),i},hh=e=>{const t=e.maxParallelFileReads;return"number"==typeof t?t<=0?1/0:t:20},lh=(e,t)=>{const s=e.moduleContext;if("function"==typeof s)return e=>{var i;return null!==(i=s(e))&&void 0!==i?i:t};if(s){const e=Object.create(null);for(const[t,i]of Object.entries(s))e[$(t)]=i;return s=>e[s]||t}return()=>t},ch=(e,t)=>{const s=e.preserveEntrySignatures;return null==s&&t.add("preserveEntrySignatures"),null!=s?s:"strict"},uh=(e,t,s)=>{const i=e.preserveModules;return i&&li('The "preserveModules" option is deprecated. Use the "output.preserveModules" option instead.',!1,t,s),i},dh=(e,t,s)=>{const i=e.treeshake;if(!1===i)return!1;const n=Zo(e.treeshake,Yo,"treeshake","false, true, ");return void 0!==n.pureExternalModules&&li('The "treeshake.pureExternalModules" option is deprecated. The "treeshake.moduleSideEffects" option should be used instead. "treeshake.pureExternalModules: true" is equivalent to "treeshake.moduleSideEffects: \'no-external\'"',!0,t,s),{annotations:!1!==n.annotations,correctVarValueBeforeDeclaration:!0===n.correctVarValueBeforeDeclaration,moduleSideEffects:"object"==typeof i&&i.pureExternalModules?ph(i.moduleSideEffects,i.pureExternalModules):ph(n.moduleSideEffects,void 0),propertyReadSideEffects:"always"===n.propertyReadSideEffects?"always":!1!==n.propertyReadSideEffects,tryCatchDeoptimization:!1!==n.tryCatchDeoptimization,unknownGlobalSideEffects:!1!==n.unknownGlobalSideEffects}},ph=(e,t)=>{if("boolean"==typeof e)return()=>e;if("no-external"===e)return(e,t)=>!t;if("function"==typeof e)return(t,s)=>!!t.startsWith("\0")||!1!==e(t,s);if(Array.isArray(e)){const t=new Set(e);return e=>t.has(e)}e&&Ks(Js("treeshake.moduleSideEffects","treeshake",'please use one of false, "no-external", a function or an array'));const s=nh(t);return(e,t)=>!(t&&s(e))};function fh(e){const t=/^[a-z]:/i.exec(e),s=t?t[0]:"";return s+e.substr(s.length).replace(/[\0?*:]/g,"_")}const mh=(e,t,s)=>{const{file:i}=e;if("string"==typeof i){if(t)return Ks(Js("output.file","outputdir",'you must set "output.dir" instead of "output.file" when using the "output.preserveModules" option'));if(!Array.isArray(s.input))return Ks(Js("output.file","outputdir",'you must set "output.dir" instead of "output.file" when providing named inputs'))}return i},gh=e=>{const t=e.format;switch(t){case void 0:case"es":case"esm":case"module":return"es";case"cjs":case"commonjs":return"cjs";case"system":case"systemjs":return"system";case"amd":case"iife":case"umd":return t;default:return Ks({message:'You must specify "output.format", which can be one of "amd", "cjs", "system", "es", "iife" or "umd".',url:"https://rollupjs.org/guide/en/#outputformat"})}},yh=(e,t)=>{var s;const i=(null!==(s=e.inlineDynamicImports)&&void 0!==s?s:t.inlineDynamicImports)||!1,{input:n}=t;return i&&(Array.isArray(n)?n:Object.keys(n)).length>1?Ks(Js("output.inlineDynamicImports","outputinlinedynamicimports",'multiple inputs are not supported when "output.inlineDynamicImports" is true')):i},Eh=(e,t,s)=>{var i;const n=(null!==(i=e.preserveModules)&&void 0!==i?i:s.preserveModules)||!1;if(n){if(t)return Ks(Js("output.inlineDynamicImports","outputinlinedynamicimports",'this option is not supported for "output.preserveModules"'));if(!1===s.preserveEntrySignatures)return Ks(Js("preserveEntrySignatures","preserveentrysignatures",'setting this option to false is not supported for "output.preserveModules"'))}return n},xh=(e,t)=>{const s=e.preferConst;return null!=s&&hi('The "output.preferConst" option is deprecated. Use the "output.generatedCode.constBindings" option instead.',!1,t),!!s},vh=e=>{const{preserveModulesRoot:t}=e;if(null!=t)return $(t)},bh=e=>{const t={autoId:!1,basePath:"",define:"define",...e.amd};if((t.autoId||t.basePath)&&t.id)return Ks(Js("output.amd.id","outputamd",'this option cannot be used together with "output.amd.autoId"/"output.amd.basePath"'));if(t.basePath&&!t.autoId)return Ks(Js("output.amd.basePath","outputamd",'this option only works with "output.amd.autoId"'));let s;return s=t.autoId?{autoId:!0,basePath:t.basePath,define:t.define}:{autoId:!1,define:t.define,id:t.id},s},Sh=(e,t)=>{const s=e[t];return"function"==typeof s?s:()=>s||""},Ah=(e,t)=>{const{dir:s}=e;return"string"==typeof s&&"string"==typeof t?Ks(Js("output.dir","outputdir",'you must set either "output.file" for a single-file build or "output.dir" when generating multiple chunks')):s},Ph=(e,t)=>{const s=e.dynamicImportFunction;return s&&hi('The "output.dynamicImportFunction" option is deprecated. Use the "renderDynamicImport" plugin hook instead.',!1,t),s},kh=(e,t)=>{const s=e.entryFileNames;return null==s&&t.add("entryFileNames"),null!=s?s:"[name].js"};function wh(e,t){const s=e.exports;if(null==s)t.add("exports");else if(!["default","named","none","auto"].includes(s))return Ks((i=s,{code:Ys.INVALID_EXPORT_OPTION,message:`"output.exports" must be "default", "named", "none", "auto", or left unspecified (defaults to "auto"), received "${i}"`,url:"https://rollupjs.org/guide/en/#outputexports"}));var i;return s||"auto"}const Ch=(e,t)=>{const s=Zo(e.generatedCode,Qo,"output.generatedCode","");return{arrowFunctions:!0===s.arrowFunctions,constBindings:!0===s.constBindings||t,objectShorthand:!0===s.objectShorthand,reservedNamesAsProps:!0===s.reservedNamesAsProps}},Ih=(e,t)=>{if(t)return"";const s=e.indent;return!1===s?"":null==s||s},Nh=new Set(["auto","esModule","default","defaultOnly",!0,!1]),_h=(e,t)=>{const s=e.interop,i=new Set,n=e=>{if(!i.has(e)){if(i.add(e),!Nh.has(e))return Ks(Js("output.interop","outputinterop",`use one of ${Array.from(Nh.values(),(e=>JSON.stringify(e))).join(", ")}`,e));"boolean"==typeof e&&hi({message:`The boolean value "${e}" for the "output.interop" option is deprecated. Use ${e?'"auto"':'"esModule", "default" or "defaultOnly"'} instead.`,url:"https://rollupjs.org/guide/en/#outputinterop"},!1,t)}return e};if("function"==typeof s){const e=Object.create(null);let t=null;return i=>null===i?t||n(t=s(i)):i in e?e[i]:n(e[i]=s(i))}return void 0===s?()=>!0:()=>n(s)},$h=(e,t,s,i)=>{const n=e.manualChunks||i.manualChunks;if(n){if(t)return Ks(Js("output.manualChunks","outputmanualchunks",'this option is not supported for "output.inlineDynamicImports"'));if(s)return Ks(Js("output.manualChunks","outputmanualchunks",'this option is not supported for "output.preserveModules"'))}return n||{}},Th=(e,t,s)=>{var i;return null!==(i=e.minifyInternalExports)&&void 0!==i?i:s||"es"===t||"system"===t};function Rh(e){return async function(e,t){const{options:s,unsetOptions:i}=await async function(e,t){if(!e)throw new Error("You must supply an options object to rollup");const s=qo(e.plugins),{options:i,unsetOptions:n}=function(e){var t,s,i;const n=new Set,r=null!==(t=e.context)&&void 0!==t?t:"undefined",a=eh(e),o=e.strictDeprecations||!1,h={acorn:th(e),acornInjectPlugins:sh(e),cache:ih(e),context:r,experimentalCacheExpiry:null!==(s=e.experimentalCacheExpiry)&&void 0!==s?s:10,external:nh(e.external),inlineDynamicImports:rh(e,a,o),input:ah(e),makeAbsoluteExternalsRelative:null===(i=e.makeAbsoluteExternalsRelative)||void 0===i||i,manualChunks:oh(e,a,o),maxParallelFileReads:hh(e),moduleContext:lh(e,r),onwarn:a,perf:e.perf||!1,plugins:qo(e.plugins),preserveEntrySignatures:ch(e,n),preserveModules:uh(e,a,o),preserveSymlinks:e.preserveSymlinks||!1,shimMissingExports:e.shimMissingExports||!1,strictDeprecations:o,treeshake:dh(e,a,o)};return Xo(e,[...Object.keys(h),"watch"],"input options",h.onwarn,/^(output)$/),{options:h,unsetOptions:n}}(await s.reduce(function(e){return async(t,s)=>s.options&&await s.options.call({meta:{rollupVersion:"2.58.0",watchMode:e}},await t)||t}(t),Promise.resolve(e)));return Mh(i.plugins,"at position "),{options:i,unsetOptions:n}}(e,null!==t);ji(s);const n=new Ho(s,t),r=!1!==e.cache;delete s.cache,delete e.cache,Bi("BUILD",1);try{await n.pluginDriver.hookParallel("buildStart",[s]),await n.build()}catch(e){const t=Object.keys(n.watchFiles);throw t.length>0&&(e.watchFiles=t),await n.pluginDriver.hookParallel("buildEnd",[e]),await n.pluginDriver.hookParallel("closeBundle",[]),e}await n.pluginDriver.hookParallel("buildEnd",[]),Fi("BUILD",1);const a={cache:r?n.getCache():void 0,async close(){a.closed||(a.closed=!0,await n.pluginDriver.hookParallel("closeBundle",[]))},closed:!1,generate:async e=>a.closed?Ks(oi()):Dh(!1,s,i,e,n),watchFiles:Object.keys(n.watchFiles),write:async e=>a.closed?Ks(oi()):Dh(!0,s,i,e,n)};s.perf&&(a.getTimings=Vi);return a}(e,null)}function Mh(e,t){for(let s=0;s<e.length;s++){const i=e[s];i.name||(i.name=`${t}${s+1}`)}}async function Dh(e,t,s,i,n){const{options:r,outputPluginDriver:a,unsetOptions:o}=function(e,t,s,i){if(!e)throw new Error("You must supply an options object");const n=qo(e.plugins);Mh(n,"at output position ");const r=t.createOutputPluginDriver(n);return{...Lh(s,i,e,r),outputPluginDriver:r}}(i,n.pluginDriver,t,s),h=new Fr(r,o,t,a,n),l=await h.generate(e);if(e){if(!r.dir&&!r.file)return Ks({code:"MISSING_OPTION",message:'You must specify "output.file" or "output.dir" for the build.'});await Promise.all(Object.values(l).map((e=>function(e,t){const s=$(t.dir||I(t.file),e.fileName);let i,n;if("asset"===e.type)n=e.source;else if(n=e.code,t.sourcemap&&e.map){let r;"inline"===t.sourcemap?r=e.map.toUrl():(r=`${C(e.fileName)}.map`,i=Io(`${s}.map`,e.map.toString())),"hidden"!==t.sourcemap&&(n+=`//# sourceMappingURL=${r}\n`)}return Promise.all([Io(s,n),i])}(e,r)))),await a.hookParallel("writeBundle",[r,l])}return c=l,{output:Object.values(c).filter((e=>Object.keys(e).length>0)).sort(((e,t)=>{const s=Vh(e),i=Vh(t);return s===i?0:s<i?-1:1}))};var c}function Lh(e,t,s,i){return function(e,t,s){var i,n,r,a,o,h,l;const c=new Set(s),u=e.compact||!1,d=gh(e),p=yh(e,t),f=Eh(e,p,t),m=mh(e,f,t),g=xh(e,t),y={amd:bh(e),assetFileNames:null!==(i=e.assetFileNames)&&void 0!==i?i:"assets/[name]-[hash][extname]",banner:Sh(e,"banner"),chunkFileNames:null!==(n=e.chunkFileNames)&&void 0!==n?n:"[name]-[hash].js",compact:u,dir:Ah(e,m),dynamicImportFunction:Ph(e,t),entryFileNames:kh(e,c),esModule:null===(r=e.esModule)||void 0===r||r,exports:wh(e,c),extend:e.extend||!1,externalLiveBindings:null===(a=e.externalLiveBindings)||void 0===a||a,file:m,footer:Sh(e,"footer"),format:d,freeze:null===(o=e.freeze)||void 0===o||o,generatedCode:Ch(e,g),globals:e.globals||{},hoistTransitiveImports:null===(h=e.hoistTransitiveImports)||void 0===h||h,indent:Ih(e,u),inlineDynamicImports:p,interop:_h(e,t),intro:Sh(e,"intro"),manualChunks:$h(e,p,f,t),minifyInternalExports:Th(e,d,u),name:e.name,namespaceToStringTag:e.namespaceToStringTag||!1,noConflict:e.noConflict||!1,outro:Sh(e,"outro"),paths:e.paths||{},plugins:qo(e.plugins),preferConst:g,preserveModules:f,preserveModulesRoot:vh(e),sanitizeFileName:"function"==typeof e.sanitizeFileName?e.sanitizeFileName:!1===e.sanitizeFileName?e=>e:fh,sourcemap:e.sourcemap||!1,sourcemapExcludeSources:e.sourcemapExcludeSources||!1,sourcemapFile:e.sourcemapFile,sourcemapPathTransform:e.sourcemapPathTransform,strict:null===(l=e.strict)||void 0===l||l,systemNullSetters:e.systemNullSetters||!1,validate:e.validate||!1};return Xo(e,Object.keys(y),"output options",t.onwarn),{options:y,unsetOptions:c}}(i.hookReduceArg0Sync("outputOptions",[s.output||s],((e,t)=>t||e),(e=>{const t=()=>e.error({code:Ys.CANNOT_EMIT_FROM_OPTIONS_HOOK,message:'Cannot emit files or set asset sources in the "outputOptions" hook, use the "renderStart" hook instead.'});return{...e,emitFile:t,setAssetSource:t}})),e,t)}var Oh;function Vh(e){return"asset"===e.type?Oh.ASSET:e.isEntry?Oh.ENTRY_CHUNK:Oh.SECONDARY_CHUNK}function Bh(e){return e}!function(e){e[e.ENTRY_CHUNK=0]="ENTRY_CHUNK",e[e.SECONDARY_CHUNK=1]="SECONDARY_CHUNK",e[e.ASSET=2]="ASSET"}(Oh||(Oh={}));export{e as VERSION,Bh as defineConfig,Rh as rollup};
diff -urN /chromium-112.0.5615.49/third_party/node/node_modules/rollup/dist/es/rollup.js /chromium-111.0.5563.110/third_party/node/node_modules/rollup/dist/es/rollup.js
--- a/third_party/node/node_modules/rollup/dist/es/rollup.js	2023-02-03 20:05:52.000000000 +0000
+++ b/third_party/node/node_modules/rollup/dist/es/rollup.js	2023-01-12 22:12:55.000000000 +0000
@@ -1,18 +1,15 @@
 /*
   @license
-	Rollup.js v3.12.0
-	Sat, 28 Jan 2023 05:55:49 GMT - commit 01ddea09dfdf1c396c1c24ba3d97743698fe1508
+	Rollup.js v2.58.0
+	Fri, 01 Oct 2021 06:54:03 GMT - commit 3a404a07f41a10d10b7af536f05b90ea46d8ad3d
+
 
 	https://github.com/rollup/rollup
 
 	Released under the MIT License.
 */
 export { version as VERSION, defineConfig, rollup, watch } from './shared/rollup.js';
-import 'node:path';
 import 'path';
-import 'node:process';
-import 'node:perf_hooks';
-import 'node:crypto';
-import 'node:fs/promises';
-import 'node:events';
-import 'tty';
+import 'crypto';
+import 'fs';
+import 'events';
diff -urN /chromium-112.0.5615.49/third_party/node/node_modules/rollup/dist/es/shared/rollup.js /chromium-111.0.5563.110/third_party/node/node_modules/rollup/dist/es/shared/rollup.js
--- a/third_party/node/node_modules/rollup/dist/es/shared/rollup.js	2023-02-03 20:05:52.000000000 +0000
+++ b/third_party/node/node_modules/rollup/dist/es/shared/rollup.js	2023-01-12 22:12:55.000000000 +0000
@@ -1,391 +1,340 @@
 /*
   @license
-	Rollup.js v3.12.0
-	Sat, 28 Jan 2023 05:55:49 GMT - commit 01ddea09dfdf1c396c1c24ba3d97743698fe1508
+	Rollup.js v2.58.0
+	Fri, 01 Oct 2021 06:54:03 GMT - commit 3a404a07f41a10d10b7af536f05b90ea46d8ad3d
+
 
 	https://github.com/rollup/rollup
 
 	Released under the MIT License.
 */
-import { resolve, basename, extname, dirname, relative as relative$1 } from 'node:path';
-import require$$0$1, { win32, posix, isAbsolute as isAbsolute$1, resolve as resolve$1 } from 'path';
-import process$1, { env as env$1 } from 'node:process';
-import { performance } from 'node:perf_hooks';
-import { createHash as createHash$1 } from 'node:crypto';
-import { lstat, realpath, readdir, readFile, mkdir, writeFile } from 'node:fs/promises';
-import { EventEmitter } from 'node:events';
-import * as tty from 'tty';
-
-var version$1 = "3.12.0";
-
-const comma = ','.charCodeAt(0);
-const semicolon = ';'.charCodeAt(0);
-const chars$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
-const intToChar = new Uint8Array(64); // 64 possible chars.
-const charToInt = new Uint8Array(128); // z is 122 in ASCII
-for (let i = 0; i < chars$1.length; i++) {
-    const c = chars$1.charCodeAt(i);
-    intToChar[i] = c;
-    charToInt[c] = i;
-}
-// Provide a fallback for older environments.
-const td = typeof TextDecoder !== 'undefined'
-    ? /* #__PURE__ */ new TextDecoder()
-    : typeof Buffer !== 'undefined'
-        ? {
-            decode(buf) {
-                const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
-                return out.toString();
-            },
-        }
-        : {
-            decode(buf) {
-                let out = '';
-                for (let i = 0; i < buf.length; i++) {
-                    out += String.fromCharCode(buf[i]);
-                }
-                return out;
-            },
-        };
+import require$$0__default, { relative as relative$1, resolve, extname, basename, win32, posix, isAbsolute as isAbsolute$1, dirname } from 'path';
+import { createHash as createHash$1 } from 'crypto';
+import fs, { lstatSync, realpathSync, readdirSync } from 'fs';
+import { EventEmitter } from 'events';
+
+var version$1 = "2.58.0";
+
+var charToInteger = {};
+var chars$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
+for (var i = 0; i < chars$1.length; i++) {
+    charToInteger[chars$1.charCodeAt(i)] = i;
+}
 function decode(mappings) {
-    const state = new Int32Array(5);
-    const decoded = [];
-    let index = 0;
-    do {
-        const semi = indexOf(mappings, index);
-        const line = [];
-        let sorted = true;
-        let lastCol = 0;
-        state[0] = 0;
-        for (let i = index; i < semi; i++) {
-            let seg;
-            i = decodeInteger(mappings, i, state, 0); // genColumn
-            const col = state[0];
-            if (col < lastCol)
-                sorted = false;
-            lastCol = col;
-            if (hasMoreVlq(mappings, i, semi)) {
-                i = decodeInteger(mappings, i, state, 1); // sourcesIndex
-                i = decodeInteger(mappings, i, state, 2); // sourceLine
-                i = decodeInteger(mappings, i, state, 3); // sourceColumn
-                if (hasMoreVlq(mappings, i, semi)) {
-                    i = decodeInteger(mappings, i, state, 4); // namesIndex
-                    seg = [col, state[1], state[2], state[3], state[4]];
-                }
-                else {
-                    seg = [col, state[1], state[2], state[3]];
-                }
+    var decoded = [];
+    var line = [];
+    var segment = [
+        0,
+        0,
+        0,
+        0,
+        0,
+    ];
+    var j = 0;
+    for (var i = 0, shift = 0, value = 0; i < mappings.length; i++) {
+        var c = mappings.charCodeAt(i);
+        if (c === 44) { // ","
+            segmentify(line, segment, j);
+            j = 0;
+        }
+        else if (c === 59) { // ";"
+            segmentify(line, segment, j);
+            j = 0;
+            decoded.push(line);
+            line = [];
+            segment[0] = 0;
+        }
+        else {
+            var integer = charToInteger[c];
+            if (integer === undefined) {
+                throw new Error('Invalid character (' + String.fromCharCode(c) + ')');
+            }
+            var hasContinuationBit = integer & 32;
+            integer &= 31;
+            value += integer << shift;
+            if (hasContinuationBit) {
+                shift += 5;
             }
             else {
-                seg = [col];
+                var shouldNegate = value & 1;
+                value >>>= 1;
+                if (shouldNegate) {
+                    value = value === 0 ? -0x80000000 : -value;
+                }
+                segment[j] += value;
+                j++;
+                value = shift = 0; // reset
             }
-            line.push(seg);
         }
-        if (!sorted)
-            sort(line);
-        decoded.push(line);
-        index = semi + 1;
-    } while (index <= mappings.length);
-    return decoded;
-}
-function indexOf(mappings, index) {
-    const idx = mappings.indexOf(';', index);
-    return idx === -1 ? mappings.length : idx;
-}
-function decodeInteger(mappings, pos, state, j) {
-    let value = 0;
-    let shift = 0;
-    let integer = 0;
-    do {
-        const c = mappings.charCodeAt(pos++);
-        integer = charToInt[c];
-        value |= (integer & 31) << shift;
-        shift += 5;
-    } while (integer & 32);
-    const shouldNegate = value & 1;
-    value >>>= 1;
-    if (shouldNegate) {
-        value = -0x80000000 | -value;
     }
-    state[j] += value;
-    return pos;
-}
-function hasMoreVlq(mappings, i, length) {
-    if (i >= length)
-        return false;
-    return mappings.charCodeAt(i) !== comma;
-}
-function sort(line) {
-    line.sort(sortComparator);
+    segmentify(line, segment, j);
+    decoded.push(line);
+    return decoded;
 }
-function sortComparator(a, b) {
-    return a[0] - b[0];
+function segmentify(line, segment, j) {
+    // This looks ugly, but we're creating specialized arrays with a specific
+    // length. This is much faster than creating a new array (which v8 expands to
+    // a capacity of 17 after pushing the first item), or slicing out a subarray
+    // (which is slow). Length 4 is assumed to be the most frequent, followed by
+    // length 5 (since not everything will have an associated name), followed by
+    // length 1 (it's probably rare for a source substring to not have an
+    // associated segment data).
+    if (j === 4)
+        line.push([segment[0], segment[1], segment[2], segment[3]]);
+    else if (j === 5)
+        line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);
+    else if (j === 1)
+        line.push([segment[0]]);
 }
 function encode(decoded) {
-    const state = new Int32Array(5);
-    const bufLength = 1024 * 16;
-    const subLength = bufLength - 36;
-    const buf = new Uint8Array(bufLength);
-    const sub = buf.subarray(0, subLength);
-    let pos = 0;
-    let out = '';
-    for (let i = 0; i < decoded.length; i++) {
-        const line = decoded[i];
-        if (i > 0) {
-            if (pos === bufLength) {
-                out += td.decode(buf);
-                pos = 0;
-            }
-            buf[pos++] = semicolon;
-        }
+    var sourceFileIndex = 0; // second field
+    var sourceCodeLine = 0; // third field
+    var sourceCodeColumn = 0; // fourth field
+    var nameIndex = 0; // fifth field
+    var mappings = '';
+    for (var i = 0; i < decoded.length; i++) {
+        var line = decoded[i];
+        if (i > 0)
+            mappings += ';';
         if (line.length === 0)
             continue;
-        state[0] = 0;
-        for (let j = 0; j < line.length; j++) {
-            const segment = line[j];
-            // We can push up to 5 ints, each int can take at most 7 chars, and we
-            // may push a comma.
-            if (pos > subLength) {
-                out += td.decode(sub);
-                buf.copyWithin(0, subLength, pos);
-                pos -= subLength;
-            }
-            if (j > 0)
-                buf[pos++] = comma;
-            pos = encodeInteger(buf, pos, state, segment, 0); // genColumn
-            if (segment.length === 1)
-                continue;
-            pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex
-            pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine
-            pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn
-            if (segment.length === 4)
-                continue;
-            pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex
+        var generatedCodeColumn = 0; // first field
+        var lineMappings = [];
+        for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {
+            var segment = line_1[_i];
+            var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);
+            generatedCodeColumn = segment[0];
+            if (segment.length > 1) {
+                segmentMappings +=
+                    encodeInteger(segment[1] - sourceFileIndex) +
+                        encodeInteger(segment[2] - sourceCodeLine) +
+                        encodeInteger(segment[3] - sourceCodeColumn);
+                sourceFileIndex = segment[1];
+                sourceCodeLine = segment[2];
+                sourceCodeColumn = segment[3];
+            }
+            if (segment.length === 5) {
+                segmentMappings += encodeInteger(segment[4] - nameIndex);
+                nameIndex = segment[4];
+            }
+            lineMappings.push(segmentMappings);
         }
+        mappings += lineMappings.join(',');
     }
-    return out + td.decode(buf.subarray(0, pos));
+    return mappings;
 }
-function encodeInteger(buf, pos, state, segment, j) {
-    const next = segment[j];
-    let num = next - state[j];
-    state[j] = next;
+function encodeInteger(num) {
+    var result = '';
     num = num < 0 ? (-num << 1) | 1 : num << 1;
     do {
-        let clamped = num & 0b011111;
+        var clamped = num & 31;
         num >>>= 5;
-        if (num > 0)
-            clamped |= 0b100000;
-        buf[pos++] = intToChar[clamped];
+        if (num > 0) {
+            clamped |= 32;
+        }
+        result += chars$1[clamped];
     } while (num > 0);
-    return pos;
+    return result;
 }
 
-class BitSet {
-	constructor(arg) {
-		this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
-	}
+var BitSet = function BitSet(arg) {
+	this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
+};
 
-	add(n) {
-		this.bits[n >> 5] |= 1 << (n & 31);
-	}
+BitSet.prototype.add = function add (n) {
+	this.bits[n >> 5] |= 1 << (n & 31);
+};
 
-	has(n) {
-		return !!(this.bits[n >> 5] & (1 << (n & 31)));
-	}
-}
+BitSet.prototype.has = function has (n) {
+	return !!(this.bits[n >> 5] & (1 << (n & 31)));
+};
 
-let Chunk$1 = class Chunk {
-	constructor(start, end, content) {
-		this.start = start;
-		this.end = end;
-		this.original = content;
+var Chunk$1 = function Chunk(start, end, content) {
+	this.start = start;
+	this.end = end;
+	this.original = content;
 
-		this.intro = '';
-		this.outro = '';
+	this.intro = '';
+	this.outro = '';
 
-		this.content = content;
-		this.storeName = false;
-		this.edited = false;
-
-		{
-			this.previous = null;
-			this.next = null;
-		}
-	}
+	this.content = content;
+	this.storeName = false;
+	this.edited = false;
 
-	appendLeft(content) {
-		this.outro += content;
-	}
+	// we make these non-enumerable, for sanity while debugging
+	Object.defineProperties(this, {
+		previous: { writable: true, value: null },
+		next:     { writable: true, value: null }
+	});
+};
 
-	appendRight(content) {
-		this.intro = this.intro + content;
-	}
+Chunk$1.prototype.appendLeft = function appendLeft (content) {
+	this.outro += content;
+};
 
-	clone() {
-		const chunk = new Chunk$1(this.start, this.end, this.original);
+Chunk$1.prototype.appendRight = function appendRight (content) {
+	this.intro = this.intro + content;
+};
 
-		chunk.intro = this.intro;
-		chunk.outro = this.outro;
-		chunk.content = this.content;
-		chunk.storeName = this.storeName;
-		chunk.edited = this.edited;
+Chunk$1.prototype.clone = function clone () {
+	var chunk = new Chunk$1(this.start, this.end, this.original);
 
-		return chunk;
-	}
+	chunk.intro = this.intro;
+	chunk.outro = this.outro;
+	chunk.content = this.content;
+	chunk.storeName = this.storeName;
+	chunk.edited = this.edited;
 
-	contains(index) {
-		return this.start < index && index < this.end;
-	}
+	return chunk;
+};
 
-	eachNext(fn) {
-		let chunk = this;
-		while (chunk) {
-			fn(chunk);
-			chunk = chunk.next;
-		}
-	}
+Chunk$1.prototype.contains = function contains (index) {
+	return this.start < index && index < this.end;
+};
 
-	eachPrevious(fn) {
-		let chunk = this;
-		while (chunk) {
-			fn(chunk);
-			chunk = chunk.previous;
-		}
+Chunk$1.prototype.eachNext = function eachNext (fn) {
+	var chunk = this;
+	while (chunk) {
+		fn(chunk);
+		chunk = chunk.next;
 	}
+};
 
-	edit(content, storeName, contentOnly) {
-		this.content = content;
-		if (!contentOnly) {
-			this.intro = '';
-			this.outro = '';
-		}
-		this.storeName = storeName;
-
-		this.edited = true;
-
-		return this;
+Chunk$1.prototype.eachPrevious = function eachPrevious (fn) {
+	var chunk = this;
+	while (chunk) {
+		fn(chunk);
+		chunk = chunk.previous;
 	}
+};
 
-	prependLeft(content) {
-		this.outro = content + this.outro;
+Chunk$1.prototype.edit = function edit (content, storeName, contentOnly) {
+	this.content = content;
+	if (!contentOnly) {
+		this.intro = '';
+		this.outro = '';
 	}
+	this.storeName = storeName;
 
-	prependRight(content) {
-		this.intro = content + this.intro;
-	}
+	this.edited = true;
 
-	split(index) {
-		const sliceIndex = index - this.start;
+	return this;
+};
 
-		const originalBefore = this.original.slice(0, sliceIndex);
-		const originalAfter = this.original.slice(sliceIndex);
+Chunk$1.prototype.prependLeft = function prependLeft (content) {
+	this.outro = content + this.outro;
+};
 
-		this.original = originalBefore;
+Chunk$1.prototype.prependRight = function prependRight (content) {
+	this.intro = content + this.intro;
+};
 
-		const newChunk = new Chunk$1(index, this.end, originalAfter);
-		newChunk.outro = this.outro;
-		this.outro = '';
+Chunk$1.prototype.split = function split (index) {
+	var sliceIndex = index - this.start;
 
-		this.end = index;
+	var originalBefore = this.original.slice(0, sliceIndex);
+	var originalAfter = this.original.slice(sliceIndex);
 
-		if (this.edited) {
-			// TODO is this block necessary?...
-			newChunk.edit('', false);
-			this.content = '';
-		} else {
-			this.content = originalBefore;
-		}
+	this.original = originalBefore;
 
-		newChunk.next = this.next;
-		if (newChunk.next) newChunk.next.previous = newChunk;
-		newChunk.previous = this;
-		this.next = newChunk;
+	var newChunk = new Chunk$1(index, this.end, originalAfter);
+	newChunk.outro = this.outro;
+	this.outro = '';
 
-		return newChunk;
-	}
+	this.end = index;
 
-	toString() {
-		return this.intro + this.content + this.outro;
+	if (this.edited) {
+		// TODO is this block necessary?...
+		newChunk.edit('', false);
+		this.content = '';
+	} else {
+		this.content = originalBefore;
 	}
 
-	trimEnd(rx) {
-		this.outro = this.outro.replace(rx, '');
-		if (this.outro.length) return true;
+	newChunk.next = this.next;
+	if (newChunk.next) { newChunk.next.previous = newChunk; }
+	newChunk.previous = this;
+	this.next = newChunk;
 
-		const trimmed = this.content.replace(rx, '');
+	return newChunk;
+};
 
-		if (trimmed.length) {
-			if (trimmed !== this.content) {
-				this.split(this.start + trimmed.length).edit('', undefined, true);
-			}
-			return true;
-		} else {
-			this.edit('', undefined, true);
+Chunk$1.prototype.toString = function toString () {
+	return this.intro + this.content + this.outro;
+};
 
-			this.intro = this.intro.replace(rx, '');
-			if (this.intro.length) return true;
+Chunk$1.prototype.trimEnd = function trimEnd (rx) {
+	this.outro = this.outro.replace(rx, '');
+	if (this.outro.length) { return true; }
+
+	var trimmed = this.content.replace(rx, '');
+
+	if (trimmed.length) {
+		if (trimmed !== this.content) {
+			this.split(this.start + trimmed.length).edit('', undefined, true);
 		}
-	}
+		return true;
+
+	} else {
+		this.edit('', undefined, true);
 
-	trimStart(rx) {
 		this.intro = this.intro.replace(rx, '');
-		if (this.intro.length) return true;
+		if (this.intro.length) { return true; }
+	}
+};
 
-		const trimmed = this.content.replace(rx, '');
+Chunk$1.prototype.trimStart = function trimStart (rx) {
+	this.intro = this.intro.replace(rx, '');
+	if (this.intro.length) { return true; }
 
-		if (trimmed.length) {
-			if (trimmed !== this.content) {
-				this.split(this.end - trimmed.length);
-				this.edit('', undefined, true);
-			}
-			return true;
-		} else {
-			this.edit('', undefined, true);
+	var trimmed = this.content.replace(rx, '');
 
-			this.outro = this.outro.replace(rx, '');
-			if (this.outro.length) return true;
+	if (trimmed.length) {
+		if (trimmed !== this.content) {
+			this.split(this.end - trimmed.length);
+			this.edit('', undefined, true);
 		}
-	}
-};
+		return true;
 
-function getBtoa () {
-	if (typeof window !== 'undefined' && typeof window.btoa === 'function') {
-		return (str) => window.btoa(unescape(encodeURIComponent(str)));
-	} else if (typeof Buffer === 'function') {
-		return (str) => Buffer.from(str, 'utf-8').toString('base64');
 	} else {
-		return () => {
-			throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');
-		};
+		this.edit('', undefined, true);
+
+		this.outro = this.outro.replace(rx, '');
+		if (this.outro.length) { return true; }
 	}
-}
+};
 
-const btoa = /*#__PURE__*/ getBtoa();
+var btoa = function () {
+	throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');
+};
+if (typeof window !== 'undefined' && typeof window.btoa === 'function') {
+	btoa = function (str) { return window.btoa(unescape(encodeURIComponent(str))); };
+} else if (typeof Buffer === 'function') {
+	btoa = function (str) { return Buffer.from(str, 'utf-8').toString('base64'); };
+}
 
-class SourceMap {
-	constructor(properties) {
-		this.version = 3;
-		this.file = properties.file;
-		this.sources = properties.sources;
-		this.sourcesContent = properties.sourcesContent;
-		this.names = properties.names;
-		this.mappings = encode(properties.mappings);
-	}
+var SourceMap = function SourceMap(properties) {
+	this.version = 3;
+	this.file = properties.file;
+	this.sources = properties.sources;
+	this.sourcesContent = properties.sourcesContent;
+	this.names = properties.names;
+	this.mappings = encode(properties.mappings);
+};
 
-	toString() {
-		return JSON.stringify(this);
-	}
+SourceMap.prototype.toString = function toString () {
+	return JSON.stringify(this);
+};
 
-	toUrl() {
-		return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());
-	}
-}
+SourceMap.prototype.toUrl = function toUrl () {
+	return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());
+};
 
 function guessIndent(code) {
-	const lines = code.split('\n');
+	var lines = code.split('\n');
 
-	const tabbed = lines.filter((line) => /^\t+/.test(line));
-	const spaced = lines.filter((line) => /^ {2,}/.test(line));
+	var tabbed = lines.filter(function (line) { return /^\t+/.test(line); });
+	var spaced = lines.filter(function (line) { return /^ {2,}/.test(line); });
 
 	if (tabbed.length === 0 && spaced.length === 0) {
 		return null;
@@ -399,8 +348,8 @@
 	}
 
 	// Otherwise, we need to guess the multiple
-	const min = spaced.reduce((previous, current) => {
-		const numSpaces = /^ +/.exec(current)[0].length;
+	var min = spaced.reduce(function (previous, current) {
+		var numSpaces = /^ +/.exec(current)[0].length;
 		return Math.min(numSpaces, previous);
 	}, Infinity);
 
@@ -408,8 +357,8 @@
 }
 
 function getRelativePath(from, to) {
-	const fromParts = from.split(/[/\\]/);
-	const toParts = to.split(/[/\\]/);
+	var fromParts = from.split(/[/\\]/);
+	var toParts = to.split(/[/\\]/);
 
 	fromParts.pop(); // get dirname
 
@@ -419,1192 +368,1083 @@
 	}
 
 	if (fromParts.length) {
-		let i = fromParts.length;
-		while (i--) fromParts[i] = '..';
+		var i = fromParts.length;
+		while (i--) { fromParts[i] = '..'; }
 	}
 
 	return fromParts.concat(toParts).join('/');
 }
 
-const toString$1 = Object.prototype.toString;
+var toString$1 = Object.prototype.toString;
 
 function isObject$1(thing) {
 	return toString$1.call(thing) === '[object Object]';
 }
 
 function getLocator$1(source) {
-	const originalLines = source.split('\n');
-	const lineOffsets = [];
+	var originalLines = source.split('\n');
+	var lineOffsets = [];
 
-	for (let i = 0, pos = 0; i < originalLines.length; i++) {
+	for (var i = 0, pos = 0; i < originalLines.length; i++) {
 		lineOffsets.push(pos);
 		pos += originalLines[i].length + 1;
 	}
 
 	return function locate(index) {
-		let i = 0;
-		let j = lineOffsets.length;
+		var i = 0;
+		var j = lineOffsets.length;
 		while (i < j) {
-			const m = (i + j) >> 1;
+			var m = (i + j) >> 1;
 			if (index < lineOffsets[m]) {
 				j = m;
 			} else {
 				i = m + 1;
 			}
 		}
-		const line = i - 1;
-		const column = index - lineOffsets[line];
-		return { line, column };
+		var line = i - 1;
+		var column = index - lineOffsets[line];
+		return { line: line, column: column };
 	};
 }
 
-class Mappings {
-	constructor(hires) {
-		this.hires = hires;
-		this.generatedCodeLine = 0;
-		this.generatedCodeColumn = 0;
-		this.raw = [];
-		this.rawSegments = this.raw[this.generatedCodeLine] = [];
-		this.pending = null;
-	}
+var Mappings = function Mappings(hires) {
+	this.hires = hires;
+	this.generatedCodeLine = 0;
+	this.generatedCodeColumn = 0;
+	this.raw = [];
+	this.rawSegments = this.raw[this.generatedCodeLine] = [];
+	this.pending = null;
+};
 
-	addEdit(sourceIndex, content, loc, nameIndex) {
-		if (content.length) {
-			const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
-			if (nameIndex >= 0) {
-				segment.push(nameIndex);
-			}
-			this.rawSegments.push(segment);
-		} else if (this.pending) {
-			this.rawSegments.push(this.pending);
+Mappings.prototype.addEdit = function addEdit (sourceIndex, content, loc, nameIndex) {
+	if (content.length) {
+		var segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
+		if (nameIndex >= 0) {
+			segment.push(nameIndex);
 		}
-
-		this.advance(content);
-		this.pending = null;
+		this.rawSegments.push(segment);
+	} else if (this.pending) {
+		this.rawSegments.push(this.pending);
 	}
 
-	addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
-		let originalCharIndex = chunk.start;
-		let first = true;
-
-		while (originalCharIndex < chunk.end) {
-			if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
-				this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
-			}
+	this.advance(content);
+	this.pending = null;
+};
 
-			if (original[originalCharIndex] === '\n') {
-				loc.line += 1;
-				loc.column = 0;
-				this.generatedCodeLine += 1;
-				this.raw[this.generatedCodeLine] = this.rawSegments = [];
-				this.generatedCodeColumn = 0;
-				first = true;
-			} else {
-				loc.column += 1;
-				this.generatedCodeColumn += 1;
-				first = false;
-			}
+Mappings.prototype.addUneditedChunk = function addUneditedChunk (sourceIndex, chunk, original, loc, sourcemapLocations) {
+	var originalCharIndex = chunk.start;
+	var first = true;
 
-			originalCharIndex += 1;
+	while (originalCharIndex < chunk.end) {
+		if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
+			this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
+		}
+
+		if (original[originalCharIndex] === '\n') {
+			loc.line += 1;
+			loc.column = 0;
+			this.generatedCodeLine += 1;
+			this.raw[this.generatedCodeLine] = this.rawSegments = [];
+			this.generatedCodeColumn = 0;
+			first = true;
+		} else {
+			loc.column += 1;
+			this.generatedCodeColumn += 1;
+			first = false;
 		}
 
-		this.pending = null;
+		originalCharIndex += 1;
 	}
 
-	advance(str) {
-		if (!str) return;
+	this.pending = null;
+};
 
-		const lines = str.split('\n');
+Mappings.prototype.advance = function advance (str) {
+	if (!str) { return; }
 
-		if (lines.length > 1) {
-			for (let i = 0; i < lines.length - 1; i++) {
-				this.generatedCodeLine++;
-				this.raw[this.generatedCodeLine] = this.rawSegments = [];
-			}
-			this.generatedCodeColumn = 0;
-		}
+	var lines = str.split('\n');
 
-		this.generatedCodeColumn += lines[lines.length - 1].length;
+	if (lines.length > 1) {
+		for (var i = 0; i < lines.length - 1; i++) {
+			this.generatedCodeLine++;
+			this.raw[this.generatedCodeLine] = this.rawSegments = [];
+		}
+		this.generatedCodeColumn = 0;
 	}
-}
 
-const n = '\n';
+	this.generatedCodeColumn += lines[lines.length - 1].length;
+};
+
+var n = '\n';
 
-const warned = {
+var warned = {
 	insertLeft: false,
 	insertRight: false,
-	storeName: false,
+	storeName: false
 };
 
-class MagicString {
-	constructor(string, options = {}) {
-		const chunk = new Chunk$1(0, string.length, string);
-
-		Object.defineProperties(this, {
-			original: { writable: true, value: string },
-			outro: { writable: true, value: '' },
-			intro: { writable: true, value: '' },
-			firstChunk: { writable: true, value: chunk },
-			lastChunk: { writable: true, value: chunk },
-			lastSearchedChunk: { writable: true, value: chunk },
-			byStart: { writable: true, value: {} },
-			byEnd: { writable: true, value: {} },
-			filename: { writable: true, value: options.filename },
-			indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
-			sourcemapLocations: { writable: true, value: new BitSet() },
-			storedNames: { writable: true, value: {} },
-			indentStr: { writable: true, value: undefined },
-		});
-
-		this.byStart[0] = chunk;
-		this.byEnd[string.length] = chunk;
-	}
+var MagicString = function MagicString(string, options) {
+	if ( options === void 0 ) options = {};
 
-	addSourcemapLocation(char) {
-		this.sourcemapLocations.add(char);
-	}
+	var chunk = new Chunk$1(0, string.length, string);
 
-	append(content) {
-		if (typeof content !== 'string') throw new TypeError('outro content must be a string');
-
-		this.outro += content;
-		return this;
-	}
+	Object.defineProperties(this, {
+		original:              { writable: true, value: string },
+		outro:                 { writable: true, value: '' },
+		intro:                 { writable: true, value: '' },
+		firstChunk:            { writable: true, value: chunk },
+		lastChunk:             { writable: true, value: chunk },
+		lastSearchedChunk:     { writable: true, value: chunk },
+		byStart:               { writable: true, value: {} },
+		byEnd:                 { writable: true, value: {} },
+		filename:              { writable: true, value: options.filename },
+		indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
+		sourcemapLocations:    { writable: true, value: new BitSet() },
+		storedNames:           { writable: true, value: {} },
+		indentStr:             { writable: true, value: guessIndent(string) }
+	});
 
-	appendLeft(index, content) {
-		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');
+	this.byStart[0] = chunk;
+	this.byEnd[string.length] = chunk;
+};
 
-		this._split(index);
+MagicString.prototype.addSourcemapLocation = function addSourcemapLocation (char) {
+	this.sourcemapLocations.add(char);
+};
 
-		const chunk = this.byEnd[index];
+MagicString.prototype.append = function append (content) {
+	if (typeof content !== 'string') { throw new TypeError('outro content must be a string'); }
 
-		if (chunk) {
-			chunk.appendLeft(content);
-		} else {
-			this.intro += content;
-		}
-		return this;
-	}
+	this.outro += content;
+	return this;
+};
 
-	appendRight(index, content) {
-		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');
+MagicString.prototype.appendLeft = function appendLeft (index, content) {
+	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }
 
-		this._split(index);
+	this._split(index);
 
-		const chunk = this.byStart[index];
+	var chunk = this.byEnd[index];
 
-		if (chunk) {
-			chunk.appendRight(content);
-		} else {
-			this.outro += content;
-		}
-		return this;
+	if (chunk) {
+		chunk.appendLeft(content);
+	} else {
+		this.intro += content;
 	}
+	return this;
+};
 
-	clone() {
-		const cloned = new MagicString(this.original, { filename: this.filename });
+MagicString.prototype.appendRight = function appendRight (index, content) {
+	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }
 
-		let originalChunk = this.firstChunk;
-		let clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());
+	this._split(index);
 
-		while (originalChunk) {
-			cloned.byStart[clonedChunk.start] = clonedChunk;
-			cloned.byEnd[clonedChunk.end] = clonedChunk;
+	var chunk = this.byStart[index];
 
-			const nextOriginalChunk = originalChunk.next;
-			const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
+	if (chunk) {
+		chunk.appendRight(content);
+	} else {
+		this.outro += content;
+	}
+	return this;
+};
 
-			if (nextClonedChunk) {
-				clonedChunk.next = nextClonedChunk;
-				nextClonedChunk.previous = clonedChunk;
+MagicString.prototype.clone = function clone () {
+	var cloned = new MagicString(this.original, { filename: this.filename });
 
-				clonedChunk = nextClonedChunk;
-			}
+	var originalChunk = this.firstChunk;
+	var clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());
 
-			originalChunk = nextOriginalChunk;
-		}
+	while (originalChunk) {
+		cloned.byStart[clonedChunk.start] = clonedChunk;
+		cloned.byEnd[clonedChunk.end] = clonedChunk;
 
-		cloned.lastChunk = clonedChunk;
+		var nextOriginalChunk = originalChunk.next;
+		var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
 
-		if (this.indentExclusionRanges) {
-			cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
+		if (nextClonedChunk) {
+			clonedChunk.next = nextClonedChunk;
+			nextClonedChunk.previous = clonedChunk;
+
+			clonedChunk = nextClonedChunk;
 		}
 
-		cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
+		originalChunk = nextOriginalChunk;
+	}
 
-		cloned.intro = this.intro;
-		cloned.outro = this.outro;
+	cloned.lastChunk = clonedChunk;
 
-		return cloned;
+	if (this.indentExclusionRanges) {
+		cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
 	}
 
-	generateDecodedMap(options) {
-		options = options || {};
-
-		const sourceIndex = 0;
-		const names = Object.keys(this.storedNames);
-		const mappings = new Mappings(options.hires);
+	cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
 
-		const locate = getLocator$1(this.original);
+	cloned.intro = this.intro;
+	cloned.outro = this.outro;
 
-		if (this.intro) {
-			mappings.advance(this.intro);
-		}
+	return cloned;
+};
 
-		this.firstChunk.eachNext((chunk) => {
-			const loc = locate(chunk.start);
+MagicString.prototype.generateDecodedMap = function generateDecodedMap (options) {
+		var this$1$1 = this;
 
-			if (chunk.intro.length) mappings.advance(chunk.intro);
+	options = options || {};
 
-			if (chunk.edited) {
-				mappings.addEdit(
-					sourceIndex,
-					chunk.content,
-					loc,
-					chunk.storeName ? names.indexOf(chunk.original) : -1
-				);
-			} else {
-				mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
-			}
+	var sourceIndex = 0;
+	var names = Object.keys(this.storedNames);
+	var mappings = new Mappings(options.hires);
 
-			if (chunk.outro.length) mappings.advance(chunk.outro);
-		});
+	var locate = getLocator$1(this.original);
 
-		return {
-			file: options.file ? options.file.split(/[/\\]/).pop() : null,
-			sources: [options.source ? getRelativePath(options.file || '', options.source) : null],
-			sourcesContent: options.includeContent ? [this.original] : [null],
-			names,
-			mappings: mappings.raw,
-		};
+	if (this.intro) {
+		mappings.advance(this.intro);
 	}
 
-	generateMap(options) {
-		return new SourceMap(this.generateDecodedMap(options));
-	}
+	this.firstChunk.eachNext(function (chunk) {
+		var loc = locate(chunk.start);
+
+		if (chunk.intro.length) { mappings.advance(chunk.intro); }
 
-	_ensureindentStr() {
-		if (this.indentStr === undefined) {
-			this.indentStr = guessIndent(this.original);
+		if (chunk.edited) {
+			mappings.addEdit(
+				sourceIndex,
+				chunk.content,
+				loc,
+				chunk.storeName ? names.indexOf(chunk.original) : -1
+			);
+		} else {
+			mappings.addUneditedChunk(sourceIndex, chunk, this$1$1.original, loc, this$1$1.sourcemapLocations);
 		}
-	}
 
-	_getRawIndentString() {
-		this._ensureindentStr();
-		return this.indentStr;
-	}
+		if (chunk.outro.length) { mappings.advance(chunk.outro); }
+	});
 
-	getIndentString() {
-		this._ensureindentStr();
-		return this.indentStr === null ? '\t' : this.indentStr;
-	}
+	return {
+		file: options.file ? options.file.split(/[/\\]/).pop() : null,
+		sources: [options.source ? getRelativePath(options.file || '', options.source) : null],
+		sourcesContent: options.includeContent ? [this.original] : [null],
+		names: names,
+		mappings: mappings.raw
+	};
+};
 
-	indent(indentStr, options) {
-		const pattern = /^[^\r\n]/gm;
+MagicString.prototype.generateMap = function generateMap (options) {
+	return new SourceMap(this.generateDecodedMap(options));
+};
 
-		if (isObject$1(indentStr)) {
-			options = indentStr;
-			indentStr = undefined;
-		}
+MagicString.prototype.getIndentString = function getIndentString () {
+	return this.indentStr === null ? '\t' : this.indentStr;
+};
 
-		if (indentStr === undefined) {
-			this._ensureindentStr();
-			indentStr = this.indentStr || '\t';
-		}
+MagicString.prototype.indent = function indent (indentStr, options) {
+	var pattern = /^[^\r\n]/gm;
 
-		if (indentStr === '') return this; // noop
+	if (isObject$1(indentStr)) {
+		options = indentStr;
+		indentStr = undefined;
+	}
 
-		options = options || {};
+	indentStr = indentStr !== undefined ? indentStr : this.indentStr || '\t';
 
-		// Process exclusion ranges
-		const isExcluded = {};
+	if (indentStr === '') { return this; } // noop
 
-		if (options.exclude) {
-			const exclusions =
-				typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;
-			exclusions.forEach((exclusion) => {
-				for (let i = exclusion[0]; i < exclusion[1]; i += 1) {
-					isExcluded[i] = true;
-				}
-			});
-		}
+	options = options || {};
 
-		let shouldIndentNextCharacter = options.indentStart !== false;
-		const replacer = (match) => {
-			if (shouldIndentNextCharacter) return `${indentStr}${match}`;
-			shouldIndentNextCharacter = true;
-			return match;
-		};
-
-		this.intro = this.intro.replace(pattern, replacer);
+	// Process exclusion ranges
+	var isExcluded = {};
 
-		let charIndex = 0;
-		let chunk = this.firstChunk;
+	if (options.exclude) {
+		var exclusions =
+			typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;
+		exclusions.forEach(function (exclusion) {
+			for (var i = exclusion[0]; i < exclusion[1]; i += 1) {
+				isExcluded[i] = true;
+			}
+		});
+	}
 
-		while (chunk) {
-			const end = chunk.end;
+	var shouldIndentNextCharacter = options.indentStart !== false;
+	var replacer = function (match) {
+		if (shouldIndentNextCharacter) { return ("" + indentStr + match); }
+		shouldIndentNextCharacter = true;
+		return match;
+	};
 
-			if (chunk.edited) {
-				if (!isExcluded[charIndex]) {
-					chunk.content = chunk.content.replace(pattern, replacer);
+	this.intro = this.intro.replace(pattern, replacer);
 
-					if (chunk.content.length) {
-						shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\n';
-					}
-				}
-			} else {
-				charIndex = chunk.start;
+	var charIndex = 0;
+	var chunk = this.firstChunk;
 
-				while (charIndex < end) {
-					if (!isExcluded[charIndex]) {
-						const char = this.original[charIndex];
-
-						if (char === '\n') {
-							shouldIndentNextCharacter = true;
-						} else if (char !== '\r' && shouldIndentNextCharacter) {
-							shouldIndentNextCharacter = false;
-
-							if (charIndex === chunk.start) {
-								chunk.prependRight(indentStr);
-							} else {
-								this._splitChunk(chunk, charIndex);
-								chunk = chunk.next;
-								chunk.prependRight(indentStr);
-							}
-						}
-					}
+	while (chunk) {
+		var end = chunk.end;
 
-					charIndex += 1;
+		if (chunk.edited) {
+			if (!isExcluded[charIndex]) {
+				chunk.content = chunk.content.replace(pattern, replacer);
+
+				if (chunk.content.length) {
+					shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\n';
 				}
 			}
+		} else {
+			charIndex = chunk.start;
 
-			charIndex = chunk.end;
-			chunk = chunk.next;
-		}
+			while (charIndex < end) {
+				if (!isExcluded[charIndex]) {
+					var char = this.original[charIndex];
 
-		this.outro = this.outro.replace(pattern, replacer);
+					if (char === '\n') {
+						shouldIndentNextCharacter = true;
+					} else if (char !== '\r' && shouldIndentNextCharacter) {
+						shouldIndentNextCharacter = false;
+
+						if (charIndex === chunk.start) {
+							chunk.prependRight(indentStr);
+						} else {
+							this._splitChunk(chunk, charIndex);
+							chunk = chunk.next;
+							chunk.prependRight(indentStr);
+						}
+					}
+				}
 
-		return this;
-	}
+				charIndex += 1;
+			}
+		}
 
-	insert() {
-		throw new Error(
-			'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)'
-		);
+		charIndex = chunk.end;
+		chunk = chunk.next;
 	}
 
-	insertLeft(index, content) {
-		if (!warned.insertLeft) {
-			console.warn(
-				'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'
-			); // eslint-disable-line no-console
-			warned.insertLeft = true;
-		}
+	this.outro = this.outro.replace(pattern, replacer);
 
-		return this.appendLeft(index, content);
-	}
+	return this;
+};
 
-	insertRight(index, content) {
-		if (!warned.insertRight) {
-			console.warn(
-				'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'
-			); // eslint-disable-line no-console
-			warned.insertRight = true;
-		}
+MagicString.prototype.insert = function insert () {
+	throw new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)');
+};
 
-		return this.prependRight(index, content);
+MagicString.prototype.insertLeft = function insertLeft (index, content) {
+	if (!warned.insertLeft) {
+		console.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'); // eslint-disable-line no-console
+		warned.insertLeft = true;
 	}
 
-	move(start, end, index) {
-		if (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');
+	return this.appendLeft(index, content);
+};
 
-		this._split(start);
-		this._split(end);
-		this._split(index);
+MagicString.prototype.insertRight = function insertRight (index, content) {
+	if (!warned.insertRight) {
+		console.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'); // eslint-disable-line no-console
+		warned.insertRight = true;
+	}
 
-		const first = this.byStart[start];
-		const last = this.byEnd[end];
+	return this.prependRight(index, content);
+};
 
-		const oldLeft = first.previous;
-		const oldRight = last.next;
+MagicString.prototype.move = function move (start, end, index) {
+	if (index >= start && index <= end) { throw new Error('Cannot move a selection inside itself'); }
 
-		const newRight = this.byStart[index];
-		if (!newRight && last === this.lastChunk) return this;
-		const newLeft = newRight ? newRight.previous : this.lastChunk;
+	this._split(start);
+	this._split(end);
+	this._split(index);
 
-		if (oldLeft) oldLeft.next = oldRight;
-		if (oldRight) oldRight.previous = oldLeft;
+	var first = this.byStart[start];
+	var last = this.byEnd[end];
 
-		if (newLeft) newLeft.next = first;
-		if (newRight) newRight.previous = last;
+	var oldLeft = first.previous;
+	var oldRight = last.next;
 
-		if (!first.previous) this.firstChunk = last.next;
-		if (!last.next) {
-			this.lastChunk = first.previous;
-			this.lastChunk.next = null;
-		}
+	var newRight = this.byStart[index];
+	if (!newRight && last === this.lastChunk) { return this; }
+	var newLeft = newRight ? newRight.previous : this.lastChunk;
 
-		first.previous = newLeft;
-		last.next = newRight || null;
+	if (oldLeft) { oldLeft.next = oldRight; }
+	if (oldRight) { oldRight.previous = oldLeft; }
 
-		if (!newLeft) this.firstChunk = first;
-		if (!newRight) this.lastChunk = last;
-		return this;
-	}
+	if (newLeft) { newLeft.next = first; }
+	if (newRight) { newRight.previous = last; }
 
-	overwrite(start, end, content, options) {
-		options = options || {};
-		return this.update(start, end, content, { ...options, overwrite: !options.contentOnly });
+	if (!first.previous) { this.firstChunk = last.next; }
+	if (!last.next) {
+		this.lastChunk = first.previous;
+		this.lastChunk.next = null;
 	}
 
-	update(start, end, content, options) {
-		if (typeof content !== 'string') throw new TypeError('replacement content must be a string');
+	first.previous = newLeft;
+	last.next = newRight || null;
 
-		while (start < 0) start += this.original.length;
-		while (end < 0) end += this.original.length;
+	if (!newLeft) { this.firstChunk = first; }
+	if (!newRight) { this.lastChunk = last; }
+	return this;
+};
 
-		if (end > this.original.length) throw new Error('end is out of bounds');
-		if (start === end)
-			throw new Error(
-				'Cannot overwrite a zero-length range – use appendLeft or prependRight instead'
-			);
+MagicString.prototype.overwrite = function overwrite (start, end, content, options) {
+	if (typeof content !== 'string') { throw new TypeError('replacement content must be a string'); }
 
-		this._split(start);
-		this._split(end);
+	while (start < 0) { start += this.original.length; }
+	while (end < 0) { end += this.original.length; }
 
-		if (options === true) {
-			if (!warned.storeName) {
-				console.warn(
-					'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'
-				); // eslint-disable-line no-console
-				warned.storeName = true;
-			}
+	if (end > this.original.length) { throw new Error('end is out of bounds'); }
+	if (start === end)
+		{ throw new Error('Cannot overwrite a zero-length range – use appendLeft or prependRight instead'); }
 
-			options = { storeName: true };
-		}
-		const storeName = options !== undefined ? options.storeName : false;
-		const overwrite = options !== undefined ? options.overwrite : false;
+	this._split(start);
+	this._split(end);
 
-		if (storeName) {
-			const original = this.original.slice(start, end);
-			Object.defineProperty(this.storedNames, original, {
-				writable: true,
-				value: true,
-				enumerable: true,
-			});
+	if (options === true) {
+		if (!warned.storeName) {
+			console.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'); // eslint-disable-line no-console
+			warned.storeName = true;
 		}
 
-		const first = this.byStart[start];
-		const last = this.byEnd[end];
-
-		if (first) {
-			let chunk = first;
-			while (chunk !== last) {
-				if (chunk.next !== this.byStart[chunk.end]) {
-					throw new Error('Cannot overwrite across a split point');
-				}
-				chunk = chunk.next;
-				chunk.edit('', false);
-			}
-
-			first.edit(content, storeName, !overwrite);
-		} else {
-			// must be inserting at the end
-			const newChunk = new Chunk$1(start, end, '').edit(content, storeName);
-
-			// TODO last chunk in the array may not be the last chunk, if it's moved...
-			last.next = newChunk;
-			newChunk.previous = last;
-		}
-		return this;
+		options = { storeName: true };
 	}
+	var storeName = options !== undefined ? options.storeName : false;
+	var contentOnly = options !== undefined ? options.contentOnly : false;
 
-	prepend(content) {
-		if (typeof content !== 'string') throw new TypeError('outro content must be a string');
-
-		this.intro = content + this.intro;
-		return this;
+	if (storeName) {
+		var original = this.original.slice(start, end);
+		this.storedNames[original] = true;
 	}
 
-	prependLeft(index, content) {
-		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');
-
-		this._split(index);
+	var first = this.byStart[start];
+	var last = this.byEnd[end];
 
-		const chunk = this.byEnd[index];
-
-		if (chunk) {
-			chunk.prependLeft(content);
-		} else {
-			this.intro = content + this.intro;
+	if (first) {
+		if (end > first.end && first.next !== this.byStart[first.end]) {
+			throw new Error('Cannot overwrite across a split point');
 		}
-		return this;
-	}
 
-	prependRight(index, content) {
-		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');
+		first.edit(content, storeName, contentOnly);
 
-		this._split(index);
-
-		const chunk = this.byStart[index];
+		if (first !== last) {
+			var chunk = first.next;
+			while (chunk !== last) {
+				chunk.edit('', false);
+				chunk = chunk.next;
+			}
 
-		if (chunk) {
-			chunk.prependRight(content);
-		} else {
-			this.outro = content + this.outro;
+			chunk.edit('', false);
 		}
-		return this;
-	}
+	} else {
+		// must be inserting at the end
+		var newChunk = new Chunk$1(start, end, '').edit(content, storeName);
 
-	remove(start, end) {
-		while (start < 0) start += this.original.length;
-		while (end < 0) end += this.original.length;
+		// TODO last chunk in the array may not be the last chunk, if it's moved...
+		last.next = newChunk;
+		newChunk.previous = last;
+	}
+	return this;
+};
 
-		if (start === end) return this;
+MagicString.prototype.prepend = function prepend (content) {
+	if (typeof content !== 'string') { throw new TypeError('outro content must be a string'); }
 
-		if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');
-		if (start > end) throw new Error('end must be greater than start');
+	this.intro = content + this.intro;
+	return this;
+};
 
-		this._split(start);
-		this._split(end);
+MagicString.prototype.prependLeft = function prependLeft (index, content) {
+	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }
 
-		let chunk = this.byStart[start];
+	this._split(index);
 
-		while (chunk) {
-			chunk.intro = '';
-			chunk.outro = '';
-			chunk.edit('');
+	var chunk = this.byEnd[index];
 
-			chunk = end > chunk.end ? this.byStart[chunk.end] : null;
-		}
-		return this;
+	if (chunk) {
+		chunk.prependLeft(content);
+	} else {
+		this.intro = content + this.intro;
 	}
+	return this;
+};
 
-	lastChar() {
-		if (this.outro.length) return this.outro[this.outro.length - 1];
-		let chunk = this.lastChunk;
-		do {
-			if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];
-			if (chunk.content.length) return chunk.content[chunk.content.length - 1];
-			if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];
-		} while ((chunk = chunk.previous));
-		if (this.intro.length) return this.intro[this.intro.length - 1];
-		return '';
-	}
+MagicString.prototype.prependRight = function prependRight (index, content) {
+	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }
 
-	lastLine() {
-		let lineIndex = this.outro.lastIndexOf(n);
-		if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);
-		let lineStr = this.outro;
-		let chunk = this.lastChunk;
-		do {
-			if (chunk.outro.length > 0) {
-				lineIndex = chunk.outro.lastIndexOf(n);
-				if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;
-				lineStr = chunk.outro + lineStr;
-			}
+	this._split(index);
 
-			if (chunk.content.length > 0) {
-				lineIndex = chunk.content.lastIndexOf(n);
-				if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;
-				lineStr = chunk.content + lineStr;
-			}
+	var chunk = this.byStart[index];
 
-			if (chunk.intro.length > 0) {
-				lineIndex = chunk.intro.lastIndexOf(n);
-				if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;
-				lineStr = chunk.intro + lineStr;
-			}
-		} while ((chunk = chunk.previous));
-		lineIndex = this.intro.lastIndexOf(n);
-		if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;
-		return this.intro + lineStr;
+	if (chunk) {
+		chunk.prependRight(content);
+	} else {
+		this.outro = content + this.outro;
 	}
+	return this;
+};
 
-	slice(start = 0, end = this.original.length) {
-		while (start < 0) start += this.original.length;
-		while (end < 0) end += this.original.length;
-
-		let result = '';
-
-		// find start chunk
-		let chunk = this.firstChunk;
-		while (chunk && (chunk.start > start || chunk.end <= start)) {
-			// found end chunk before start
-			if (chunk.start < end && chunk.end >= end) {
-				return result;
-			}
+MagicString.prototype.remove = function remove (start, end) {
+	while (start < 0) { start += this.original.length; }
+	while (end < 0) { end += this.original.length; }
+
+	if (start === end) { return this; }
+
+	if (start < 0 || end > this.original.length) { throw new Error('Character is out of bounds'); }
+	if (start > end) { throw new Error('end must be greater than start'); }
+
+	this._split(start);
+	this._split(end);
+
+	var chunk = this.byStart[start];
+
+	while (chunk) {
+		chunk.intro = '';
+		chunk.outro = '';
+		chunk.edit('');
+
+		chunk = end > chunk.end ? this.byStart[chunk.end] : null;
+	}
+	return this;
+};
+
+MagicString.prototype.lastChar = function lastChar () {
+	if (this.outro.length)
+		{ return this.outro[this.outro.length - 1]; }
+	var chunk = this.lastChunk;
+	do {
+		if (chunk.outro.length)
+			{ return chunk.outro[chunk.outro.length - 1]; }
+		if (chunk.content.length)
+			{ return chunk.content[chunk.content.length - 1]; }
+		if (chunk.intro.length)
+			{ return chunk.intro[chunk.intro.length - 1]; }
+	} while (chunk = chunk.previous);
+	if (this.intro.length)
+		{ return this.intro[this.intro.length - 1]; }
+	return '';
+};
+
+MagicString.prototype.lastLine = function lastLine () {
+	var lineIndex = this.outro.lastIndexOf(n);
+	if (lineIndex !== -1)
+		{ return this.outro.substr(lineIndex + 1); }
+	var lineStr = this.outro;
+	var chunk = this.lastChunk;
+	do {
+		if (chunk.outro.length > 0) {
+			lineIndex = chunk.outro.lastIndexOf(n);
+			if (lineIndex !== -1)
+				{ return chunk.outro.substr(lineIndex + 1) + lineStr; }
+			lineStr = chunk.outro + lineStr;
+		}
 
-			chunk = chunk.next;
+		if (chunk.content.length > 0) {
+			lineIndex = chunk.content.lastIndexOf(n);
+			if (lineIndex !== -1)
+				{ return chunk.content.substr(lineIndex + 1) + lineStr; }
+			lineStr = chunk.content + lineStr;
 		}
 
-		if (chunk && chunk.edited && chunk.start !== start)
-			throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);
+		if (chunk.intro.length > 0) {
+			lineIndex = chunk.intro.lastIndexOf(n);
+			if (lineIndex !== -1)
+				{ return chunk.intro.substr(lineIndex + 1) + lineStr; }
+			lineStr = chunk.intro + lineStr;
+		}
+	} while (chunk = chunk.previous);
+	lineIndex = this.intro.lastIndexOf(n);
+	if (lineIndex !== -1)
+		{ return this.intro.substr(lineIndex + 1) + lineStr; }
+	return this.intro + lineStr;
+};
+
+MagicString.prototype.slice = function slice (start, end) {
+		if ( start === void 0 ) start = 0;
+		if ( end === void 0 ) end = this.original.length;
+
+	while (start < 0) { start += this.original.length; }
+	while (end < 0) { end += this.original.length; }
+
+	var result = '';
+
+	// find start chunk
+	var chunk = this.firstChunk;
+	while (chunk && (chunk.start > start || chunk.end <= start)) {
+		// found end chunk before start
+		if (chunk.start < end && chunk.end >= end) {
+			return result;
+		}
 
-		const startChunk = chunk;
-		while (chunk) {
-			if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
-				result += chunk.intro;
-			}
+		chunk = chunk.next;
+	}
 
-			const containsEnd = chunk.start < end && chunk.end >= end;
-			if (containsEnd && chunk.edited && chunk.end !== end)
-				throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);
+	if (chunk && chunk.edited && chunk.start !== start)
+		{ throw new Error(("Cannot use replaced character " + start + " as slice start anchor.")); }
 
-			const sliceStart = startChunk === chunk ? start - chunk.start : 0;
-			const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
+	var startChunk = chunk;
+	while (chunk) {
+		if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
+			result += chunk.intro;
+		}
 
-			result += chunk.content.slice(sliceStart, sliceEnd);
+		var containsEnd = chunk.start < end && chunk.end >= end;
+		if (containsEnd && chunk.edited && chunk.end !== end)
+			{ throw new Error(("Cannot use replaced character " + end + " as slice end anchor.")); }
 
-			if (chunk.outro && (!containsEnd || chunk.end === end)) {
-				result += chunk.outro;
-			}
+		var sliceStart = startChunk === chunk ? start - chunk.start : 0;
+		var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
 
-			if (containsEnd) {
-				break;
-			}
+		result += chunk.content.slice(sliceStart, sliceEnd);
 
-			chunk = chunk.next;
+		if (chunk.outro && (!containsEnd || chunk.end === end)) {
+			result += chunk.outro;
 		}
 
-		return result;
-	}
-
-	// TODO deprecate this? not really very useful
-	snip(start, end) {
-		const clone = this.clone();
-		clone.remove(0, start);
-		clone.remove(end, clone.original.length);
+		if (containsEnd) {
+			break;
+		}
 
-		return clone;
+		chunk = chunk.next;
 	}
 
-	_split(index) {
-		if (this.byStart[index] || this.byEnd[index]) return;
-
-		let chunk = this.lastSearchedChunk;
-		const searchForward = index > chunk.end;
+	return result;
+};
 
-		while (chunk) {
-			if (chunk.contains(index)) return this._splitChunk(chunk, index);
+// TODO deprecate this? not really very useful
+MagicString.prototype.snip = function snip (start, end) {
+	var clone = this.clone();
+	clone.remove(0, start);
+	clone.remove(end, clone.original.length);
 
-			chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
-		}
-	}
+	return clone;
+};
 
-	_splitChunk(chunk, index) {
-		if (chunk.edited && chunk.content.length) {
-			// zero-length edited chunks are a special case (overlapping replacements)
-			const loc = getLocator$1(this.original)(index);
-			throw new Error(
-				`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – "${chunk.original}")`
-			);
-		}
+MagicString.prototype._split = function _split (index) {
+	if (this.byStart[index] || this.byEnd[index]) { return; }
 
-		const newChunk = chunk.split(index);
+	var chunk = this.lastSearchedChunk;
+	var searchForward = index > chunk.end;
 
-		this.byEnd[index] = chunk;
-		this.byStart[index] = newChunk;
-		this.byEnd[newChunk.end] = newChunk;
+	while (chunk) {
+		if (chunk.contains(index)) { return this._splitChunk(chunk, index); }
 
-		if (chunk === this.lastChunk) this.lastChunk = newChunk;
+		chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
+	}
+};
 
-		this.lastSearchedChunk = chunk;
-		return true;
+MagicString.prototype._splitChunk = function _splitChunk (chunk, index) {
+	if (chunk.edited && chunk.content.length) {
+		// zero-length edited chunks are a special case (overlapping replacements)
+		var loc = getLocator$1(this.original)(index);
+		throw new Error(
+			("Cannot split a chunk that has already been edited (" + (loc.line) + ":" + (loc.column) + " – \"" + (chunk.original) + "\")")
+		);
 	}
 
-	toString() {
-		let str = this.intro;
+	var newChunk = chunk.split(index);
 
-		let chunk = this.firstChunk;
-		while (chunk) {
-			str += chunk.toString();
-			chunk = chunk.next;
-		}
+	this.byEnd[index] = chunk;
+	this.byStart[index] = newChunk;
+	this.byEnd[newChunk.end] = newChunk;
 
-		return str + this.outro;
-	}
+	if (chunk === this.lastChunk) { this.lastChunk = newChunk; }
 
-	isEmpty() {
-		let chunk = this.firstChunk;
-		do {
-			if (
-				(chunk.intro.length && chunk.intro.trim()) ||
-				(chunk.content.length && chunk.content.trim()) ||
-				(chunk.outro.length && chunk.outro.trim())
-			)
-				return false;
-		} while ((chunk = chunk.next));
-		return true;
-	}
+	this.lastSearchedChunk = chunk;
+	return true;
+};
 
-	length() {
-		let chunk = this.firstChunk;
-		let length = 0;
-		do {
-			length += chunk.intro.length + chunk.content.length + chunk.outro.length;
-		} while ((chunk = chunk.next));
-		return length;
-	}
+MagicString.prototype.toString = function toString () {
+	var str = this.intro;
 
-	trimLines() {
-		return this.trim('[\\r\\n]');
+	var chunk = this.firstChunk;
+	while (chunk) {
+		str += chunk.toString();
+		chunk = chunk.next;
 	}
 
-	trim(charType) {
-		return this.trimStart(charType).trimEnd(charType);
-	}
+	return str + this.outro;
+};
 
-	trimEndAborted(charType) {
-		const rx = new RegExp((charType || '\\s') + '+$');
+MagicString.prototype.isEmpty = function isEmpty () {
+	var chunk = this.firstChunk;
+	do {
+		if (chunk.intro.length && chunk.intro.trim() ||
+				chunk.content.length && chunk.content.trim() ||
+				chunk.outro.length && chunk.outro.trim())
+			{ return false; }
+	} while (chunk = chunk.next);
+	return true;
+};
 
-		this.outro = this.outro.replace(rx, '');
-		if (this.outro.length) return true;
+MagicString.prototype.length = function length () {
+	var chunk = this.firstChunk;
+	var length = 0;
+	do {
+		length += chunk.intro.length + chunk.content.length + chunk.outro.length;
+	} while (chunk = chunk.next);
+	return length;
+};
 
-		let chunk = this.lastChunk;
+MagicString.prototype.trimLines = function trimLines () {
+	return this.trim('[\\r\\n]');
+};
 
-		do {
-			const end = chunk.end;
-			const aborted = chunk.trimEnd(rx);
+MagicString.prototype.trim = function trim (charType) {
+	return this.trimStart(charType).trimEnd(charType);
+};
 
-			// if chunk was trimmed, we have a new lastChunk
-			if (chunk.end !== end) {
-				if (this.lastChunk === chunk) {
-					this.lastChunk = chunk.next;
-				}
+MagicString.prototype.trimEndAborted = function trimEndAborted (charType) {
+	var rx = new RegExp((charType || '\\s') + '+$');
 
-				this.byEnd[chunk.end] = chunk;
-				this.byStart[chunk.next.start] = chunk.next;
-				this.byEnd[chunk.next.end] = chunk.next;
-			}
+	this.outro = this.outro.replace(rx, '');
+	if (this.outro.length) { return true; }
 
-			if (aborted) return true;
-			chunk = chunk.previous;
-		} while (chunk);
+	var chunk = this.lastChunk;
 
-		return false;
-	}
+	do {
+		var end = chunk.end;
+		var aborted = chunk.trimEnd(rx);
 
-	trimEnd(charType) {
-		this.trimEndAborted(charType);
-		return this;
-	}
-	trimStartAborted(charType) {
-		const rx = new RegExp('^' + (charType || '\\s') + '+');
+		// if chunk was trimmed, we have a new lastChunk
+		if (chunk.end !== end) {
+			if (this.lastChunk === chunk) {
+				this.lastChunk = chunk.next;
+			}
 
-		this.intro = this.intro.replace(rx, '');
-		if (this.intro.length) return true;
+			this.byEnd[chunk.end] = chunk;
+			this.byStart[chunk.next.start] = chunk.next;
+			this.byEnd[chunk.next.end] = chunk.next;
+		}
 
-		let chunk = this.firstChunk;
+		if (aborted) { return true; }
+		chunk = chunk.previous;
+	} while (chunk);
 
-		do {
-			const end = chunk.end;
-			const aborted = chunk.trimStart(rx);
+	return false;
+};
 
-			if (chunk.end !== end) {
-				// special case...
-				if (chunk === this.lastChunk) this.lastChunk = chunk.next;
-
-				this.byEnd[chunk.end] = chunk;
-				this.byStart[chunk.next.start] = chunk.next;
-				this.byEnd[chunk.next.end] = chunk.next;
-			}
+MagicString.prototype.trimEnd = function trimEnd (charType) {
+	this.trimEndAborted(charType);
+	return this;
+};
+MagicString.prototype.trimStartAborted = function trimStartAborted (charType) {
+	var rx = new RegExp('^' + (charType || '\\s') + '+');
 
-			if (aborted) return true;
-			chunk = chunk.next;
-		} while (chunk);
+	this.intro = this.intro.replace(rx, '');
+	if (this.intro.length) { return true; }
 
-		return false;
-	}
+	var chunk = this.firstChunk;
 
-	trimStart(charType) {
-		this.trimStartAborted(charType);
-		return this;
-	}
+	do {
+		var end = chunk.end;
+		var aborted = chunk.trimStart(rx);
 
-	hasChanged() {
-		return this.original !== this.toString();
-	}
+		if (chunk.end !== end) {
+			// special case...
+			if (chunk === this.lastChunk) { this.lastChunk = chunk.next; }
 
-	_replaceRegexp(searchValue, replacement) {
-		function getReplacement(match, str) {
-			if (typeof replacement === 'string') {
-				return replacement.replace(/\$(\$|&|\d+)/g, (_, i) => {
-					// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter
-					if (i === '$') return '$';
-					if (i === '&') return match[0];
-					const num = +i;
-					if (num < match.length) return match[+i];
-					return `$${i}`;
-				});
-			} else {
-				return replacement(...match, match.index, str, match.groups);
-			}
-		}
-		function matchAll(re, str) {
-			let match;
-			const matches = [];
-			while ((match = re.exec(str))) {
-				matches.push(match);
-			}
-			return matches;
+			this.byEnd[chunk.end] = chunk;
+			this.byStart[chunk.next.start] = chunk.next;
+			this.byEnd[chunk.next.end] = chunk.next;
 		}
-		if (searchValue.global) {
-			const matches = matchAll(searchValue, this.original);
-			matches.forEach((match) => {
-				if (match.index != null)
-					this.overwrite(
-						match.index,
-						match.index + match[0].length,
-						getReplacement(match, this.original)
-					);
-			});
-		} else {
-			const match = this.original.match(searchValue);
-			if (match && match.index != null)
-				this.overwrite(
-					match.index,
-					match.index + match[0].length,
-					getReplacement(match, this.original)
-				);
-		}
-		return this;
-	}
 
-	_replaceString(string, replacement) {
-		const { original } = this;
-		const index = original.indexOf(string);
+		if (aborted) { return true; }
+		chunk = chunk.next;
+	} while (chunk);
 
-		if (index !== -1) {
-			this.overwrite(index, index + string.length, replacement);
-		}
+	return false;
+};
 
-		return this;
-	}
+MagicString.prototype.trimStart = function trimStart (charType) {
+	this.trimStartAborted(charType);
+	return this;
+};
 
-	replace(searchValue, replacement) {
-		if (typeof searchValue === 'string') {
-			return this._replaceString(searchValue, replacement);
-		}
+var hasOwnProp = Object.prototype.hasOwnProperty;
 
-		return this._replaceRegexp(searchValue, replacement);
-	}
+var Bundle$1 = function Bundle(options) {
+	if ( options === void 0 ) options = {};
 
-	_replaceAllString(string, replacement) {
-		const { original } = this;
-		const stringLength = string.length;
-		for (
-			let index = original.indexOf(string);
-			index !== -1;
-			index = original.indexOf(string, index + stringLength)
-		) {
-			this.overwrite(index, index + stringLength, replacement);
-		}
+	this.intro = options.intro || '';
+	this.separator = options.separator !== undefined ? options.separator : '\n';
+	this.sources = [];
+	this.uniqueSources = [];
+	this.uniqueSourceIndexByFilename = {};
+};
 
-		return this;
+Bundle$1.prototype.addSource = function addSource (source) {
+	if (source instanceof MagicString) {
+		return this.addSource({
+			content: source,
+			filename: source.filename,
+			separator: this.separator
+		});
 	}
 
-	replaceAll(searchValue, replacement) {
-		if (typeof searchValue === 'string') {
-			return this._replaceAllString(searchValue, replacement);
-		}
-
-		if (!searchValue.global) {
-			throw new TypeError(
-				'MagicString.prototype.replaceAll called with a non-global RegExp argument'
-			);
-		}
-
-		return this._replaceRegexp(searchValue, replacement);
+	if (!isObject$1(source) || !source.content) {
+		throw new Error('bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`');
 	}
-}
 
-const hasOwnProp = Object.prototype.hasOwnProperty;
+	['filename', 'indentExclusionRanges', 'separator'].forEach(function (option) {
+		if (!hasOwnProp.call(source, option)) { source[option] = source.content[option]; }
+	});
 
-let Bundle$1 = class Bundle {
-	constructor(options = {}) {
-		this.intro = options.intro || '';
-		this.separator = options.separator !== undefined ? options.separator : '\n';
-		this.sources = [];
-		this.uniqueSources = [];
-		this.uniqueSourceIndexByFilename = {};
+	if (source.separator === undefined) {
+		// TODO there's a bunch of this sort of thing, needs cleaning up
+		source.separator = this.separator;
 	}
 
-	addSource(source) {
-		if (source instanceof MagicString) {
-			return this.addSource({
-				content: source,
-				filename: source.filename,
-				separator: this.separator,
-			});
-		}
-
-		if (!isObject$1(source) || !source.content) {
-			throw new Error(
-				'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`'
-			);
+	if (source.filename) {
+		if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {
+			this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;
+			this.uniqueSources.push({ filename: source.filename, content: source.content.original });
+		} else {
+			var uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];
+			if (source.content.original !== uniqueSource.content) {
+				throw new Error(("Illegal source: same filename (" + (source.filename) + "), different contents"));
+			}
 		}
+	}
 
-		['filename', 'indentExclusionRanges', 'separator'].forEach((option) => {
-			if (!hasOwnProp.call(source, option)) source[option] = source.content[option];
-		});
+	this.sources.push(source);
+	return this;
+};
 
-		if (source.separator === undefined) {
-			// TODO there's a bunch of this sort of thing, needs cleaning up
-			source.separator = this.separator;
-		}
+Bundle$1.prototype.append = function append (str, options) {
+	this.addSource({
+		content: new MagicString(str),
+		separator: (options && options.separator) || ''
+	});
 
-		if (source.filename) {
-			if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {
-				this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;
-				this.uniqueSources.push({ filename: source.filename, content: source.content.original });
-			} else {
-				const uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];
-				if (source.content.original !== uniqueSource.content) {
-					throw new Error(`Illegal source: same filename (${source.filename}), different contents`);
-				}
-			}
-		}
+	return this;
+};
 
-		this.sources.push(source);
-		return this;
-	}
+Bundle$1.prototype.clone = function clone () {
+	var bundle = new Bundle$1({
+		intro: this.intro,
+		separator: this.separator
+	});
 
-	append(str, options) {
-		this.addSource({
-			content: new MagicString(str),
-			separator: (options && options.separator) || '',
+	this.sources.forEach(function (source) {
+		bundle.addSource({
+			filename: source.filename,
+			content: source.content.clone(),
+			separator: source.separator
 		});
+	});
 
-		return this;
-	}
+	return bundle;
+};
 
-	clone() {
-		const bundle = new Bundle$1({
-			intro: this.intro,
-			separator: this.separator,
-		});
+Bundle$1.prototype.generateDecodedMap = function generateDecodedMap (options) {
+		var this$1$1 = this;
+		if ( options === void 0 ) options = {};
 
-		this.sources.forEach((source) => {
-			bundle.addSource({
-				filename: source.filename,
-				content: source.content.clone(),
-				separator: source.separator,
-			});
+	var names = [];
+	this.sources.forEach(function (source) {
+		Object.keys(source.content.storedNames).forEach(function (name) {
+			if (!~names.indexOf(name)) { names.push(name); }
 		});
+	});
 
-		return bundle;
-	}
+	var mappings = new Mappings(options.hires);
 
-	generateDecodedMap(options = {}) {
-		const names = [];
-		this.sources.forEach((source) => {
-			Object.keys(source.content.storedNames).forEach((name) => {
-				if (!~names.indexOf(name)) names.push(name);
-			});
-		});
-
-		const mappings = new Mappings(options.hires);
+	if (this.intro) {
+		mappings.advance(this.intro);
+	}
 
-		if (this.intro) {
-			mappings.advance(this.intro);
+	this.sources.forEach(function (source, i) {
+		if (i > 0) {
+			mappings.advance(this$1$1.separator);
 		}
 
-		this.sources.forEach((source, i) => {
-			if (i > 0) {
-				mappings.advance(this.separator);
-			}
-
-			const sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;
-			const magicString = source.content;
-			const locate = getLocator$1(magicString.original);
+		var sourceIndex = source.filename ? this$1$1.uniqueSourceIndexByFilename[source.filename] : -1;
+		var magicString = source.content;
+		var locate = getLocator$1(magicString.original);
 
-			if (magicString.intro) {
-				mappings.advance(magicString.intro);
-			}
+		if (magicString.intro) {
+			mappings.advance(magicString.intro);
+		}
 
-			magicString.firstChunk.eachNext((chunk) => {
-				const loc = locate(chunk.start);
+		magicString.firstChunk.eachNext(function (chunk) {
+			var loc = locate(chunk.start);
 
-				if (chunk.intro.length) mappings.advance(chunk.intro);
+			if (chunk.intro.length) { mappings.advance(chunk.intro); }
 
-				if (source.filename) {
-					if (chunk.edited) {
-						mappings.addEdit(
-							sourceIndex,
-							chunk.content,
-							loc,
-							chunk.storeName ? names.indexOf(chunk.original) : -1
-						);
-					} else {
-						mappings.addUneditedChunk(
-							sourceIndex,
-							chunk,
-							magicString.original,
-							loc,
-							magicString.sourcemapLocations
-						);
-					}
+			if (source.filename) {
+				if (chunk.edited) {
+					mappings.addEdit(
+						sourceIndex,
+						chunk.content,
+						loc,
+						chunk.storeName ? names.indexOf(chunk.original) : -1
+					);
 				} else {
-					mappings.advance(chunk.content);
+					mappings.addUneditedChunk(
+						sourceIndex,
+						chunk,
+						magicString.original,
+						loc,
+						magicString.sourcemapLocations
+					);
 				}
-
-				if (chunk.outro.length) mappings.advance(chunk.outro);
-			});
-
-			if (magicString.outro) {
-				mappings.advance(magicString.outro);
+			} else {
+				mappings.advance(chunk.content);
 			}
+
+			if (chunk.outro.length) { mappings.advance(chunk.outro); }
 		});
 
-		return {
-			file: options.file ? options.file.split(/[/\\]/).pop() : null,
-			sources: this.uniqueSources.map((source) => {
-				return options.file ? getRelativePath(options.file, source.filename) : source.filename;
-			}),
-			sourcesContent: this.uniqueSources.map((source) => {
-				return options.includeContent ? source.content : null;
-			}),
-			names,
-			mappings: mappings.raw,
-		};
-	}
+		if (magicString.outro) {
+			mappings.advance(magicString.outro);
+		}
+	});
 
-	generateMap(options) {
-		return new SourceMap(this.generateDecodedMap(options));
-	}
+	return {
+		file: options.file ? options.file.split(/[/\\]/).pop() : null,
+		sources: this.uniqueSources.map(function (source) {
+			return options.file ? getRelativePath(options.file, source.filename) : source.filename;
+		}),
+		sourcesContent: this.uniqueSources.map(function (source) {
+			return options.includeContent ? source.content : null;
+		}),
+		names: names,
+		mappings: mappings.raw
+	};
+};
 
-	getIndentString() {
-		const indentStringCounts = {};
+Bundle$1.prototype.generateMap = function generateMap (options) {
+	return new SourceMap(this.generateDecodedMap(options));
+};
 
-		this.sources.forEach((source) => {
-			const indentStr = source.content._getRawIndentString();
+Bundle$1.prototype.getIndentString = function getIndentString () {
+	var indentStringCounts = {};
 
-			if (indentStr === null) return;
+	this.sources.forEach(function (source) {
+		var indentStr = source.content.indentStr;
 
-			if (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;
-			indentStringCounts[indentStr] += 1;
-		});
+		if (indentStr === null) { return; }
 
-		return (
-			Object.keys(indentStringCounts).sort((a, b) => {
-				return indentStringCounts[a] - indentStringCounts[b];
-			})[0] || '\t'
-		);
-	}
+		if (!indentStringCounts[indentStr]) { indentStringCounts[indentStr] = 0; }
+		indentStringCounts[indentStr] += 1;
+	});
 
-	indent(indentStr) {
-		if (!arguments.length) {
-			indentStr = this.getIndentString();
-		}
+	return (
+		Object.keys(indentStringCounts).sort(function (a, b) {
+			return indentStringCounts[a] - indentStringCounts[b];
+		})[0] || '\t'
+	);
+};
 
-		if (indentStr === '') return this; // noop
+Bundle$1.prototype.indent = function indent (indentStr) {
+		var this$1$1 = this;
 
-		let trailingNewline = !this.intro || this.intro.slice(-1) === '\n';
+	if (!arguments.length) {
+		indentStr = this.getIndentString();
+	}
 
-		this.sources.forEach((source, i) => {
-			const separator = source.separator !== undefined ? source.separator : this.separator;
-			const indentStart = trailingNewline || (i > 0 && /\r?\n$/.test(separator));
+	if (indentStr === '') { return this; } // noop
 
-			source.content.indent(indentStr, {
-				exclude: source.indentExclusionRanges,
-				indentStart, //: trailingNewline || /\r?\n$/.test( separator )  //true///\r?\n/.test( separator )
-			});
+	var trailingNewline = !this.intro || this.intro.slice(-1) === '\n';
 
-			trailingNewline = source.content.lastChar() === '\n';
+	this.sources.forEach(function (source, i) {
+		var separator = source.separator !== undefined ? source.separator : this$1$1.separator;
+		var indentStart = trailingNewline || (i > 0 && /\r?\n$/.test(separator));
+
+		source.content.indent(indentStr, {
+			exclude: source.indentExclusionRanges,
+			indentStart: indentStart //: trailingNewline || /\r?\n$/.test( separator )  //true///\r?\n/.test( separator )
 		});
 
-		if (this.intro) {
-			this.intro =
-				indentStr +
-				this.intro.replace(/^[^\n]/gm, (match, index) => {
-					return index > 0 ? indentStr + match : match;
-				});
-		}
+		trailingNewline = source.content.lastChar() === '\n';
+	});
 
-		return this;
+	if (this.intro) {
+		this.intro =
+			indentStr +
+			this.intro.replace(/^[^\n]/gm, function (match, index) {
+				return index > 0 ? indentStr + match : match;
+			});
 	}
 
-	prepend(str) {
-		this.intro = str + this.intro;
-		return this;
-	}
+	return this;
+};
 
-	toString() {
-		const body = this.sources
-			.map((source, i) => {
-				const separator = source.separator !== undefined ? source.separator : this.separator;
-				const str = (i > 0 ? separator : '') + source.content.toString();
-
-				return str;
-			})
-			.join('');
+Bundle$1.prototype.prepend = function prepend (str) {
+	this.intro = str + this.intro;
+	return this;
+};
 
-		return this.intro + body;
-	}
+Bundle$1.prototype.toString = function toString () {
+		var this$1$1 = this;
 
-	isEmpty() {
-		if (this.intro.length && this.intro.trim()) return false;
-		if (this.sources.some((source) => !source.content.isEmpty())) return false;
-		return true;
-	}
+	var body = this.sources
+		.map(function (source, i) {
+			var separator = source.separator !== undefined ? source.separator : this$1$1.separator;
+			var str = (i > 0 ? separator : '') + source.content.toString();
 
-	length() {
-		return this.sources.reduce(
-			(length, source) => length + source.content.length(),
-			this.intro.length
-		);
-	}
+			return str;
+		})
+		.join('');
 
-	trimLines() {
-		return this.trim('[\\r\\n]');
-	}
+	return this.intro + body;
+};
 
-	trim(charType) {
-		return this.trimStart(charType).trimEnd(charType);
-	}
+Bundle$1.prototype.isEmpty = function isEmpty () {
+	if (this.intro.length && this.intro.trim())
+		{ return false; }
+	if (this.sources.some(function (source) { return !source.content.isEmpty(); }))
+		{ return false; }
+	return true;
+};
 
-	trimStart(charType) {
-		const rx = new RegExp('^' + (charType || '\\s') + '+');
-		this.intro = this.intro.replace(rx, '');
+Bundle$1.prototype.length = function length () {
+	return this.sources.reduce(function (length, source) { return length + source.content.length(); }, this.intro.length);
+};
 
-		if (!this.intro) {
-			let source;
-			let i = 0;
-
-			do {
-				source = this.sources[i++];
-				if (!source) {
-					break;
-				}
-			} while (!source.content.trimStartAborted(charType));
-		}
+Bundle$1.prototype.trimLines = function trimLines () {
+	return this.trim('[\\r\\n]');
+};
 
-		return this;
-	}
+Bundle$1.prototype.trim = function trim (charType) {
+	return this.trimStart(charType).trimEnd(charType);
+};
 
-	trimEnd(charType) {
-		const rx = new RegExp((charType || '\\s') + '+$');
+Bundle$1.prototype.trimStart = function trimStart (charType) {
+	var rx = new RegExp('^' + (charType || '\\s') + '+');
+	this.intro = this.intro.replace(rx, '');
 
-		let source;
-		let i = this.sources.length - 1;
+	if (!this.intro) {
+		var source;
+		var i = 0;
 
 		do {
-			source = this.sources[i--];
+			source = this.sources[i++];
 			if (!source) {
-				this.intro = this.intro.replace(rx, '');
 				break;
 			}
-		} while (!source.content.trimEndAborted(charType));
-
-		return this;
+		} while (!source.content.trimStartAborted(charType));
 	}
+
+	return this;
 };
 
-const ANY_SLASH_REGEX = /[/\\]/;
+Bundle$1.prototype.trimEnd = function trimEnd (charType) {
+	var rx = new RegExp((charType || '\\s') + '+$');
+
+	var source;
+	var i = this.sources.length - 1;
+
+	do {
+		source = this.sources[i--];
+		if (!source) {
+			this.intro = this.intro.replace(rx, '');
+			break;
+		}
+	} while (!source.content.trimEndAborted(charType));
+
+	return this;
+};
+
+const MagicString$1 = MagicString;
+
 function relative(from, to) {
-    const fromParts = from.split(ANY_SLASH_REGEX).filter(Boolean);
-    const toParts = to.split(ANY_SLASH_REGEX).filter(Boolean);
+    const fromParts = from.split(/[/\\]/).filter(Boolean);
+    const toParts = to.split(/[/\\]/).filter(Boolean);
     if (fromParts[0] === '.')
         fromParts.shift();
     if (toParts[0] === '.')
@@ -1623,130 +1463,20 @@
     return toParts.join('/');
 }
 
-const needsEscapeRegEx = /[\n\r'\\\u2028\u2029]/;
-const quoteNewlineRegEx = /([\n\r'\u2028\u2029])/g;
-const backSlashRegEx = /\\/g;
-function escapeId(id) {
-    if (!needsEscapeRegEx.test(id))
-        return id;
-    return id.replace(backSlashRegEx, '\\\\').replace(quoteNewlineRegEx, '\\$1');
-}
-
-const ABSOLUTE_PATH_REGEX = /^(?:\/|(?:[A-Za-z]:)?[/\\|])/;
-const RELATIVE_PATH_REGEX = /^\.?\.(\/|$)/;
-function isAbsolute(path) {
-    return ABSOLUTE_PATH_REGEX.test(path);
-}
-function isRelative(path) {
-    return RELATIVE_PATH_REGEX.test(path);
-}
-const BACKSLASH_REGEX = /\\/g;
-function normalize(path) {
-    return path.replace(BACKSLASH_REGEX, '/');
-}
-
-function getAliasName(id) {
-    const base = basename(id);
-    return base.slice(0, Math.max(0, base.length - extname(id).length));
-}
-function relativeId(id) {
-    if (!isAbsolute(id))
-        return id;
-    return relative(resolve(), id);
-}
-function isPathFragment(name) {
-    // starting with "/", "./", "../", "C:/"
-    return (name[0] === '/' || (name[0] === '.' && (name[1] === '/' || name[1] === '.')) || isAbsolute(name));
-}
-const UPPER_DIR_REGEX = /^(\.\.\/)*\.\.$/;
-function getImportPath(importerId, targetPath, stripJsExtension, ensureFileName) {
-    let relativePath = normalize(relative(dirname(importerId), targetPath));
-    if (stripJsExtension && relativePath.endsWith('.js')) {
-        relativePath = relativePath.slice(0, -3);
-    }
-    if (ensureFileName) {
-        if (relativePath === '')
-            return '../' + basename(targetPath);
-        if (UPPER_DIR_REGEX.test(relativePath)) {
-            return [...relativePath.split('/'), '..', basename(targetPath)].join('/');
-        }
-    }
-    return relativePath ? (relativePath.startsWith('..') ? relativePath : './' + relativePath) : '.';
-}
-
-class ExternalChunk {
-    constructor(module, options, inputBase) {
-        this.options = options;
-        this.inputBase = inputBase;
-        this.defaultVariableName = '';
-        this.namespaceVariableName = '';
-        this.variableName = '';
-        this.fileName = null;
-        this.importAssertions = null;
-        this.id = module.id;
-        this.moduleInfo = module.info;
-        this.renormalizeRenderPath = module.renormalizeRenderPath;
-        this.suggestedVariableName = module.suggestedVariableName;
-    }
-    getFileName() {
-        if (this.fileName) {
-            return this.fileName;
-        }
-        const { paths } = this.options;
-        return (this.fileName =
-            (typeof paths === 'function' ? paths(this.id) : paths[this.id]) ||
-                (this.renormalizeRenderPath ? normalize(relative$1(this.inputBase, this.id)) : this.id));
-    }
-    getImportAssertions(snippets) {
-        return (this.importAssertions || (this.importAssertions = formatAssertions$1(this.options.format === 'es' &&
-            this.options.externalImportAssertions &&
-            this.moduleInfo.assertions, snippets)));
-    }
-    getImportPath(importer) {
-        return escapeId(this.renormalizeRenderPath
-            ? getImportPath(importer, this.getFileName(), this.options.format === 'amd', false)
-            : this.getFileName());
-    }
-}
-function formatAssertions$1(assertions, { getObject }) {
-    if (!assertions) {
-        return null;
-    }
-    const assertionEntries = Object.entries(assertions).map(([key, value]) => [key, `'${value}'`]);
-    if (assertionEntries.length > 0) {
-        return getObject(assertionEntries, { lineBreakIndent: null });
-    }
-    return null;
-}
-
 function getOrCreate(map, key, init) {
     const existing = map.get(key);
-    if (existing !== undefined) {
+    if (existing) {
         return existing;
     }
     const value = init();
     map.set(key, value);
     return value;
 }
-function getNewSet() {
-    return new Set();
-}
-function getNewArray() {
-    return [];
-}
 
 const UnknownKey = Symbol('Unknown Key');
-const UnknownNonAccessorKey = Symbol('Unknown Non-Accessor Key');
 const UnknownInteger = Symbol('Unknown Integer');
-const SymbolToStringTag = Symbol('Symbol.toStringTag');
 const EMPTY_PATH = [];
 const UNKNOWN_PATH = [UnknownKey];
-// For deoptimizations, this means we are modifying an unknown property but did
-// not lose track of the object or are creating a setter/getter;
-// For assignment effects it means we do not check for setter/getter effects
-// but only if something is mutated that is included, which is relevant for
-// Object.defineProperty
-const UNKNOWN_NON_ACCESSOR_PATH = [UnknownNonAccessorKey];
 const UNKNOWN_INTEGER_PATH = [UnknownInteger];
 const EntitiesKey = Symbol('Entities');
 class PathTracker {
@@ -1795,7 +1525,7 @@
                 currentPaths[pathSegment] ||
                     Object.create(null, { [EntitiesKey]: { value: new Map() } });
         }
-        const trackedEntities = getOrCreate(currentPaths[EntitiesKey], discriminator, getNewSet);
+        const trackedEntities = getOrCreate(currentPaths[EntitiesKey], discriminator, () => new Set());
         if (trackedEntities.has(entity))
             return true;
         trackedEntities.add(entity);
@@ -1804,78 +1534,51 @@
 }
 
 const UnknownValue = Symbol('Unknown Value');
-const UnknownTruthyValue = Symbol('Unknown Truthy Value');
 class ExpressionEntity {
     constructor() {
         this.included = false;
     }
     deoptimizePath(_path) { }
-    deoptimizeThisOnInteractionAtPath({ thisArg }, _path, _recursionTracker) {
-        thisArg.deoptimizePath(UNKNOWN_PATH);
+    deoptimizeThisOnEventAtPath(_event, _path, thisParameter, _recursionTracker) {
+        thisParameter.deoptimizePath(UNKNOWN_PATH);
     }
     /**
      * If possible it returns a stringifyable literal value for this node that can be used
      * for inlining or comparing values.
-     * Otherwise, it should return UnknownValue.
+     * Otherwise it should return UnknownValue.
      */
     getLiteralValueAtPath(_path, _recursionTracker, _origin) {
         return UnknownValue;
     }
-    getReturnExpressionWhenCalledAtPath(_path, _interaction, _recursionTracker, _origin) {
-        return UNKNOWN_RETURN_EXPRESSION;
+    getReturnExpressionWhenCalledAtPath(_path, _callOptions, _recursionTracker, _origin) {
+        return UNKNOWN_EXPRESSION;
+    }
+    hasEffectsWhenAccessedAtPath(_path, _context) {
+        return true;
     }
-    hasEffectsOnInteractionAtPath(_path, _interaction, _context) {
+    hasEffectsWhenAssignedAtPath(_path, _context) {
         return true;
     }
-    include(_context, _includeChildrenRecursively, _options) {
+    hasEffectsWhenCalledAtPath(_path, _callOptions, _context) {
+        return true;
+    }
+    include(_context, _includeChildrenRecursively) {
         this.included = true;
     }
-    includeCallArguments(context, parameters) {
-        for (const argument of parameters) {
-            argument.include(context, false);
+    includeCallArguments(context, args) {
+        for (const arg of args) {
+            arg.include(context, false);
         }
     }
-    shouldBeIncluded(_context) {
-        return true;
-    }
 }
 const UNKNOWN_EXPRESSION = new (class UnknownExpression extends ExpressionEntity {
 })();
-const UNKNOWN_RETURN_EXPRESSION = [
-    UNKNOWN_EXPRESSION,
-    false
-];
-
-const INTERACTION_ACCESSED = 0;
-const INTERACTION_ASSIGNED = 1;
-const INTERACTION_CALLED = 2;
-const NODE_INTERACTION_UNKNOWN_ACCESS = {
-    thisArg: null,
-    type: INTERACTION_ACCESSED
-};
-const UNKNOWN_ARG = [UNKNOWN_EXPRESSION];
-const NODE_INTERACTION_UNKNOWN_ASSIGNMENT = {
-    args: UNKNOWN_ARG,
-    thisArg: null,
-    type: INTERACTION_ASSIGNED
-};
-const NO_ARGS = [];
-// While this is technically a call without arguments, we can compare against
-// this reference in places where precise values or thisArg would make a
-// difference
-const NODE_INTERACTION_UNKNOWN_CALL = {
-    args: NO_ARGS,
-    thisArg: null,
-    type: INTERACTION_CALLED,
-    withNew: false
-};
 
 class Variable extends ExpressionEntity {
     constructor(name) {
         super();
         this.name = name;
         this.alwaysRendered = false;
-        this.forbiddenNames = null;
         this.initReached = false;
         this.isId = false;
         this.isReassigned = false;
@@ -1888,13 +1591,6 @@
      * Necessary to be able to change variable names.
      */
     addReference(_identifier) { }
-    /**
-     * Prevent this variable from being renamed to this name to avoid name
-     * collisions
-     */
-    forbidName(name) {
-        (this.forbiddenNames || (this.forbiddenNames = new Set())).add(name);
-    }
     getBaseVariableName() {
         return this.renderBaseName || this.renderName || this.name;
     }
@@ -1902,8 +1598,8 @@
         const name = this.renderName || this.name;
         return this.renderBaseName ? `${this.renderBaseName}${getPropertyAccess(name)}` : name;
     }
-    hasEffectsOnInteractionAtPath(path, { type }, _context) {
-        return type !== INTERACTION_ACCESSED || path.length > 0;
+    hasEffectsWhenAccessedAtPath(path, _context) {
+        return path.length > 0;
     }
     /**
      * Marks this variable as being part of the bundle, which is usually the case when one of
@@ -1934,8 +1630,8 @@
             this.module.suggestName(identifier.name);
         }
     }
-    hasEffectsOnInteractionAtPath(path, { type }) {
-        return type !== INTERACTION_ACCESSED || path.length > (this.isNamespace ? 1 : 0);
+    hasEffectsWhenAccessedAtPath(path) {
+        return path.length > (this.isNamespace ? 1 : 0);
     }
     include() {
         if (!this.included) {
@@ -1949,79 +1645,36 @@
 const EMPTY_OBJECT = Object.freeze({});
 const EMPTY_ARRAY = Object.freeze([]);
 
-function getLocator(source, options) {
-    if (options === void 0) { options = {}; }
-    var offsetLine = options.offsetLine || 0;
-    var offsetColumn = options.offsetColumn || 0;
-    var originalLines = source.split('\n');
-    var start = 0;
-    var lineRanges = originalLines.map(function (line, i) {
-        var end = start + line.length + 1;
-        var range = { start: start, end: end, line: i };
-        start = end;
-        return range;
-    });
-    var i = 0;
-    function rangeContains(range, index) {
-        return range.start <= index && index < range.end;
-    }
-    function getLocation(range, index) {
-        return { line: offsetLine + range.line, column: offsetColumn + index - range.start, character: index };
-    }
-    function locate(search, startIndex) {
-        if (typeof search === 'string') {
-            search = source.indexOf(search, startIndex || 0);
-        }
-        var range = lineRanges[i];
-        var d = search >= range.end ? 1 : -1;
-        while (range) {
-            if (rangeContains(range, search))
-                return getLocation(range, search);
-            i += d;
-            range = lineRanges[i];
-        }
+const reservedWords$2 = 'break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public'.split(' ');
+const builtins$2 = 'Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl'.split(' ');
+const blacklisted = new Set(reservedWords$2.concat(builtins$2));
+const illegalCharacters = /[^$_a-zA-Z0-9]/g;
+const startsWithDigit = (str) => /\d/.test(str[0]);
+function isLegal(str) {
+    if (startsWithDigit(str) || blacklisted.has(str)) {
+        return false;
     }
-    return locate;
+    return !illegalCharacters.test(str);
 }
-function locate(source, search, options) {
-    if (typeof options === 'number') {
-        throw new Error('locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument');
-    }
-    return getLocator(source, options)(search, options && options.startIndex);
+function makeLegal(str) {
+    str = str.replace(/-(\w)/g, (_, letter) => letter.toUpperCase()).replace(illegalCharacters, '_');
+    if (startsWithDigit(str) || blacklisted.has(str))
+        str = `_${str}`;
+    return str || '_';
 }
 
-function spaces(index) {
-    let result = '';
-    while (index--)
-        result += ' ';
-    return result;
+const absolutePath = /^(?:\/|(?:[A-Za-z]:)?[\\|/])/;
+const relativePath = /^\.?\.\//;
+function isAbsolute(path) {
+    return absolutePath.test(path);
 }
-function tabsToSpaces(value) {
-    return value.replace(/^\t+/, match => match.split('\t').join('  '));
+function isRelative(path) {
+    return relativePath.test(path);
 }
-function getCodeFrame(source, line, column) {
-    let lines = source.split('\n');
-    const frameStart = Math.max(0, line - 3);
-    let frameEnd = Math.min(line + 2, lines.length);
-    lines = lines.slice(frameStart, frameEnd);
-    while (!/\S/.test(lines[lines.length - 1])) {
-        lines.pop();
-        frameEnd -= 1;
-    }
-    const digits = String(frameEnd).length;
-    return lines
-        .map((sourceLine, index) => {
-        const isErrorLine = frameStart + index + 1 === line;
-        let lineNumber = String(index + frameStart + 1);
-        while (lineNumber.length < digits)
-            lineNumber = ` ${lineNumber}`;
-        if (isErrorLine) {
-            const indicator = spaces(digits + 2 + tabsToSpaces(sourceLine.slice(0, column)).length) + '^';
-            return `${lineNumber}: ${tabsToSpaces(sourceLine)}\n${indicator}`;
-        }
-        return `${lineNumber}: ${tabsToSpaces(sourceLine)}`;
-    })
-        .join('\n');
+function normalize(path) {
+    if (path.indexOf('\\') == -1)
+        return path;
+    return path.replace(/\\/g, '/');
 }
 
 function printQuotedStringList(list, verbs) {
@@ -2036,782 +1689,118 @@
     return output;
 }
 
-function isValidUrl(url) {
-    try {
-        new URL(url);
-    }
-    catch {
-        return false;
-    }
-    return true;
-}
-function getRollupUrl(snippet) {
-    return `https://rollupjs.org/${snippet}`;
-}
-
-// troubleshooting
-const URL_AVOIDING_EVAL = 'troubleshooting/#avoiding-eval';
-const URL_NAME_IS_NOT_EXPORTED = 'troubleshooting/#error-name-is-not-exported-by-module';
-const URL_THIS_IS_UNDEFINED = 'troubleshooting/#error-this-is-undefined';
-const URL_TREATING_MODULE_AS_EXTERNAL_DEPENDENCY = 'troubleshooting/#warning-treating-module-as-external-dependency';
-const URL_SOURCEMAP_IS_LIKELY_TO_BE_INCORRECT = 'troubleshooting/#warning-sourcemap-is-likely-to-be-incorrect';
-// configuration-options
-const URL_MAXPARALLELFILEOPS = 'configuration-options/#maxparallelfileops';
-const URL_OUTPUT_AMD_ID = 'configuration-options/#output-amd-id';
-const URL_OUTPUT_AMD_BASEPATH = 'configuration-options/#output-amd-basepath';
-const URL_OUTPUT_DIR = 'configuration-options/#output-dir';
-const URL_OUTPUT_DYNAMICIMPORTFUNCTION = 'configuration-options/#output-dynamicimportfunction';
-const URL_OUTPUT_EXPORTS = 'configuration-options/#output-exports';
-const URL_OUTPUT_EXTEND = 'configuration-options/#output-extend';
-const URL_OUTPUT_FORMAT = 'configuration-options/#output-format';
-const URL_OUTPUT_GENERATEDCODE = 'configuration-options/#output-generatedcode';
-const URL_OUTPUT_GENERATEDCODE_CONSTBINDINGS = 'configuration-options/#output-generatedcode-constbindings';
-const URL_OUTPUT_GENERATEDCODE_SYMBOLS = 'configuration-options/#output-generatedcode-symbols';
-const URL_OUTPUT_GLOBALS = 'configuration-options/#output-globals';
-const URL_OUTPUT_INLINEDYNAMICIMPORTS = 'configuration-options/#output-inlinedynamicimports';
-const URL_OUTPUT_INTEROP = 'configuration-options/#output-interop';
-const URL_OUTPUT_MANUALCHUNKS = 'configuration-options/#output-manualchunks';
-const URL_OUTPUT_NAME = 'configuration-options/#output-name';
-const URL_OUTPUT_PRESERVEMODULES = 'configuration-options/#output-preservemodules';
-const URL_OUTPUT_SOURCEMAPBASEURL = 'configuration-options/#output-sourcemapbaseurl';
-const URL_OUTPUT_SOURCEMAPFILE = 'configuration-options/#output-sourcemapfile';
-const URL_PRESERVEENTRYSIGNATURES = 'configuration-options/#preserveentrysignatures';
-const URL_TREESHAKE = 'configuration-options/#treeshake';
-const URL_TREESHAKE_MODULESIDEEFFECTS = 'configuration-options/#treeshake-modulesideeffects';
-const URL_WATCH = 'configuration-options/#watch';
-const URL_RENDERDYNAMICIMPORT = 'plugin-development/#renderdynamicimport';
-const URL_THIS_GETMODULEIDS = 'plugin-development/#this-getmoduleids';
-const URL_THIS_GETMODULEINFO = 'plugin-development/#this-getmoduleinfo';
-
-function error(base) {
-    if (!(base instanceof Error)) {
-        base = Object.assign(new Error(base.message), base);
-        Object.defineProperty(base, 'name', { value: 'RollupError' });
-    }
-    throw base;
-}
-function augmentCodeLocation(properties, pos, source, id) {
-    if (typeof pos === 'object') {
-        const { line, column } = pos;
-        properties.loc = { column, file: id, line };
-    }
-    else {
-        properties.pos = pos;
-        const { line, column } = locate(source, pos, { offsetLine: 1 });
-        properties.loc = { column, file: id, line };
-    }
-    if (properties.frame === undefined) {
-        const { line, column } = properties.loc;
-        properties.frame = getCodeFrame(source, line, column);
-    }
-}
-// Error codes should be sorted alphabetically while errors should be sorted by
-// error code below
-const ADDON_ERROR = 'ADDON_ERROR', ALREADY_CLOSED = 'ALREADY_CLOSED', AMBIGUOUS_EXTERNAL_NAMESPACES = 'AMBIGUOUS_EXTERNAL_NAMESPACES', ANONYMOUS_PLUGIN_CACHE = 'ANONYMOUS_PLUGIN_CACHE', ASSET_NOT_FINALISED = 'ASSET_NOT_FINALISED', ASSET_NOT_FOUND = 'ASSET_NOT_FOUND', ASSET_SOURCE_ALREADY_SET = 'ASSET_SOURCE_ALREADY_SET', ASSET_SOURCE_MISSING = 'ASSET_SOURCE_MISSING', BAD_LOADER = 'BAD_LOADER', CANNOT_CALL_NAMESPACE = 'CANNOT_CALL_NAMESPACE', CANNOT_EMIT_FROM_OPTIONS_HOOK = 'CANNOT_EMIT_FROM_OPTIONS_HOOK', CHUNK_NOT_GENERATED = 'CHUNK_NOT_GENERATED', CHUNK_INVALID = 'CHUNK_INVALID', CIRCULAR_DEPENDENCY = 'CIRCULAR_DEPENDENCY', CIRCULAR_REEXPORT = 'CIRCULAR_REEXPORT', CYCLIC_CROSS_CHUNK_REEXPORT = 'CYCLIC_CROSS_CHUNK_REEXPORT', DEPRECATED_FEATURE = 'DEPRECATED_FEATURE', DUPLICATE_PLUGIN_NAME = 'DUPLICATE_PLUGIN_NAME', EMPTY_BUNDLE = 'EMPTY_BUNDLE', EVAL = 'EVAL', EXTERNAL_SYNTHETIC_EXPORTS = 'EXTERNAL_SYNTHETIC_EXPORTS', FILE_NAME_CONFLICT = 'FILE_NAME_CONFLICT', FILE_NOT_FOUND = 'FILE_NOT_FOUND', ILLEGAL_IDENTIFIER_AS_NAME = 'ILLEGAL_IDENTIFIER_AS_NAME', ILLEGAL_REASSIGNMENT = 'ILLEGAL_REASSIGNMENT', INCONSISTENT_IMPORT_ASSERTIONS = 'INCONSISTENT_IMPORT_ASSERTIONS', INPUT_HOOK_IN_OUTPUT_PLUGIN = 'INPUT_HOOK_IN_OUTPUT_PLUGIN', INVALID_CHUNK = 'INVALID_CHUNK', INVALID_EXPORT_OPTION = 'INVALID_EXPORT_OPTION', INVALID_EXTERNAL_ID = 'INVALID_EXTERNAL_ID', INVALID_OPTION = 'INVALID_OPTION', INVALID_PLUGIN_HOOK = 'INVALID_PLUGIN_HOOK', INVALID_ROLLUP_PHASE = 'INVALID_ROLLUP_PHASE', INVALID_SETASSETSOURCE = 'INVALID_SETASSETSOURCE', INVALID_TLA_FORMAT = 'INVALID_TLA_FORMAT', MISSING_EXPORT = 'MISSING_EXPORT', MISSING_GLOBAL_NAME = 'MISSING_GLOBAL_NAME', MISSING_IMPLICIT_DEPENDANT = 'MISSING_IMPLICIT_DEPENDANT', MISSING_NAME_OPTION_FOR_IIFE_EXPORT = 'MISSING_NAME_OPTION_FOR_IIFE_EXPORT', MISSING_NODE_BUILTINS = 'MISSING_NODE_BUILTINS', MISSING_OPTION = 'MISSING_OPTION', MIXED_EXPORTS = 'MIXED_EXPORTS', MODULE_LEVEL_DIRECTIVE = 'MODULE_LEVEL_DIRECTIVE', NAMESPACE_CONFLICT = 'NAMESPACE_CONFLICT', NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE = 'NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE', PARSE_ERROR = 'PARSE_ERROR', PLUGIN_ERROR = 'PLUGIN_ERROR', SHIMMED_EXPORT = 'SHIMMED_EXPORT', SOURCEMAP_BROKEN = 'SOURCEMAP_BROKEN', SOURCEMAP_ERROR = 'SOURCEMAP_ERROR', SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT = 'SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT', THIS_IS_UNDEFINED = 'THIS_IS_UNDEFINED', UNEXPECTED_NAMED_IMPORT = 'UNEXPECTED_NAMED_IMPORT', UNKNOWN_OPTION = 'UNKNOWN_OPTION', UNRESOLVED_ENTRY = 'UNRESOLVED_ENTRY', UNRESOLVED_IMPORT = 'UNRESOLVED_IMPORT', UNUSED_EXTERNAL_IMPORT = 'UNUSED_EXTERNAL_IMPORT', VALIDATION_ERROR = 'VALIDATION_ERROR';
-function errorAddonNotGenerated(message, hook, plugin) {
-    return {
-        code: ADDON_ERROR,
-        message: `Could not retrieve "${hook}". Check configuration of plugin "${plugin}".
-\tError Message: ${message}`
-    };
-}
-function errorAlreadyClosed() {
-    return {
-        code: ALREADY_CLOSED,
-        message: 'Bundle is already closed, no more calls to "generate" or "write" are allowed.'
-    };
-}
-function errorAmbiguousExternalNamespaces(binding, reexportingModule, usedModule, sources) {
-    return {
-        binding,
-        code: AMBIGUOUS_EXTERNAL_NAMESPACES,
-        ids: sources,
-        message: `Ambiguous external namespace resolution: "${relativeId(reexportingModule)}" re-exports "${binding}" from one of the external modules ${printQuotedStringList(sources.map(module => relativeId(module)))}, guessing "${relativeId(usedModule)}".`,
-        reexporter: reexportingModule
-    };
-}
-function errorAnonymousPluginCache() {
-    return {
-        code: ANONYMOUS_PLUGIN_CACHE,
-        message: 'A plugin is trying to use the Rollup cache but is not declaring a plugin name or cacheKey.'
-    };
-}
-function errorAssetNotFinalisedForFileName(name) {
-    return {
-        code: ASSET_NOT_FINALISED,
-        message: `Plugin error - Unable to get file name for asset "${name}". Ensure that the source is set and that generate is called first. If you reference assets via import.meta.ROLLUP_FILE_URL_<referenceId>, you need to either have set their source after "renderStart" or need to provide an explicit "fileName" when emitting them.`
-    };
-}
-function errorAssetReferenceIdNotFoundForSetSource(assetReferenceId) {
-    return {
-        code: ASSET_NOT_FOUND,
-        message: `Plugin error - Unable to set the source for unknown asset "${assetReferenceId}".`
-    };
-}
-function errorAssetSourceAlreadySet(name) {
-    return {
-        code: ASSET_SOURCE_ALREADY_SET,
-        message: `Unable to set the source for asset "${name}", source already set.`
-    };
-}
-function errorNoAssetSourceSet(assetName) {
-    return {
-        code: ASSET_SOURCE_MISSING,
-        message: `Plugin error creating asset "${assetName}" - no asset source set.`
-    };
-}
-function errorBadLoader(id) {
-    return {
-        code: BAD_LOADER,
-        message: `Error loading "${relativeId(id)}": plugin load hook should return a string, a { code, map } object, or nothing/null.`
-    };
-}
-function errorCannotCallNamespace(name) {
-    return {
-        code: CANNOT_CALL_NAMESPACE,
-        message: `Cannot call a namespace ("${name}").`
-    };
-}
-function errorCannotEmitFromOptionsHook() {
-    return {
-        code: CANNOT_EMIT_FROM_OPTIONS_HOOK,
-        message: `Cannot emit files or set asset sources in the "outputOptions" hook, use the "renderStart" hook instead.`
-    };
-}
-function errorChunkNotGeneratedForFileName(name) {
-    return {
-        code: CHUNK_NOT_GENERATED,
-        message: `Plugin error - Unable to get file name for emitted chunk "${name}". You can only get file names once chunks have been generated after the "renderStart" hook.`
-    };
-}
-function errorChunkInvalid({ fileName, code }, exception) {
-    const errorProperties = {
-        code: CHUNK_INVALID,
-        message: `Chunk "${fileName}" is not valid JavaScript: ${exception.message}.`
-    };
-    augmentCodeLocation(errorProperties, exception.loc, code, fileName);
-    return errorProperties;
-}
-function errorCircularDependency(cyclePath) {
-    return {
-        code: CIRCULAR_DEPENDENCY,
-        ids: cyclePath,
-        message: `Circular dependency: ${cyclePath.map(relativeId).join(' -> ')}`
-    };
-}
-function errorCircularReexport(exportName, exporter) {
-    return {
-        code: CIRCULAR_REEXPORT,
-        exporter,
-        message: `"${exportName}" cannot be exported from "${relativeId(exporter)}" as it is a reexport that references itself.`
-    };
-}
-function errorCyclicCrossChunkReexport(exportName, exporter, reexporter, importer) {
-    return {
-        code: CYCLIC_CROSS_CHUNK_REEXPORT,
-        exporter,
-        id: importer,
-        message: `Export "${exportName}" of module "${relativeId(exporter)}" was reexported through module "${relativeId(reexporter)}" while both modules are dependencies of each other and will end up in different chunks by current Rollup settings. This scenario is not well supported at the moment as it will produce a circular dependency between chunks and will likely lead to broken execution order.\nEither change the import in "${relativeId(importer)}" to point directly to the exporting module or do not use "preserveModules" to ensure these modules end up in the same chunk.`,
-        reexporter
-    };
-}
-function errorDeprecation(deprecation, urlSnippet, plugin) {
-    return {
-        code: DEPRECATED_FEATURE,
-        message: deprecation,
-        url: getRollupUrl(urlSnippet),
-        ...(plugin ? { plugin } : {})
-    };
-}
-function errorDuplicatePluginName(plugin) {
-    return {
-        code: DUPLICATE_PLUGIN_NAME,
-        message: `The plugin name ${plugin} is being used twice in the same build. Plugin names must be distinct or provide a cacheKey (please post an issue to the plugin if you are a plugin user).`
-    };
-}
-function errorEmptyChunk(chunkName) {
-    return {
-        code: EMPTY_BUNDLE,
-        message: `Generated an empty chunk: "${chunkName}".`,
-        names: [chunkName]
-    };
-}
-function errorEval(id) {
-    return {
-        code: EVAL,
-        id,
-        message: `Use of eval in "${relativeId(id)}" is strongly discouraged as it poses security risks and may cause issues with minification.`,
-        url: getRollupUrl(URL_AVOIDING_EVAL)
-    };
-}
-function errorExternalSyntheticExports(id, importer) {
-    return {
-        code: EXTERNAL_SYNTHETIC_EXPORTS,
-        exporter: id,
-        message: `External "${id}" cannot have "syntheticNamedExports" enabled (imported by "${relativeId(importer)}").`
-    };
-}
-function errorFileNameConflict(fileName) {
-    return {
-        code: FILE_NAME_CONFLICT,
-        message: `The emitted file "${fileName}" overwrites a previously emitted file of the same name.`
-    };
-}
-function errorFileReferenceIdNotFoundForFilename(assetReferenceId) {
-    return {
-        code: FILE_NOT_FOUND,
-        message: `Plugin error - Unable to get file name for unknown file "${assetReferenceId}".`
-    };
-}
-function errorIllegalIdentifierAsName(name) {
-    return {
-        code: ILLEGAL_IDENTIFIER_AS_NAME,
-        message: `Given name "${name}" is not a legal JS identifier. If you need this, you can try "output.extend: true".`,
-        url: getRollupUrl(URL_OUTPUT_EXTEND)
-    };
-}
-function errorIllegalImportReassignment(name, importingId) {
-    return {
-        code: ILLEGAL_REASSIGNMENT,
-        message: `Illegal reassignment of import "${name}" in "${relativeId(importingId)}".`
-    };
-}
-function errorInconsistentImportAssertions(existingAssertions, newAssertions, source, importer) {
-    return {
-        code: INCONSISTENT_IMPORT_ASSERTIONS,
-        message: `Module "${relativeId(importer)}" tried to import "${relativeId(source)}" with ${formatAssertions(newAssertions)} assertions, but it was already imported elsewhere with ${formatAssertions(existingAssertions)} assertions. Please ensure that import assertions for the same module are always consistent.`
-    };
-}
-const formatAssertions = (assertions) => {
-    const entries = Object.entries(assertions);
-    if (entries.length === 0)
-        return 'no';
-    return entries.map(([key, value]) => `"${key}": "${value}"`).join(', ');
-};
-function errorInputHookInOutputPlugin(pluginName, hookName) {
-    return {
-        code: INPUT_HOOK_IN_OUTPUT_PLUGIN,
-        message: `The "${hookName}" hook used by the output plugin ${pluginName} is a build time hook and will not be run for that plugin. Either this plugin cannot be used as an output plugin, or it should have an option to configure it as an output plugin.`
-    };
-}
-function errorCannotAssignModuleToChunk(moduleId, assignToAlias, currentAlias) {
-    return {
-        code: INVALID_CHUNK,
-        message: `Cannot assign "${relativeId(moduleId)}" to the "${assignToAlias}" chunk as it is already in the "${currentAlias}" chunk.`
-    };
-}
-function errorInvalidExportOptionValue(optionValue) {
-    return {
-        code: INVALID_EXPORT_OPTION,
-        message: `"output.exports" must be "default", "named", "none", "auto", or left unspecified (defaults to "auto"), received "${optionValue}".`,
-        url: getRollupUrl(URL_OUTPUT_EXPORTS)
-    };
-}
-function errorIncompatibleExportOptionValue(optionValue, keys, entryModule) {
-    return {
-        code: INVALID_EXPORT_OPTION,
-        message: `"${optionValue}" was specified for "output.exports", but entry module "${relativeId(entryModule)}" has the following exports: ${printQuotedStringList(keys)}`,
-        url: getRollupUrl(URL_OUTPUT_EXPORTS)
-    };
-}
-function errorInternalIdCannotBeExternal(source, importer) {
-    return {
-        code: INVALID_EXTERNAL_ID,
-        message: `"${source}" is imported as an external by "${relativeId(importer)}", but is already an existing non-external module id.`
-    };
-}
-function errorInvalidOption(option, urlSnippet, explanation, value) {
-    return {
-        code: INVALID_OPTION,
-        message: `Invalid value ${value === undefined ? '' : `${JSON.stringify(value)} `}for option "${option}" - ${explanation}.`,
-        url: getRollupUrl(urlSnippet)
-    };
-}
-function errorInvalidAddonPluginHook(hook, plugin) {
-    return {
-        code: INVALID_PLUGIN_HOOK,
-        hook,
-        message: `Error running plugin hook "${hook}" for plugin "${plugin}", expected a string, a function hook or an object with a "handler" string or function.`,
-        plugin
-    };
-}
-function errorInvalidFunctionPluginHook(hook, plugin) {
-    return {
-        code: INVALID_PLUGIN_HOOK,
-        hook,
-        message: `Error running plugin hook "${hook}" for plugin "${plugin}", expected a function hook or an object with a "handler" function.`,
-        plugin
-    };
-}
-function errorInvalidRollupPhaseForAddWatchFile() {
-    return {
-        code: INVALID_ROLLUP_PHASE,
-        message: `Cannot call "addWatchFile" after the build has finished.`
-    };
-}
-function errorInvalidRollupPhaseForChunkEmission() {
-    return {
-        code: INVALID_ROLLUP_PHASE,
-        message: `Cannot emit chunks after module loading has finished.`
-    };
-}
-function errorInvalidSetAssetSourceCall() {
-    return {
-        code: INVALID_SETASSETSOURCE,
-        message: `setAssetSource cannot be called in transform for caching reasons. Use emitFile with a source, or call setAssetSource in another hook.`
-    };
-}
-function errorInvalidFormatForTopLevelAwait(id, format) {
-    return {
-        code: INVALID_TLA_FORMAT,
-        id,
-        message: `Module format "${format}" does not support top-level await. Use the "es" or "system" output formats rather.`
-    };
-}
-function errorMissingExport(binding, importingModule, exporter) {
-    const isJson = extname(exporter) === '.json';
-    return {
-        binding,
-        code: MISSING_EXPORT,
-        exporter,
-        id: importingModule,
-        message: `"${binding}" is not exported by "${relativeId(exporter)}", imported by "${relativeId(importingModule)}".${isJson ? ' (Note that you need @rollup/plugin-json to import JSON files)' : ''}`,
-        url: getRollupUrl(URL_NAME_IS_NOT_EXPORTED)
-    };
-}
-function errorMissingGlobalName(externalId, guess) {
-    return {
-        code: MISSING_GLOBAL_NAME,
-        id: externalId,
-        message: `No name was provided for external module "${externalId}" in "output.globals" – guessing "${guess}".`,
-        names: [guess],
-        url: getRollupUrl(URL_OUTPUT_GLOBALS)
-    };
-}
-function errorImplicitDependantCannotBeExternal(unresolvedId, implicitlyLoadedBefore) {
-    return {
-        code: MISSING_IMPLICIT_DEPENDANT,
-        message: `Module "${relativeId(unresolvedId)}" that should be implicitly loaded before "${relativeId(implicitlyLoadedBefore)}" cannot be external.`
-    };
-}
-function errorUnresolvedImplicitDependant(unresolvedId, implicitlyLoadedBefore) {
-    return {
-        code: MISSING_IMPLICIT_DEPENDANT,
-        message: `Module "${relativeId(unresolvedId)}" that should be implicitly loaded before "${relativeId(implicitlyLoadedBefore)}" could not be resolved.`
-    };
-}
-function errorImplicitDependantIsNotIncluded(module) {
-    const implicitDependencies = [...module.implicitlyLoadedBefore]
-        .map(dependency => relativeId(dependency.id))
-        .sort();
-    return {
-        code: MISSING_IMPLICIT_DEPENDANT,
-        message: `Module "${relativeId(module.id)}" that should be implicitly loaded before ${printQuotedStringList(implicitDependencies)} is not included in the module graph. Either it was not imported by an included module or only via a tree-shaken dynamic import, or no imported bindings were used and it had otherwise no side-effects.`
-    };
-}
-function errorMissingNameOptionForIifeExport() {
-    return {
-        code: MISSING_NAME_OPTION_FOR_IIFE_EXPORT,
-        message: `If you do not supply "output.name", you may not be able to access the exports of an IIFE bundle.`,
-        url: getRollupUrl(URL_OUTPUT_NAME)
-    };
-}
-function errorMissingNameOptionForUmdExport() {
-    return {
-        code: MISSING_NAME_OPTION_FOR_IIFE_EXPORT,
-        message: 'You must supply "output.name" for UMD bundles that have exports so that the exports are accessible in environments without a module loader.',
-        url: getRollupUrl(URL_OUTPUT_NAME)
-    };
-}
-function errorMissingNodeBuiltins(externalBuiltins) {
-    return {
-        code: MISSING_NODE_BUILTINS,
-        ids: externalBuiltins,
-        message: `Creating a browser bundle that depends on Node.js built-in modules (${printQuotedStringList(externalBuiltins)}). You might need to include https://github.com/FredKSchott/rollup-plugin-polyfill-node`
-    };
-}
-// eslint-disable-next-line unicorn/prevent-abbreviations
-function errorMissingFileOrDirOption() {
-    return {
-        code: MISSING_OPTION,
-        message: 'You must specify "output.file" or "output.dir" for the build.',
-        url: getRollupUrl(URL_OUTPUT_DIR)
-    };
-}
-function errorMixedExport(facadeModuleId, name) {
-    return {
-        code: MIXED_EXPORTS,
-        id: facadeModuleId,
-        message: `Entry module "${relativeId(facadeModuleId)}" is using named and default exports together. Consumers of your bundle will have to use \`${name || 'chunk'}.default\` to access the default export, which may not be what you want. Use \`output.exports: "named"\` to disable this warning.`,
-        url: getRollupUrl(URL_OUTPUT_EXPORTS)
-    };
-}
-function errorModuleLevelDirective(directive, id) {
-    return {
-        code: MODULE_LEVEL_DIRECTIVE,
-        id,
-        message: `Module level directives cause errors when bundled, "${directive}" in "${relativeId(id)}" was ignored.`
-    };
-}
-function errorNamespaceConflict(binding, reexportingModuleId, sources) {
-    return {
-        binding,
-        code: NAMESPACE_CONFLICT,
-        ids: sources,
-        message: `Conflicting namespaces: "${relativeId(reexportingModuleId)}" re-exports "${binding}" from one of the modules ${printQuotedStringList(sources.map(moduleId => relativeId(moduleId)))} (will be ignored).`,
-        reexporter: reexportingModuleId
-    };
-}
-function errorNoTransformMapOrAstWithoutCode(pluginName) {
-    return {
-        code: NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE,
-        message: `The plugin "${pluginName}" returned a "map" or "ast" without returning ` +
-            'a "code". This will be ignored.'
-    };
-}
-function errorParseError(error, moduleId) {
-    let message = error.message.replace(/ \(\d+:\d+\)$/, '');
-    if (moduleId.endsWith('.json')) {
-        message += ' (Note that you need @rollup/plugin-json to import JSON files)';
-    }
-    else if (!moduleId.endsWith('.js')) {
-        message += ' (Note that you need plugins to import files that are not JavaScript)';
-    }
-    return {
-        cause: error,
-        code: PARSE_ERROR,
-        id: moduleId,
-        message
-    };
-}
-function errorPluginError(error, plugin, { hook, id } = {}) {
-    if (typeof error === 'string')
-        error = { message: error };
-    if (error.code && error.code !== PLUGIN_ERROR) {
-        error.pluginCode = error.code;
-    }
-    error.code = PLUGIN_ERROR;
-    error.plugin = plugin;
-    if (hook) {
-        error.hook = hook;
-    }
-    if (id) {
-        error.id = id;
-    }
-    return error;
-}
-function errorShimmedExport(id, binding) {
-    return {
-        binding,
-        code: SHIMMED_EXPORT,
-        exporter: id,
-        message: `Missing export "${binding}" has been shimmed in module "${relativeId(id)}".`
-    };
-}
-function errorSourcemapBroken(plugin) {
-    return {
-        code: SOURCEMAP_BROKEN,
-        message: `Sourcemap is likely to be incorrect: a plugin (${plugin}) was used to transform files, but didn't generate a sourcemap for the transformation. Consult the plugin documentation for help`,
-        plugin,
-        url: getRollupUrl(URL_SOURCEMAP_IS_LIKELY_TO_BE_INCORRECT)
-    };
-}
-function errorConflictingSourcemapSources(filename) {
-    return {
-        code: SOURCEMAP_BROKEN,
-        message: `Multiple conflicting contents for sourcemap source ${filename}`
-    };
-}
-function errorInvalidSourcemapForError(error, id, column, line, pos) {
-    return {
-        cause: error,
-        code: SOURCEMAP_ERROR,
-        id,
-        loc: {
-            column,
-            file: id,
-            line
-        },
-        message: `Error when using sourcemap for reporting an error: ${error.message}`,
-        pos
-    };
-}
-function errorSyntheticNamedExportsNeedNamespaceExport(id, syntheticNamedExportsOption) {
-    return {
-        code: SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT,
-        exporter: id,
-        message: `Module "${relativeId(id)}" that is marked with \`syntheticNamedExports: ${JSON.stringify(syntheticNamedExportsOption)}\` needs ${typeof syntheticNamedExportsOption === 'string' && syntheticNamedExportsOption !== 'default'
-            ? `an explicit export named "${syntheticNamedExportsOption}"`
-            : 'a default export'} that does not reexport an unresolved named export of the same module.`
-    };
-}
-function errorThisIsUndefined() {
-    return {
-        code: THIS_IS_UNDEFINED,
-        message: `The 'this' keyword is equivalent to 'undefined' at the top level of an ES module, and has been rewritten`,
-        url: getRollupUrl(URL_THIS_IS_UNDEFINED)
-    };
-}
-function errorUnexpectedNamedImport(id, imported, isReexport) {
-    const importType = isReexport ? 'reexport' : 'import';
-    return {
-        code: UNEXPECTED_NAMED_IMPORT,
-        exporter: id,
-        message: `The named export "${imported}" was ${importType}ed from the external module "${relativeId(id)}" even though its interop type is "defaultOnly". Either remove or change this ${importType} or change the value of the "output.interop" option.`,
-        url: getRollupUrl(URL_OUTPUT_INTEROP)
-    };
-}
-function errorUnexpectedNamespaceReexport(id) {
-    return {
-        code: UNEXPECTED_NAMED_IMPORT,
-        exporter: id,
-        message: `There was a namespace "*" reexport from the external module "${relativeId(id)}" even though its interop type is "defaultOnly". This will be ignored as namespace reexports only reexport named exports. If this is not intended, either remove or change this reexport or change the value of the "output.interop" option.`,
-        url: getRollupUrl(URL_OUTPUT_INTEROP)
-    };
-}
-function errorUnknownOption(optionType, unknownOptions, validOptions) {
-    return {
-        code: UNKNOWN_OPTION,
-        message: `Unknown ${optionType}: ${unknownOptions.join(', ')}. Allowed options: ${validOptions.join(', ')}`
-    };
-}
-function errorEntryCannotBeExternal(unresolvedId) {
-    return {
-        code: UNRESOLVED_ENTRY,
-        message: `Entry module "${relativeId(unresolvedId)}" cannot be external.`
-    };
-}
-function errorUnresolvedEntry(unresolvedId) {
-    return {
-        code: UNRESOLVED_ENTRY,
-        message: `Could not resolve entry module "${relativeId(unresolvedId)}".`
-    };
-}
-function errorUnresolvedImport(source, importer) {
-    return {
-        code: UNRESOLVED_IMPORT,
-        exporter: source,
-        id: importer,
-        message: `Could not resolve "${source}" from "${relativeId(importer)}"`
-    };
-}
-function errorUnresolvedImportTreatedAsExternal(source, importer) {
-    return {
-        code: UNRESOLVED_IMPORT,
-        exporter: source,
-        id: importer,
-        message: `"${source}" is imported by "${relativeId(importer)}", but could not be resolved – treating it as an external dependency.`,
-        url: getRollupUrl(URL_TREATING_MODULE_AS_EXTERNAL_DEPENDENCY)
-    };
-}
-function errorUnusedExternalImports(externalId, names, importers) {
-    return {
-        code: UNUSED_EXTERNAL_IMPORT,
-        exporter: externalId,
-        ids: importers,
-        message: `${printQuotedStringList(names, [
-            'is',
-            'are'
-        ])} imported from external module "${externalId}" but never used in ${printQuotedStringList(importers.map(importer => relativeId(importer)))}.`,
-        names
-    };
-}
-function errorFailedValidation(message) {
-    return {
-        code: VALIDATION_ERROR,
-        message
-    };
-}
-function warnDeprecation(deprecation, urlSnippet, activeDeprecation, options, plugin) {
-    warnDeprecationWithOptions(deprecation, urlSnippet, activeDeprecation, options.onwarn, options.strictDeprecations, plugin);
-}
-function warnDeprecationWithOptions(deprecation, urlSnippet, activeDeprecation, warn, strictDeprecations, plugin) {
-    if (activeDeprecation || strictDeprecations) {
-        const warning = errorDeprecation(deprecation, urlSnippet, plugin);
-        if (strictDeprecations) {
-            return error(warning);
-        }
-        warn(warning);
-    }
+function getAliasName(id) {
+    const base = basename(id);
+    return base.substr(0, base.length - extname(id).length);
 }
-
-const RESERVED_NAMES = new Set([
-    'await',
-    'break',
-    'case',
-    'catch',
-    'class',
-    'const',
-    'continue',
-    'debugger',
-    'default',
-    'delete',
-    'do',
-    'else',
-    'enum',
-    'eval',
-    'export',
-    'extends',
-    'false',
-    'finally',
-    'for',
-    'function',
-    'if',
-    'implements',
-    'import',
-    'in',
-    'instanceof',
-    'interface',
-    'let',
-    'NaN',
-    'new',
-    'null',
-    'package',
-    'private',
-    'protected',
-    'public',
-    'return',
-    'static',
-    'super',
-    'switch',
-    'this',
-    'throw',
-    'true',
-    'try',
-    'typeof',
-    'undefined',
-    'var',
-    'void',
-    'while',
-    'with',
-    'yield'
-]);
-const RESERVED_NAMES$1 = RESERVED_NAMES;
-
-const illegalCharacters = /[^\w$]/g;
-const startsWithDigit = (value) => /\d/.test(value[0]);
-const needsEscape = (value) => startsWithDigit(value) || RESERVED_NAMES$1.has(value) || value === 'arguments';
-function isLegal(value) {
-    if (needsEscape(value)) {
-        return false;
-    }
-    return !illegalCharacters.test(value);
+function relativeId(id) {
+    if (!isAbsolute(id))
+        return id;
+    return relative$1(resolve(), id);
 }
-function makeLegal(value) {
-    value = value
-        .replace(/-(\w)/g, (_, letter) => letter.toUpperCase())
-        .replace(illegalCharacters, '_');
-    if (needsEscape(value))
-        value = `_${value}`;
-    return value || '_';
+function isPathFragment(name) {
+    // starting with "/", "./", "../", "C:/"
+    return (name[0] === '/' || (name[0] === '.' && (name[1] === '/' || name[1] === '.')) || isAbsolute(name));
 }
 
 class ExternalModule {
-    constructor(options, id, moduleSideEffects, meta, renormalizeRenderPath, assertions) {
+    constructor(options, id, hasModuleSideEffects, meta, renormalizeRenderPath) {
         this.options = options;
         this.id = id;
         this.renormalizeRenderPath = renormalizeRenderPath;
+        this.declarations = Object.create(null);
+        this.defaultVariableName = '';
         this.dynamicImporters = [];
         this.execIndex = Infinity;
         this.exportedVariables = new Map();
         this.importers = [];
+        this.mostCommonSuggestion = 0;
+        this.nameSuggestions = Object.create(null);
+        this.namespaceVariableName = '';
         this.reexported = false;
+        this.renderPath = undefined;
         this.used = false;
-        this.declarations = new Map();
-        this.mostCommonSuggestion = 0;
-        this.nameSuggestions = new Map();
-        this.suggestedVariableName = makeLegal(id.split(/[/\\]/).pop());
+        this.variableName = '';
+        this.suggestedVariableName = makeLegal(id.split(/[\\/]/).pop());
         const { importers, dynamicImporters } = this;
-        const info = (this.info = {
-            assertions,
+        this.info = {
             ast: null,
             code: null,
-            dynamicallyImportedIdResolutions: EMPTY_ARRAY,
             dynamicallyImportedIds: EMPTY_ARRAY,
             get dynamicImporters() {
                 return dynamicImporters.sort();
             },
-            exportedBindings: null,
-            exports: null,
-            hasDefaultExport: null,
-            get hasModuleSideEffects() {
-                warnDeprecation('Accessing ModuleInfo.hasModuleSideEffects from plugins is deprecated. Please use ModuleInfo.moduleSideEffects instead.', URL_THIS_GETMODULEINFO, true, options);
-                return info.moduleSideEffects;
-            },
+            hasModuleSideEffects,
             id,
             implicitlyLoadedAfterOneOf: EMPTY_ARRAY,
             implicitlyLoadedBefore: EMPTY_ARRAY,
-            importedIdResolutions: EMPTY_ARRAY,
             importedIds: EMPTY_ARRAY,
             get importers() {
                 return importers.sort();
             },
             isEntry: false,
             isExternal: true,
-            isIncluded: null,
             meta,
-            moduleSideEffects,
             syntheticNamedExports: false
-        });
-        // Hide the deprecated key so that it only warns when accessed explicitly
-        Object.defineProperty(this.info, 'hasModuleSideEffects', {
-            enumerable: false
-        });
+        };
     }
     getVariableForExportName(name) {
-        const declaration = this.declarations.get(name);
+        let declaration = this.declarations[name];
         if (declaration)
-            return [declaration];
-        const externalVariable = new ExternalVariable(this, name);
-        this.declarations.set(name, externalVariable);
-        this.exportedVariables.set(externalVariable, name);
-        return [externalVariable];
+            return declaration;
+        this.declarations[name] = declaration = new ExternalVariable(this, name);
+        this.exportedVariables.set(declaration, name);
+        return declaration;
+    }
+    setRenderPath(options, inputBase) {
+        this.renderPath =
+            typeof options.paths === 'function' ? options.paths(this.id) : options.paths[this.id];
+        if (!this.renderPath) {
+            this.renderPath = this.renormalizeRenderPath
+                ? normalize(relative$1(inputBase, this.id))
+                : this.id;
+        }
+        return this.renderPath;
     }
     suggestName(name) {
-        const value = (this.nameSuggestions.get(name) ?? 0) + 1;
-        this.nameSuggestions.set(name, value);
-        if (value > this.mostCommonSuggestion) {
-            this.mostCommonSuggestion = value;
+        if (!this.nameSuggestions[name])
+            this.nameSuggestions[name] = 0;
+        this.nameSuggestions[name] += 1;
+        if (this.nameSuggestions[name] > this.mostCommonSuggestion) {
+            this.mostCommonSuggestion = this.nameSuggestions[name];
             this.suggestedVariableName = name;
         }
     }
     warnUnusedImports() {
-        const unused = [...this.declarations]
-            .filter(([name, declaration]) => name !== '*' && !declaration.included && !this.reexported && !declaration.referenced)
-            .map(([name]) => name);
+        const unused = Object.keys(this.declarations).filter(name => {
+            if (name === '*')
+                return false;
+            const declaration = this.declarations[name];
+            return !declaration.included && !this.reexported && !declaration.referenced;
+        });
         if (unused.length === 0)
             return;
         const importersSet = new Set();
         for (const name of unused) {
-            for (const importer of this.declarations.get(name).module.importers) {
+            const { importers } = this.declarations[name].module;
+            for (const importer of importers) {
                 importersSet.add(importer);
             }
         }
         const importersArray = [...importersSet];
-        this.options.onwarn(errorUnusedExternalImports(this.id, unused, importersArray));
+        this.options.onwarn({
+            code: 'UNUSED_EXTERNAL_IMPORT',
+            message: `${printQuotedStringList(unused, ['is', 'are'])} imported from external module "${this.id}" but never used in ${printQuotedStringList(importersArray.map(importer => relativeId(importer)))}.`,
+            names: unused,
+            source: this.id,
+            sources: importersArray
+        });
     }
 }
 
-function getDefaultExportFromCjs (x) {
-	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
-}
-
 function getAugmentedNamespace(n) {
-  if (n.__esModule) return n;
-  var f = n.default;
-	if (typeof f == "function") {
-		var a = function a () {
-			if (this instanceof a) {
-				var args = [null];
-				args.push.apply(args, arguments);
-				var Ctor = Function.bind.apply(f, args);
-				return new Ctor();
-			}
-			return f.apply(this, arguments);
-		};
-		a.prototype = f.prototype;
-  } else a = {};
-  Object.defineProperty(a, '__esModule', {value: true});
+	if (n.__esModule) return n;
+	var a = Object.defineProperty({}, '__esModule', {value: true});
 	Object.keys(n).forEach(function (k) {
 		var d = Object.getOwnPropertyDescriptor(n, k);
 		Object.defineProperty(a, k, d.get ? d : {
@@ -2824,15 +1813,9 @@
 	return a;
 }
 
-var picomatchExports = {};
-var picomatch$1 = {
-  get exports(){ return picomatchExports; },
-  set exports(v){ picomatchExports = v; },
-};
-
 var utils$3 = {};
 
-const path$1 = require$$0$1;
+const path$1 = require$$0__default;
 const WIN_SLASH = '\\\\/';
 const WIN_NO_SLASH = `[^${WIN_SLASH}]`;
 
@@ -3012,69 +1995,69 @@
 
 (function (exports) {
 
-	const path = require$$0$1;
-	const win32 = process.platform === 'win32';
-	const {
-	  REGEX_BACKSLASH,
-	  REGEX_REMOVE_BACKSLASH,
-	  REGEX_SPECIAL_CHARS,
-	  REGEX_SPECIAL_CHARS_GLOBAL
-	} = constants$2;
-
-	exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);
-	exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);
-	exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);
-	exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
-	exports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');
-
-	exports.removeBackslashes = str => {
-	  return str.replace(REGEX_REMOVE_BACKSLASH, match => {
-	    return match === '\\' ? '' : match;
-	  });
-	};
+const path = require$$0__default;
+const win32 = process.platform === 'win32';
+const {
+  REGEX_BACKSLASH,
+  REGEX_REMOVE_BACKSLASH,
+  REGEX_SPECIAL_CHARS,
+  REGEX_SPECIAL_CHARS_GLOBAL
+} = constants$2;
 
-	exports.supportsLookbehinds = () => {
-	  const segs = process.version.slice(1).split('.').map(Number);
-	  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {
-	    return true;
-	  }
-	  return false;
-	};
+exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);
+exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);
+exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);
+exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
+exports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');
+
+exports.removeBackslashes = str => {
+  return str.replace(REGEX_REMOVE_BACKSLASH, match => {
+    return match === '\\' ? '' : match;
+  });
+};
 
-	exports.isWindows = options => {
-	  if (options && typeof options.windows === 'boolean') {
-	    return options.windows;
-	  }
-	  return win32 === true || path.sep === '\\';
-	};
+exports.supportsLookbehinds = () => {
+  const segs = process.version.slice(1).split('.').map(Number);
+  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {
+    return true;
+  }
+  return false;
+};
 
-	exports.escapeLast = (input, char, lastIdx) => {
-	  const idx = input.lastIndexOf(char, lastIdx);
-	  if (idx === -1) return input;
-	  if (input[idx - 1] === '\\') return exports.escapeLast(input, char, idx - 1);
-	  return `${input.slice(0, idx)}\\${input.slice(idx)}`;
-	};
+exports.isWindows = options => {
+  if (options && typeof options.windows === 'boolean') {
+    return options.windows;
+  }
+  return win32 === true || path.sep === '\\';
+};
 
-	exports.removePrefix = (input, state = {}) => {
-	  let output = input;
-	  if (output.startsWith('./')) {
-	    output = output.slice(2);
-	    state.prefix = './';
-	  }
-	  return output;
-	};
+exports.escapeLast = (input, char, lastIdx) => {
+  const idx = input.lastIndexOf(char, lastIdx);
+  if (idx === -1) return input;
+  if (input[idx - 1] === '\\') return exports.escapeLast(input, char, idx - 1);
+  return `${input.slice(0, idx)}\\${input.slice(idx)}`;
+};
 
-	exports.wrapOutput = (input, state = {}, options = {}) => {
-	  const prepend = options.contains ? '' : '^';
-	  const append = options.contains ? '' : '$';
-
-	  let output = `${prepend}(?:${input})${append}`;
-	  if (state.negated === true) {
-	    output = `(?:^(?!${output}).*$)`;
-	  }
-	  return output;
-	};
-} (utils$3));
+exports.removePrefix = (input, state = {}) => {
+  let output = input;
+  if (output.startsWith('./')) {
+    output = output.slice(2);
+    state.prefix = './';
+  }
+  return output;
+};
+
+exports.wrapOutput = (input, state = {}, options = {}) => {
+  const prepend = options.contains ? '' : '^';
+  const append = options.contains ? '' : '$';
+
+  let output = `${prepend}(?:${input})${append}`;
+  if (state.negated === true) {
+    output = `(?:^(?!${output}).*$)`;
+  }
+  return output;
+};
+}(utils$3));
 
 const utils$2 = utils$3;
 const {
@@ -3511,7 +2494,7 @@
  * @return {Object}
  */
 
-const parse$2 = (input, options) => {
+const parse$1 = (input, options) => {
   if (typeof input !== 'string') {
     throw new TypeError('Expected a string');
   }
@@ -3709,14 +2692,7 @@
       }
 
       if (token.inner.includes('*') && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
-        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.
-        // In this case, we need to parse the string and use it in the output of the original pattern.
-        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.
-        //
-        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.
-        const expression = parse$2(rest, { ...options, fastpaths: false }).output;
-
-        output = token.close = `)${expression})${extglobStar})`;
+        output = token.close = `)${rest})${extglobStar})`;
       }
 
       if (token.prev.type === 'bos') {
@@ -4460,7 +3436,7 @@
  * impact when none of the fast paths match.
  */
 
-parse$2.fastpaths = (input, options) => {
+parse$1.fastpaths = (input, options) => {
   const opts = { ...options };
   const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
   const len = input.length;
@@ -4547,11 +3523,11 @@
   return source;
 };
 
-var parse_1 = parse$2;
+var parse_1 = parse$1;
 
-const path = require$$0$1;
+const path = require$$0__default;
 const scan = scan_1;
-const parse$1 = parse_1;
+const parse = parse_1;
 const utils = utils$3;
 const constants = constants$2;
 const isObject = val => val && typeof val === 'object' && !Array.isArray(val);
@@ -4578,9 +3554,9 @@
  * @api public
  */
 
-const picomatch = (glob, options, returnState = false) => {
+const picomatch$1 = (glob, options, returnState = false) => {
   if (Array.isArray(glob)) {
-    const fns = glob.map(input => picomatch(input, options, returnState));
+    const fns = glob.map(input => picomatch$1(input, options, returnState));
     const arrayMatcher = str => {
       for (const isMatch of fns) {
         const state = isMatch(str);
@@ -4600,8 +3576,8 @@
   const opts = options || {};
   const posix = utils.isWindows(options);
   const regex = isState
-    ? picomatch.compileRe(glob, options)
-    : picomatch.makeRe(glob, options, false, true);
+    ? picomatch$1.compileRe(glob, options)
+    : picomatch$1.makeRe(glob, options, false, true);
 
   const state = regex.state;
   delete regex.state;
@@ -4609,11 +3585,11 @@
   let isIgnored = () => false;
   if (opts.ignore) {
     const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
-    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
+    isIgnored = picomatch$1(opts.ignore, ignoreOpts, returnState);
   }
 
   const matcher = (input, returnObject = false) => {
-    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
+    const { isMatch, match, output } = picomatch$1.test(input, regex, options, { glob, posix });
     const result = { glob, state, regex, posix, input, output, match, isMatch };
 
     if (typeof opts.onResult === 'function') {
@@ -4663,7 +3639,7 @@
  * @api public
  */
 
-picomatch.test = (input, regex, options, { glob, posix } = {}) => {
+picomatch$1.test = (input, regex, options, { glob, posix } = {}) => {
   if (typeof input !== 'string') {
     throw new TypeError('Expected input to be a string');
   }
@@ -4684,7 +3660,7 @@
 
   if (match === false || opts.capture === true) {
     if (opts.matchBase === true || opts.basename === true) {
-      match = picomatch.matchBase(input, regex, options, posix);
+      match = picomatch$1.matchBase(input, regex, options, posix);
     } else {
       match = regex.exec(output);
     }
@@ -4707,8 +3683,8 @@
  * @api public
  */
 
-picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
-  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
+picomatch$1.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
+  const regex = glob instanceof RegExp ? glob : picomatch$1.makeRe(glob, options);
   return regex.test(path.basename(input));
 };
 
@@ -4729,7 +3705,7 @@
  * @api public
  */
 
-picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
+picomatch$1.isMatch = (str, patterns, options) => picomatch$1(patterns, options)(str);
 
 /**
  * Parse a glob pattern to create the source string for a regular
@@ -4745,9 +3721,9 @@
  * @api public
  */
 
-picomatch.parse = (pattern, options) => {
-  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));
-  return parse$1(pattern, { ...options, fastpaths: false });
+picomatch$1.parse = (pattern, options) => {
+  if (Array.isArray(pattern)) return pattern.map(p => picomatch$1.parse(p, options));
+  return parse(pattern, { ...options, fastpaths: false });
 };
 
 /**
@@ -4777,7 +3753,7 @@
  * @api public
  */
 
-picomatch.scan = (input, options) => scan(input, options);
+picomatch$1.scan = (input, options) => scan(input, options);
 
 /**
  * Compile a regular expression from the `state` object returned by the
@@ -4791,7 +3767,7 @@
  * @api public
  */
 
-picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
+picomatch$1.compileRe = (state, options, returnOutput = false, returnState = false) => {
   if (returnOutput === true) {
     return state.output;
   }
@@ -4805,7 +3781,7 @@
     source = `^(?!${source}).*$`;
   }
 
-  const regex = picomatch.toRegex(source, options);
+  const regex = picomatch$1.toRegex(source, options);
   if (returnState === true) {
     regex.state = state;
   }
@@ -4832,7 +3808,7 @@
  * @api public
  */
 
-picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
+picomatch$1.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
   if (!input || typeof input !== 'string') {
     throw new TypeError('Expected a non-empty string');
   }
@@ -4840,14 +3816,14 @@
   let parsed = { negated: false, fastpaths: true };
 
   if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
-    parsed.output = parse$1.fastpaths(input, options);
+    parsed.output = parse.fastpaths(input, options);
   }
 
   if (!parsed.output) {
-    parsed = parse$1(input, options);
+    parsed = parse(input, options);
   }
 
-  return picomatch.compileRe(parsed, options, returnOutput, returnState);
+  return picomatch$1.compileRe(parsed, options, returnOutput, returnState);
 };
 
 /**
@@ -4867,7 +3843,7 @@
  * @api public
  */
 
-picomatch.toRegex = (source, options) => {
+picomatch$1.toRegex = (source, options) => {
   try {
     const opts = options || {};
     return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
@@ -4882,20 +3858,17 @@
  * @return {Object}
  */
 
-picomatch.constants = constants;
+picomatch$1.constants = constants;
 
 /**
  * Expose "picomatch"
  */
 
-var picomatch_1 = picomatch;
+var picomatch_1 = picomatch$1;
 
-(function (module) {
+var picomatch = picomatch_1;
 
-	module.exports = picomatch_1;
-} (picomatch$1));
-
-const pm = /*@__PURE__*/getDefaultExportFromCjs(picomatchExports);
+const pm = picomatch;
 
 const extractors = {
     ArrayPattern(names, param) {
@@ -4950,17 +3923,17 @@
 
 function getMatcherString(id, resolutionBase) {
     if (resolutionBase === false || isAbsolute$1(id) || id.startsWith('*')) {
-        return normalizePath(id);
+        return id;
     }
     // resolve('') is valid and will default to process.cwd()
-    const basePath = normalizePath(resolve$1(resolutionBase || ''))
+    const basePath = normalizePath(resolve(resolutionBase || ''))
         // escape all possible (posix + win) path characters that might interfere with regex
         .replace(/[-^$*+?.()|[\]{}]/g, '\\$&');
     // Note that we use posix.join because:
     // 1. the basePath has been normalized to use /
     // 2. the incoming glob (id) matcher, also uses /
     // otherwise Node will force backslash (\) on windows
-    return posix.join(basePath, normalizePath(id));
+    return posix.join(basePath, id);
 }
 const createFilter = function createFilter(include, exclude, options) {
     const resolutionBase = options && options.resolve;
@@ -4998,10 +3971,51 @@
 };
 
 const reservedWords$1 = 'break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public';
-const builtins = 'arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl';
-const forbiddenIdentifiers = new Set(`${reservedWords$1} ${builtins}`.split(' '));
+const builtins$1 = 'arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl';
+const forbiddenIdentifiers = new Set(`${reservedWords$1} ${builtins$1}`.split(' '));
 forbiddenIdentifiers.add('');
 
+function getLocator(source, options) {
+    if (options === void 0) { options = {}; }
+    var offsetLine = options.offsetLine || 0;
+    var offsetColumn = options.offsetColumn || 0;
+    var originalLines = source.split('\n');
+    var start = 0;
+    var lineRanges = originalLines.map(function (line, i) {
+        var end = start + line.length + 1;
+        var range = { start: start, end: end, line: i };
+        start = end;
+        return range;
+    });
+    var i = 0;
+    function rangeContains(range, index) {
+        return range.start <= index && index < range.end;
+    }
+    function getLocation(range, index) {
+        return { line: offsetLine + range.line, column: offsetColumn + index - range.start, character: index };
+    }
+    function locate(search, startIndex) {
+        if (typeof search === 'string') {
+            search = source.indexOf(search, startIndex || 0);
+        }
+        var range = lineRanges[i];
+        var d = search >= range.end ? 1 : -1;
+        while (range) {
+            if (rangeContains(range, search))
+                return getLocation(range, search);
+            i += d;
+            range = lineRanges[i];
+        }
+    }
+    return locate;
+}
+function locate(source, search, options) {
+    if (typeof options === 'number') {
+        throw new Error('locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument');
+    }
+    return getLocator(source, options)(search, options && options.startIndex);
+}
+
 const BROKEN_FLOW_NONE = 0;
 const BROKEN_FLOW_BREAK_CONTINUE = 1;
 const BROKEN_FLOW_ERROR_RETURN_LABEL = 2;
@@ -5030,208 +4044,6 @@
     };
 }
 
-function assembleMemberDescriptions(memberDescriptions, inheritedDescriptions = null) {
-    return Object.create(inheritedDescriptions, memberDescriptions);
-}
-const UNDEFINED_EXPRESSION = new (class UndefinedExpression extends ExpressionEntity {
-    getLiteralValueAtPath() {
-        return undefined;
-    }
-})();
-const returnsUnknown = {
-    value: {
-        hasEffectsWhenCalled: null,
-        returns: UNKNOWN_EXPRESSION
-    }
-};
-const UNKNOWN_LITERAL_BOOLEAN = new (class UnknownBoolean extends ExpressionEntity {
-    getReturnExpressionWhenCalledAtPath(path) {
-        if (path.length === 1) {
-            return getMemberReturnExpressionWhenCalled(literalBooleanMembers, path[0]);
-        }
-        return UNKNOWN_RETURN_EXPRESSION;
-    }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        if (interaction.type === INTERACTION_ACCESSED) {
-            return path.length > 1;
-        }
-        if (interaction.type === INTERACTION_CALLED && path.length === 1) {
-            return hasMemberEffectWhenCalled(literalBooleanMembers, path[0], interaction, context);
-        }
-        return true;
-    }
-})();
-const returnsBoolean = {
-    value: {
-        hasEffectsWhenCalled: null,
-        returns: UNKNOWN_LITERAL_BOOLEAN
-    }
-};
-const UNKNOWN_LITERAL_NUMBER = new (class UnknownNumber extends ExpressionEntity {
-    getReturnExpressionWhenCalledAtPath(path) {
-        if (path.length === 1) {
-            return getMemberReturnExpressionWhenCalled(literalNumberMembers, path[0]);
-        }
-        return UNKNOWN_RETURN_EXPRESSION;
-    }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        if (interaction.type === INTERACTION_ACCESSED) {
-            return path.length > 1;
-        }
-        if (interaction.type === INTERACTION_CALLED && path.length === 1) {
-            return hasMemberEffectWhenCalled(literalNumberMembers, path[0], interaction, context);
-        }
-        return true;
-    }
-})();
-const returnsNumber = {
-    value: {
-        hasEffectsWhenCalled: null,
-        returns: UNKNOWN_LITERAL_NUMBER
-    }
-};
-const UNKNOWN_LITERAL_STRING = new (class UnknownString extends ExpressionEntity {
-    getReturnExpressionWhenCalledAtPath(path) {
-        if (path.length === 1) {
-            return getMemberReturnExpressionWhenCalled(literalStringMembers, path[0]);
-        }
-        return UNKNOWN_RETURN_EXPRESSION;
-    }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        if (interaction.type === INTERACTION_ACCESSED) {
-            return path.length > 1;
-        }
-        if (interaction.type === INTERACTION_CALLED && path.length === 1) {
-            return hasMemberEffectWhenCalled(literalStringMembers, path[0], interaction, context);
-        }
-        return true;
-    }
-})();
-const returnsString = {
-    value: {
-        hasEffectsWhenCalled: null,
-        returns: UNKNOWN_LITERAL_STRING
-    }
-};
-const stringReplace = {
-    value: {
-        hasEffectsWhenCalled({ args }, context) {
-            const argument1 = args[1];
-            return (args.length < 2 ||
-                (typeof argument1.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, {
-                    deoptimizeCache() { }
-                }) === 'symbol' &&
-                    argument1.hasEffectsOnInteractionAtPath(EMPTY_PATH, NODE_INTERACTION_UNKNOWN_CALL, context)));
-        },
-        returns: UNKNOWN_LITERAL_STRING
-    }
-};
-const objectMembers = assembleMemberDescriptions({
-    hasOwnProperty: returnsBoolean,
-    isPrototypeOf: returnsBoolean,
-    propertyIsEnumerable: returnsBoolean,
-    toLocaleString: returnsString,
-    toString: returnsString,
-    valueOf: returnsUnknown
-});
-const literalBooleanMembers = assembleMemberDescriptions({
-    valueOf: returnsBoolean
-}, objectMembers);
-const literalNumberMembers = assembleMemberDescriptions({
-    toExponential: returnsString,
-    toFixed: returnsString,
-    toLocaleString: returnsString,
-    toPrecision: returnsString,
-    valueOf: returnsNumber
-}, objectMembers);
-/**
- * RegExp are stateful when they have the global or sticky flags set.
- * But if we actually don't use them, the side effect does not matter.
- * the check logic in `hasEffectsOnInteractionAtPath`.
- */
-const literalRegExpMembers = assembleMemberDescriptions({
-    exec: returnsUnknown,
-    test: returnsBoolean
-}, objectMembers);
-const literalStringMembers = assembleMemberDescriptions({
-    anchor: returnsString,
-    at: returnsUnknown,
-    big: returnsString,
-    blink: returnsString,
-    bold: returnsString,
-    charAt: returnsString,
-    charCodeAt: returnsNumber,
-    codePointAt: returnsUnknown,
-    concat: returnsString,
-    endsWith: returnsBoolean,
-    fixed: returnsString,
-    fontcolor: returnsString,
-    fontsize: returnsString,
-    includes: returnsBoolean,
-    indexOf: returnsNumber,
-    italics: returnsString,
-    lastIndexOf: returnsNumber,
-    link: returnsString,
-    localeCompare: returnsNumber,
-    match: returnsUnknown,
-    matchAll: returnsUnknown,
-    normalize: returnsString,
-    padEnd: returnsString,
-    padStart: returnsString,
-    repeat: returnsString,
-    replace: stringReplace,
-    replaceAll: stringReplace,
-    search: returnsNumber,
-    slice: returnsString,
-    small: returnsString,
-    split: returnsUnknown,
-    startsWith: returnsBoolean,
-    strike: returnsString,
-    sub: returnsString,
-    substr: returnsString,
-    substring: returnsString,
-    sup: returnsString,
-    toLocaleLowerCase: returnsString,
-    toLocaleUpperCase: returnsString,
-    toLowerCase: returnsString,
-    toString: returnsString,
-    toUpperCase: returnsString,
-    trim: returnsString,
-    trimEnd: returnsString,
-    trimLeft: returnsString,
-    trimRight: returnsString,
-    trimStart: returnsString,
-    valueOf: returnsString
-}, objectMembers);
-function getLiteralMembersForValue(value) {
-    if (value instanceof RegExp) {
-        return literalRegExpMembers;
-    }
-    switch (typeof value) {
-        case 'boolean': {
-            return literalBooleanMembers;
-        }
-        case 'number': {
-            return literalNumberMembers;
-        }
-        case 'string': {
-            return literalStringMembers;
-        }
-    }
-    return Object.create(null);
-}
-function hasMemberEffectWhenCalled(members, memberName, interaction, context) {
-    if (typeof memberName !== 'string' || !members[memberName]) {
-        return true;
-    }
-    return members[memberName].hasEffectsWhenCalled?.(interaction, context) || false;
-}
-function getMemberReturnExpressionWhenCalled(members, memberName) {
-    if (typeof memberName !== 'string' || !members[memberName])
-        return UNKNOWN_RETURN_EXPRESSION;
-    return [members[memberName].returns, false];
-}
-
 // AST walker module for Mozilla Parser API compatible trees
 
 function skipThrough(node, st, c) { c(node, st); }
@@ -5505,6 +4317,8 @@
 const ConditionalExpression$1 = 'ConditionalExpression';
 const ExpressionStatement$1 = 'ExpressionStatement';
 const Identifier$1 = 'Identifier';
+const ImportDefaultSpecifier$1 = 'ImportDefaultSpecifier';
+const ImportNamespaceSpecifier$1 = 'ImportNamespaceSpecifier';
 const LogicalExpression$1 = 'LogicalExpression';
 const NewExpression$1 = 'NewExpression';
 const Program$1 = 'Program';
@@ -5519,19 +4333,26 @@
 const whiteSpaceNoNewline = '[ \\f\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]';
 const SOURCEMAPPING_URL_RE = new RegExp(`^#${whiteSpaceNoNewline}+${SOURCEMAPPING_URL}=.+`);
 
+// patch up acorn-walk until class-fields are officially supported
+base$1.PropertyDefinition = function (node, st, c) {
+    if (node.computed) {
+        c(node.key, st, 'Expression');
+    }
+    if (node.value) {
+        c(node.value, st, 'Expression');
+    }
+};
 const ANNOTATION_KEY = '_rollupAnnotations';
 const INVALID_COMMENT_KEY = '_rollupRemoved';
 function handlePureAnnotationsOfNode(node, state, type = node.type) {
-    const { annotations, code } = state;
-    // eslint-disable-next-line unicorn/consistent-destructuring
+    const { annotations } = state;
     let comment = annotations[state.annotationIndex];
     while (comment && node.start >= comment.end) {
-        markPureNode(node, comment, code);
+        markPureNode(node, comment, state.code);
         comment = annotations[++state.annotationIndex];
     }
     if (comment && comment.end <= node.end) {
         base$1[type](node, state, handlePureAnnotationsOfNode);
-        // eslint-disable-next-line unicorn/consistent-destructuring
         while ((comment = annotations[state.annotationIndex]) && comment.end <= node.end) {
             ++state.annotationIndex;
             annotateNode(node, comment, false);
@@ -5550,11 +4371,10 @@
             annotatedNodes.push(node);
             switch (node.type) {
                 case ExpressionStatement$1:
-                case ChainExpression$1: {
+                case ChainExpression$1:
                     node = node.expression;
                     continue;
-                }
-                case SequenceExpression$1: {
+                case SequenceExpression$1:
                     // if there are parentheses, the annotation would apply to the entire expression
                     if (doesNotMatchOutsideComment(code.slice(parentStart, node.start), noWhitespace)) {
                         node = node.expressions[0];
@@ -5562,8 +4382,7 @@
                     }
                     invalidAnnotation = true;
                     break;
-                }
-                case ConditionalExpression$1: {
+                case ConditionalExpression$1:
                     // if there are parentheses, the annotation would apply to the entire expression
                     if (doesNotMatchOutsideComment(code.slice(parentStart, node.start), noWhitespace)) {
                         node = node.test;
@@ -5571,9 +4390,8 @@
                     }
                     invalidAnnotation = true;
                     break;
-                }
                 case LogicalExpression$1:
-                case BinaryExpression$1: {
+                case BinaryExpression$1:
                     // if there are parentheses, the annotation would apply to the entire expression
                     if (doesNotMatchOutsideComment(code.slice(parentStart, node.start), noWhitespace)) {
                         node = node.left;
@@ -5581,14 +4399,11 @@
                     }
                     invalidAnnotation = true;
                     break;
-                }
                 case CallExpression$1:
-                case NewExpression$1: {
+                case NewExpression$1:
                     break;
-                }
-                default: {
+                default:
                     invalidAnnotation = true;
-                }
             }
             break;
         }
@@ -5624,7 +4439,7 @@
     }
     return true;
 }
-const pureCommentRegex = /[#@]__PURE__/;
+const pureCommentRegex = /[@#]__PURE__/;
 function addAnnotations(comments, esTreeAst, code) {
     const annotations = [];
     const sourceMappingComments = [];
@@ -5657,9 +4472,6 @@
 }
 
 const keys = {
-    // TODO this should be removed once ImportExpression follows official ESTree
-    //  specs with "null" as default
-    ImportExpression: ['arguments'],
     Literal: [],
     Program: ['body']
 };
@@ -5670,18 +4482,9 @@
 
 const INCLUDE_PARAMETERS = 'variables';
 class NodeBase extends ExpressionEntity {
-    constructor(esTreeNode, parent, parentScope, keepEsTreeNode = false) {
+    constructor(esTreeNode, parent, parentScope) {
         super();
-        /**
-         * Nodes can apply custom deoptimizations once they become part of the
-         * executed code. To do this, they must initialize this as false, implement
-         * applyDeoptimizations and call this from include and hasEffects if they have
-         * custom handlers
-         */
-        this.deoptimized = false;
-        // Nodes can opt-in to keep the AST if needed during the build pipeline.
-        // Avoid true when possible as large AST takes up memory.
-        this.esTreeNode = keepEsTreeNode ? esTreeNode : null;
+        this.esTreeNode = esTreeNode;
         this.keys = keys[esTreeNode.type] || getAndCreateKeys(esTreeNode);
         this.parent = parent;
         this.context = parent.context;
@@ -5699,12 +4502,15 @@
     bind() {
         for (const key of this.keys) {
             const value = this[key];
+            if (value === null)
+                continue;
             if (Array.isArray(value)) {
                 for (const child of value) {
-                    child?.bind();
+                    if (child !== null)
+                        child.bind();
                 }
             }
-            else if (value) {
+            else {
                 value.bind();
             }
         }
@@ -5716,7 +4522,7 @@
         this.scope = parentScope;
     }
     hasEffects(context) {
-        if (!this.deoptimized)
+        if (this.deoptimized === false)
             this.applyDeoptimizations();
         for (const key of this.keys) {
             const value = this[key];
@@ -5724,7 +4530,7 @@
                 continue;
             if (Array.isArray(value)) {
                 for (const child of value) {
-                    if (child?.hasEffects(context))
+                    if (child !== null && child.hasEffects(context))
                         return true;
                 }
             }
@@ -5733,12 +4539,8 @@
         }
         return false;
     }
-    hasEffectsAsAssignmentTarget(context, _checkAccess) {
-        return (this.hasEffects(context) ||
-            this.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.assignmentInteraction, context));
-    }
-    include(context, includeChildrenRecursively, _options) {
-        if (!this.deoptimized)
+    include(context, includeChildrenRecursively) {
+        if (this.deoptimized === false)
             this.applyDeoptimizations();
         this.included = true;
         for (const key of this.keys) {
@@ -5747,7 +4549,8 @@
                 continue;
             if (Array.isArray(value)) {
                 for (const child of value) {
-                    child?.include(context, includeChildrenRecursively);
+                    if (child !== null)
+                        child.include(context, includeChildrenRecursively);
                 }
             }
             else {
@@ -5755,7 +4558,7 @@
             }
         }
     }
-    includeAsAssignmentTarget(context, includeChildrenRecursively, _deoptimizeAccess) {
+    includeAsSingleStatement(context, includeChildrenRecursively) {
         this.include(context, includeChildrenRecursively);
     }
     /**
@@ -5767,7 +4570,7 @@
             code.appendLeft(this.end, ';');
         }
     }
-    parseNode(esTreeNode, keepEsTreeNodeKeys) {
+    parseNode(esTreeNode) {
         for (const [key, value] of Object.entries(esTreeNode)) {
             // That way, we can override this function to add custom initialisation and then call super.parseNode
             if (this.hasOwnProperty(key))
@@ -5789,11 +4592,13 @@
                 for (const child of value) {
                     this[key].push(child === null
                         ? null
-                        : new (this.context.getNodeConstructor(child.type))(child, this, this.scope, keepEsTreeNodeKeys?.includes(key)));
+                        : new (this.context.nodeConstructors[child.type] ||
+                            this.context.nodeConstructors.UnknownNode)(child, this, this.scope));
                 }
             }
             else {
-                this[key] = new (this.context.getNodeConstructor(value.type))(value, this, this.scope, keepEsTreeNodeKeys?.includes(key));
+                this[key] = new (this.context.nodeConstructors[value.type] ||
+                    this.context.nodeConstructors.UnknownNode)(value, this, this.scope);
             }
         }
     }
@@ -5804,7 +4609,8 @@
                 continue;
             if (Array.isArray(value)) {
                 for (const child of value) {
-                    child?.render(code, options);
+                    if (child !== null)
+                        child.render(code, options);
                 }
             }
             else {
@@ -5812,739 +4618,468 @@
             }
         }
     }
-    setAssignedValue(value) {
-        this.assignmentInteraction = { args: [value], thisArg: null, type: INTERACTION_ASSIGNED };
-    }
     shouldBeIncluded(context) {
         return this.included || (!context.brokenFlow && this.hasEffects(createHasEffectsContext()));
     }
-    /**
-     * Just deoptimize everything by default so that when e.g. we do not track
-     * something properly, it is deoptimized.
-     * @protected
-     */
-    applyDeoptimizations() {
-        this.deoptimized = true;
-        for (const key of this.keys) {
-            const value = this[key];
-            if (value === null)
-                continue;
-            if (Array.isArray(value)) {
-                for (const child of value) {
-                    child?.deoptimizePath(UNKNOWN_PATH);
-                }
-            }
-            else {
-                value.deoptimizePath(UNKNOWN_PATH);
-            }
-        }
-        this.context.requestTreeshakingPass();
-    }
+    applyDeoptimizations() { }
 }
 
-class SpreadElement extends NodeBase {
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        if (path.length > 0) {
-            this.argument.deoptimizeThisOnInteractionAtPath(interaction, [UnknownKey, ...path], recursionTracker);
-        }
+class ExportAllDeclaration extends NodeBase {
+    hasEffects() {
+        return false;
     }
-    hasEffects(context) {
-        if (!this.deoptimized)
-            this.applyDeoptimizations();
-        const { propertyReadSideEffects } = this.context.options
-            .treeshake;
-        return (this.argument.hasEffects(context) ||
-            (propertyReadSideEffects &&
-                (propertyReadSideEffects === 'always' ||
-                    this.argument.hasEffectsOnInteractionAtPath(UNKNOWN_PATH, NODE_INTERACTION_UNKNOWN_ACCESS, context))));
+    initialise() {
+        this.context.addExport(this);
     }
-    applyDeoptimizations() {
-        this.deoptimized = true;
-        // Only properties of properties of the argument could become subject to reassignment
-        // This will also reassign the return values of iterators
-        this.argument.deoptimizePath([UnknownKey, UnknownKey]);
-        this.context.requestTreeshakingPass();
+    render(code, _options, nodeRenderOptions) {
+        code.remove(nodeRenderOptions.start, nodeRenderOptions.end);
     }
 }
+ExportAllDeclaration.prototype.needsBoundaries = true;
 
-class Method extends ExpressionEntity {
-    constructor(description) {
-        super();
-        this.description = description;
-    }
-    deoptimizeThisOnInteractionAtPath({ type, thisArg }, path) {
-        if (type === INTERACTION_CALLED && path.length === 0 && this.description.mutatesSelfAsArray) {
-            thisArg.deoptimizePath(UNKNOWN_INTEGER_PATH);
-        }
-    }
-    getReturnExpressionWhenCalledAtPath(path, { thisArg }) {
-        if (path.length > 0) {
-            return UNKNOWN_RETURN_EXPRESSION;
-        }
-        return [
-            this.description.returnsPrimitive ||
-                (this.description.returns === 'self'
-                    ? thisArg || UNKNOWN_EXPRESSION
-                    : this.description.returns()),
-            false
-        ];
-    }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        const { type } = interaction;
-        if (path.length > (type === INTERACTION_ACCESSED ? 1 : 0)) {
-            return true;
-        }
-        if (type === INTERACTION_CALLED) {
-            const { args, thisArg } = interaction;
-            if (this.description.mutatesSelfAsArray === true &&
-                thisArg?.hasEffectsOnInteractionAtPath(UNKNOWN_INTEGER_PATH, NODE_INTERACTION_UNKNOWN_ASSIGNMENT, context)) {
-                return true;
+function treeshakeNode(node, code, start, end) {
+    code.remove(start, end);
+    if (node.annotations) {
+        for (const annotation of node.annotations) {
+            if (annotation.start < start) {
+                code.remove(annotation.start, annotation.end);
             }
-            if (this.description.callsArgs) {
-                for (const argumentIndex of this.description.callsArgs) {
-                    if (args[argumentIndex]?.hasEffectsOnInteractionAtPath(EMPTY_PATH, NODE_INTERACTION_UNKNOWN_CALL, context)) {
-                        return true;
-                    }
-                }
+            else {
+                return;
             }
         }
-        return false;
     }
 }
-const METHOD_RETURNS_BOOLEAN = [
-    new Method({
-        callsArgs: null,
-        mutatesSelfAsArray: false,
-        returns: null,
-        returnsPrimitive: UNKNOWN_LITERAL_BOOLEAN
-    })
-];
-const METHOD_RETURNS_STRING = [
-    new Method({
-        callsArgs: null,
-        mutatesSelfAsArray: false,
-        returns: null,
-        returnsPrimitive: UNKNOWN_LITERAL_STRING
-    })
-];
-const METHOD_RETURNS_NUMBER = [
-    new Method({
-        callsArgs: null,
-        mutatesSelfAsArray: false,
-        returns: null,
-        returnsPrimitive: UNKNOWN_LITERAL_NUMBER
-    })
-];
-const METHOD_RETURNS_UNKNOWN = [
-    new Method({
-        callsArgs: null,
-        mutatesSelfAsArray: false,
-        returns: null,
-        returnsPrimitive: UNKNOWN_EXPRESSION
-    })
-];
-
-const INTEGER_REG_EXP = /^\d+$/;
-class ObjectEntity extends ExpressionEntity {
-    // If a PropertyMap is used, this will be taken as propertiesAndGettersByKey
-    // and we assume there are no setters or getters
-    constructor(properties, prototypeExpression, immutable = false) {
-        super();
-        this.prototypeExpression = prototypeExpression;
-        this.immutable = immutable;
-        this.allProperties = [];
-        this.deoptimizedPaths = Object.create(null);
-        this.expressionsToBeDeoptimizedByKey = Object.create(null);
-        this.gettersByKey = Object.create(null);
-        this.hasLostTrack = false;
-        this.hasUnknownDeoptimizedInteger = false;
-        this.hasUnknownDeoptimizedProperty = false;
-        this.propertiesAndGettersByKey = Object.create(null);
-        this.propertiesAndSettersByKey = Object.create(null);
-        this.settersByKey = Object.create(null);
-        this.thisParametersToBeDeoptimized = new Set();
-        this.unknownIntegerProps = [];
-        this.unmatchableGetters = [];
-        this.unmatchablePropertiesAndGetters = [];
-        this.unmatchableSetters = [];
-        if (Array.isArray(properties)) {
-            this.buildPropertyMaps(properties);
-        }
-        else {
-            this.propertiesAndGettersByKey = this.propertiesAndSettersByKey = properties;
-            for (const propertiesForKey of Object.values(properties)) {
-                this.allProperties.push(...propertiesForKey);
-            }
-        }
+function removeAnnotations(node, code) {
+    if (!node.annotations && node.parent.type === ExpressionStatement$1) {
+        node = node.parent;
     }
-    deoptimizeAllProperties(noAccessors) {
-        const isDeoptimized = this.hasLostTrack || this.hasUnknownDeoptimizedProperty;
-        if (noAccessors) {
-            this.hasUnknownDeoptimizedProperty = true;
-        }
-        else {
-            this.hasLostTrack = true;
-        }
-        if (isDeoptimized) {
-            return;
-        }
-        for (const properties of [
-            ...Object.values(this.propertiesAndGettersByKey),
-            ...Object.values(this.settersByKey)
-        ]) {
-            for (const property of properties) {
-                property.deoptimizePath(UNKNOWN_PATH);
-            }
+    if (node.annotations) {
+        for (const annotation of node.annotations) {
+            code.remove(annotation.start, annotation.end);
         }
-        // While the prototype itself cannot be mutated, each property can
-        this.prototypeExpression?.deoptimizePath([UnknownKey, UnknownKey]);
-        this.deoptimizeCachedEntities();
     }
-    deoptimizeIntegerProperties() {
-        if (this.hasLostTrack ||
-            this.hasUnknownDeoptimizedProperty ||
-            this.hasUnknownDeoptimizedInteger) {
-            return;
-        }
-        this.hasUnknownDeoptimizedInteger = true;
-        for (const [key, propertiesAndGetters] of Object.entries(this.propertiesAndGettersByKey)) {
-            if (INTEGER_REG_EXP.test(key)) {
-                for (const property of propertiesAndGetters) {
-                    property.deoptimizePath(UNKNOWN_PATH);
-                }
-            }
+}
+
+const NO_SEMICOLON = { isNoStatement: true };
+// This assumes there are only white-space and comments between start and the string we are looking for
+function findFirstOccurrenceOutsideComment(code, searchString, start = 0) {
+    let searchPos, charCodeAfterSlash;
+    searchPos = code.indexOf(searchString, start);
+    while (true) {
+        start = code.indexOf('/', start);
+        if (start === -1 || start >= searchPos)
+            return searchPos;
+        charCodeAfterSlash = code.charCodeAt(++start);
+        ++start;
+        // With our assumption, '/' always starts a comment. Determine comment type:
+        start =
+            charCodeAfterSlash === 47 /*"/"*/
+                ? code.indexOf('\n', start) + 1
+                : code.indexOf('*/', start) + 2;
+        if (start > searchPos) {
+            searchPos = code.indexOf(searchString, start);
         }
-        this.deoptimizeCachedIntegerEntities();
     }
-    // Assumption: If only a specific path is deoptimized, no accessors are created
-    deoptimizePath(path) {
-        if (this.hasLostTrack || this.immutable) {
-            return;
-        }
-        const key = path[0];
-        if (path.length === 1) {
-            if (typeof key !== 'string') {
-                if (key === UnknownInteger) {
-                    return this.deoptimizeIntegerProperties();
-                }
-                return this.deoptimizeAllProperties(key === UnknownNonAccessorKey);
-            }
-            if (!this.deoptimizedPaths[key]) {
-                this.deoptimizedPaths[key] = true;
-                // we only deoptimizeCache exact matches as in all other cases,
-                // we do not return a literal value or return expression
-                const expressionsToBeDeoptimized = this.expressionsToBeDeoptimizedByKey[key];
-                if (expressionsToBeDeoptimized) {
-                    for (const expression of expressionsToBeDeoptimized) {
-                        expression.deoptimizeCache();
-                    }
-                }
-            }
-        }
-        const subPath = path.length === 1 ? UNKNOWN_PATH : path.slice(1);
-        for (const property of typeof key === 'string'
-            ? [
-                ...(this.propertiesAndGettersByKey[key] || this.unmatchablePropertiesAndGetters),
-                ...(this.settersByKey[key] || this.unmatchableSetters)
-            ]
-            : this.allProperties) {
-            property.deoptimizePath(subPath);
+}
+const NON_WHITESPACE = /\S/g;
+function findNonWhiteSpace(code, index) {
+    NON_WHITESPACE.lastIndex = index;
+    const result = NON_WHITESPACE.exec(code);
+    return result.index;
+}
+// This assumes "code" only contains white-space and comments
+// Returns position of line-comment if applicable
+function findFirstLineBreakOutsideComment(code) {
+    let lineBreakPos, charCodeAfterSlash, start = 0;
+    lineBreakPos = code.indexOf('\n', start);
+    while (true) {
+        start = code.indexOf('/', start);
+        if (start === -1 || start > lineBreakPos)
+            return [lineBreakPos, lineBreakPos + 1];
+        // With our assumption, '/' always starts a comment. Determine comment type:
+        charCodeAfterSlash = code.charCodeAt(start + 1);
+        if (charCodeAfterSlash === 47 /*"/"*/)
+            return [start, lineBreakPos + 1];
+        start = code.indexOf('*/', start + 3) + 2;
+        if (start > lineBreakPos) {
+            lineBreakPos = code.indexOf('\n', start);
         }
-        this.prototypeExpression?.deoptimizePath(path.length === 1 ? [...path, UnknownKey] : path);
     }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        const [key, ...subPath] = path;
-        if (this.hasLostTrack ||
-            // single paths that are deoptimized will not become getters or setters
-            ((interaction.type === INTERACTION_CALLED || path.length > 1) &&
-                (this.hasUnknownDeoptimizedProperty ||
-                    (typeof key === 'string' && this.deoptimizedPaths[key])))) {
-            interaction.thisArg.deoptimizePath(UNKNOWN_PATH);
-            return;
-        }
-        const [propertiesForExactMatchByKey, relevantPropertiesByKey, relevantUnmatchableProperties] = interaction.type === INTERACTION_CALLED || path.length > 1
-            ? [
-                this.propertiesAndGettersByKey,
-                this.propertiesAndGettersByKey,
-                this.unmatchablePropertiesAndGetters
-            ]
-            : interaction.type === INTERACTION_ACCESSED
-                ? [this.propertiesAndGettersByKey, this.gettersByKey, this.unmatchableGetters]
-                : [this.propertiesAndSettersByKey, this.settersByKey, this.unmatchableSetters];
-        if (typeof key === 'string') {
-            if (propertiesForExactMatchByKey[key]) {
-                const properties = relevantPropertiesByKey[key];
-                if (properties) {
-                    for (const property of properties) {
-                        property.deoptimizeThisOnInteractionAtPath(interaction, subPath, recursionTracker);
-                    }
-                }
-                if (!this.immutable) {
-                    this.thisParametersToBeDeoptimized.add(interaction.thisArg);
-                }
-                return;
-            }
-            for (const property of relevantUnmatchableProperties) {
-                property.deoptimizeThisOnInteractionAtPath(interaction, subPath, recursionTracker);
+}
+function renderStatementList(statements, code, start, end, options) {
+    let currentNode, currentNodeStart, currentNodeNeedsBoundaries, nextNodeStart;
+    let nextNode = statements[0];
+    let nextNodeNeedsBoundaries = !nextNode.included || nextNode.needsBoundaries;
+    if (nextNodeNeedsBoundaries) {
+        nextNodeStart =
+            start + findFirstLineBreakOutsideComment(code.original.slice(start, nextNode.start))[1];
+    }
+    for (let nextIndex = 1; nextIndex <= statements.length; nextIndex++) {
+        currentNode = nextNode;
+        currentNodeStart = nextNodeStart;
+        currentNodeNeedsBoundaries = nextNodeNeedsBoundaries;
+        nextNode = statements[nextIndex];
+        nextNodeNeedsBoundaries =
+            nextNode === undefined ? false : !nextNode.included || nextNode.needsBoundaries;
+        if (currentNodeNeedsBoundaries || nextNodeNeedsBoundaries) {
+            nextNodeStart =
+                currentNode.end +
+                    findFirstLineBreakOutsideComment(code.original.slice(currentNode.end, nextNode === undefined ? end : nextNode.start))[1];
+            if (currentNode.included) {
+                currentNodeNeedsBoundaries
+                    ? currentNode.render(code, options, {
+                        end: nextNodeStart,
+                        start: currentNodeStart
+                    })
+                    : currentNode.render(code, options);
             }
-            if (INTEGER_REG_EXP.test(key)) {
-                for (const property of this.unknownIntegerProps) {
-                    property.deoptimizeThisOnInteractionAtPath(interaction, subPath, recursionTracker);
-                }
+            else {
+                treeshakeNode(currentNode, code, currentNodeStart, nextNodeStart);
             }
         }
         else {
-            for (const properties of [
-                ...Object.values(relevantPropertiesByKey),
-                relevantUnmatchableProperties
-            ]) {
-                for (const property of properties) {
-                    property.deoptimizeThisOnInteractionAtPath(interaction, subPath, recursionTracker);
-                }
-            }
-            for (const property of this.unknownIntegerProps) {
-                property.deoptimizeThisOnInteractionAtPath(interaction, subPath, recursionTracker);
-            }
-        }
-        if (!this.immutable) {
-            this.thisParametersToBeDeoptimized.add(interaction.thisArg);
-        }
-        this.prototypeExpression?.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
-    }
-    getLiteralValueAtPath(path, recursionTracker, origin) {
-        if (path.length === 0) {
-            return UnknownTruthyValue;
-        }
-        const key = path[0];
-        const expressionAtPath = this.getMemberExpressionAndTrackDeopt(key, origin);
-        if (expressionAtPath) {
-            return expressionAtPath.getLiteralValueAtPath(path.slice(1), recursionTracker, origin);
-        }
-        if (this.prototypeExpression) {
-            return this.prototypeExpression.getLiteralValueAtPath(path, recursionTracker, origin);
-        }
-        if (path.length === 1) {
-            return undefined;
+            currentNode.render(code, options);
         }
-        return UnknownValue;
     }
-    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
-        if (path.length === 0) {
-            return UNKNOWN_RETURN_EXPRESSION;
-        }
-        const [key, ...subPath] = path;
-        const expressionAtPath = this.getMemberExpressionAndTrackDeopt(key, origin);
-        if (expressionAtPath) {
-            return expressionAtPath.getReturnExpressionWhenCalledAtPath(subPath, interaction, recursionTracker, origin);
+}
+// This assumes that the first character is not part of the first node
+function getCommaSeparatedNodesWithBoundaries(nodes, code, start, end) {
+    const splitUpNodes = [];
+    let node, nextNode, nextNodeStart, contentEnd, char;
+    let separator = start - 1;
+    for (let nextIndex = 0; nextIndex < nodes.length; nextIndex++) {
+        nextNode = nodes[nextIndex];
+        if (node !== undefined) {
+            separator =
+                node.end +
+                    findFirstOccurrenceOutsideComment(code.original.slice(node.end, nextNode.start), ',');
         }
-        if (this.prototypeExpression) {
-            return this.prototypeExpression.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
+        nextNodeStart = contentEnd =
+            separator +
+                1 +
+                findFirstLineBreakOutsideComment(code.original.slice(separator + 1, nextNode.start))[1];
+        while (((char = code.original.charCodeAt(nextNodeStart)),
+            char === 32 /*" "*/ || char === 9 /*"\t"*/ || char === 10 /*"\n"*/ || char === 13) /*"\r"*/)
+            nextNodeStart++;
+        if (node !== undefined) {
+            splitUpNodes.push({
+                contentEnd,
+                end: nextNodeStart,
+                node,
+                separator,
+                start
+            });
         }
-        return UNKNOWN_RETURN_EXPRESSION;
+        node = nextNode;
+        start = nextNodeStart;
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        const [key, ...subPath] = path;
-        if (subPath.length > 0 || interaction.type === INTERACTION_CALLED) {
-            const expressionAtPath = this.getMemberExpression(key);
-            if (expressionAtPath) {
-                return expressionAtPath.hasEffectsOnInteractionAtPath(subPath, interaction, context);
-            }
-            if (this.prototypeExpression) {
-                return this.prototypeExpression.hasEffectsOnInteractionAtPath(path, interaction, context);
-            }
-            return true;
-        }
-        if (key === UnknownNonAccessorKey)
-            return false;
-        if (this.hasLostTrack)
-            return true;
-        const [propertiesAndAccessorsByKey, accessorsByKey, unmatchableAccessors] = interaction.type === INTERACTION_ACCESSED
-            ? [this.propertiesAndGettersByKey, this.gettersByKey, this.unmatchableGetters]
-            : [this.propertiesAndSettersByKey, this.settersByKey, this.unmatchableSetters];
-        if (typeof key === 'string') {
-            if (propertiesAndAccessorsByKey[key]) {
-                const accessors = accessorsByKey[key];
-                if (accessors) {
-                    for (const accessor of accessors) {
-                        if (accessor.hasEffectsOnInteractionAtPath(subPath, interaction, context))
-                            return true;
-                    }
-                }
-                return false;
-            }
-            for (const accessor of unmatchableAccessors) {
-                if (accessor.hasEffectsOnInteractionAtPath(subPath, interaction, context)) {
-                    return true;
-                }
-            }
-        }
-        else {
-            for (const accessors of [...Object.values(accessorsByKey), unmatchableAccessors]) {
-                for (const accessor of accessors) {
-                    if (accessor.hasEffectsOnInteractionAtPath(subPath, interaction, context))
-                        return true;
-                }
-            }
-        }
-        if (this.prototypeExpression) {
-            return this.prototypeExpression.hasEffectsOnInteractionAtPath(path, interaction, context);
+    splitUpNodes.push({
+        contentEnd: end,
+        end,
+        node: node,
+        separator: null,
+        start
+    });
+    return splitUpNodes;
+}
+// This assumes there are only white-space and comments between start and end
+function removeLineBreaks(code, start, end) {
+    while (true) {
+        const [removeStart, removeEnd] = findFirstLineBreakOutsideComment(code.original.slice(start, end));
+        if (removeStart === -1) {
+            break;
         }
-        return false;
+        code.remove(start + removeStart, (start += removeEnd));
     }
-    buildPropertyMaps(properties) {
-        const { allProperties, propertiesAndGettersByKey, propertiesAndSettersByKey, settersByKey, gettersByKey, unknownIntegerProps, unmatchablePropertiesAndGetters, unmatchableGetters, unmatchableSetters } = this;
-        const unmatchablePropertiesAndSetters = [];
-        for (let index = properties.length - 1; index >= 0; index--) {
-            const { key, kind, property } = properties[index];
-            allProperties.push(property);
-            if (typeof key === 'string') {
-                if (kind === 'set') {
-                    if (!propertiesAndSettersByKey[key]) {
-                        propertiesAndSettersByKey[key] = [property, ...unmatchablePropertiesAndSetters];
-                        settersByKey[key] = [property, ...unmatchableSetters];
-                    }
-                }
-                else if (kind === 'get') {
-                    if (!propertiesAndGettersByKey[key]) {
-                        propertiesAndGettersByKey[key] = [property, ...unmatchablePropertiesAndGetters];
-                        gettersByKey[key] = [property, ...unmatchableGetters];
-                    }
-                }
-                else {
-                    if (!propertiesAndSettersByKey[key]) {
-                        propertiesAndSettersByKey[key] = [property, ...unmatchablePropertiesAndSetters];
-                    }
-                    if (!propertiesAndGettersByKey[key]) {
-                        propertiesAndGettersByKey[key] = [property, ...unmatchablePropertiesAndGetters];
-                    }
-                }
-            }
-            else {
-                if (key === UnknownInteger) {
-                    unknownIntegerProps.push(property);
-                    continue;
-                }
-                if (kind === 'set')
-                    unmatchableSetters.push(property);
-                if (kind === 'get')
-                    unmatchableGetters.push(property);
-                if (kind !== 'get')
-                    unmatchablePropertiesAndSetters.push(property);
-                if (kind !== 'set')
-                    unmatchablePropertiesAndGetters.push(property);
-            }
-        }
+}
+
+function getSystemExportStatement(exportedVariables, { exportNamesByVariable, snippets: { _, getObject, getPropertyAccess } }, modifier = '') {
+    if (exportedVariables.length === 1 &&
+        exportNamesByVariable.get(exportedVariables[0]).length === 1) {
+        const variable = exportedVariables[0];
+        return `exports('${exportNamesByVariable.get(variable)}',${_}${variable.getName(getPropertyAccess)}${modifier})`;
     }
-    deoptimizeCachedEntities() {
-        for (const expressionsToBeDeoptimized of Object.values(this.expressionsToBeDeoptimizedByKey)) {
-            for (const expression of expressionsToBeDeoptimized) {
-                expression.deoptimizeCache();
+    else {
+        const fields = [];
+        for (const variable of exportedVariables) {
+            for (const exportName of exportNamesByVariable.get(variable)) {
+                fields.push([exportName, variable.getName(getPropertyAccess) + modifier]);
             }
         }
-        for (const expression of this.thisParametersToBeDeoptimized) {
-            expression.deoptimizePath(UNKNOWN_PATH);
-        }
+        return `exports(${getObject(fields, { lineBreakIndent: null })})`;
     }
-    deoptimizeCachedIntegerEntities() {
-        for (const [key, expressionsToBeDeoptimized] of Object.entries(this.expressionsToBeDeoptimizedByKey)) {
-            if (INTEGER_REG_EXP.test(key)) {
-                for (const expression of expressionsToBeDeoptimized) {
-                    expression.deoptimizeCache();
-                }
-            }
-        }
-        for (const expression of this.thisParametersToBeDeoptimized) {
-            expression.deoptimizePath(UNKNOWN_INTEGER_PATH);
-        }
+}
+function renderSystemExportExpression(exportedVariable, expressionStart, expressionEnd, code, { exportNamesByVariable, snippets: { _ } }) {
+    code.prependRight(expressionStart, `exports('${exportNamesByVariable.get(exportedVariable)}',${_}`);
+    code.appendLeft(expressionEnd, ')');
+}
+function renderSystemExportFunction(exportedVariables, expressionStart, expressionEnd, needsParens, code, options) {
+    const { _, getDirectReturnIifeLeft } = options.snippets;
+    code.prependRight(expressionStart, getDirectReturnIifeLeft(['v'], `${getSystemExportStatement(exportedVariables, options)},${_}v`, { needsArrowReturnParens: true, needsWrappedFunction: needsParens }));
+    code.appendLeft(expressionEnd, ')');
+}
+function renderSystemExportSequenceAfterExpression(exportedVariable, expressionStart, expressionEnd, needsParens, code, options) {
+    const { _, getPropertyAccess } = options.snippets;
+    code.appendLeft(expressionEnd, `,${_}${getSystemExportStatement([exportedVariable], options)},${_}${exportedVariable.getName(getPropertyAccess)}`);
+    if (needsParens) {
+        code.prependRight(expressionStart, '(');
+        code.appendLeft(expressionEnd, ')');
     }
-    getMemberExpression(key) {
-        if (this.hasLostTrack ||
-            this.hasUnknownDeoptimizedProperty ||
-            typeof key !== 'string' ||
-            (this.hasUnknownDeoptimizedInteger && INTEGER_REG_EXP.test(key)) ||
-            this.deoptimizedPaths[key]) {
-            return UNKNOWN_EXPRESSION;
-        }
-        const properties = this.propertiesAndGettersByKey[key];
-        if (properties?.length === 1) {
-            return properties[0];
-        }
-        if (properties ||
-            this.unmatchablePropertiesAndGetters.length > 0 ||
-            (this.unknownIntegerProps.length > 0 && INTEGER_REG_EXP.test(key))) {
-            return UNKNOWN_EXPRESSION;
-        }
-        return null;
+}
+function renderSystemExportSequenceBeforeExpression(exportedVariable, expressionStart, expressionEnd, needsParens, code, options, modifier) {
+    const { _ } = options.snippets;
+    code.prependRight(expressionStart, `${getSystemExportStatement([exportedVariable], options, modifier)},${_}`);
+    if (needsParens) {
+        code.prependRight(expressionStart, '(');
+        code.appendLeft(expressionEnd, ')');
     }
-    getMemberExpressionAndTrackDeopt(key, origin) {
-        if (typeof key !== 'string') {
-            return UNKNOWN_EXPRESSION;
-        }
-        const expression = this.getMemberExpression(key);
-        if (!(expression === UNKNOWN_EXPRESSION || this.immutable)) {
-            const expressionsToBeDeoptimized = (this.expressionsToBeDeoptimizedByKey[key] =
-                this.expressionsToBeDeoptimizedByKey[key] || []);
-            expressionsToBeDeoptimized.push(origin);
-        }
-        return expression;
+}
+
+const chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$';
+const base = 64;
+function toBase64(num) {
+    let outStr = '';
+    do {
+        const curDigit = num % base;
+        num = Math.floor(num / base);
+        outStr = chars[curDigit] + outStr;
+    } while (num !== 0);
+    return outStr;
+}
+
+const RESERVED_NAMES = {
+    __proto__: null,
+    await: true,
+    break: true,
+    case: true,
+    catch: true,
+    class: true,
+    const: true,
+    continue: true,
+    debugger: true,
+    default: true,
+    delete: true,
+    do: true,
+    else: true,
+    enum: true,
+    eval: true,
+    export: true,
+    extends: true,
+    false: true,
+    finally: true,
+    for: true,
+    function: true,
+    if: true,
+    implements: true,
+    import: true,
+    in: true,
+    instanceof: true,
+    interface: true,
+    let: true,
+    new: true,
+    null: true,
+    package: true,
+    private: true,
+    protected: true,
+    public: true,
+    return: true,
+    static: true,
+    super: true,
+    switch: true,
+    this: true,
+    throw: true,
+    true: true,
+    try: true,
+    typeof: true,
+    undefined: true,
+    var: true,
+    void: true,
+    while: true,
+    with: true,
+    yield: true
+};
+
+function getSafeName(baseName, usedNames) {
+    let safeName = baseName;
+    let count = 1;
+    while (usedNames.has(safeName) || RESERVED_NAMES[safeName]) {
+        safeName = `${baseName}$${toBase64(count++)}`;
     }
+    usedNames.add(safeName);
+    return safeName;
 }
 
-const isInteger = (property) => typeof property === 'string' && /^\d+$/.test(property);
-// This makes sure unknown properties are not handled as "undefined" but as
-// "unknown" but without access side effects. An exception is done for numeric
-// properties as we do not expect new builtin properties to be numbers, this
-// will improve tree-shaking for out-of-bounds array properties
-const OBJECT_PROTOTYPE_FALLBACK = new (class ObjectPrototypeFallbackExpression extends ExpressionEntity {
-    deoptimizeThisOnInteractionAtPath({ type, thisArg }, path) {
-        if (type === INTERACTION_CALLED && path.length === 1 && !isInteger(path[0])) {
-            thisArg.deoptimizePath(UNKNOWN_PATH);
+const NO_ARGS = [];
+
+function assembleMemberDescriptions(memberDescriptions, inheritedDescriptions = null) {
+    return Object.create(inheritedDescriptions, memberDescriptions);
+}
+const UNDEFINED_EXPRESSION = new (class UndefinedExpression extends ExpressionEntity {
+    getLiteralValueAtPath() {
+        return undefined;
+    }
+})();
+const returnsUnknown = {
+    value: {
+        callsArgs: null,
+        returns: UNKNOWN_EXPRESSION
+    }
+};
+const UNKNOWN_LITERAL_BOOLEAN = new (class UnknownBoolean extends ExpressionEntity {
+    getReturnExpressionWhenCalledAtPath(path) {
+        if (path.length === 1) {
+            return getMemberReturnExpressionWhenCalled(literalBooleanMembers, path[0]);
         }
+        return UNKNOWN_EXPRESSION;
     }
-    getLiteralValueAtPath(path) {
-        // We ignore number properties as we do not expect new properties to be
-        // numbers and also want to keep handling out-of-bound array elements as
-        // "undefined"
-        return path.length === 1 && isInteger(path[0]) ? undefined : UnknownValue;
+    hasEffectsWhenAccessedAtPath(path) {
+        return path.length > 1;
     }
-    hasEffectsOnInteractionAtPath(path, { type }) {
-        return path.length > 1 || type === INTERACTION_CALLED;
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        if (path.length === 1) {
+            return hasMemberEffectWhenCalled(literalBooleanMembers, path[0], callOptions, context);
+        }
+        return true;
     }
 })();
-const OBJECT_PROTOTYPE = new ObjectEntity({
-    __proto__: null,
-    hasOwnProperty: METHOD_RETURNS_BOOLEAN,
-    isPrototypeOf: METHOD_RETURNS_BOOLEAN,
-    propertyIsEnumerable: METHOD_RETURNS_BOOLEAN,
-    toLocaleString: METHOD_RETURNS_STRING,
-    toString: METHOD_RETURNS_STRING,
-    valueOf: METHOD_RETURNS_UNKNOWN
-}, OBJECT_PROTOTYPE_FALLBACK, true);
-
-const NEW_ARRAY_PROPERTIES = [
-    { key: UnknownInteger, kind: 'init', property: UNKNOWN_EXPRESSION },
-    { key: 'length', kind: 'init', property: UNKNOWN_LITERAL_NUMBER }
-];
-const METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_BOOLEAN = [
-    new Method({
-        callsArgs: [0],
-        mutatesSelfAsArray: 'deopt-only',
-        returns: null,
-        returnsPrimitive: UNKNOWN_LITERAL_BOOLEAN
-    })
-];
-const METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NUMBER = [
-    new Method({
-        callsArgs: [0],
-        mutatesSelfAsArray: 'deopt-only',
-        returns: null,
-        returnsPrimitive: UNKNOWN_LITERAL_NUMBER
-    })
-];
-const METHOD_MUTATES_SELF_RETURNS_NEW_ARRAY = [
-    new Method({
-        callsArgs: null,
-        mutatesSelfAsArray: true,
-        returns: () => new ObjectEntity(NEW_ARRAY_PROPERTIES, ARRAY_PROTOTYPE),
-        returnsPrimitive: null
-    })
-];
-const METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY = [
-    new Method({
-        callsArgs: null,
-        mutatesSelfAsArray: 'deopt-only',
-        returns: () => new ObjectEntity(NEW_ARRAY_PROPERTIES, ARRAY_PROTOTYPE),
-        returnsPrimitive: null
-    })
-];
-const METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY = [
-    new Method({
-        callsArgs: [0],
-        mutatesSelfAsArray: 'deopt-only',
-        returns: () => new ObjectEntity(NEW_ARRAY_PROPERTIES, ARRAY_PROTOTYPE),
-        returnsPrimitive: null
-    })
-];
-const METHOD_MUTATES_SELF_RETURNS_NUMBER = [
-    new Method({
-        callsArgs: null,
-        mutatesSelfAsArray: true,
-        returns: null,
-        returnsPrimitive: UNKNOWN_LITERAL_NUMBER
-    })
-];
-const METHOD_MUTATES_SELF_RETURNS_UNKNOWN = [
-    new Method({
-        callsArgs: null,
-        mutatesSelfAsArray: true,
-        returns: null,
-        returnsPrimitive: UNKNOWN_EXPRESSION
-    })
-];
-const METHOD_DEOPTS_SELF_RETURNS_UNKNOWN = [
-    new Method({
-        callsArgs: null,
-        mutatesSelfAsArray: 'deopt-only',
-        returns: null,
-        returnsPrimitive: UNKNOWN_EXPRESSION
-    })
-];
-const METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN = [
-    new Method({
-        callsArgs: [0],
-        mutatesSelfAsArray: 'deopt-only',
-        returns: null,
-        returnsPrimitive: UNKNOWN_EXPRESSION
-    })
-];
-const METHOD_MUTATES_SELF_RETURNS_SELF = [
-    new Method({
+const returnsBoolean = {
+    value: {
         callsArgs: null,
-        mutatesSelfAsArray: true,
-        returns: 'self',
-        returnsPrimitive: null
-    })
-];
-const METHOD_CALLS_ARG_MUTATES_SELF_RETURNS_SELF = [
-    new Method({
-        callsArgs: [0],
-        mutatesSelfAsArray: true,
-        returns: 'self',
-        returnsPrimitive: null
-    })
-];
-const ARRAY_PROTOTYPE = new ObjectEntity({
-    __proto__: null,
-    // We assume that accessors have effects as we do not track the accessed value afterwards
-    at: METHOD_DEOPTS_SELF_RETURNS_UNKNOWN,
-    concat: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY,
-    copyWithin: METHOD_MUTATES_SELF_RETURNS_SELF,
-    entries: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY,
-    every: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_BOOLEAN,
-    fill: METHOD_MUTATES_SELF_RETURNS_SELF,
-    filter: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY,
-    find: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
-    findIndex: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NUMBER,
-    findLast: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
-    findLastIndex: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NUMBER,
-    flat: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY,
-    flatMap: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY,
-    forEach: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
-    includes: METHOD_RETURNS_BOOLEAN,
-    indexOf: METHOD_RETURNS_NUMBER,
-    join: METHOD_RETURNS_STRING,
-    keys: METHOD_RETURNS_UNKNOWN,
-    lastIndexOf: METHOD_RETURNS_NUMBER,
-    map: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY,
-    pop: METHOD_MUTATES_SELF_RETURNS_UNKNOWN,
-    push: METHOD_MUTATES_SELF_RETURNS_NUMBER,
-    reduce: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
-    reduceRight: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
-    reverse: METHOD_MUTATES_SELF_RETURNS_SELF,
-    shift: METHOD_MUTATES_SELF_RETURNS_UNKNOWN,
-    slice: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY,
-    some: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_BOOLEAN,
-    sort: METHOD_CALLS_ARG_MUTATES_SELF_RETURNS_SELF,
-    splice: METHOD_MUTATES_SELF_RETURNS_NEW_ARRAY,
-    toLocaleString: METHOD_RETURNS_STRING,
-    toString: METHOD_RETURNS_STRING,
-    unshift: METHOD_MUTATES_SELF_RETURNS_NUMBER,
-    values: METHOD_DEOPTS_SELF_RETURNS_UNKNOWN
-}, OBJECT_PROTOTYPE, true);
-
-class ArrayExpression extends NodeBase {
-    constructor() {
-        super(...arguments);
-        this.objectEntity = null;
-    }
-    deoptimizePath(path) {
-        this.getObjectEntity().deoptimizePath(path);
+        returns: UNKNOWN_LITERAL_BOOLEAN
     }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        this.getObjectEntity().deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
+};
+const UNKNOWN_LITERAL_NUMBER = new (class UnknownNumber extends ExpressionEntity {
+    getReturnExpressionWhenCalledAtPath(path) {
+        if (path.length === 1) {
+            return getMemberReturnExpressionWhenCalled(literalNumberMembers, path[0]);
+        }
+        return UNKNOWN_EXPRESSION;
     }
-    getLiteralValueAtPath(path, recursionTracker, origin) {
-        return this.getObjectEntity().getLiteralValueAtPath(path, recursionTracker, origin);
+    hasEffectsWhenAccessedAtPath(path) {
+        return path.length > 1;
     }
-    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
-        return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        if (path.length === 1) {
+            return hasMemberEffectWhenCalled(literalNumberMembers, path[0], callOptions, context);
+        }
+        return true;
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        return this.getObjectEntity().hasEffectsOnInteractionAtPath(path, interaction, context);
+})();
+const returnsNumber = {
+    value: {
+        callsArgs: null,
+        returns: UNKNOWN_LITERAL_NUMBER
     }
-    applyDeoptimizations() {
-        this.deoptimized = true;
-        let hasSpread = false;
-        for (let index = 0; index < this.elements.length; index++) {
-            const element = this.elements[index];
-            if (element && (hasSpread || element instanceof SpreadElement)) {
-                hasSpread = true;
-                element.deoptimizePath(UNKNOWN_PATH);
-            }
+};
+const UNKNOWN_LITERAL_STRING = new (class UnknownString extends ExpressionEntity {
+    getReturnExpressionWhenCalledAtPath(path) {
+        if (path.length === 1) {
+            return getMemberReturnExpressionWhenCalled(literalStringMembers, path[0]);
         }
-        this.context.requestTreeshakingPass();
+        return UNKNOWN_EXPRESSION;
     }
-    getObjectEntity() {
-        if (this.objectEntity !== null) {
-            return this.objectEntity;
-        }
-        const properties = [
-            { key: 'length', kind: 'init', property: UNKNOWN_LITERAL_NUMBER }
-        ];
-        let hasSpread = false;
-        for (let index = 0; index < this.elements.length; index++) {
-            const element = this.elements[index];
-            if (hasSpread || element instanceof SpreadElement) {
-                if (element) {
-                    hasSpread = true;
-                    properties.unshift({ key: UnknownInteger, kind: 'init', property: element });
-                }
-            }
-            else if (element) {
-                properties.push({ key: String(index), kind: 'init', property: element });
-            }
-            else {
-                properties.push({ key: String(index), kind: 'init', property: UNDEFINED_EXPRESSION });
-            }
-        }
-        return (this.objectEntity = new ObjectEntity(properties, ARRAY_PROTOTYPE));
+    hasEffectsWhenAccessedAtPath(path) {
+        return path.length > 1;
     }
-}
-
-class ArrayPattern extends NodeBase {
-    addExportedVariables(variables, exportNamesByVariable) {
-        for (const element of this.elements) {
-            element?.addExportedVariables(variables, exportNamesByVariable);
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        if (path.length === 1) {
+            return hasMemberEffectWhenCalled(literalStringMembers, path[0], callOptions, context);
         }
+        return true;
     }
-    declare(kind) {
-        const variables = [];
-        for (const element of this.elements) {
-            if (element !== null) {
-                variables.push(...element.declare(kind, UNKNOWN_EXPRESSION));
-            }
-        }
-        return variables;
+})();
+const returnsString = {
+    value: {
+        callsArgs: null,
+        returns: UNKNOWN_LITERAL_STRING
     }
-    // Patterns can only be deoptimized at the empty path at the moment
-    deoptimizePath() {
-        for (const element of this.elements) {
-            element?.deoptimizePath(EMPTY_PATH);
+};
+const objectMembers = assembleMemberDescriptions({
+    hasOwnProperty: returnsBoolean,
+    isPrototypeOf: returnsBoolean,
+    propertyIsEnumerable: returnsBoolean,
+    toLocaleString: returnsString,
+    toString: returnsString,
+    valueOf: returnsUnknown
+});
+const literalBooleanMembers = assembleMemberDescriptions({
+    valueOf: returnsBoolean
+}, objectMembers);
+const literalNumberMembers = assembleMemberDescriptions({
+    toExponential: returnsString,
+    toFixed: returnsString,
+    toLocaleString: returnsString,
+    toPrecision: returnsString,
+    valueOf: returnsNumber
+}, objectMembers);
+const literalStringMembers = assembleMemberDescriptions({
+    charAt: returnsString,
+    charCodeAt: returnsNumber,
+    codePointAt: returnsNumber,
+    concat: returnsString,
+    endsWith: returnsBoolean,
+    includes: returnsBoolean,
+    indexOf: returnsNumber,
+    lastIndexOf: returnsNumber,
+    localeCompare: returnsNumber,
+    match: returnsBoolean,
+    normalize: returnsString,
+    padEnd: returnsString,
+    padStart: returnsString,
+    repeat: returnsString,
+    replace: {
+        value: {
+            callsArgs: [1],
+            returns: UNKNOWN_LITERAL_STRING
         }
+    },
+    search: returnsNumber,
+    slice: returnsString,
+    split: returnsUnknown,
+    startsWith: returnsBoolean,
+    substr: returnsString,
+    substring: returnsString,
+    toLocaleLowerCase: returnsString,
+    toLocaleUpperCase: returnsString,
+    toLowerCase: returnsString,
+    toUpperCase: returnsString,
+    trim: returnsString,
+    valueOf: returnsString
+}, objectMembers);
+function getLiteralMembersForValue(value) {
+    switch (typeof value) {
+        case 'boolean':
+            return literalBooleanMembers;
+        case 'number':
+            return literalNumberMembers;
+        case 'string':
+            return literalStringMembers;
+        default:
+            return Object.create(null);
     }
-    // Patterns are only checked at the emtpy path at the moment
-    hasEffectsOnInteractionAtPath(_path, interaction, context) {
-        for (const element of this.elements) {
-            if (element?.hasEffectsOnInteractionAtPath(EMPTY_PATH, interaction, context))
-                return true;
-        }
-        return false;
+}
+function hasMemberEffectWhenCalled(members, memberName, callOptions, context) {
+    if (typeof memberName !== 'string' || !members[memberName]) {
+        return true;
     }
-    markDeclarationReached() {
-        for (const element of this.elements) {
-            element?.markDeclarationReached();
-        }
+    if (!members[memberName].callsArgs)
+        return false;
+    for (const argIndex of members[memberName].callsArgs) {
+        if (callOptions.args[argIndex] &&
+            callOptions.args[argIndex].hasEffectsWhenCalledAtPath(EMPTY_PATH, {
+                args: NO_ARGS,
+                thisParam: null,
+                withNew: false
+            }, context))
+            return true;
     }
+    return false;
+}
+function getMemberReturnExpressionWhenCalled(members, memberName) {
+    if (typeof memberName !== 'string' || !members[memberName])
+        return UNKNOWN_EXPRESSION;
+    return members[memberName].returns;
 }
 
 class LocalVariable extends Variable {
@@ -6574,6 +5109,7 @@
         }
     }
     deoptimizePath(path) {
+        var _a, _b;
         if (this.isReassigned ||
             this.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(path, this)) {
             return;
@@ -6586,18 +5122,18 @@
                 for (const expression of expressionsToBeDeoptimized) {
                     expression.deoptimizeCache();
                 }
-                this.init?.deoptimizePath(UNKNOWN_PATH);
+                (_a = this.init) === null || _a === void 0 ? void 0 : _a.deoptimizePath(UNKNOWN_PATH);
             }
         }
         else {
-            this.init?.deoptimizePath(path);
+            (_b = this.init) === null || _b === void 0 ? void 0 : _b.deoptimizePath(path);
         }
     }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
         if (this.isReassigned || !this.init) {
-            return interaction.thisArg.deoptimizePath(UNKNOWN_PATH);
+            return thisParameter.deoptimizePath(UNKNOWN_PATH);
         }
-        recursionTracker.withTrackedEntityAtPath(path, this.init, () => this.init.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker), undefined);
+        recursionTracker.withTrackedEntityAtPath(path, this.init, () => this.init.deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker), undefined);
     }
     getLiteralValueAtPath(path, recursionTracker, origin) {
         if (this.isReassigned || !this.init) {
@@ -6608,43 +5144,39 @@
             return this.init.getLiteralValueAtPath(path, recursionTracker, origin);
         }, UnknownValue);
     }
-    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
+    getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin) {
         if (this.isReassigned || !this.init) {
-            return UNKNOWN_RETURN_EXPRESSION;
+            return UNKNOWN_EXPRESSION;
         }
         return recursionTracker.withTrackedEntityAtPath(path, this.init, () => {
             this.expressionsToBeDeoptimized.push(origin);
-            return this.init.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
-        }, UNKNOWN_RETURN_EXPRESSION);
+            return this.init.getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin);
+        }, UNKNOWN_EXPRESSION);
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        switch (interaction.type) {
-            case INTERACTION_ACCESSED: {
-                if (this.isReassigned)
-                    return true;
-                return (this.init &&
-                    !context.accessed.trackEntityAtPathAndGetIfTracked(path, this) &&
-                    this.init.hasEffectsOnInteractionAtPath(path, interaction, context));
-            }
-            case INTERACTION_ASSIGNED: {
-                if (this.included)
-                    return true;
-                if (path.length === 0)
-                    return false;
-                if (this.isReassigned)
-                    return true;
-                return (this.init &&
-                    !context.assigned.trackEntityAtPathAndGetIfTracked(path, this) &&
-                    this.init.hasEffectsOnInteractionAtPath(path, interaction, context));
-            }
-            case INTERACTION_CALLED: {
-                if (this.isReassigned)
-                    return true;
-                return (this.init &&
-                    !(interaction.withNew ? context.instantiated : context.called).trackEntityAtPathAndGetIfTracked(path, interaction.args, this) &&
-                    this.init.hasEffectsOnInteractionAtPath(path, interaction, context));
-            }
-        }
+    hasEffectsWhenAccessedAtPath(path, context) {
+        if (this.isReassigned)
+            return true;
+        return (this.init &&
+            !context.accessed.trackEntityAtPathAndGetIfTracked(path, this) &&
+            this.init.hasEffectsWhenAccessedAtPath(path, context));
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        if (this.included)
+            return true;
+        if (path.length === 0)
+            return false;
+        if (this.isReassigned)
+            return true;
+        return (this.init &&
+            !context.accessed.trackEntityAtPathAndGetIfTracked(path, this) &&
+            this.init.hasEffectsWhenAssignedAtPath(path, context));
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        if (this.isReassigned)
+            return true;
+        return (this.init &&
+            !(callOptions.withNew ? context.instantiated : context.called).trackEntityAtPathAndGetIfTracked(path, callOptions, this) &&
+            this.init.hasEffectsWhenCalledAtPath(path, callOptions, context));
     }
     include() {
         if (!this.included) {
@@ -6665,15 +5197,15 @@
             }
         }
     }
-    includeCallArguments(context, parameters) {
+    includeCallArguments(context, args) {
         if (this.isReassigned || (this.init && context.includedCallArguments.has(this.init))) {
-            for (const argument of parameters) {
-                argument.include(context, false);
+            for (const arg of args) {
+                arg.include(context, false);
             }
         }
         else if (this.init) {
             context.includedCallArguments.add(this.init);
-            this.init.includeCallArguments(context, parameters);
+            this.init.includeCallArguments(context, args);
             context.includedCallArguments.delete(this.init);
         }
     }
@@ -6690,29 +5222,7 @@
     }
 }
 
-const chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$';
-const base = 64;
-function toBase64(value) {
-    let outString = '';
-    do {
-        const currentDigit = value % base;
-        value = (value / base) | 0;
-        outString = chars[currentDigit] + outString;
-    } while (value !== 0);
-    return outString;
-}
-
-function getSafeName(baseName, usedNames, forbiddenNames) {
-    let safeName = baseName;
-    let count = 1;
-    while (usedNames.has(safeName) || RESERVED_NAMES$1.has(safeName) || forbiddenNames?.has(safeName)) {
-        safeName = `${baseName}$${toBase64(count++)}`;
-    }
-    usedNames.add(safeName);
-    return safeName;
-}
-
-let Scope$1 = class Scope {
+class Scope$1 {
     constructor() {
         this.children = [];
         this.variables = new Map();
@@ -6735,7 +5245,7 @@
     findVariable(_name) {
         throw new Error('Internal Error: findVariable needs to be implemented by a subclass');
     }
-};
+}
 
 class ChildScope extends Scope$1 {
     constructor(parent) {
@@ -6798,7 +5308,7 @@
         }
         for (const [name, variable] of this.variables) {
             if (variable.included || variable.alwaysRendered) {
-                variable.setRenderNames(null, getSafeName(name, usedNames, variable.forbiddenNames));
+                variable.setRenderNames(null, getSafeName(name, usedNames));
             }
         }
         for (const scope of this.children) {
@@ -6819,108 +5329,7 @@
     }
 }
 
-class ParameterScope extends ChildScope {
-    constructor(parent, context) {
-        super(parent);
-        this.parameters = [];
-        this.hasRest = false;
-        this.context = context;
-        this.hoistedBodyVarScope = new ChildScope(this);
-    }
-    /**
-     * Adds a parameter to this scope. Parameters must be added in the correct
-     * order, e.g. from left to right.
-     */
-    addParameterDeclaration(identifier) {
-        const name = identifier.name;
-        let variable = this.hoistedBodyVarScope.variables.get(name);
-        if (variable) {
-            variable.addDeclaration(identifier, null);
-        }
-        else {
-            variable = new LocalVariable(name, identifier, UNKNOWN_EXPRESSION, this.context);
-        }
-        this.variables.set(name, variable);
-        return variable;
-    }
-    addParameterVariables(parameters, hasRest) {
-        this.parameters = parameters;
-        for (const parameterList of parameters) {
-            for (const parameter of parameterList) {
-                parameter.alwaysRendered = true;
-            }
-        }
-        this.hasRest = hasRest;
-    }
-    includeCallArguments(context, parameters) {
-        let calledFromTryStatement = false;
-        let argumentIncluded = false;
-        const restParameter = this.hasRest && this.parameters[this.parameters.length - 1];
-        for (const checkedArgument of parameters) {
-            if (checkedArgument instanceof SpreadElement) {
-                for (const argument of parameters) {
-                    argument.include(context, false);
-                }
-                break;
-            }
-        }
-        for (let index = parameters.length - 1; index >= 0; index--) {
-            const parameterVariables = this.parameters[index] || restParameter;
-            const argument = parameters[index];
-            if (parameterVariables) {
-                calledFromTryStatement = false;
-                if (parameterVariables.length === 0) {
-                    // handle empty destructuring
-                    argumentIncluded = true;
-                }
-                else {
-                    for (const variable of parameterVariables) {
-                        if (variable.included) {
-                            argumentIncluded = true;
-                        }
-                        if (variable.calledFromTryStatement) {
-                            calledFromTryStatement = true;
-                        }
-                    }
-                }
-            }
-            if (!argumentIncluded && argument.shouldBeIncluded(context)) {
-                argumentIncluded = true;
-            }
-            if (argumentIncluded) {
-                argument.include(context, calledFromTryStatement);
-            }
-        }
-    }
-}
-
-class ReturnValueScope extends ParameterScope {
-    constructor() {
-        super(...arguments);
-        this.returnExpression = null;
-        this.returnExpressions = [];
-    }
-    addReturnExpression(expression) {
-        this.returnExpressions.push(expression);
-    }
-    getReturnExpression() {
-        if (this.returnExpression === null)
-            this.updateReturnExpression();
-        return this.returnExpression;
-    }
-    updateReturnExpression() {
-        if (this.returnExpressions.length === 1) {
-            this.returnExpression = this.returnExpressions[0];
-        }
-        else {
-            this.returnExpression = UNKNOWN_EXPRESSION;
-            for (const expression of this.returnExpressions) {
-                expression.deoptimizePath(UNKNOWN_PATH);
-            }
-        }
-    }
-}
-
+//@ts-check
 /** @typedef { import('estree').Node} Node */
 /** @typedef {Node | {
  *   type: 'PropertyDefinition';
@@ -6932,7 +5341,7 @@
  *
  * @param {NodeWithPropertyDefinition} node
  * @param {NodeWithPropertyDefinition} parent
- * @returns {boolean}
+ * @returns boolean
  */
 function is_reference (node, parent) {
 	if (node.type === 'MemberExpression') {
@@ -6971,32 +5380,10 @@
 	return false;
 }
 
-const PureFunctionKey = Symbol('PureFunction');
-const getPureFunctions = ({ treeshake }) => {
-    const pureFunctions = Object.create(null);
-    for (const functionName of treeshake ? treeshake.manualPureFunctions : []) {
-        let currentFunctions = pureFunctions;
-        for (const pathSegment of functionName.split('.')) {
-            currentFunctions = currentFunctions[pathSegment] || (currentFunctions[pathSegment] = Object.create(null));
-        }
-        currentFunctions[PureFunctionKey] = true;
-    }
-    return pureFunctions;
-};
-
 /* eslint sort-keys: "off" */
 const ValueProperties = Symbol('Value Properties');
-const getTruthyLiteralValue = () => UnknownTruthyValue;
-const returnFalse = () => false;
-const returnTrue = () => true;
-const PURE = {
-    getLiteralValue: getTruthyLiteralValue,
-    hasEffectsWhenCalled: returnFalse
-};
-const IMPURE = {
-    getLiteralValue: getTruthyLiteralValue,
-    hasEffectsWhenCalled: returnTrue
-};
+const PURE = { pure: true };
+const IMPURE = { pure: false };
 // We use shortened variables to reduce file size here
 /* OBJECT */
 const O = {
@@ -7008,17 +5395,6 @@
     __proto__: null,
     [ValueProperties]: PURE
 };
-/* FUNCTION THAT MUTATES FIRST ARG WITHOUT TRIGGERING ACCESSORS */
-const MUTATES_ARG_WITHOUT_ACCESSOR = {
-    __proto__: null,
-    [ValueProperties]: {
-        getLiteralValue: getTruthyLiteralValue,
-        hasEffectsWhenCalled({ args }, context) {
-            return (args.length === 0 ||
-                args[0].hasEffectsOnInteractionAtPath(UNKNOWN_NON_ACCESSOR_PATH, NODE_INTERACTION_UNKNOWN_ASSIGNMENT, context));
-        }
-    }
-};
 /* CONSTRUCTOR */
 const C = {
     __proto__: null,
@@ -7157,24 +5533,17 @@
         __proto__: null,
         [ValueProperties]: PURE,
         create: PF,
-        // Technically those can throw in certain situations, but we ignore this as
-        // code that relies on this will hopefully wrap this in a try-catch, which
-        // deoptimizes everything anyway
-        defineProperty: MUTATES_ARG_WITHOUT_ACCESSOR,
-        defineProperties: MUTATES_ARG_WITHOUT_ACCESSOR,
-        freeze: MUTATES_ARG_WITHOUT_ACCESSOR,
+        getNotifier: PF,
+        getOwn: PF,
         getOwnPropertyDescriptor: PF,
         getOwnPropertyNames: PF,
         getOwnPropertySymbols: PF,
         getPrototypeOf: PF,
-        hasOwn: PF,
         is: PF,
         isExtensible: PF,
         isFrozen: PF,
         isSealed: PF,
         keys: PF,
-        fromEntries: PF,
-        entries: PF,
         prototype: O
     },
     parseFloat: PF,
@@ -7209,16 +5578,7 @@
         [ValueProperties]: PURE,
         for: PF,
         keyFor: PF,
-        prototype: O,
-        toStringTag: {
-            __proto__: null,
-            [ValueProperties]: {
-                getLiteralValue() {
-                    return SymbolToStringTag;
-                },
-                hasEffectsWhenCalled: returnTrue
-            }
-        }
+        prototype: O
     },
     SyntaxError: PC,
     toLocaleString: O,
@@ -7855,35 +6215,27 @@
     }
     return currentGlobal[ValueProperties];
 }
+function isPureGlobal(path) {
+    const globalAtPath = getGlobalAtPath(path);
+    return globalAtPath !== null && globalAtPath.pure;
+}
+function isGlobalMember(path) {
+    if (path.length === 1) {
+        return path[0] === 'undefined' || getGlobalAtPath(path) !== null;
+    }
+    return getGlobalAtPath(path.slice(0, -1)) !== null;
+}
 
 class GlobalVariable extends Variable {
     constructor() {
         super(...arguments);
-        // Ensure we use live-bindings for globals as we do not know if they have
-        // been reassigned
         this.isReassigned = true;
     }
-    getLiteralValueAtPath(path, _recursionTracker, _origin) {
-        const globalAtPath = getGlobalAtPath([this.name, ...path]);
-        return globalAtPath ? globalAtPath.getLiteralValue() : UnknownValue;
-    }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        switch (interaction.type) {
-            case INTERACTION_ACCESSED: {
-                if (path.length === 0) {
-                    // Technically, "undefined" is a global variable of sorts
-                    return this.name !== 'undefined' && !getGlobalAtPath([this.name]);
-                }
-                return !getGlobalAtPath([this.name, ...path].slice(0, -1));
-            }
-            case INTERACTION_ASSIGNED: {
-                return true;
-            }
-            case INTERACTION_CALLED: {
-                const globalAtPath = getGlobalAtPath([this.name, ...path]);
-                return !globalAtPath || globalAtPath.hasEffectsWhenCalled(interaction, context);
-            }
-        }
+    hasEffectsWhenAccessedAtPath(path) {
+        return !isGlobalMember([this.name, ...path]);
+    }
+    hasEffectsWhenCalledAtPath(path) {
+        return !isPureGlobal([this.name, ...path]);
     }
 }
 
@@ -7898,15 +6250,16 @@
     constructor() {
         super(...arguments);
         this.variable = null;
+        this.deoptimized = false;
         this.isTDZAccess = null;
     }
     addExportedVariables(variables, exportNamesByVariable) {
-        if (exportNamesByVariable.has(this.variable)) {
+        if (this.variable !== null && exportNamesByVariable.has(this.variable)) {
             variables.push(this.variable);
         }
     }
     bind() {
-        if (!this.variable && is_reference(this, this.parent)) {
+        if (this.variable === null && is_reference(this, this.parent)) {
             this.variable = this.scope.findVariable(this.name);
             this.variable.addReference(this);
         }
@@ -7915,34 +6268,29 @@
         let variable;
         const { treeshake } = this.context.options;
         switch (kind) {
-            case 'var': {
+            case 'var':
                 variable = this.scope.addDeclaration(this, this.context, init, true);
                 if (treeshake && treeshake.correctVarValueBeforeDeclaration) {
                     // Necessary to make sure the init is deoptimized. We cannot call deoptimizePath here.
                     variable.markInitializersForDeoptimization();
                 }
                 break;
-            }
-            case 'function': {
+            case 'function':
                 // in strict mode, functions are only hoisted within a scope but not across block scopes
                 variable = this.scope.addDeclaration(this, this.context, init, false);
                 break;
-            }
             case 'let':
             case 'const':
-            case 'class': {
+            case 'class':
                 variable = this.scope.addDeclaration(this, this.context, init, false);
                 break;
-            }
-            case 'parameter': {
+            case 'parameter':
                 variable = this.scope.addParameterDeclaration(this);
                 break;
-            }
             /* istanbul ignore next */
-            default: {
+            default:
                 /* istanbul ignore next */
                 throw new Error(`Internal Error: Unexpected identifier kind ${kind}.`);
-            }
         }
         variable.kind = kind;
         return [(this.variable = variable)];
@@ -7951,21 +6299,18 @@
         if (path.length === 0 && !this.scope.contains(this.name)) {
             this.disallowImportReassignment();
         }
-        // We keep conditional chaining because an unknown Node could have an
-        // Identifier as property that might be deoptimized by default
-        this.variable?.deoptimizePath(path);
+        this.variable.deoptimizePath(path);
     }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        this.variable.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
+        this.variable.deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker);
     }
     getLiteralValueAtPath(path, recursionTracker, origin) {
         return this.getVariableRespectingTDZ().getLiteralValueAtPath(path, recursionTracker, origin);
     }
-    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
-        const [expression, isPure] = this.getVariableRespectingTDZ().getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
-        return [expression, isPure || this.isPureFunction(path)];
+    getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin) {
+        return this.getVariableRespectingTDZ().getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin);
     }
-    hasEffects(context) {
+    hasEffects() {
         if (!this.deoptimized)
             this.applyDeoptimizations();
         if (this.isPossibleTDZ() && this.variable.kind !== 'var') {
@@ -7973,24 +6318,21 @@
         }
         return (this.context.options.treeshake.unknownGlobalSideEffects &&
             this.variable instanceof GlobalVariable &&
-            !this.isPureFunction(EMPTY_PATH) &&
-            this.variable.hasEffectsOnInteractionAtPath(EMPTY_PATH, NODE_INTERACTION_UNKNOWN_ACCESS, context));
+            this.variable.hasEffectsWhenAccessedAtPath(EMPTY_PATH));
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        switch (interaction.type) {
-            case INTERACTION_ACCESSED: {
-                return (this.variable !== null &&
-                    !this.isPureFunction(path) &&
-                    this.getVariableRespectingTDZ().hasEffectsOnInteractionAtPath(path, interaction, context));
-            }
-            case INTERACTION_ASSIGNED: {
-                return (path.length > 0 ? this.getVariableRespectingTDZ() : this.variable).hasEffectsOnInteractionAtPath(path, interaction, context);
-            }
-            case INTERACTION_CALLED: {
-                return (!this.isPureFunction(path) &&
-                    this.getVariableRespectingTDZ().hasEffectsOnInteractionAtPath(path, interaction, context));
-            }
-        }
+    hasEffectsWhenAccessedAtPath(path, context) {
+        return (this.variable !== null &&
+            this.getVariableRespectingTDZ().hasEffectsWhenAccessedAtPath(path, context));
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        return (!this.variable ||
+            (path.length > 0
+                ? this.getVariableRespectingTDZ()
+                : this.variable).hasEffectsWhenAssignedAtPath(path, context));
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        return (!this.variable ||
+            this.getVariableRespectingTDZ().hasEffectsWhenCalledAtPath(path, callOptions, context));
     }
     include() {
         if (!this.deoptimized)
@@ -8002,8 +6344,8 @@
             }
         }
     }
-    includeCallArguments(context, parameters) {
-        this.variable.includeCallArguments(context, parameters);
+    includeCallArguments(context, args) {
+        this.getVariableRespectingTDZ().includeCallArguments(context, args);
     }
     isPossibleTDZ() {
         // return cached value to avoid issues with the next tree-shaking pass
@@ -8056,13 +6398,16 @@
     }
     applyDeoptimizations() {
         this.deoptimized = true;
-        if (this.variable instanceof LocalVariable) {
+        if (this.variable !== null && this.variable instanceof LocalVariable) {
             this.variable.consolidateInitializers();
             this.context.requestTreeshakingPass();
         }
     }
     disallowImportReassignment() {
-        return this.context.error(errorIllegalImportReassignment(this.name, this.context.module.id), this.start);
+        return this.context.error({
+            code: 'ILLEGAL_REASSIGNMENT',
+            message: `Illegal reassignment to import '${this.name}'`
+        }, this.start);
     }
     getVariableRespectingTDZ() {
         if (this.isPossibleTDZ()) {
@@ -8070,183 +6415,1706 @@
         }
         return this.variable;
     }
-    isPureFunction(path) {
-        let currentPureFunction = this.context.manualPureFunctions[this.name];
-        for (const segment of path) {
-            if (currentPureFunction) {
-                if (currentPureFunction[PureFunctionKey]) {
+}
+function closestParentFunctionOrProgram(node) {
+    while (node && !/^Program|Function/.test(node.type)) {
+        node = node.parent;
+    }
+    // one of: ArrowFunctionExpression, FunctionDeclaration, FunctionExpression or Program
+    return node;
+}
+
+const EVENT_ACCESSED = 0;
+const EVENT_ASSIGNED = 1;
+const EVENT_CALLED = 2;
+
+class MethodBase extends NodeBase {
+    constructor() {
+        super(...arguments);
+        this.accessedValue = null;
+        this.accessorCallOptions = {
+            args: NO_ARGS,
+            thisParam: null,
+            withNew: false
+        };
+    }
+    // As getter properties directly receive their values from fixed function
+    // expressions, there is no known situation where a getter is deoptimized.
+    deoptimizeCache() { }
+    deoptimizePath(path) {
+        this.getAccessedValue().deoptimizePath(path);
+    }
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
+        if (event === EVENT_ACCESSED && this.kind === 'get' && path.length === 0) {
+            return this.value.deoptimizeThisOnEventAtPath(EVENT_CALLED, EMPTY_PATH, thisParameter, recursionTracker);
+        }
+        if (event === EVENT_ASSIGNED && this.kind === 'set' && path.length === 0) {
+            return this.value.deoptimizeThisOnEventAtPath(EVENT_CALLED, EMPTY_PATH, thisParameter, recursionTracker);
+        }
+        this.getAccessedValue().deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker);
+    }
+    getLiteralValueAtPath(path, recursionTracker, origin) {
+        return this.getAccessedValue().getLiteralValueAtPath(path, recursionTracker, origin);
+    }
+    getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin) {
+        return this.getAccessedValue().getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin);
+    }
+    hasEffects(context) {
+        return this.key.hasEffects(context);
+    }
+    hasEffectsWhenAccessedAtPath(path, context) {
+        if (this.kind === 'get' && path.length === 0) {
+            return this.value.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.accessorCallOptions, context);
+        }
+        return this.getAccessedValue().hasEffectsWhenAccessedAtPath(path, context);
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        if (this.kind === 'set') {
+            return this.value.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.accessorCallOptions, context);
+        }
+        return this.getAccessedValue().hasEffectsWhenAssignedAtPath(path, context);
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        return this.getAccessedValue().hasEffectsWhenCalledAtPath(path, callOptions, context);
+    }
+    getAccessedValue() {
+        if (this.accessedValue === null) {
+            if (this.kind === 'get') {
+                this.accessedValue = UNKNOWN_EXPRESSION;
+                return (this.accessedValue = this.value.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, this.accessorCallOptions, SHARED_RECURSION_TRACKER, this));
+            }
+            else {
+                return (this.accessedValue = this.value);
+            }
+        }
+        return this.accessedValue;
+    }
+}
+
+class MethodDefinition extends MethodBase {
+}
+
+const INTEGER_REG_EXP = /^\d+$/;
+class ObjectEntity extends ExpressionEntity {
+    // If a PropertyMap is used, this will be taken as propertiesAndGettersByKey
+    // and we assume there are no setters or getters
+    constructor(properties, prototypeExpression, immutable = false) {
+        super();
+        this.prototypeExpression = prototypeExpression;
+        this.immutable = immutable;
+        this.allProperties = [];
+        this.deoptimizedPaths = Object.create(null);
+        this.expressionsToBeDeoptimizedByKey = Object.create(null);
+        this.gettersByKey = Object.create(null);
+        this.hasUnknownDeoptimizedInteger = false;
+        this.hasUnknownDeoptimizedProperty = false;
+        this.propertiesAndGettersByKey = Object.create(null);
+        this.propertiesAndSettersByKey = Object.create(null);
+        this.settersByKey = Object.create(null);
+        this.thisParametersToBeDeoptimized = new Set();
+        this.unknownIntegerProps = [];
+        this.unmatchableGetters = [];
+        this.unmatchablePropertiesAndGetters = [];
+        this.unmatchableSetters = [];
+        if (Array.isArray(properties)) {
+            this.buildPropertyMaps(properties);
+        }
+        else {
+            this.propertiesAndGettersByKey = this.propertiesAndSettersByKey = properties;
+            for (const propertiesForKey of Object.values(properties)) {
+                this.allProperties.push(...propertiesForKey);
+            }
+        }
+    }
+    deoptimizeAllProperties() {
+        var _a;
+        if (this.hasUnknownDeoptimizedProperty) {
+            return;
+        }
+        this.hasUnknownDeoptimizedProperty = true;
+        for (const properties of Object.values(this.propertiesAndGettersByKey).concat(Object.values(this.settersByKey))) {
+            for (const property of properties) {
+                property.deoptimizePath(UNKNOWN_PATH);
+            }
+        }
+        // While the prototype itself cannot be mutated, each property can
+        (_a = this.prototypeExpression) === null || _a === void 0 ? void 0 : _a.deoptimizePath([UnknownKey, UnknownKey]);
+        this.deoptimizeCachedEntities();
+    }
+    deoptimizeIntegerProperties() {
+        if (this.hasUnknownDeoptimizedProperty || this.hasUnknownDeoptimizedInteger) {
+            return;
+        }
+        this.hasUnknownDeoptimizedInteger = true;
+        for (const [key, propertiesAndGetters] of Object.entries(this.propertiesAndGettersByKey)) {
+            if (INTEGER_REG_EXP.test(key)) {
+                for (const property of propertiesAndGetters) {
+                    property.deoptimizePath(UNKNOWN_PATH);
+                }
+            }
+        }
+        this.deoptimizeCachedIntegerEntities();
+    }
+    deoptimizePath(path) {
+        var _a;
+        if (this.hasUnknownDeoptimizedProperty || this.immutable)
+            return;
+        const key = path[0];
+        if (path.length === 1) {
+            if (typeof key !== 'string') {
+                if (key === UnknownInteger) {
+                    return this.deoptimizeIntegerProperties();
+                }
+                return this.deoptimizeAllProperties();
+            }
+            if (!this.deoptimizedPaths[key]) {
+                this.deoptimizedPaths[key] = true;
+                // we only deoptimizeCache exact matches as in all other cases,
+                // we do not return a literal value or return expression
+                const expressionsToBeDeoptimized = this.expressionsToBeDeoptimizedByKey[key];
+                if (expressionsToBeDeoptimized) {
+                    for (const expression of expressionsToBeDeoptimized) {
+                        expression.deoptimizeCache();
+                    }
+                }
+            }
+        }
+        const subPath = path.length === 1 ? UNKNOWN_PATH : path.slice(1);
+        for (const property of typeof key === 'string'
+            ? (this.propertiesAndGettersByKey[key] || this.unmatchablePropertiesAndGetters).concat(this.settersByKey[key] || this.unmatchableSetters)
+            : this.allProperties) {
+            property.deoptimizePath(subPath);
+        }
+        (_a = this.prototypeExpression) === null || _a === void 0 ? void 0 : _a.deoptimizePath(path.length === 1 ? [UnknownKey, UnknownKey] : path);
+    }
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
+        var _a;
+        const [key, ...subPath] = path;
+        if (this.hasUnknownDeoptimizedProperty ||
+            // single paths that are deoptimized will not become getters or setters
+            ((event === EVENT_CALLED || path.length > 1) &&
+                typeof key === 'string' &&
+                this.deoptimizedPaths[key])) {
+            thisParameter.deoptimizePath(UNKNOWN_PATH);
+            return;
+        }
+        const [propertiesForExactMatchByKey, relevantPropertiesByKey, relevantUnmatchableProperties] = event === EVENT_CALLED || path.length > 1
+            ? [
+                this.propertiesAndGettersByKey,
+                this.propertiesAndGettersByKey,
+                this.unmatchablePropertiesAndGetters
+            ]
+            : event === EVENT_ACCESSED
+                ? [this.propertiesAndGettersByKey, this.gettersByKey, this.unmatchableGetters]
+                : [this.propertiesAndSettersByKey, this.settersByKey, this.unmatchableSetters];
+        if (typeof key === 'string') {
+            if (propertiesForExactMatchByKey[key]) {
+                const properties = relevantPropertiesByKey[key];
+                if (properties) {
+                    for (const property of properties) {
+                        property.deoptimizeThisOnEventAtPath(event, subPath, thisParameter, recursionTracker);
+                    }
+                }
+                if (!this.immutable) {
+                    this.thisParametersToBeDeoptimized.add(thisParameter);
+                }
+                return;
+            }
+            for (const property of relevantUnmatchableProperties) {
+                property.deoptimizeThisOnEventAtPath(event, subPath, thisParameter, recursionTracker);
+            }
+            if (INTEGER_REG_EXP.test(key)) {
+                for (const property of this.unknownIntegerProps) {
+                    property.deoptimizeThisOnEventAtPath(event, subPath, thisParameter, recursionTracker);
+                }
+            }
+        }
+        else {
+            for (const properties of Object.values(relevantPropertiesByKey).concat([
+                relevantUnmatchableProperties
+            ])) {
+                for (const property of properties) {
+                    property.deoptimizeThisOnEventAtPath(event, subPath, thisParameter, recursionTracker);
+                }
+            }
+            for (const property of this.unknownIntegerProps) {
+                property.deoptimizeThisOnEventAtPath(event, subPath, thisParameter, recursionTracker);
+            }
+        }
+        if (!this.immutable) {
+            this.thisParametersToBeDeoptimized.add(thisParameter);
+        }
+        (_a = this.prototypeExpression) === null || _a === void 0 ? void 0 : _a.deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker);
+    }
+    getLiteralValueAtPath(path, recursionTracker, origin) {
+        if (path.length === 0) {
+            return UnknownValue;
+        }
+        const key = path[0];
+        const expressionAtPath = this.getMemberExpressionAndTrackDeopt(key, origin);
+        if (expressionAtPath) {
+            return expressionAtPath.getLiteralValueAtPath(path.slice(1), recursionTracker, origin);
+        }
+        if (this.prototypeExpression) {
+            return this.prototypeExpression.getLiteralValueAtPath(path, recursionTracker, origin);
+        }
+        if (path.length === 1) {
+            return undefined;
+        }
+        return UnknownValue;
+    }
+    getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin) {
+        if (path.length === 0) {
+            return UNKNOWN_EXPRESSION;
+        }
+        const key = path[0];
+        const expressionAtPath = this.getMemberExpressionAndTrackDeopt(key, origin);
+        if (expressionAtPath) {
+            return expressionAtPath.getReturnExpressionWhenCalledAtPath(path.slice(1), callOptions, recursionTracker, origin);
+        }
+        if (this.prototypeExpression) {
+            return this.prototypeExpression.getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin);
+        }
+        return UNKNOWN_EXPRESSION;
+    }
+    hasEffectsWhenAccessedAtPath(path, context) {
+        const [key, ...subPath] = path;
+        if (path.length > 1) {
+            if (typeof key !== 'string') {
+                return true;
+            }
+            const expressionAtPath = this.getMemberExpression(key);
+            if (expressionAtPath) {
+                return expressionAtPath.hasEffectsWhenAccessedAtPath(subPath, context);
+            }
+            if (this.prototypeExpression) {
+                return this.prototypeExpression.hasEffectsWhenAccessedAtPath(path, context);
+            }
+            return true;
+        }
+        if (this.hasUnknownDeoptimizedProperty)
+            return true;
+        if (typeof key === 'string') {
+            if (this.propertiesAndGettersByKey[key]) {
+                const getters = this.gettersByKey[key];
+                if (getters) {
+                    for (const getter of getters) {
+                        if (getter.hasEffectsWhenAccessedAtPath(subPath, context))
+                            return true;
+                    }
+                }
+                return false;
+            }
+            for (const getter of this.unmatchableGetters) {
+                if (getter.hasEffectsWhenAccessedAtPath(subPath, context)) {
                     return true;
                 }
-                currentPureFunction = currentPureFunction[segment];
             }
-            else {
+        }
+        else {
+            for (const getters of Object.values(this.gettersByKey).concat([this.unmatchableGetters])) {
+                for (const getter of getters) {
+                    if (getter.hasEffectsWhenAccessedAtPath(subPath, context))
+                        return true;
+                }
+            }
+        }
+        if (this.prototypeExpression) {
+            return this.prototypeExpression.hasEffectsWhenAccessedAtPath(path, context);
+        }
+        return false;
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        const [key, ...subPath] = path;
+        if (path.length > 1) {
+            if (typeof key !== 'string') {
+                return true;
+            }
+            const expressionAtPath = this.getMemberExpression(key);
+            if (expressionAtPath) {
+                return expressionAtPath.hasEffectsWhenAssignedAtPath(subPath, context);
+            }
+            if (this.prototypeExpression) {
+                return this.prototypeExpression.hasEffectsWhenAssignedAtPath(path, context);
+            }
+            return true;
+        }
+        if (this.hasUnknownDeoptimizedProperty)
+            return true;
+        // We do not need to test for unknown properties as in that case, hasUnknownDeoptimizedProperty is true
+        if (typeof key === 'string') {
+            if (this.propertiesAndSettersByKey[key]) {
+                const setters = this.settersByKey[key];
+                if (setters) {
+                    for (const setter of setters) {
+                        if (setter.hasEffectsWhenAssignedAtPath(subPath, context))
+                            return true;
+                    }
+                }
                 return false;
             }
+            for (const property of this.unmatchableSetters) {
+                if (property.hasEffectsWhenAssignedAtPath(subPath, context)) {
+                    return true;
+                }
+            }
+        }
+        if (this.prototypeExpression) {
+            return this.prototypeExpression.hasEffectsWhenAssignedAtPath(path, context);
         }
-        return currentPureFunction?.[PureFunctionKey];
+        return false;
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        const key = path[0];
+        const expressionAtPath = this.getMemberExpression(key);
+        if (expressionAtPath) {
+            return expressionAtPath.hasEffectsWhenCalledAtPath(path.slice(1), callOptions, context);
+        }
+        if (this.prototypeExpression) {
+            return this.prototypeExpression.hasEffectsWhenCalledAtPath(path, callOptions, context);
+        }
+        return true;
+    }
+    buildPropertyMaps(properties) {
+        const { allProperties, propertiesAndGettersByKey, propertiesAndSettersByKey, settersByKey, gettersByKey, unknownIntegerProps, unmatchablePropertiesAndGetters, unmatchableGetters, unmatchableSetters } = this;
+        const unmatchablePropertiesAndSetters = [];
+        for (let index = properties.length - 1; index >= 0; index--) {
+            const { key, kind, property } = properties[index];
+            allProperties.push(property);
+            if (typeof key !== 'string') {
+                if (key === UnknownInteger) {
+                    unknownIntegerProps.push(property);
+                    continue;
+                }
+                if (kind === 'set')
+                    unmatchableSetters.push(property);
+                if (kind === 'get')
+                    unmatchableGetters.push(property);
+                if (kind !== 'get')
+                    unmatchablePropertiesAndSetters.push(property);
+                if (kind !== 'set')
+                    unmatchablePropertiesAndGetters.push(property);
+            }
+            else {
+                if (kind === 'set') {
+                    if (!propertiesAndSettersByKey[key]) {
+                        propertiesAndSettersByKey[key] = [property, ...unmatchablePropertiesAndSetters];
+                        settersByKey[key] = [property, ...unmatchableSetters];
+                    }
+                }
+                else if (kind === 'get') {
+                    if (!propertiesAndGettersByKey[key]) {
+                        propertiesAndGettersByKey[key] = [property, ...unmatchablePropertiesAndGetters];
+                        gettersByKey[key] = [property, ...unmatchableGetters];
+                    }
+                }
+                else {
+                    if (!propertiesAndSettersByKey[key]) {
+                        propertiesAndSettersByKey[key] = [property, ...unmatchablePropertiesAndSetters];
+                    }
+                    if (!propertiesAndGettersByKey[key]) {
+                        propertiesAndGettersByKey[key] = [property, ...unmatchablePropertiesAndGetters];
+                    }
+                }
+            }
+        }
+    }
+    deoptimizeCachedEntities() {
+        for (const expressionsToBeDeoptimized of Object.values(this.expressionsToBeDeoptimizedByKey)) {
+            for (const expression of expressionsToBeDeoptimized) {
+                expression.deoptimizeCache();
+            }
+        }
+        for (const expression of this.thisParametersToBeDeoptimized) {
+            expression.deoptimizePath(UNKNOWN_PATH);
+        }
+    }
+    deoptimizeCachedIntegerEntities() {
+        for (const [key, expressionsToBeDeoptimized] of Object.entries(this.expressionsToBeDeoptimizedByKey)) {
+            if (INTEGER_REG_EXP.test(key)) {
+                for (const expression of expressionsToBeDeoptimized) {
+                    expression.deoptimizeCache();
+                }
+            }
+        }
+        for (const expression of this.thisParametersToBeDeoptimized) {
+            expression.deoptimizePath(UNKNOWN_INTEGER_PATH);
+        }
+    }
+    getMemberExpression(key) {
+        if (this.hasUnknownDeoptimizedProperty ||
+            typeof key !== 'string' ||
+            (this.hasUnknownDeoptimizedInteger && INTEGER_REG_EXP.test(key)) ||
+            this.deoptimizedPaths[key]) {
+            return UNKNOWN_EXPRESSION;
+        }
+        const properties = this.propertiesAndGettersByKey[key];
+        if ((properties === null || properties === void 0 ? void 0 : properties.length) === 1) {
+            return properties[0];
+        }
+        if (properties ||
+            this.unmatchablePropertiesAndGetters.length > 0 ||
+            (this.unknownIntegerProps.length && INTEGER_REG_EXP.test(key))) {
+            return UNKNOWN_EXPRESSION;
+        }
+        return null;
+    }
+    getMemberExpressionAndTrackDeopt(key, origin) {
+        if (typeof key !== 'string') {
+            return UNKNOWN_EXPRESSION;
+        }
+        const expression = this.getMemberExpression(key);
+        if (!(expression === UNKNOWN_EXPRESSION || this.immutable)) {
+            const expressionsToBeDeoptimized = (this.expressionsToBeDeoptimizedByKey[key] =
+                this.expressionsToBeDeoptimizedByKey[key] || []);
+            expressionsToBeDeoptimized.push(origin);
+        }
+        return expression;
     }
 }
-function closestParentFunctionOrProgram(node) {
-    while (node && !/^Program|Function/.test(node.type)) {
-        node = node.parent;
+
+class ObjectMember extends ExpressionEntity {
+    constructor(object, key) {
+        super();
+        this.object = object;
+        this.key = key;
+    }
+    deoptimizePath(path) {
+        this.object.deoptimizePath([this.key, ...path]);
+    }
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
+        this.object.deoptimizeThisOnEventAtPath(event, [this.key, ...path], thisParameter, recursionTracker);
+    }
+    getLiteralValueAtPath(path, recursionTracker, origin) {
+        return this.object.getLiteralValueAtPath([this.key, ...path], recursionTracker, origin);
+    }
+    getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin) {
+        return this.object.getReturnExpressionWhenCalledAtPath([this.key, ...path], callOptions, recursionTracker, origin);
+    }
+    hasEffectsWhenAccessedAtPath(path, context) {
+        if (path.length === 0)
+            return false;
+        return this.object.hasEffectsWhenAccessedAtPath([this.key, ...path], context);
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        return this.object.hasEffectsWhenAssignedAtPath([this.key, ...path], context);
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        return this.object.hasEffectsWhenCalledAtPath([this.key, ...path], callOptions, context);
     }
-    // one of: ArrowFunctionExpression, FunctionDeclaration, FunctionExpression or Program
-    return node;
 }
 
-function treeshakeNode(node, code, start, end) {
-    code.remove(start, end);
-    if (node.annotations) {
-        for (const annotation of node.annotations) {
-            if (annotation.start < start) {
-                code.remove(annotation.start, annotation.end);
+class Method extends ExpressionEntity {
+    constructor(description) {
+        super();
+        this.description = description;
+    }
+    deoptimizeThisOnEventAtPath(event, path, thisParameter) {
+        if (event === EVENT_CALLED && path.length === 0 && this.description.mutatesSelfAsArray) {
+            thisParameter.deoptimizePath(UNKNOWN_INTEGER_PATH);
+        }
+    }
+    getReturnExpressionWhenCalledAtPath(path, callOptions) {
+        if (path.length > 0) {
+            return UNKNOWN_EXPRESSION;
+        }
+        return (this.description.returnsPrimitive ||
+            (this.description.returns === 'self'
+                ? callOptions.thisParam || UNKNOWN_EXPRESSION
+                : this.description.returns()));
+    }
+    hasEffectsWhenAccessedAtPath(path) {
+        return path.length > 1;
+    }
+    hasEffectsWhenAssignedAtPath(path) {
+        return path.length > 0;
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        var _a, _b;
+        if (path.length > 0 ||
+            (this.description.mutatesSelfAsArray === true &&
+                ((_a = callOptions.thisParam) === null || _a === void 0 ? void 0 : _a.hasEffectsWhenAssignedAtPath(UNKNOWN_INTEGER_PATH, context)))) {
+            return true;
+        }
+        if (!this.description.callsArgs) {
+            return false;
+        }
+        for (const argIndex of this.description.callsArgs) {
+            if ((_b = callOptions.args[argIndex]) === null || _b === void 0 ? void 0 : _b.hasEffectsWhenCalledAtPath(EMPTY_PATH, {
+                args: NO_ARGS,
+                thisParam: null,
+                withNew: false
+            }, context)) {
+                return true;
             }
-            else {
+        }
+        return false;
+    }
+    includeCallArguments(context, args) {
+        for (const arg of args) {
+            arg.include(context, false);
+        }
+    }
+}
+const METHOD_RETURNS_BOOLEAN = [
+    new Method({
+        callsArgs: null,
+        mutatesSelfAsArray: false,
+        returns: null,
+        returnsPrimitive: UNKNOWN_LITERAL_BOOLEAN
+    })
+];
+const METHOD_RETURNS_STRING = [
+    new Method({
+        callsArgs: null,
+        mutatesSelfAsArray: false,
+        returns: null,
+        returnsPrimitive: UNKNOWN_LITERAL_STRING
+    })
+];
+const METHOD_RETURNS_NUMBER = [
+    new Method({
+        callsArgs: null,
+        mutatesSelfAsArray: false,
+        returns: null,
+        returnsPrimitive: UNKNOWN_LITERAL_NUMBER
+    })
+];
+const METHOD_RETURNS_UNKNOWN = [
+    new Method({
+        callsArgs: null,
+        mutatesSelfAsArray: false,
+        returns: null,
+        returnsPrimitive: UNKNOWN_EXPRESSION
+    })
+];
+
+const OBJECT_PROTOTYPE = new ObjectEntity({
+    __proto__: null,
+    hasOwnProperty: METHOD_RETURNS_BOOLEAN,
+    isPrototypeOf: METHOD_RETURNS_BOOLEAN,
+    propertyIsEnumerable: METHOD_RETURNS_BOOLEAN,
+    toLocaleString: METHOD_RETURNS_STRING,
+    toString: METHOD_RETURNS_STRING,
+    valueOf: METHOD_RETURNS_UNKNOWN
+}, null, true);
+
+class ClassNode extends NodeBase {
+    constructor() {
+        super(...arguments);
+        this.objectEntity = null;
+    }
+    createScope(parentScope) {
+        this.scope = new ChildScope(parentScope);
+    }
+    deoptimizeCache() {
+        this.getObjectEntity().deoptimizeAllProperties();
+    }
+    deoptimizePath(path) {
+        this.getObjectEntity().deoptimizePath(path);
+    }
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
+        this.getObjectEntity().deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker);
+    }
+    getLiteralValueAtPath(path, recursionTracker, origin) {
+        return this.getObjectEntity().getLiteralValueAtPath(path, recursionTracker, origin);
+    }
+    getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin) {
+        return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin);
+    }
+    hasEffects(context) {
+        var _a, _b;
+        const initEffect = ((_a = this.superClass) === null || _a === void 0 ? void 0 : _a.hasEffects(context)) || this.body.hasEffects(context);
+        (_b = this.id) === null || _b === void 0 ? void 0 : _b.markDeclarationReached();
+        return initEffect || super.hasEffects(context);
+    }
+    hasEffectsWhenAccessedAtPath(path, context) {
+        return this.getObjectEntity().hasEffectsWhenAccessedAtPath(path, context);
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        return this.getObjectEntity().hasEffectsWhenAssignedAtPath(path, context);
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        if (path.length === 0) {
+            return (!callOptions.withNew ||
+                (this.classConstructor !== null
+                    ? this.classConstructor.hasEffectsWhenCalledAtPath(EMPTY_PATH, callOptions, context)
+                    : this.superClass !== null &&
+                        this.superClass.hasEffectsWhenCalledAtPath(path, callOptions, context)));
+        }
+        else {
+            return this.getObjectEntity().hasEffectsWhenCalledAtPath(path, callOptions, context);
+        }
+    }
+    include(context, includeChildrenRecursively) {
+        var _a;
+        this.included = true;
+        (_a = this.superClass) === null || _a === void 0 ? void 0 : _a.include(context, includeChildrenRecursively);
+        this.body.include(context, includeChildrenRecursively);
+        if (this.id) {
+            this.id.markDeclarationReached();
+            this.id.include();
+        }
+    }
+    initialise() {
+        var _a;
+        (_a = this.id) === null || _a === void 0 ? void 0 : _a.declare('class', this);
+        for (const method of this.body.body) {
+            if (method instanceof MethodDefinition && method.kind === 'constructor') {
+                this.classConstructor = method;
                 return;
             }
         }
+        this.classConstructor = null;
+    }
+    getObjectEntity() {
+        if (this.objectEntity !== null) {
+            return this.objectEntity;
+        }
+        const staticProperties = [];
+        const dynamicMethods = [];
+        for (const definition of this.body.body) {
+            const properties = definition.static ? staticProperties : dynamicMethods;
+            const definitionKind = definition.kind;
+            // Note that class fields do not end up on the prototype
+            if (properties === dynamicMethods && !definitionKind)
+                continue;
+            const kind = definitionKind === 'set' || definitionKind === 'get' ? definitionKind : 'init';
+            let key;
+            if (definition.computed) {
+                const keyValue = definition.key.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
+                if (keyValue === UnknownValue) {
+                    properties.push({ key: UnknownKey, kind, property: definition });
+                    continue;
+                }
+                else {
+                    key = String(keyValue);
+                }
+            }
+            else {
+                key =
+                    definition.key instanceof Identifier
+                        ? definition.key.name
+                        : String(definition.key.value);
+            }
+            properties.push({ key, kind, property: definition });
+        }
+        staticProperties.unshift({
+            key: 'prototype',
+            kind: 'init',
+            property: new ObjectEntity(dynamicMethods, this.superClass ? new ObjectMember(this.superClass, 'prototype') : OBJECT_PROTOTYPE)
+        });
+        return (this.objectEntity = new ObjectEntity(staticProperties, this.superClass || OBJECT_PROTOTYPE));
     }
 }
-function removeAnnotations(node, code) {
-    if (!node.annotations && node.parent.type === ExpressionStatement$1) {
-        node = node.parent;
+
+class ClassDeclaration extends ClassNode {
+    initialise() {
+        super.initialise();
+        if (this.id !== null) {
+            this.id.variable.isId = true;
+        }
     }
-    if (node.annotations) {
-        for (const annotation of node.annotations) {
-            code.remove(annotation.start, annotation.end);
+    parseNode(esTreeNode) {
+        if (esTreeNode.id !== null) {
+            this.id = new this.context.nodeConstructors.Identifier(esTreeNode.id, this, this.scope.parent);
         }
+        super.parseNode(esTreeNode);
+    }
+    render(code, options) {
+        const { exportNamesByVariable, format, snippets: { _ } } = options;
+        if (format === 'system' && this.id && exportNamesByVariable.has(this.id.variable)) {
+            code.appendLeft(this.end, `${_}${getSystemExportStatement([this.id.variable], options)};`);
+        }
+        super.render(code, options);
     }
 }
 
-const NO_SEMICOLON = { isNoStatement: true };
-// This assumes there are only white-space and comments between start and the string we are looking for
-function findFirstOccurrenceOutsideComment(code, searchString, start = 0) {
-    let searchPos, charCodeAfterSlash;
-    searchPos = code.indexOf(searchString, start);
-    while (true) {
-        start = code.indexOf('/', start);
-        if (start === -1 || start >= searchPos)
-            return searchPos;
-        charCodeAfterSlash = code.charCodeAt(++start);
-        ++start;
-        // With our assumption, '/' always starts a comment. Determine comment type:
-        start =
-            charCodeAfterSlash === 47 /*"/"*/
-                ? code.indexOf('\n', start) + 1
-                : code.indexOf('*/', start) + 2;
-        if (start > searchPos) {
-            searchPos = code.indexOf(searchString, start);
+class ArgumentsVariable extends LocalVariable {
+    constructor(context) {
+        super('arguments', null, UNKNOWN_EXPRESSION, context);
+    }
+    hasEffectsWhenAccessedAtPath(path) {
+        return path.length > 1;
+    }
+    hasEffectsWhenAssignedAtPath() {
+        return true;
+    }
+    hasEffectsWhenCalledAtPath() {
+        return true;
+    }
+}
+
+class ThisVariable extends LocalVariable {
+    constructor(context) {
+        super('this', null, null, context);
+        this.deoptimizedPaths = [];
+        this.entitiesToBeDeoptimized = new Set();
+        this.thisDeoptimizationList = [];
+        this.thisDeoptimizations = new DiscriminatedPathTracker();
+    }
+    addEntityToBeDeoptimized(entity) {
+        for (const path of this.deoptimizedPaths) {
+            entity.deoptimizePath(path);
         }
+        for (const thisDeoptimization of this.thisDeoptimizationList) {
+            this.applyThisDeoptimizationEvent(entity, thisDeoptimization);
+        }
+        this.entitiesToBeDeoptimized.add(entity);
+    }
+    deoptimizePath(path) {
+        if (path.length === 0 ||
+            this.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(path, this)) {
+            return;
+        }
+        this.deoptimizedPaths.push(path);
+        for (const entity of this.entitiesToBeDeoptimized) {
+            entity.deoptimizePath(path);
+        }
+    }
+    deoptimizeThisOnEventAtPath(event, path, thisParameter) {
+        const thisDeoptimization = {
+            event,
+            path,
+            thisParameter
+        };
+        if (!this.thisDeoptimizations.trackEntityAtPathAndGetIfTracked(path, event, thisParameter)) {
+            for (const entity of this.entitiesToBeDeoptimized) {
+                this.applyThisDeoptimizationEvent(entity, thisDeoptimization);
+            }
+            this.thisDeoptimizationList.push(thisDeoptimization);
+        }
+    }
+    hasEffectsWhenAccessedAtPath(path, context) {
+        return (this.getInit(context).hasEffectsWhenAccessedAtPath(path, context) ||
+            super.hasEffectsWhenAccessedAtPath(path, context));
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        return (this.getInit(context).hasEffectsWhenAssignedAtPath(path, context) ||
+            super.hasEffectsWhenAssignedAtPath(path, context));
+    }
+    applyThisDeoptimizationEvent(entity, { event, path, thisParameter }) {
+        entity.deoptimizeThisOnEventAtPath(event, path, thisParameter === this ? entity : thisParameter, SHARED_RECURSION_TRACKER);
+    }
+    getInit(context) {
+        return context.replacedVariableInits.get(this) || UNKNOWN_EXPRESSION;
     }
 }
-const NON_WHITESPACE = /\S/g;
-function findNonWhiteSpace(code, index) {
-    NON_WHITESPACE.lastIndex = index;
-    const result = NON_WHITESPACE.exec(code);
-    return result.index;
+
+class SpreadElement extends NodeBase {
+    constructor() {
+        super(...arguments);
+        this.deoptimized = false;
+    }
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
+        if (path.length > 0) {
+            this.argument.deoptimizeThisOnEventAtPath(event, [UnknownKey, ...path], thisParameter, recursionTracker);
+        }
+    }
+    hasEffects(context) {
+        if (!this.deoptimized)
+            this.applyDeoptimizations();
+        const { propertyReadSideEffects } = this.context.options
+            .treeshake;
+        return (this.argument.hasEffects(context) ||
+            (propertyReadSideEffects &&
+                (propertyReadSideEffects === 'always' ||
+                    this.argument.hasEffectsWhenAccessedAtPath(UNKNOWN_PATH, context))));
+    }
+    applyDeoptimizations() {
+        this.deoptimized = true;
+        // Only properties of properties of the argument could become subject to reassignment
+        // This will also reassign the return values of iterators
+        this.argument.deoptimizePath([UnknownKey, UnknownKey]);
+        this.context.requestTreeshakingPass();
+    }
 }
-// This assumes "code" only contains white-space and comments
-// Returns position of line-comment if applicable
-function findFirstLineBreakOutsideComment(code) {
-    let lineBreakPos, charCodeAfterSlash, start = 0;
-    lineBreakPos = code.indexOf('\n', start);
-    while (true) {
-        start = code.indexOf('/', start);
-        if (start === -1 || start > lineBreakPos)
-            return [lineBreakPos, lineBreakPos + 1];
-        // With our assumption, '/' always starts a comment. Determine comment type:
-        charCodeAfterSlash = code.charCodeAt(start + 1);
-        if (charCodeAfterSlash === 47 /*"/"*/)
-            return [start, lineBreakPos + 1];
-        start = code.indexOf('*/', start + 3) + 2;
-        if (start > lineBreakPos) {
-            lineBreakPos = code.indexOf('\n', start);
+
+class ParameterScope extends ChildScope {
+    constructor(parent, context) {
+        super(parent);
+        this.parameters = [];
+        this.hasRest = false;
+        this.context = context;
+        this.hoistedBodyVarScope = new ChildScope(this);
+    }
+    /**
+     * Adds a parameter to this scope. Parameters must be added in the correct
+     * order, e.g. from left to right.
+     */
+    addParameterDeclaration(identifier) {
+        const name = identifier.name;
+        let variable = this.hoistedBodyVarScope.variables.get(name);
+        if (variable) {
+            variable.addDeclaration(identifier, null);
+        }
+        else {
+            variable = new LocalVariable(name, identifier, UNKNOWN_EXPRESSION, this.context);
+        }
+        this.variables.set(name, variable);
+        return variable;
+    }
+    addParameterVariables(parameters, hasRest) {
+        this.parameters = parameters;
+        for (const parameterList of parameters) {
+            for (const parameter of parameterList) {
+                parameter.alwaysRendered = true;
+            }
+        }
+        this.hasRest = hasRest;
+    }
+    includeCallArguments(context, args) {
+        let calledFromTryStatement = false;
+        let argIncluded = false;
+        const restParam = this.hasRest && this.parameters[this.parameters.length - 1];
+        for (const checkedArg of args) {
+            if (checkedArg instanceof SpreadElement) {
+                for (const arg of args) {
+                    arg.include(context, false);
+                }
+                break;
+            }
+        }
+        for (let index = args.length - 1; index >= 0; index--) {
+            const paramVars = this.parameters[index] || restParam;
+            const arg = args[index];
+            if (paramVars) {
+                calledFromTryStatement = false;
+                if (paramVars.length === 0) {
+                    // handle empty destructuring
+                    argIncluded = true;
+                }
+                else {
+                    for (const variable of paramVars) {
+                        if (variable.included) {
+                            argIncluded = true;
+                        }
+                        if (variable.calledFromTryStatement) {
+                            calledFromTryStatement = true;
+                        }
+                    }
+                }
+            }
+            if (!argIncluded && arg.shouldBeIncluded(context)) {
+                argIncluded = true;
+            }
+            if (argIncluded) {
+                arg.include(context, calledFromTryStatement);
+            }
         }
     }
 }
-function renderStatementList(statements, code, start, end, options) {
-    let currentNode, currentNodeStart, currentNodeNeedsBoundaries, nextNodeStart;
-    let nextNode = statements[0];
-    let nextNodeNeedsBoundaries = !nextNode.included || nextNode.needsBoundaries;
-    if (nextNodeNeedsBoundaries) {
-        nextNodeStart =
-            start + findFirstLineBreakOutsideComment(code.original.slice(start, nextNode.start))[1];
+
+class ReturnValueScope extends ParameterScope {
+    constructor() {
+        super(...arguments);
+        this.returnExpression = null;
+        this.returnExpressions = [];
     }
-    for (let nextIndex = 1; nextIndex <= statements.length; nextIndex++) {
-        currentNode = nextNode;
-        currentNodeStart = nextNodeStart;
-        currentNodeNeedsBoundaries = nextNodeNeedsBoundaries;
-        nextNode = statements[nextIndex];
-        nextNodeNeedsBoundaries =
-            nextNode === undefined ? false : !nextNode.included || nextNode.needsBoundaries;
-        if (currentNodeNeedsBoundaries || nextNodeNeedsBoundaries) {
-            nextNodeStart =
-                currentNode.end +
-                    findFirstLineBreakOutsideComment(code.original.slice(currentNode.end, nextNode === undefined ? end : nextNode.start))[1];
-            if (currentNode.included) {
-                currentNodeNeedsBoundaries
-                    ? currentNode.render(code, options, {
-                        end: nextNodeStart,
-                        start: currentNodeStart
-                    })
-                    : currentNode.render(code, options);
+    addReturnExpression(expression) {
+        this.returnExpressions.push(expression);
+    }
+    getReturnExpression() {
+        if (this.returnExpression === null)
+            this.updateReturnExpression();
+        return this.returnExpression;
+    }
+    updateReturnExpression() {
+        if (this.returnExpressions.length === 1) {
+            this.returnExpression = this.returnExpressions[0];
+        }
+        else {
+            this.returnExpression = UNKNOWN_EXPRESSION;
+            for (const expression of this.returnExpressions) {
+                expression.deoptimizePath(UNKNOWN_PATH);
+            }
+        }
+    }
+}
+
+class FunctionScope extends ReturnValueScope {
+    constructor(parent, context) {
+        super(parent, context);
+        this.variables.set('arguments', (this.argumentsVariable = new ArgumentsVariable(context)));
+        this.variables.set('this', (this.thisVariable = new ThisVariable(context)));
+    }
+    findLexicalBoundary() {
+        return this;
+    }
+    includeCallArguments(context, args) {
+        super.includeCallArguments(context, args);
+        if (this.argumentsVariable.included) {
+            for (const arg of args) {
+                if (!arg.included) {
+                    arg.include(context, false);
+                }
+            }
+        }
+    }
+}
+
+class RestElement extends NodeBase {
+    constructor() {
+        super(...arguments);
+        this.deoptimized = false;
+        this.declarationInit = null;
+    }
+    addExportedVariables(variables, exportNamesByVariable) {
+        this.argument.addExportedVariables(variables, exportNamesByVariable);
+    }
+    declare(kind, init) {
+        this.declarationInit = init;
+        return this.argument.declare(kind, UNKNOWN_EXPRESSION);
+    }
+    deoptimizePath(path) {
+        path.length === 0 && this.argument.deoptimizePath(EMPTY_PATH);
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        return path.length > 0 || this.argument.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context);
+    }
+    markDeclarationReached() {
+        this.argument.markDeclarationReached();
+    }
+    applyDeoptimizations() {
+        this.deoptimized = true;
+        if (this.declarationInit !== null) {
+            this.declarationInit.deoptimizePath([UnknownKey, UnknownKey]);
+            this.context.requestTreeshakingPass();
+        }
+    }
+}
+
+class FunctionNode extends NodeBase {
+    constructor() {
+        super(...arguments);
+        this.deoptimizedReturn = false;
+        this.isPrototypeDeoptimized = false;
+    }
+    createScope(parentScope) {
+        this.scope = new FunctionScope(parentScope, this.context);
+    }
+    deoptimizePath(path) {
+        if (path.length === 1) {
+            if (path[0] === 'prototype') {
+                this.isPrototypeDeoptimized = true;
+            }
+            else if (path[0] === UnknownKey) {
+                this.isPrototypeDeoptimized = true;
+                // A reassignment of UNKNOWN_PATH is considered equivalent to having lost track
+                // which means the return expression needs to be reassigned as well
+                this.scope.getReturnExpression().deoptimizePath(UNKNOWN_PATH);
+            }
+        }
+    }
+    // TODO for completeness, we should also track other events here
+    deoptimizeThisOnEventAtPath(event, path, thisParameter) {
+        if (event === EVENT_CALLED) {
+            if (path.length > 0) {
+                thisParameter.deoptimizePath(UNKNOWN_PATH);
             }
             else {
-                treeshakeNode(currentNode, code, currentNodeStart, nextNodeStart);
+                this.scope.thisVariable.addEntityToBeDeoptimized(thisParameter);
             }
         }
+    }
+    getReturnExpressionWhenCalledAtPath(path) {
+        if (path.length !== 0) {
+            return UNKNOWN_EXPRESSION;
+        }
+        if (this.async) {
+            if (!this.deoptimizedReturn) {
+                this.deoptimizedReturn = true;
+                this.scope.getReturnExpression().deoptimizePath(UNKNOWN_PATH);
+                this.context.requestTreeshakingPass();
+            }
+            return UNKNOWN_EXPRESSION;
+        }
+        return this.scope.getReturnExpression();
+    }
+    hasEffects() {
+        return this.id !== null && this.id.hasEffects();
+    }
+    hasEffectsWhenAccessedAtPath(path) {
+        if (path.length <= 1)
+            return false;
+        return path.length > 2 || path[0] !== 'prototype' || this.isPrototypeDeoptimized;
+    }
+    hasEffectsWhenAssignedAtPath(path) {
+        if (path.length <= 1) {
+            return false;
+        }
+        return path.length > 2 || path[0] !== 'prototype' || this.isPrototypeDeoptimized;
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        if (path.length > 0)
+            return true;
+        if (this.async) {
+            const { propertyReadSideEffects } = this.context.options
+                .treeshake;
+            const returnExpression = this.scope.getReturnExpression();
+            if (returnExpression.hasEffectsWhenCalledAtPath(['then'], { args: NO_ARGS, thisParam: null, withNew: false }, context) ||
+                (propertyReadSideEffects &&
+                    (propertyReadSideEffects === 'always' ||
+                        returnExpression.hasEffectsWhenAccessedAtPath(['then'], context)))) {
+                return true;
+            }
+        }
+        for (const param of this.params) {
+            if (param.hasEffects(context))
+                return true;
+        }
+        const thisInit = context.replacedVariableInits.get(this.scope.thisVariable);
+        context.replacedVariableInits.set(this.scope.thisVariable, callOptions.withNew
+            ? new ObjectEntity(Object.create(null), OBJECT_PROTOTYPE)
+            : UNKNOWN_EXPRESSION);
+        const { brokenFlow, ignore } = context;
+        context.ignore = {
+            breaks: false,
+            continues: false,
+            labels: new Set(),
+            returnYield: true
+        };
+        if (this.body.hasEffects(context))
+            return true;
+        context.brokenFlow = brokenFlow;
+        if (thisInit) {
+            context.replacedVariableInits.set(this.scope.thisVariable, thisInit);
+        }
         else {
-            currentNode.render(code, options);
+            context.replacedVariableInits.delete(this.scope.thisVariable);
         }
+        context.ignore = ignore;
+        return false;
+    }
+    include(context, includeChildrenRecursively) {
+        this.included = true;
+        if (this.id)
+            this.id.include();
+        const hasArguments = this.scope.argumentsVariable.included;
+        for (const param of this.params) {
+            if (!(param instanceof Identifier) || hasArguments) {
+                param.include(context, includeChildrenRecursively);
+            }
+        }
+        const { brokenFlow } = context;
+        context.brokenFlow = BROKEN_FLOW_NONE;
+        this.body.include(context, includeChildrenRecursively);
+        context.brokenFlow = brokenFlow;
+    }
+    includeCallArguments(context, args) {
+        this.scope.includeCallArguments(context, args);
+    }
+    initialise() {
+        if (this.id !== null) {
+            this.id.declare('function', this);
+        }
+        this.scope.addParameterVariables(this.params.map(param => param.declare('parameter', UNKNOWN_EXPRESSION)), this.params[this.params.length - 1] instanceof RestElement);
+        this.body.addImplicitReturnExpressionToScope();
+    }
+    parseNode(esTreeNode) {
+        this.body = new this.context.nodeConstructors.BlockStatement(esTreeNode.body, this, this.scope.hoistedBodyVarScope);
+        super.parseNode(esTreeNode);
     }
 }
-// This assumes that the first character is not part of the first node
-function getCommaSeparatedNodesWithBoundaries(nodes, code, start, end) {
-    const splitUpNodes = [];
-    let node, nextNodeStart, contentEnd, char;
-    let separator = start - 1;
-    for (const nextNode of nodes) {
-        if (node !== undefined) {
-            separator =
-                node.end +
-                    findFirstOccurrenceOutsideComment(code.original.slice(node.end, nextNode.start), ',');
+FunctionNode.prototype.preventChildBlockScope = true;
+
+class FunctionDeclaration extends FunctionNode {
+    initialise() {
+        super.initialise();
+        if (this.id !== null) {
+            this.id.variable.isId = true;
         }
-        nextNodeStart = contentEnd =
-            separator +
-                1 +
-                findFirstLineBreakOutsideComment(code.original.slice(separator + 1, nextNode.start))[1];
-        while (((char = code.original.charCodeAt(nextNodeStart)),
-            char === 32 /*" "*/ || char === 9 /*"\t"*/ || char === 10 /*"\n"*/ || char === 13) /*"\r"*/)
-            nextNodeStart++;
-        if (node !== undefined) {
-            splitUpNodes.push({
-                contentEnd,
-                end: nextNodeStart,
-                node,
-                separator,
-                start
+    }
+    parseNode(esTreeNode) {
+        if (esTreeNode.id !== null) {
+            this.id = new this.context.nodeConstructors.Identifier(esTreeNode.id, this, this.scope.parent);
+        }
+        super.parseNode(esTreeNode);
+    }
+}
+
+// The header ends at the first non-white-space after "default"
+function getDeclarationStart(code, start) {
+    return findNonWhiteSpace(code, findFirstOccurrenceOutsideComment(code, 'default', start) + 7);
+}
+function getIdInsertPosition(code, declarationKeyword, endMarker, start) {
+    const declarationEnd = findFirstOccurrenceOutsideComment(code, declarationKeyword, start) + declarationKeyword.length;
+    code = code.slice(declarationEnd, findFirstOccurrenceOutsideComment(code, endMarker, declarationEnd));
+    const generatorStarPos = findFirstOccurrenceOutsideComment(code, '*');
+    if (generatorStarPos === -1) {
+        return declarationEnd;
+    }
+    return declarationEnd + generatorStarPos + 1;
+}
+class ExportDefaultDeclaration extends NodeBase {
+    include(context, includeChildrenRecursively) {
+        super.include(context, includeChildrenRecursively);
+        if (includeChildrenRecursively) {
+            this.context.includeVariableInModule(this.variable);
+        }
+    }
+    initialise() {
+        const declaration = this.declaration;
+        this.declarationName =
+            (declaration.id && declaration.id.name) || this.declaration.name;
+        this.variable = this.scope.addExportDefaultDeclaration(this.declarationName || this.context.getModuleName(), this, this.context);
+        this.context.addExport(this);
+    }
+    render(code, options, nodeRenderOptions) {
+        const { start, end } = nodeRenderOptions;
+        const declarationStart = getDeclarationStart(code.original, this.start);
+        if (this.declaration instanceof FunctionDeclaration) {
+            this.renderNamedDeclaration(code, declarationStart, 'function', '(', this.declaration.id === null, options);
+        }
+        else if (this.declaration instanceof ClassDeclaration) {
+            this.renderNamedDeclaration(code, declarationStart, 'class', '{', this.declaration.id === null, options);
+        }
+        else if (this.variable.getOriginalVariable() !== this.variable) {
+            // Remove altogether to prevent re-declaring the same variable
+            treeshakeNode(this, code, start, end);
+            return;
+        }
+        else if (this.variable.included) {
+            this.renderVariableDeclaration(code, declarationStart, options);
+        }
+        else {
+            code.remove(this.start, declarationStart);
+            this.declaration.render(code, options, {
+                renderedSurroundingElement: ExpressionStatement$1
             });
+            if (code.original[this.end - 1] !== ';') {
+                code.appendLeft(this.end, ';');
+            }
+            return;
+        }
+        this.declaration.render(code, options);
+    }
+    renderNamedDeclaration(code, declarationStart, declarationKeyword, endMarker, needsId, options) {
+        const { exportNamesByVariable, format, snippets: { getPropertyAccess } } = options;
+        const name = this.variable.getName(getPropertyAccess);
+        // Remove `export default`
+        code.remove(this.start, declarationStart);
+        if (needsId) {
+            code.appendLeft(getIdInsertPosition(code.original, declarationKeyword, endMarker, declarationStart), ` ${name}`);
+        }
+        if (format === 'system' &&
+            this.declaration instanceof ClassDeclaration &&
+            exportNamesByVariable.has(this.variable)) {
+            code.appendLeft(this.end, ` ${getSystemExportStatement([this.variable], options)};`);
+        }
+    }
+    renderVariableDeclaration(code, declarationStart, { format, exportNamesByVariable, snippets: { cnst, getPropertyAccess } }) {
+        const hasTrailingSemicolon = code.original.charCodeAt(this.end - 1) === 59; /*";"*/
+        const systemExportNames = format === 'system' && exportNamesByVariable.get(this.variable);
+        if (systemExportNames) {
+            code.overwrite(this.start, declarationStart, `${cnst} ${this.variable.getName(getPropertyAccess)} = exports('${systemExportNames[0]}', `);
+            code.appendRight(hasTrailingSemicolon ? this.end - 1 : this.end, ')' + (hasTrailingSemicolon ? '' : ';'));
+        }
+        else {
+            code.overwrite(this.start, declarationStart, `${cnst} ${this.variable.getName(getPropertyAccess)} = `);
+            if (!hasTrailingSemicolon) {
+                code.appendLeft(this.end, ';');
+            }
         }
-        node = nextNode;
-        start = nextNodeStart;
     }
-    splitUpNodes.push({
-        contentEnd: end,
-        end,
-        node: node,
-        separator: null,
-        start
-    });
-    return splitUpNodes;
 }
-// This assumes there are only white-space and comments between start and end
-function removeLineBreaks(code, start, end) {
-    while (true) {
-        const [removeStart, removeEnd] = findFirstLineBreakOutsideComment(code.original.slice(start, end));
-        if (removeStart === -1) {
-            break;
+ExportDefaultDeclaration.prototype.needsBoundaries = true;
+
+class Literal extends NodeBase {
+    deoptimizeThisOnEventAtPath() { }
+    getLiteralValueAtPath(path) {
+        if (path.length > 0 ||
+            // unknown literals can also be null but do not start with an "n"
+            (this.value === null && this.context.code.charCodeAt(this.start) !== 110) ||
+            typeof this.value === 'bigint' ||
+            // to support shims for regular expressions
+            this.context.code.charCodeAt(this.start) === 47) {
+            return UnknownValue;
+        }
+        return this.value;
+    }
+    getReturnExpressionWhenCalledAtPath(path) {
+        if (path.length !== 1)
+            return UNKNOWN_EXPRESSION;
+        return getMemberReturnExpressionWhenCalled(this.members, path[0]);
+    }
+    hasEffectsWhenAccessedAtPath(path) {
+        if (this.value === null) {
+            return path.length > 0;
+        }
+        return path.length > 1;
+    }
+    hasEffectsWhenAssignedAtPath(path) {
+        return path.length > 0;
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        if (path.length === 1) {
+            return hasMemberEffectWhenCalled(this.members, path[0], callOptions, context);
+        }
+        return true;
+    }
+    initialise() {
+        this.members = getLiteralMembersForValue(this.value);
+    }
+    parseNode(esTreeNode) {
+        this.value = esTreeNode.value;
+        this.regex = esTreeNode.regex;
+        super.parseNode(esTreeNode);
+    }
+    render(code) {
+        if (typeof this.value === 'string') {
+            code.indentExclusionRanges.push([this.start + 1, this.end - 1]);
+        }
+    }
+}
+
+class Program extends NodeBase {
+    constructor() {
+        super(...arguments);
+        this.hasCachedEffect = false;
+    }
+    hasEffects(context) {
+        // We are caching here to later more efficiently identify side-effect-free modules
+        if (this.hasCachedEffect)
+            return true;
+        for (const node of this.body) {
+            if (node.hasEffects(context)) {
+                return (this.hasCachedEffect = true);
+            }
+        }
+        return false;
+    }
+    include(context, includeChildrenRecursively) {
+        this.included = true;
+        for (const node of this.body) {
+            if (includeChildrenRecursively || node.shouldBeIncluded(context)) {
+                node.include(context, includeChildrenRecursively);
+            }
+        }
+    }
+    render(code, options) {
+        if (this.body.length) {
+            renderStatementList(this.body, code, this.start, this.end, options);
+        }
+        else {
+            super.render(code, options);
+        }
+    }
+}
+
+class TemplateLiteral extends NodeBase {
+    getLiteralValueAtPath(path) {
+        if (path.length > 0 || this.quasis.length !== 1) {
+            return UnknownValue;
+        }
+        return this.quasis[0].value.cooked;
+    }
+    render(code, options) {
+        code.indentExclusionRanges.push([this.start, this.end]);
+        super.render(code, options);
+    }
+}
+
+function isReassignedExportsMember(variable, exportNamesByVariable) {
+    return (variable.renderBaseName !== null && exportNamesByVariable.has(variable) && variable.isReassigned);
+}
+
+function areAllDeclarationsIncludedAndNotExported(declarations, exportNamesByVariable) {
+    for (const declarator of declarations) {
+        if (!declarator.id.included)
+            return false;
+        if (declarator.id.type === Identifier$1) {
+            if (exportNamesByVariable.has(declarator.id.variable))
+                return false;
+        }
+        else {
+            const exportedVariables = [];
+            declarator.id.addExportedVariables(exportedVariables, exportNamesByVariable);
+            if (exportedVariables.length > 0)
+                return false;
+        }
+    }
+    return true;
+}
+class VariableDeclaration extends NodeBase {
+    deoptimizePath() {
+        for (const declarator of this.declarations) {
+            declarator.deoptimizePath(EMPTY_PATH);
+        }
+    }
+    hasEffectsWhenAssignedAtPath() {
+        return false;
+    }
+    include(context, includeChildrenRecursively) {
+        this.included = true;
+        for (const declarator of this.declarations) {
+            if (includeChildrenRecursively || declarator.shouldBeIncluded(context))
+                declarator.include(context, includeChildrenRecursively);
+        }
+    }
+    includeAsSingleStatement(context, includeChildrenRecursively) {
+        this.included = true;
+        for (const declarator of this.declarations) {
+            if (includeChildrenRecursively || declarator.shouldBeIncluded(context)) {
+                declarator.include(context, includeChildrenRecursively);
+                declarator.id.include(context, includeChildrenRecursively);
+            }
+        }
+    }
+    initialise() {
+        for (const declarator of this.declarations) {
+            declarator.declareDeclarator(this.kind);
+        }
+    }
+    render(code, options, nodeRenderOptions = BLANK) {
+        if (areAllDeclarationsIncludedAndNotExported(this.declarations, options.exportNamesByVariable)) {
+            for (const declarator of this.declarations) {
+                declarator.render(code, options);
+            }
+            if (!nodeRenderOptions.isNoStatement &&
+                code.original.charCodeAt(this.end - 1) !== 59 /*";"*/) {
+                code.appendLeft(this.end, ';');
+            }
+        }
+        else {
+            this.renderReplacedDeclarations(code, options, nodeRenderOptions);
+        }
+    }
+    renderDeclarationEnd(code, separatorString, lastSeparatorPos, actualContentEnd, renderedContentEnd, systemPatternExports, options, isNoStatement) {
+        if (code.original.charCodeAt(this.end - 1) === 59 /*";"*/) {
+            code.remove(this.end - 1, this.end);
+        }
+        if (!isNoStatement) {
+            separatorString += ';';
+        }
+        if (lastSeparatorPos !== null) {
+            if (code.original.charCodeAt(actualContentEnd - 1) === 10 /*"\n"*/ &&
+                (code.original.charCodeAt(this.end) === 10 /*"\n"*/ ||
+                    code.original.charCodeAt(this.end) === 13) /*"\r"*/) {
+                actualContentEnd--;
+                if (code.original.charCodeAt(actualContentEnd) === 13 /*"\r"*/) {
+                    actualContentEnd--;
+                }
+            }
+            if (actualContentEnd === lastSeparatorPos + 1) {
+                code.overwrite(lastSeparatorPos, renderedContentEnd, separatorString);
+            }
+            else {
+                code.overwrite(lastSeparatorPos, lastSeparatorPos + 1, separatorString);
+                code.remove(actualContentEnd, renderedContentEnd);
+            }
+        }
+        else {
+            code.appendLeft(renderedContentEnd, separatorString);
+        }
+        if (systemPatternExports.length > 0) {
+            code.appendLeft(renderedContentEnd, ` ${getSystemExportStatement(systemPatternExports, options)};`);
+        }
+    }
+    renderReplacedDeclarations(code, options, { isNoStatement }) {
+        const separatedNodes = getCommaSeparatedNodesWithBoundaries(this.declarations, code, this.start + this.kind.length, this.end - (code.original.charCodeAt(this.end - 1) === 59 /*";"*/ ? 1 : 0));
+        let actualContentEnd, renderedContentEnd;
+        renderedContentEnd = findNonWhiteSpace(code.original, this.start + this.kind.length);
+        let lastSeparatorPos = renderedContentEnd - 1;
+        code.remove(this.start, lastSeparatorPos);
+        let isInDeclaration = false;
+        let hasRenderedContent = false;
+        let separatorString = '', leadingString, nextSeparatorString;
+        const aggregatedSystemExports = [];
+        const singleSystemExport = gatherSystemExportsAndGetSingleExport(separatedNodes, options, aggregatedSystemExports);
+        for (const { node, start, separator, contentEnd, end } of separatedNodes) {
+            if (!node.included) {
+                code.remove(start, end);
+                continue;
+            }
+            node.render(code, options);
+            leadingString = '';
+            nextSeparatorString = '';
+            if (!node.id.included ||
+                (node.id instanceof Identifier &&
+                    isReassignedExportsMember(node.id.variable, options.exportNamesByVariable))) {
+                if (hasRenderedContent) {
+                    separatorString += ';';
+                }
+                isInDeclaration = false;
+            }
+            else {
+                if (singleSystemExport && singleSystemExport === node.id.variable) {
+                    const operatorPos = findFirstOccurrenceOutsideComment(code.original, '=', node.id.end);
+                    renderSystemExportExpression(singleSystemExport, findNonWhiteSpace(code.original, operatorPos + 1), separator === null ? contentEnd : separator, code, options);
+                }
+                if (isInDeclaration) {
+                    separatorString += ',';
+                }
+                else {
+                    if (hasRenderedContent) {
+                        separatorString += ';';
+                    }
+                    leadingString += `${this.kind} `;
+                    isInDeclaration = true;
+                }
+            }
+            if (renderedContentEnd === lastSeparatorPos + 1) {
+                code.overwrite(lastSeparatorPos, renderedContentEnd, separatorString + leadingString);
+            }
+            else {
+                code.overwrite(lastSeparatorPos, lastSeparatorPos + 1, separatorString);
+                code.appendLeft(renderedContentEnd, leadingString);
+            }
+            actualContentEnd = contentEnd;
+            renderedContentEnd = end;
+            hasRenderedContent = true;
+            lastSeparatorPos = separator;
+            separatorString = nextSeparatorString;
+        }
+        this.renderDeclarationEnd(code, separatorString, lastSeparatorPos, actualContentEnd, renderedContentEnd, aggregatedSystemExports, options, isNoStatement);
+    }
+}
+function gatherSystemExportsAndGetSingleExport(separatedNodes, options, aggregatedSystemExports) {
+    var _a;
+    let singleSystemExport = null;
+    if (options.format === 'system') {
+        for (const { node } of separatedNodes) {
+            if (node.id instanceof Identifier &&
+                node.init &&
+                aggregatedSystemExports.length === 0 &&
+                ((_a = options.exportNamesByVariable.get(node.id.variable)) === null || _a === void 0 ? void 0 : _a.length) === 1) {
+                singleSystemExport = node.id.variable;
+                aggregatedSystemExports.push(singleSystemExport);
+            }
+            else {
+                node.id.addExportedVariables(aggregatedSystemExports, options.exportNamesByVariable);
+            }
+        }
+        if (aggregatedSystemExports.length > 1) {
+            singleSystemExport = null;
+        }
+        else if (singleSystemExport) {
+            aggregatedSystemExports.length = 0;
+        }
+    }
+    return singleSystemExport;
+}
+
+const NEW_ARRAY_PROPERTIES = [
+    { key: UnknownInteger, kind: 'init', property: UNKNOWN_EXPRESSION },
+    { key: 'length', kind: 'init', property: UNKNOWN_LITERAL_NUMBER }
+];
+const METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_BOOLEAN = [
+    new Method({
+        callsArgs: [0],
+        mutatesSelfAsArray: 'deopt-only',
+        returns: null,
+        returnsPrimitive: UNKNOWN_LITERAL_BOOLEAN
+    })
+];
+const METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NUMBER = [
+    new Method({
+        callsArgs: [0],
+        mutatesSelfAsArray: 'deopt-only',
+        returns: null,
+        returnsPrimitive: UNKNOWN_LITERAL_NUMBER
+    })
+];
+const METHOD_MUTATES_SELF_RETURNS_NEW_ARRAY = [
+    new Method({
+        callsArgs: null,
+        mutatesSelfAsArray: true,
+        returns: () => new ObjectEntity(NEW_ARRAY_PROPERTIES, ARRAY_PROTOTYPE),
+        returnsPrimitive: null
+    })
+];
+const METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY = [
+    new Method({
+        callsArgs: null,
+        mutatesSelfAsArray: 'deopt-only',
+        returns: () => new ObjectEntity(NEW_ARRAY_PROPERTIES, ARRAY_PROTOTYPE),
+        returnsPrimitive: null
+    })
+];
+const METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY = [
+    new Method({
+        callsArgs: [0],
+        mutatesSelfAsArray: 'deopt-only',
+        returns: () => new ObjectEntity(NEW_ARRAY_PROPERTIES, ARRAY_PROTOTYPE),
+        returnsPrimitive: null
+    })
+];
+const METHOD_MUTATES_SELF_RETURNS_NUMBER = [
+    new Method({
+        callsArgs: null,
+        mutatesSelfAsArray: true,
+        returns: null,
+        returnsPrimitive: UNKNOWN_LITERAL_NUMBER
+    })
+];
+const METHOD_MUTATES_SELF_RETURNS_UNKNOWN = [
+    new Method({
+        callsArgs: null,
+        mutatesSelfAsArray: true,
+        returns: null,
+        returnsPrimitive: UNKNOWN_EXPRESSION
+    })
+];
+const METHOD_DEOPTS_SELF_RETURNS_UNKNOWN = [
+    new Method({
+        callsArgs: null,
+        mutatesSelfAsArray: 'deopt-only',
+        returns: null,
+        returnsPrimitive: UNKNOWN_EXPRESSION
+    })
+];
+const METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN = [
+    new Method({
+        callsArgs: [0],
+        mutatesSelfAsArray: 'deopt-only',
+        returns: null,
+        returnsPrimitive: UNKNOWN_EXPRESSION
+    })
+];
+const METHOD_MUTATES_SELF_RETURNS_SELF = [
+    new Method({
+        callsArgs: null,
+        mutatesSelfAsArray: true,
+        returns: 'self',
+        returnsPrimitive: null
+    })
+];
+const METHOD_CALLS_ARG_MUTATES_SELF_RETURNS_SELF = [
+    new Method({
+        callsArgs: [0],
+        mutatesSelfAsArray: true,
+        returns: 'self',
+        returnsPrimitive: null
+    })
+];
+const ARRAY_PROTOTYPE = new ObjectEntity({
+    __proto__: null,
+    // We assume that accessors have effects as we do not track the accessed value afterwards
+    at: METHOD_DEOPTS_SELF_RETURNS_UNKNOWN,
+    concat: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY,
+    copyWithin: METHOD_MUTATES_SELF_RETURNS_SELF,
+    entries: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY,
+    every: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_BOOLEAN,
+    fill: METHOD_MUTATES_SELF_RETURNS_SELF,
+    filter: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY,
+    find: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
+    findIndex: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NUMBER,
+    forEach: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
+    includes: METHOD_RETURNS_BOOLEAN,
+    indexOf: METHOD_RETURNS_NUMBER,
+    join: METHOD_RETURNS_STRING,
+    keys: METHOD_RETURNS_UNKNOWN,
+    lastIndexOf: METHOD_RETURNS_NUMBER,
+    map: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY,
+    pop: METHOD_MUTATES_SELF_RETURNS_UNKNOWN,
+    push: METHOD_MUTATES_SELF_RETURNS_NUMBER,
+    reduce: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
+    reduceRight: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
+    reverse: METHOD_MUTATES_SELF_RETURNS_SELF,
+    shift: METHOD_MUTATES_SELF_RETURNS_UNKNOWN,
+    slice: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY,
+    some: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_BOOLEAN,
+    sort: METHOD_CALLS_ARG_MUTATES_SELF_RETURNS_SELF,
+    splice: METHOD_MUTATES_SELF_RETURNS_NEW_ARRAY,
+    unshift: METHOD_MUTATES_SELF_RETURNS_NUMBER,
+    values: METHOD_DEOPTS_SELF_RETURNS_UNKNOWN
+}, OBJECT_PROTOTYPE, true);
+
+class ArrayExpression extends NodeBase {
+    constructor() {
+        super(...arguments);
+        this.objectEntity = null;
+    }
+    deoptimizePath(path) {
+        this.getObjectEntity().deoptimizePath(path);
+    }
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
+        this.getObjectEntity().deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker);
+    }
+    getLiteralValueAtPath(path, recursionTracker, origin) {
+        return this.getObjectEntity().getLiteralValueAtPath(path, recursionTracker, origin);
+    }
+    getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin) {
+        return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin);
+    }
+    hasEffectsWhenAccessedAtPath(path, context) {
+        return this.getObjectEntity().hasEffectsWhenAccessedAtPath(path, context);
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        return this.getObjectEntity().hasEffectsWhenAssignedAtPath(path, context);
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        return this.getObjectEntity().hasEffectsWhenCalledAtPath(path, callOptions, context);
+    }
+    getObjectEntity() {
+        if (this.objectEntity !== null) {
+            return this.objectEntity;
+        }
+        const properties = [
+            { key: 'length', kind: 'init', property: UNKNOWN_LITERAL_NUMBER }
+        ];
+        let hasSpread = false;
+        for (let index = 0; index < this.elements.length; index++) {
+            const element = this.elements[index];
+            if (element instanceof SpreadElement || hasSpread) {
+                if (element) {
+                    hasSpread = true;
+                    properties.unshift({ key: UnknownInteger, kind: 'init', property: element });
+                }
+            }
+            else if (!element) {
+                properties.push({ key: String(index), kind: 'init', property: UNDEFINED_EXPRESSION });
+            }
+            else {
+                properties.push({ key: String(index), kind: 'init', property: element });
+            }
+        }
+        return (this.objectEntity = new ObjectEntity(properties, ARRAY_PROTOTYPE));
+    }
+}
+
+class ArrayPattern extends NodeBase {
+    addExportedVariables(variables, exportNamesByVariable) {
+        for (const element of this.elements) {
+            if (element !== null) {
+                element.addExportedVariables(variables, exportNamesByVariable);
+            }
+        }
+    }
+    declare(kind) {
+        const variables = [];
+        for (const element of this.elements) {
+            if (element !== null) {
+                variables.push(...element.declare(kind, UNKNOWN_EXPRESSION));
+            }
+        }
+        return variables;
+    }
+    deoptimizePath(path) {
+        if (path.length === 0) {
+            for (const element of this.elements) {
+                if (element !== null) {
+                    element.deoptimizePath(path);
+                }
+            }
+        }
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        if (path.length > 0)
+            return true;
+        for (const element of this.elements) {
+            if (element !== null && element.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context))
+                return true;
+        }
+        return false;
+    }
+    markDeclarationReached() {
+        for (const element of this.elements) {
+            if (element !== null) {
+                element.markDeclarationReached();
+            }
         }
-        code.remove(start + removeStart, (start += removeEnd));
     }
 }
 
@@ -8272,7 +8140,10 @@
             this.parent.type === Program$1) {
             this.context.warn(
             // This is necessary, because either way (deleting or not) can lead to errors.
-            errorModuleLevelDirective(this.directive, this.context.module.id), this.start);
+            {
+                code: 'MODULE_LEVEL_DIRECTIVE',
+                message: `Module level directives cause errors when bundled, '${this.directive}' was ignored.`
+            }, this.start);
         }
     }
     render(code, options) {
@@ -8285,7 +8156,6 @@
             return this.parent.type !== Program$1;
         return super.shouldBeIncluded(context);
     }
-    applyDeoptimizations() { }
 }
 
 class BlockStatement extends NodeBase {
@@ -8308,15 +8178,15 @@
         if (this.deoptimizeBody)
             return true;
         for (const node of this.body) {
-            if (context.brokenFlow)
-                break;
             if (node.hasEffects(context))
                 return true;
+            if (context.brokenFlow)
+                break;
         }
         return false;
     }
     include(context, includeChildrenRecursively) {
-        if (!(this.deoptimizeBody && this.directlyIncluded)) {
+        if (!this.deoptimizeBody || !this.directlyIncluded) {
             this.included = true;
             this.directlyIncluded = true;
             if (this.deoptimizeBody)
@@ -8334,7 +8204,7 @@
                 firstBodyStatement.directive === 'use asm';
     }
     render(code, options) {
-        if (this.body.length > 0) {
+        if (this.body.length) {
             renderStatementList(this.body, code, this.start + 1, this.end - 1, options);
         }
         else {
@@ -8343,62 +8213,26 @@
     }
 }
 
-class RestElement extends NodeBase {
-    constructor() {
-        super(...arguments);
-        this.declarationInit = null;
-    }
-    addExportedVariables(variables, exportNamesByVariable) {
-        this.argument.addExportedVariables(variables, exportNamesByVariable);
-    }
-    declare(kind, init) {
-        this.declarationInit = init;
-        return this.argument.declare(kind, UNKNOWN_EXPRESSION);
-    }
-    deoptimizePath(path) {
-        path.length === 0 && this.argument.deoptimizePath(EMPTY_PATH);
-    }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        return (path.length > 0 ||
-            this.argument.hasEffectsOnInteractionAtPath(EMPTY_PATH, interaction, context));
-    }
-    markDeclarationReached() {
-        this.argument.markDeclarationReached();
-    }
-    applyDeoptimizations() {
-        this.deoptimized = true;
-        if (this.declarationInit !== null) {
-            this.declarationInit.deoptimizePath([UnknownKey, UnknownKey]);
-            this.context.requestTreeshakingPass();
-        }
-    }
-}
-
-class FunctionBase extends NodeBase {
+class ArrowFunctionExpression extends NodeBase {
     constructor() {
         super(...arguments);
-        this.objectEntity = null;
         this.deoptimizedReturn = false;
     }
+    createScope(parentScope) {
+        this.scope = new ReturnValueScope(parentScope, this.context);
+    }
     deoptimizePath(path) {
-        this.getObjectEntity().deoptimizePath(path);
+        // A reassignment of UNKNOWN_PATH is considered equivalent to having lost track
+        // which means the return expression needs to be reassigned
         if (path.length === 1 && path[0] === UnknownKey) {
-            // A reassignment of UNKNOWN_PATH is considered equivalent to having lost track
-            // which means the return expression needs to be reassigned
             this.scope.getReturnExpression().deoptimizePath(UNKNOWN_PATH);
         }
     }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        if (path.length > 0) {
-            this.getObjectEntity().deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
-        }
-    }
-    getLiteralValueAtPath(path, recursionTracker, origin) {
-        return this.getObjectEntity().getLiteralValueAtPath(path, recursionTracker, origin);
-    }
-    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
-        if (path.length > 0) {
-            return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
+    // Arrow functions do not mutate their context
+    deoptimizeThisOnEventAtPath() { }
+    getReturnExpressionWhenCalledAtPath(path) {
+        if (path.length !== 0) {
+            return UNKNOWN_EXPRESSION;
         }
         if (this.async) {
             if (!this.deoptimizedReturn) {
@@ -8406,45 +8240,67 @@
                 this.scope.getReturnExpression().deoptimizePath(UNKNOWN_PATH);
                 this.context.requestTreeshakingPass();
             }
-            return UNKNOWN_RETURN_EXPRESSION;
+            return UNKNOWN_EXPRESSION;
         }
-        return [this.scope.getReturnExpression(), false];
+        return this.scope.getReturnExpression();
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        if (path.length > 0 || interaction.type !== INTERACTION_CALLED) {
-            return this.getObjectEntity().hasEffectsOnInteractionAtPath(path, interaction, context);
-        }
+    hasEffects() {
+        return false;
+    }
+    hasEffectsWhenAccessedAtPath(path) {
+        return path.length > 1;
+    }
+    hasEffectsWhenAssignedAtPath(path) {
+        return path.length > 1;
+    }
+    hasEffectsWhenCalledAtPath(path, _callOptions, context) {
+        if (path.length > 0)
+            return true;
         if (this.async) {
             const { propertyReadSideEffects } = this.context.options
                 .treeshake;
             const returnExpression = this.scope.getReturnExpression();
-            if (returnExpression.hasEffectsOnInteractionAtPath(['then'], NODE_INTERACTION_UNKNOWN_CALL, context) ||
+            if (returnExpression.hasEffectsWhenCalledAtPath(['then'], { args: NO_ARGS, thisParam: null, withNew: false }, context) ||
                 (propertyReadSideEffects &&
                     (propertyReadSideEffects === 'always' ||
-                        returnExpression.hasEffectsOnInteractionAtPath(['then'], NODE_INTERACTION_UNKNOWN_ACCESS, context)))) {
+                        returnExpression.hasEffectsWhenAccessedAtPath(['then'], context)))) {
                 return true;
             }
         }
-        for (const parameter of this.params) {
-            if (parameter.hasEffects(context))
+        for (const param of this.params) {
+            if (param.hasEffects(context))
                 return true;
         }
+        const { ignore, brokenFlow } = context;
+        context.ignore = {
+            breaks: false,
+            continues: false,
+            labels: new Set(),
+            returnYield: true
+        };
+        if (this.body.hasEffects(context))
+            return true;
+        context.ignore = ignore;
+        context.brokenFlow = brokenFlow;
         return false;
     }
     include(context, includeChildrenRecursively) {
-        if (!this.deoptimized)
-            this.applyDeoptimizations();
         this.included = true;
+        for (const param of this.params) {
+            if (!(param instanceof Identifier)) {
+                param.include(context, includeChildrenRecursively);
+            }
+        }
         const { brokenFlow } = context;
         context.brokenFlow = BROKEN_FLOW_NONE;
         this.body.include(context, includeChildrenRecursively);
         context.brokenFlow = brokenFlow;
     }
-    includeCallArguments(context, parameters) {
-        this.scope.includeCallArguments(context, parameters);
+    includeCallArguments(context, args) {
+        this.scope.includeCallArguments(context, args);
     }
     initialise() {
-        this.scope.addParameterVariables(this.params.map(parameter => parameter.declare('parameter', UNKNOWN_EXPRESSION)), this.params[this.params.length - 1] instanceof RestElement);
+        this.scope.addParameterVariables(this.params.map(param => param.declare('parameter', UNKNOWN_EXPRESSION)), this.params[this.params.length - 1] instanceof RestElement);
         if (this.body instanceof BlockStatement) {
             this.body.addImplicitReturnExpressionToScope();
         }
@@ -8454,102 +8310,12 @@
     }
     parseNode(esTreeNode) {
         if (esTreeNode.body.type === BlockStatement$1) {
-            this.body = new BlockStatement(esTreeNode.body, this, this.scope.hoistedBodyVarScope);
+            this.body = new this.context.nodeConstructors.BlockStatement(esTreeNode.body, this, this.scope.hoistedBodyVarScope);
         }
         super.parseNode(esTreeNode);
     }
-    applyDeoptimizations() { }
-}
-FunctionBase.prototype.preventChildBlockScope = true;
-
-class ArrowFunctionExpression extends FunctionBase {
-    constructor() {
-        super(...arguments);
-        this.objectEntity = null;
-    }
-    createScope(parentScope) {
-        this.scope = new ReturnValueScope(parentScope, this.context);
-    }
-    hasEffects() {
-        if (!this.deoptimized)
-            this.applyDeoptimizations();
-        return false;
-    }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        if (super.hasEffectsOnInteractionAtPath(path, interaction, context))
-            return true;
-        if (interaction.type === INTERACTION_CALLED) {
-            const { ignore, brokenFlow } = context;
-            context.ignore = {
-                breaks: false,
-                continues: false,
-                labels: new Set(),
-                returnYield: true
-            };
-            if (this.body.hasEffects(context))
-                return true;
-            context.ignore = ignore;
-            context.brokenFlow = brokenFlow;
-        }
-        return false;
-    }
-    include(context, includeChildrenRecursively) {
-        super.include(context, includeChildrenRecursively);
-        for (const parameter of this.params) {
-            if (!(parameter instanceof Identifier)) {
-                parameter.include(context, includeChildrenRecursively);
-            }
-        }
-    }
-    getObjectEntity() {
-        if (this.objectEntity !== null) {
-            return this.objectEntity;
-        }
-        return (this.objectEntity = new ObjectEntity([], OBJECT_PROTOTYPE));
-    }
-}
-
-function getSystemExportStatement(exportedVariables, { exportNamesByVariable, snippets: { _, getObject, getPropertyAccess } }, modifier = '') {
-    if (exportedVariables.length === 1 &&
-        exportNamesByVariable.get(exportedVariables[0]).length === 1) {
-        const variable = exportedVariables[0];
-        return `exports('${exportNamesByVariable.get(variable)}',${_}${variable.getName(getPropertyAccess)}${modifier})`;
-    }
-    else {
-        const fields = [];
-        for (const variable of exportedVariables) {
-            for (const exportName of exportNamesByVariable.get(variable)) {
-                fields.push([exportName, variable.getName(getPropertyAccess) + modifier]);
-            }
-        }
-        return `exports(${getObject(fields, { lineBreakIndent: null })})`;
-    }
-}
-function renderSystemExportExpression(exportedVariable, expressionStart, expressionEnd, code, { exportNamesByVariable, snippets: { _ } }) {
-    code.prependRight(expressionStart, `exports('${exportNamesByVariable.get(exportedVariable)}',${_}`);
-    code.appendLeft(expressionEnd, ')');
-}
-function renderSystemExportFunction(exportedVariables, expressionStart, expressionEnd, needsParens, code, options) {
-    const { _, getDirectReturnIifeLeft } = options.snippets;
-    code.prependRight(expressionStart, getDirectReturnIifeLeft(['v'], `${getSystemExportStatement(exportedVariables, options)},${_}v`, { needsArrowReturnParens: true, needsWrappedFunction: needsParens }));
-    code.appendLeft(expressionEnd, ')');
-}
-function renderSystemExportSequenceAfterExpression(exportedVariable, expressionStart, expressionEnd, needsParens, code, options) {
-    const { _, getPropertyAccess } = options.snippets;
-    code.appendLeft(expressionEnd, `,${_}${getSystemExportStatement([exportedVariable], options)},${_}${exportedVariable.getName(getPropertyAccess)}`);
-    if (needsParens) {
-        code.prependRight(expressionStart, '(');
-        code.appendLeft(expressionEnd, ')');
-    }
-}
-function renderSystemExportSequenceBeforeExpression(exportedVariable, expressionStart, expressionEnd, needsParens, code, options, modifier) {
-    const { _ } = options.snippets;
-    code.prependRight(expressionStart, `${getSystemExportStatement([exportedVariable], options, modifier)},${_}`);
-    if (needsParens) {
-        code.prependRight(expressionStart, '(');
-        code.appendLeft(expressionEnd, ')');
-    }
 }
+ArrowFunctionExpression.prototype.preventChildBlockScope = true;
 
 class ObjectPattern extends NodeBase {
     addExportedVariables(variables, exportNamesByVariable) {
@@ -8576,12 +8342,11 @@
             }
         }
     }
-    hasEffectsOnInteractionAtPath(
-    // At the moment, this is only triggered for assignment left-hand sides,
-    // where the path is empty
-    _path, interaction, context) {
+    hasEffectsWhenAssignedAtPath(path, context) {
+        if (path.length > 0)
+            return true;
         for (const property of this.properties) {
-            if (property.hasEffectsOnInteractionAtPath(EMPTY_PATH, interaction, context))
+            if (property.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context))
                 return true;
         }
         return false;
@@ -8594,79 +8359,80 @@
 }
 
 class AssignmentExpression extends NodeBase {
+    constructor() {
+        super(...arguments);
+        this.deoptimized = false;
+    }
     hasEffects(context) {
-        const { deoptimized, left, operator, right } = this;
-        if (!deoptimized)
+        if (!this.deoptimized)
             this.applyDeoptimizations();
-        // MemberExpressions do not access the property before assignments if the
-        // operator is '='.
-        return (right.hasEffects(context) || left.hasEffectsAsAssignmentTarget(context, operator !== '='));
+        return (this.right.hasEffects(context) ||
+            this.left.hasEffects(context) ||
+            this.left.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context));
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        return this.right.hasEffectsOnInteractionAtPath(path, interaction, context);
+    hasEffectsWhenAccessedAtPath(path, context) {
+        return path.length > 0 && this.right.hasEffectsWhenAccessedAtPath(path, context);
     }
     include(context, includeChildrenRecursively) {
-        const { deoptimized, left, right, operator } = this;
-        if (!deoptimized)
+        if (!this.deoptimized)
             this.applyDeoptimizations();
         this.included = true;
+        let hasEffectsContext;
         if (includeChildrenRecursively ||
-            operator !== '=' ||
-            left.included ||
-            left.hasEffectsAsAssignmentTarget(createHasEffectsContext(), false)) {
-            left.includeAsAssignmentTarget(context, includeChildrenRecursively, operator !== '=');
+            this.operator !== '=' ||
+            this.left.included ||
+            ((hasEffectsContext = createHasEffectsContext()),
+                this.left.hasEffects(hasEffectsContext) ||
+                    this.left.hasEffectsWhenAssignedAtPath(EMPTY_PATH, hasEffectsContext))) {
+            this.left.include(context, includeChildrenRecursively);
         }
-        right.include(context, includeChildrenRecursively);
-    }
-    initialise() {
-        this.left.setAssignedValue(this.right);
+        this.right.include(context, includeChildrenRecursively);
     }
     render(code, options, { preventASI, renderedParentType, renderedSurroundingElement } = BLANK) {
-        const { left, right, start, end, parent } = this;
-        if (left.included) {
-            left.render(code, options);
-            right.render(code, options);
+        if (this.left.included) {
+            this.left.render(code, options);
+            this.right.render(code, options);
         }
         else {
-            const inclusionStart = findNonWhiteSpace(code.original, findFirstOccurrenceOutsideComment(code.original, '=', left.end) + 1);
-            code.remove(start, inclusionStart);
+            const inclusionStart = findNonWhiteSpace(code.original, findFirstOccurrenceOutsideComment(code.original, '=', this.left.end) + 1);
+            code.remove(this.start, inclusionStart);
             if (preventASI) {
-                removeLineBreaks(code, inclusionStart, right.start);
+                removeLineBreaks(code, inclusionStart, this.right.start);
             }
-            right.render(code, options, {
-                renderedParentType: renderedParentType || parent.type,
-                renderedSurroundingElement: renderedSurroundingElement || parent.type
+            this.right.render(code, options, {
+                renderedParentType: renderedParentType || this.parent.type,
+                renderedSurroundingElement: renderedSurroundingElement || this.parent.type
             });
         }
         if (options.format === 'system') {
-            if (left instanceof Identifier) {
-                const variable = left.variable;
+            if (this.left instanceof Identifier) {
+                const variable = this.left.variable;
                 const exportNames = options.exportNamesByVariable.get(variable);
                 if (exportNames) {
                     if (exportNames.length === 1) {
-                        renderSystemExportExpression(variable, start, end, code, options);
+                        renderSystemExportExpression(variable, this.start, this.end, code, options);
                     }
                     else {
-                        renderSystemExportSequenceAfterExpression(variable, start, end, parent.type !== ExpressionStatement$1, code, options);
+                        renderSystemExportSequenceAfterExpression(variable, this.start, this.end, this.parent.type !== ExpressionStatement$1, code, options);
                     }
                     return;
                 }
             }
             else {
                 const systemPatternExports = [];
-                left.addExportedVariables(systemPatternExports, options.exportNamesByVariable);
+                this.left.addExportedVariables(systemPatternExports, options.exportNamesByVariable);
                 if (systemPatternExports.length > 0) {
-                    renderSystemExportFunction(systemPatternExports, start, end, renderedSurroundingElement === ExpressionStatement$1, code, options);
+                    renderSystemExportFunction(systemPatternExports, this.start, this.end, renderedSurroundingElement === ExpressionStatement$1, code, options);
                     return;
                 }
             }
         }
-        if (left.included &&
-            left instanceof ObjectPattern &&
+        if (this.left.included &&
+            this.left instanceof ObjectPattern &&
             (renderedSurroundingElement === ExpressionStatement$1 ||
                 renderedSurroundingElement === ArrowFunctionExpression$1)) {
-            code.appendRight(start, '(');
-            code.prependLeft(end, ')');
+            code.appendRight(this.start, '(');
+            code.prependLeft(this.end, ')');
         }
     }
     applyDeoptimizations() {
@@ -8678,6 +8444,10 @@
 }
 
 class AssignmentPattern extends NodeBase {
+    constructor() {
+        super(...arguments);
+        this.deoptimized = false;
+    }
     addExportedVariables(variables, exportNamesByVariable) {
         this.left.addExportedVariables(variables, exportNamesByVariable);
     }
@@ -8687,8 +8457,8 @@
     deoptimizePath(path) {
         path.length === 0 && this.left.deoptimizePath(path);
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        return (path.length > 0 || this.left.hasEffectsOnInteractionAtPath(EMPTY_PATH, interaction, context));
+    hasEffectsWhenAssignedAtPath(path, context) {
+        return path.length > 0 || this.left.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context);
     }
     markDeclarationReached() {
         this.left.markDeclarationReached();
@@ -8705,160 +8475,11 @@
     }
 }
 
-class ArgumentsVariable extends LocalVariable {
-    constructor(context) {
-        super('arguments', null, UNKNOWN_EXPRESSION, context);
-    }
-    hasEffectsOnInteractionAtPath(path, { type }) {
-        return type !== INTERACTION_ACCESSED || path.length > 1;
-    }
-}
-
-class ThisVariable extends LocalVariable {
-    constructor(context) {
-        super('this', null, null, context);
-        this.deoptimizedPaths = [];
-        this.entitiesToBeDeoptimized = new Set();
-        this.thisDeoptimizationList = [];
-        this.thisDeoptimizations = new DiscriminatedPathTracker();
-    }
-    addEntityToBeDeoptimized(entity) {
-        for (const path of this.deoptimizedPaths) {
-            entity.deoptimizePath(path);
-        }
-        for (const { interaction, path } of this.thisDeoptimizationList) {
-            entity.deoptimizeThisOnInteractionAtPath(interaction, path, SHARED_RECURSION_TRACKER);
-        }
-        this.entitiesToBeDeoptimized.add(entity);
-    }
-    deoptimizePath(path) {
-        if (path.length === 0 ||
-            this.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(path, this)) {
-            return;
-        }
-        this.deoptimizedPaths.push(path);
-        for (const entity of this.entitiesToBeDeoptimized) {
-            entity.deoptimizePath(path);
-        }
-    }
-    deoptimizeThisOnInteractionAtPath(interaction, path) {
-        const thisDeoptimization = {
-            interaction,
-            path
-        };
-        if (!this.thisDeoptimizations.trackEntityAtPathAndGetIfTracked(path, interaction.type, interaction.thisArg)) {
-            for (const entity of this.entitiesToBeDeoptimized) {
-                entity.deoptimizeThisOnInteractionAtPath(interaction, path, SHARED_RECURSION_TRACKER);
-            }
-            this.thisDeoptimizationList.push(thisDeoptimization);
-        }
-    }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        return (this.getInit(context).hasEffectsOnInteractionAtPath(path, interaction, context) ||
-            super.hasEffectsOnInteractionAtPath(path, interaction, context));
-    }
-    getInit(context) {
-        return context.replacedVariableInits.get(this) || UNKNOWN_EXPRESSION;
-    }
-}
-
-class FunctionScope extends ReturnValueScope {
-    constructor(parent, context) {
-        super(parent, context);
-        this.variables.set('arguments', (this.argumentsVariable = new ArgumentsVariable(context)));
-        this.variables.set('this', (this.thisVariable = new ThisVariable(context)));
-    }
-    findLexicalBoundary() {
-        return this;
-    }
-    includeCallArguments(context, parameters) {
-        super.includeCallArguments(context, parameters);
-        if (this.argumentsVariable.included) {
-            for (const argument of parameters) {
-                if (!argument.included) {
-                    argument.include(context, false);
-                }
-            }
-        }
-    }
-}
-
-class FunctionNode extends FunctionBase {
+class AwaitExpression extends NodeBase {
     constructor() {
         super(...arguments);
-        this.objectEntity = null;
-    }
-    createScope(parentScope) {
-        this.scope = new FunctionScope(parentScope, this.context);
-    }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        super.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
-        if (interaction.type === INTERACTION_CALLED && path.length === 0) {
-            this.scope.thisVariable.addEntityToBeDeoptimized(interaction.thisArg);
-        }
-    }
-    hasEffects(context) {
-        if (!this.deoptimized)
-            this.applyDeoptimizations();
-        return !!this.id?.hasEffects(context);
-    }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        if (super.hasEffectsOnInteractionAtPath(path, interaction, context))
-            return true;
-        if (interaction.type === INTERACTION_CALLED) {
-            const thisInit = context.replacedVariableInits.get(this.scope.thisVariable);
-            context.replacedVariableInits.set(this.scope.thisVariable, interaction.withNew
-                ? new ObjectEntity(Object.create(null), OBJECT_PROTOTYPE)
-                : UNKNOWN_EXPRESSION);
-            const { brokenFlow, ignore, replacedVariableInits } = context;
-            context.ignore = {
-                breaks: false,
-                continues: false,
-                labels: new Set(),
-                returnYield: true
-            };
-            if (this.body.hasEffects(context))
-                return true;
-            context.brokenFlow = brokenFlow;
-            if (thisInit) {
-                replacedVariableInits.set(this.scope.thisVariable, thisInit);
-            }
-            else {
-                replacedVariableInits.delete(this.scope.thisVariable);
-            }
-            context.ignore = ignore;
-        }
-        return false;
-    }
-    include(context, includeChildrenRecursively) {
-        super.include(context, includeChildrenRecursively);
-        this.id?.include();
-        const hasArguments = this.scope.argumentsVariable.included;
-        for (const parameter of this.params) {
-            if (!(parameter instanceof Identifier) || hasArguments) {
-                parameter.include(context, includeChildrenRecursively);
-            }
-        }
-    }
-    initialise() {
-        super.initialise();
-        this.id?.declare('function', this);
-    }
-    getObjectEntity() {
-        if (this.objectEntity !== null) {
-            return this.objectEntity;
-        }
-        return (this.objectEntity = new ObjectEntity([
-            {
-                key: 'prototype',
-                kind: 'init',
-                property: new ObjectEntity([], OBJECT_PROTOTYPE)
-            }
-        ], OBJECT_PROTOTYPE));
+        this.deoptimized = false;
     }
-}
-
-class AwaitExpression extends NodeBase {
     hasEffects() {
         if (!this.deoptimized)
             this.applyDeoptimizations();
@@ -8880,6 +8501,11 @@
         }
         this.argument.include(context, includeChildrenRecursively);
     }
+    applyDeoptimizations() {
+        this.deoptimized = true;
+        this.argument.deoptimizePath(UNKNOWN_PATH);
+        this.context.requestTreeshakingPass();
+    }
 }
 
 const binaryOperators = {
@@ -8903,10 +8529,9 @@
     '>>': (left, right) => left >> right,
     '>>>': (left, right) => left >>> right,
     '^': (left, right) => left ^ right,
+    in: () => UnknownValue,
+    instanceof: () => UnknownValue,
     '|': (left, right) => left | right
-    // We use the fallback for cases where we return something unknown
-    // in: () => UnknownValue,
-    // instanceof: () => UnknownValue,
 };
 class BinaryExpression extends NodeBase {
     deoptimizeCache() { }
@@ -8914,27 +8539,26 @@
         if (path.length > 0)
             return UnknownValue;
         const leftValue = this.left.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);
-        if (typeof leftValue === 'symbol')
+        if (leftValue === UnknownValue)
             return UnknownValue;
         const rightValue = this.right.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);
-        if (typeof rightValue === 'symbol')
+        if (rightValue === UnknownValue)
             return UnknownValue;
-        const operatorFunction = binaryOperators[this.operator];
-        if (!operatorFunction)
+        const operatorFn = binaryOperators[this.operator];
+        if (!operatorFn)
             return UnknownValue;
-        return operatorFunction(leftValue, rightValue);
+        return operatorFn(leftValue, rightValue);
     }
     hasEffects(context) {
         // support some implicit type coercion runtime errors
         if (this.operator === '+' &&
             this.parent instanceof ExpressionStatement &&
-            this.left.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this) === '') {
+            this.left.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this) === '')
             return true;
-        }
         return super.hasEffects(context);
     }
-    hasEffectsOnInteractionAtPath(path, { type }) {
-        return type !== INTERACTION_ACCESSED || path.length > 1;
+    hasEffectsWhenAccessedAtPath(path) {
+        return path.length > 1;
     }
     render(code, options, { renderedSurroundingElement } = BLANK) {
         this.left.render(code, options, { renderedSurroundingElement });
@@ -8967,83 +8591,6 @@
     }
 }
 
-function renderCallArguments(code, options, node) {
-    if (node.arguments.length > 0) {
-        if (node.arguments[node.arguments.length - 1].included) {
-            for (const argument of node.arguments) {
-                argument.render(code, options);
-            }
-        }
-        else {
-            let lastIncludedIndex = node.arguments.length - 2;
-            while (lastIncludedIndex >= 0 && !node.arguments[lastIncludedIndex].included) {
-                lastIncludedIndex--;
-            }
-            if (lastIncludedIndex >= 0) {
-                for (let index = 0; index <= lastIncludedIndex; index++) {
-                    node.arguments[index].render(code, options);
-                }
-                code.remove(findFirstOccurrenceOutsideComment(code.original, ',', node.arguments[lastIncludedIndex].end), node.end - 1);
-            }
-            else {
-                code.remove(findFirstOccurrenceOutsideComment(code.original, '(', node.callee.end) + 1, node.end - 1);
-            }
-        }
-    }
-}
-
-class Literal extends NodeBase {
-    deoptimizeThisOnInteractionAtPath() { }
-    getLiteralValueAtPath(path) {
-        if (path.length > 0 ||
-            // unknown literals can also be null but do not start with an "n"
-            (this.value === null && this.context.code.charCodeAt(this.start) !== 110) ||
-            typeof this.value === 'bigint' ||
-            // to support shims for regular expressions
-            this.context.code.charCodeAt(this.start) === 47) {
-            return UnknownValue;
-        }
-        return this.value;
-    }
-    getReturnExpressionWhenCalledAtPath(path) {
-        if (path.length !== 1)
-            return UNKNOWN_RETURN_EXPRESSION;
-        return getMemberReturnExpressionWhenCalled(this.members, path[0]);
-    }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        switch (interaction.type) {
-            case INTERACTION_ACCESSED: {
-                return path.length > (this.value === null ? 0 : 1);
-            }
-            case INTERACTION_ASSIGNED: {
-                return true;
-            }
-            case INTERACTION_CALLED: {
-                if (this.included &&
-                    this.value instanceof RegExp &&
-                    (this.value.global || this.value.sticky)) {
-                    return true;
-                }
-                return (path.length !== 1 ||
-                    hasMemberEffectWhenCalled(this.members, path[0], interaction, context));
-            }
-        }
-    }
-    initialise() {
-        this.members = getLiteralMembersForValue(this.value);
-    }
-    parseNode(esTreeNode) {
-        this.value = esTreeNode.value;
-        this.regex = esTreeNode.regex;
-        super.parseNode(esTreeNode);
-    }
-    render(code) {
-        if (typeof this.value === 'string') {
-            code.indentExclusionRanges.push([this.start + 1, this.end - 1]);
-        }
-    }
-}
-
 // To avoid infinite recursions
 const MAX_PATH_DEPTH = 7;
 function getResolvablePropertyKey(memberExpression) {
@@ -9085,22 +8632,22 @@
     constructor() {
         super(...arguments);
         this.variable = null;
-        this.assignmentDeoptimized = false;
+        this.deoptimized = false;
         this.bound = false;
         this.expressionsToBeDeoptimized = [];
-        this.isUndefined = false;
+        this.replacement = null;
     }
     bind() {
         this.bound = true;
         const path = getPathIfNotComputed(this);
         const baseVariable = path && this.scope.findVariable(path[0].key);
-        if (baseVariable?.isNamespace) {
-            const resolvedVariable = resolveNamespaceVariables(baseVariable, path.slice(1), this.context);
+        if (baseVariable && baseVariable.isNamespace) {
+            const resolvedVariable = this.resolveNamespaceVariables(baseVariable, path.slice(1));
             if (!resolvedVariable) {
                 super.bind();
             }
-            else if (resolvedVariable === 'undefined') {
-                this.isUndefined = true;
+            else if (typeof resolvedVariable === 'string') {
+                this.replacement = resolvedVariable;
             }
             else {
                 this.variable = resolvedVariable;
@@ -9126,33 +8673,31 @@
         if (this.variable) {
             this.variable.deoptimizePath(path);
         }
-        else if (!this.isUndefined && path.length < MAX_PATH_DEPTH) {
-            const propertyKey = this.getPropertyKey();
-            this.object.deoptimizePath([
-                propertyKey === UnknownKey ? UnknownNonAccessorKey : propertyKey,
-                ...path
-            ]);
+        else if (!this.replacement) {
+            if (path.length < MAX_PATH_DEPTH) {
+                this.object.deoptimizePath([this.getPropertyKey(), ...path]);
+            }
         }
     }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
         if (this.variable) {
-            this.variable.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
+            this.variable.deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker);
         }
-        else if (!this.isUndefined) {
+        else if (!this.replacement) {
             if (path.length < MAX_PATH_DEPTH) {
-                this.object.deoptimizeThisOnInteractionAtPath(interaction, [this.getPropertyKey(), ...path], recursionTracker);
+                this.object.deoptimizeThisOnEventAtPath(event, [this.getPropertyKey(), ...path], thisParameter, recursionTracker);
             }
             else {
-                interaction.thisArg.deoptimizePath(UNKNOWN_PATH);
+                thisParameter.deoptimizePath(UNKNOWN_PATH);
             }
         }
     }
     getLiteralValueAtPath(path, recursionTracker, origin) {
-        if (this.variable) {
+        if (this.variable !== null) {
             return this.variable.getLiteralValueAtPath(path, recursionTracker, origin);
         }
-        if (this.isUndefined) {
-            return undefined;
+        if (this.replacement) {
+            return UnknownValue;
         }
         this.expressionsToBeDeoptimized.push(origin);
         if (path.length < MAX_PATH_DEPTH) {
@@ -9160,86 +8705,97 @@
         }
         return UnknownValue;
     }
-    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
-        if (this.variable) {
-            return this.variable.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
+    getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin) {
+        if (this.variable !== null) {
+            return this.variable.getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin);
         }
-        if (this.isUndefined) {
-            return [UNDEFINED_EXPRESSION, false];
+        if (this.replacement) {
+            return UNKNOWN_EXPRESSION;
         }
         this.expressionsToBeDeoptimized.push(origin);
         if (path.length < MAX_PATH_DEPTH) {
-            return this.object.getReturnExpressionWhenCalledAtPath([this.getPropertyKey(), ...path], interaction, recursionTracker, origin);
+            return this.object.getReturnExpressionWhenCalledAtPath([this.getPropertyKey(), ...path], callOptions, recursionTracker, origin);
         }
-        return UNKNOWN_RETURN_EXPRESSION;
+        return UNKNOWN_EXPRESSION;
     }
     hasEffects(context) {
         if (!this.deoptimized)
             this.applyDeoptimizations();
+        const { propertyReadSideEffects } = this.context.options
+            .treeshake;
         return (this.property.hasEffects(context) ||
             this.object.hasEffects(context) ||
-            this.hasAccessEffect(context));
+            // Assignments do not access the property before assigning
+            (!(this.variable ||
+                this.replacement ||
+                (this.parent instanceof AssignmentExpression && this.parent.operator === '=')) &&
+                propertyReadSideEffects &&
+                (propertyReadSideEffects === 'always' ||
+                    this.object.hasEffectsWhenAccessedAtPath([this.getPropertyKey()], context))));
     }
-    hasEffectsAsAssignmentTarget(context, checkAccess) {
-        if (checkAccess && !this.deoptimized)
-            this.applyDeoptimizations();
-        if (!this.assignmentDeoptimized)
-            this.applyAssignmentDeoptimization();
-        return (this.property.hasEffects(context) ||
-            this.object.hasEffects(context) ||
-            (checkAccess && this.hasAccessEffect(context)) ||
-            this.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.assignmentInteraction, context));
+    hasEffectsWhenAccessedAtPath(path, context) {
+        if (this.variable !== null) {
+            return this.variable.hasEffectsWhenAccessedAtPath(path, context);
+        }
+        if (this.replacement) {
+            return true;
+        }
+        if (path.length < MAX_PATH_DEPTH) {
+            return this.object.hasEffectsWhenAccessedAtPath([this.getPropertyKey(), ...path], context);
+        }
+        return true;
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        if (this.variable) {
-            return this.variable.hasEffectsOnInteractionAtPath(path, interaction, context);
+    hasEffectsWhenAssignedAtPath(path, context) {
+        if (this.variable !== null) {
+            return this.variable.hasEffectsWhenAssignedAtPath(path, context);
         }
-        if (this.isUndefined) {
+        if (this.replacement) {
             return true;
         }
         if (path.length < MAX_PATH_DEPTH) {
-            return this.object.hasEffectsOnInteractionAtPath([this.getPropertyKey(), ...path], interaction, context);
+            return this.object.hasEffectsWhenAssignedAtPath([this.getPropertyKey(), ...path], context);
+        }
+        return true;
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        if (this.variable !== null) {
+            return this.variable.hasEffectsWhenCalledAtPath(path, callOptions, context);
+        }
+        if (this.replacement) {
+            return true;
+        }
+        if (path.length < MAX_PATH_DEPTH) {
+            return this.object.hasEffectsWhenCalledAtPath([this.getPropertyKey(), ...path], callOptions, context);
         }
         return true;
     }
     include(context, includeChildrenRecursively) {
         if (!this.deoptimized)
             this.applyDeoptimizations();
-        this.includeProperties(context, includeChildrenRecursively);
-    }
-    includeAsAssignmentTarget(context, includeChildrenRecursively, deoptimizeAccess) {
-        if (!this.assignmentDeoptimized)
-            this.applyAssignmentDeoptimization();
-        if (deoptimizeAccess) {
-            this.include(context, includeChildrenRecursively);
-        }
-        else {
-            this.includeProperties(context, includeChildrenRecursively);
+        if (!this.included) {
+            this.included = true;
+            if (this.variable !== null) {
+                this.context.includeVariableInModule(this.variable);
+            }
         }
+        this.object.include(context, includeChildrenRecursively);
+        this.property.include(context, includeChildrenRecursively);
     }
-    includeCallArguments(context, parameters) {
+    includeCallArguments(context, args) {
         if (this.variable) {
-            this.variable.includeCallArguments(context, parameters);
+            this.variable.includeCallArguments(context, args);
         }
         else {
-            super.includeCallArguments(context, parameters);
+            super.includeCallArguments(context, args);
         }
     }
     initialise() {
         this.propertyKey = getResolvablePropertyKey(this);
-        this.accessInteraction = { thisArg: this.object, type: INTERACTION_ACCESSED };
-    }
-    isSkippedAsOptional(origin) {
-        return (!this.variable &&
-            !this.isUndefined &&
-            (this.object.isSkippedAsOptional?.(origin) ||
-                (this.optional &&
-                    this.object.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, origin) == null)));
     }
     render(code, options, { renderedParentType, isCalleeOfRenderedParent, renderedSurroundingElement } = BLANK) {
-        if (this.variable || this.isUndefined) {
+        if (this.variable || this.replacement) {
             const { snippets: { getPropertyAccess } } = options;
-            let replacement = this.variable ? this.variable.getName(getPropertyAccess) : 'undefined';
+            let replacement = this.variable ? this.variable.getName(getPropertyAccess) : this.replacement;
             if (renderedParentType && isCalleeOfRenderedParent)
                 replacement = '0, ' + replacement;
             code.overwrite(this.start, this.end, replacement, {
@@ -9255,13 +8811,6 @@
             this.property.render(code, options);
         }
     }
-    setAssignedValue(value) {
-        this.assignmentInteraction = {
-            args: [value],
-            thisArg: this.object,
-            type: INTERACTION_ASSIGNED
-        };
-    }
     applyDeoptimizations() {
         this.deoptimized = true;
         const { propertyReadSideEffects } = this.context.options
@@ -9270,22 +8819,14 @@
         // Namespaces are not bound and should not be deoptimized
         this.bound &&
             propertyReadSideEffects &&
-            !(this.variable || this.isUndefined)) {
-            const propertyKey = this.getPropertyKey();
-            this.object.deoptimizeThisOnInteractionAtPath(this.accessInteraction, [propertyKey], SHARED_RECURSION_TRACKER);
-            this.context.requestTreeshakingPass();
-        }
-    }
-    applyAssignmentDeoptimization() {
-        this.assignmentDeoptimized = true;
-        const { propertyReadSideEffects } = this.context.options
-            .treeshake;
-        if (
-        // Namespaces are not bound and should not be deoptimized
-        this.bound &&
-            propertyReadSideEffects &&
-            !(this.variable || this.isUndefined)) {
-            this.object.deoptimizeThisOnInteractionAtPath(this.assignmentInteraction, [this.getPropertyKey()], SHARED_RECURSION_TRACKER);
+            !(this.variable || this.replacement)) {
+            // Regular Assignments do not access the property before assigning
+            if (!(this.parent instanceof AssignmentExpression && this.parent.operator === '=')) {
+                this.object.deoptimizeThisOnEventAtPath(EVENT_ACCESSED, [this.propertyKey], this.object, SHARED_RECURSION_TRACKER);
+            }
+            if (this.parent instanceof AssignmentExpression) {
+                this.object.deoptimizeThisOnEventAtPath(EVENT_ASSIGNED, [this.propertyKey], this.object, SHARED_RECURSION_TRACKER);
+            }
             this.context.requestTreeshakingPass();
         }
     }
@@ -9296,7 +8837,10 @@
                 if (this.variable) {
                     this.context.includeVariableInModule(this.variable);
                 }
-                this.context.warn(errorIllegalImportReassignment(this.object.name, this.context.module.id), this.start);
+                this.context.warn({
+                    code: 'ILLEGAL_NAMESPACE_REASSIGNMENT',
+                    message: `Illegal reassignment to import '${this.object.name}'`
+                }, this.start);
             }
         }
     }
@@ -9304,62 +8848,70 @@
         if (this.propertyKey === null) {
             this.propertyKey = UnknownKey;
             const value = this.property.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
-            return (this.propertyKey =
-                value === SymbolToStringTag
-                    ? value
-                    : typeof value === 'symbol'
-                        ? UnknownKey
-                        : String(value));
+            return (this.propertyKey = value === UnknownValue ? UnknownKey : String(value));
         }
         return this.propertyKey;
     }
-    hasAccessEffect(context) {
-        const { propertyReadSideEffects } = this.context.options
-            .treeshake;
-        return (!(this.variable || this.isUndefined) &&
-            propertyReadSideEffects &&
-            (propertyReadSideEffects === 'always' ||
-                this.object.hasEffectsOnInteractionAtPath([this.getPropertyKey()], this.accessInteraction, context)));
-    }
-    includeProperties(context, includeChildrenRecursively) {
-        if (!this.included) {
-            this.included = true;
-            if (this.variable) {
-                this.context.includeVariableInModule(this.variable);
-            }
-        }
-        this.object.include(context, includeChildrenRecursively);
-        this.property.include(context, includeChildrenRecursively);
-    }
-}
-function resolveNamespaceVariables(baseVariable, path, astContext) {
-    if (path.length === 0)
-        return baseVariable;
-    if (!baseVariable.isNamespace || baseVariable instanceof ExternalVariable)
-        return null;
-    const exportName = path[0].key;
-    const variable = baseVariable.context.traceExport(exportName);
-    if (!variable) {
-        if (path.length === 1) {
+    resolveNamespaceVariables(baseVariable, path) {
+        if (path.length === 0)
+            return baseVariable;
+        if (!baseVariable.isNamespace || baseVariable instanceof ExternalVariable)
+            return null;
+        const exportName = path[0].key;
+        const variable = baseVariable.context.traceExport(exportName);
+        if (!variable) {
             const fileName = baseVariable.context.fileName;
-            astContext.warn(errorMissingExport(exportName, astContext.module.id, fileName), path[0].pos);
+            this.context.warn({
+                code: 'MISSING_EXPORT',
+                exporter: relativeId(fileName),
+                importer: relativeId(this.context.fileName),
+                message: `'${exportName}' is not exported by '${relativeId(fileName)}'`,
+                missing: exportName,
+                url: `https://rollupjs.org/guide/en/#error-name-is-not-exported-by-module`
+            }, path[0].pos);
             return 'undefined';
         }
-        return null;
+        return this.resolveNamespaceVariables(variable, path.slice(1));
     }
-    return resolveNamespaceVariables(variable, path.slice(1), astContext);
 }
 
-class CallExpressionBase extends NodeBase {
+class CallExpression extends NodeBase {
     constructor() {
         super(...arguments);
-        this.returnExpression = null;
+        this.deoptimized = false;
         this.deoptimizableDependentExpressions = [];
         this.expressionsToBeDeoptimized = new Set();
+        this.returnExpression = null;
+    }
+    bind() {
+        super.bind();
+        if (this.callee instanceof Identifier) {
+            const variable = this.scope.findVariable(this.callee.name);
+            if (variable.isNamespace) {
+                this.context.warn({
+                    code: 'CANNOT_CALL_NAMESPACE',
+                    message: `Cannot call a namespace ('${this.callee.name}')`
+                }, this.start);
+            }
+            if (this.callee.name === 'eval') {
+                this.context.warn({
+                    code: 'EVAL',
+                    message: `Use of eval is strongly discouraged, as it poses security risks and may cause issues with minification`,
+                    url: 'https://rollupjs.org/guide/en/#avoiding-eval'
+                }, this.start);
+            }
+        }
+        this.callOptions = {
+            args: this.arguments,
+            thisParam: this.callee instanceof MemberExpression && !this.callee.variable
+                ? this.callee.object
+                : null,
+            withNew: false
+        };
     }
     deoptimizeCache() {
-        if (this.returnExpression?.[0] !== UNKNOWN_EXPRESSION) {
-            this.returnExpression = UNKNOWN_RETURN_EXPRESSION;
+        if (this.returnExpression !== UNKNOWN_EXPRESSION) {
+            this.returnExpression = UNKNOWN_EXPRESSION;
             for (const expression of this.deoptimizableDependentExpressions) {
                 expression.deoptimizeCache();
             }
@@ -9373,27 +8925,25 @@
             this.context.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(path, this)) {
             return;
         }
-        const [returnExpression] = this.getReturnExpression();
+        const returnExpression = this.getReturnExpression();
         if (returnExpression !== UNKNOWN_EXPRESSION) {
             returnExpression.deoptimizePath(path);
         }
     }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        const [returnExpression, isPure] = this.getReturnExpression(recursionTracker);
-        if (isPure)
-            return;
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
+        const returnExpression = this.getReturnExpression(recursionTracker);
         if (returnExpression === UNKNOWN_EXPRESSION) {
-            interaction.thisArg.deoptimizePath(UNKNOWN_PATH);
+            thisParameter.deoptimizePath(UNKNOWN_PATH);
         }
         else {
             recursionTracker.withTrackedEntityAtPath(path, returnExpression, () => {
-                this.expressionsToBeDeoptimized.add(interaction.thisArg);
-                returnExpression.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
-            }, null);
+                this.expressionsToBeDeoptimized.add(thisParameter);
+                returnExpression.deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker);
+            }, undefined);
         }
     }
     getLiteralValueAtPath(path, recursionTracker, origin) {
-        const [returnExpression] = this.getReturnExpression(recursionTracker);
+        const returnExpression = this.getReturnExpression(recursionTracker);
         if (returnExpression === UNKNOWN_EXPRESSION) {
             return UnknownValue;
         }
@@ -9402,56 +8952,15 @@
             return returnExpression.getLiteralValueAtPath(path, recursionTracker, origin);
         }, UnknownValue);
     }
-    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
+    getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin) {
         const returnExpression = this.getReturnExpression(recursionTracker);
-        if (returnExpression[0] === UNKNOWN_EXPRESSION) {
-            return returnExpression;
+        if (this.returnExpression === UNKNOWN_EXPRESSION) {
+            return UNKNOWN_EXPRESSION;
         }
         return recursionTracker.withTrackedEntityAtPath(path, returnExpression, () => {
             this.deoptimizableDependentExpressions.push(origin);
-            const [expression, isPure] = returnExpression[0].getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
-            return [expression, isPure || returnExpression[1]];
-        }, UNKNOWN_RETURN_EXPRESSION);
-    }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        const { type } = interaction;
-        if (type === INTERACTION_CALLED) {
-            const { args, withNew } = interaction;
-            if ((withNew ? context.instantiated : context.called).trackEntityAtPathAndGetIfTracked(path, args, this)) {
-                return false;
-            }
-        }
-        else if ((type === INTERACTION_ASSIGNED
-            ? context.assigned
-            : context.accessed).trackEntityAtPathAndGetIfTracked(path, this)) {
-            return false;
-        }
-        const [returnExpression, isPure] = this.getReturnExpression();
-        return ((type === INTERACTION_ASSIGNED || !isPure) &&
-            returnExpression.hasEffectsOnInteractionAtPath(path, interaction, context));
-    }
-}
-
-class CallExpression extends CallExpressionBase {
-    bind() {
-        super.bind();
-        if (this.callee instanceof Identifier) {
-            const variable = this.scope.findVariable(this.callee.name);
-            if (variable.isNamespace) {
-                this.context.warn(errorCannotCallNamespace(this.callee.name), this.start);
-            }
-            if (this.callee.name === 'eval') {
-                this.context.warn(errorEval(this.context.module.id), this.start);
-            }
-        }
-        this.interaction = {
-            args: this.arguments,
-            thisArg: this.callee instanceof MemberExpression && !this.callee.variable
-                ? this.callee.object
-                : null,
-            type: INTERACTION_CALLED,
-            withNew: false
-        };
+            return returnExpression.getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin);
+        }, UNKNOWN_EXPRESSION);
     }
     hasEffects(context) {
         try {
@@ -9463,13 +8972,25 @@
                 this.annotations)
                 return false;
             return (this.callee.hasEffects(context) ||
-                this.callee.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.interaction, context));
+                this.callee.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.callOptions, context));
         }
         finally {
             if (!this.deoptimized)
                 this.applyDeoptimizations();
         }
     }
+    hasEffectsWhenAccessedAtPath(path, context) {
+        return (!context.accessed.trackEntityAtPathAndGetIfTracked(path, this) &&
+            this.getReturnExpression().hasEffectsWhenAccessedAtPath(path, context));
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        return (!context.assigned.trackEntityAtPathAndGetIfTracked(path, this) &&
+            this.getReturnExpression().hasEffectsWhenAssignedAtPath(path, context));
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        return (!(callOptions.withNew ? context.instantiated : context.called).trackEntityAtPathAndGetIfTracked(path, callOptions, this) &&
+            this.getReturnExpression().hasEffectsWhenCalledAtPath(path, callOptions, context));
+    }
     include(context, includeChildrenRecursively) {
         if (!this.deoptimized)
             this.applyDeoptimizations();
@@ -9486,23 +9007,44 @@
             this.callee.include(context, false);
         }
         this.callee.includeCallArguments(context, this.arguments);
-    }
-    isSkippedAsOptional(origin) {
-        return (this.callee.isSkippedAsOptional?.(origin) ||
-            (this.optional &&
-                this.callee.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, origin) == null));
+        const returnExpression = this.getReturnExpression();
+        if (!returnExpression.included) {
+            returnExpression.include(context, false);
+        }
     }
     render(code, options, { renderedSurroundingElement } = BLANK) {
         this.callee.render(code, options, {
             isCalleeOfRenderedParent: true,
             renderedSurroundingElement
         });
-        renderCallArguments(code, options, this);
+        if (this.arguments.length > 0) {
+            if (this.arguments[this.arguments.length - 1].included) {
+                for (const arg of this.arguments) {
+                    arg.render(code, options);
+                }
+            }
+            else {
+                let lastIncludedIndex = this.arguments.length - 2;
+                while (lastIncludedIndex >= 0 && !this.arguments[lastIncludedIndex].included) {
+                    lastIncludedIndex--;
+                }
+                if (lastIncludedIndex >= 0) {
+                    for (let index = 0; index <= lastIncludedIndex; index++) {
+                        this.arguments[index].render(code, options);
+                    }
+                    code.remove(findFirstOccurrenceOutsideComment(code.original, ',', this.arguments[lastIncludedIndex].end), this.end - 1);
+                }
+                else {
+                    code.remove(findFirstOccurrenceOutsideComment(code.original, '(', this.callee.end) + 1, this.end - 1);
+                }
+            }
+        }
     }
     applyDeoptimizations() {
         this.deoptimized = true;
-        if (this.interaction.thisArg) {
-            this.callee.deoptimizeThisOnInteractionAtPath(this.interaction, EMPTY_PATH, SHARED_RECURSION_TRACKER);
+        const { thisParam } = this.callOptions;
+        if (thisParam) {
+            this.callee.deoptimizeThisOnEventAtPath(EVENT_CALLED, EMPTY_PATH, thisParam, SHARED_RECURSION_TRACKER);
         }
         for (const argument of this.arguments) {
             // This will make sure all properties of parameters behave as "unknown"
@@ -9512,8 +9054,8 @@
     }
     getReturnExpression(recursionTracker = SHARED_RECURSION_TRACKER) {
         if (this.returnExpression === null) {
-            this.returnExpression = UNKNOWN_RETURN_EXPRESSION;
-            return (this.returnExpression = this.callee.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, this.interaction, recursionTracker, this));
+            this.returnExpression = UNKNOWN_EXPRESSION;
+            return (this.returnExpression = this.callee.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, this.callOptions, recursionTracker, this));
         }
         return this.returnExpression;
     }
@@ -9544,7 +9086,8 @@
         // name instead of the variable
         const { param } = esTreeNode;
         if (param) {
-            this.param = new (this.context.getNodeConstructor(param.type))(param, this, this.scope);
+            this.param = new (this.context.nodeConstructors[param.type] ||
+                this.context.nodeConstructors.UnknownNode)(param, this, this.scope);
             this.param.declare('parameter', UNKNOWN_EXPRESSION);
         }
         super.parseNode(esTreeNode);
@@ -9552,18 +9095,6 @@
 }
 
 class ChainExpression extends NodeBase {
-    // deoptimizations are not relevant as we are not caching values
-    deoptimizeCache() { }
-    getLiteralValueAtPath(path, recursionTracker, origin) {
-        if (this.expression.isSkippedAsOptional(origin))
-            return undefined;
-        return this.expression.getLiteralValueAtPath(path, recursionTracker, origin);
-    }
-    hasEffects(context) {
-        if (this.expression.isSkippedAsOptional(this))
-            return false;
-        return this.expression.hasEffects(context);
-    }
 }
 
 class ClassBodyScope extends ChildScope {
@@ -9592,269 +9123,10 @@
     parseNode(esTreeNode) {
         const body = (this.body = []);
         for (const definition of esTreeNode.body) {
-            body.push(new (this.context.getNodeConstructor(definition.type))(definition, this, definition.static ? this.scope : this.scope.instanceScope));
+            body.push(new this.context.nodeConstructors[definition.type](definition, this, definition.static ? this.scope : this.scope.instanceScope));
         }
         super.parseNode(esTreeNode);
     }
-    applyDeoptimizations() { }
-}
-
-class MethodBase extends NodeBase {
-    constructor() {
-        super(...arguments);
-        this.accessedValue = null;
-    }
-    // As getter properties directly receive their values from fixed function
-    // expressions, there is no known situation where a getter is deoptimized.
-    deoptimizeCache() { }
-    deoptimizePath(path) {
-        this.getAccessedValue()[0].deoptimizePath(path);
-    }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        if (interaction.type === INTERACTION_ACCESSED && this.kind === 'get' && path.length === 0) {
-            return this.value.deoptimizeThisOnInteractionAtPath({
-                args: NO_ARGS,
-                thisArg: interaction.thisArg,
-                type: INTERACTION_CALLED,
-                withNew: false
-            }, EMPTY_PATH, recursionTracker);
-        }
-        if (interaction.type === INTERACTION_ASSIGNED && this.kind === 'set' && path.length === 0) {
-            return this.value.deoptimizeThisOnInteractionAtPath({
-                args: interaction.args,
-                thisArg: interaction.thisArg,
-                type: INTERACTION_CALLED,
-                withNew: false
-            }, EMPTY_PATH, recursionTracker);
-        }
-        this.getAccessedValue()[0].deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
-    }
-    getLiteralValueAtPath(path, recursionTracker, origin) {
-        return this.getAccessedValue()[0].getLiteralValueAtPath(path, recursionTracker, origin);
-    }
-    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
-        return this.getAccessedValue()[0].getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
-    }
-    hasEffects(context) {
-        return this.key.hasEffects(context);
-    }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        if (this.kind === 'get' && interaction.type === INTERACTION_ACCESSED && path.length === 0) {
-            return this.value.hasEffectsOnInteractionAtPath(EMPTY_PATH, {
-                args: NO_ARGS,
-                thisArg: interaction.thisArg,
-                type: INTERACTION_CALLED,
-                withNew: false
-            }, context);
-        }
-        // setters are only called for empty paths
-        if (this.kind === 'set' && interaction.type === INTERACTION_ASSIGNED) {
-            return this.value.hasEffectsOnInteractionAtPath(EMPTY_PATH, {
-                args: interaction.args,
-                thisArg: interaction.thisArg,
-                type: INTERACTION_CALLED,
-                withNew: false
-            }, context);
-        }
-        return this.getAccessedValue()[0].hasEffectsOnInteractionAtPath(path, interaction, context);
-    }
-    applyDeoptimizations() { }
-    getAccessedValue() {
-        if (this.accessedValue === null) {
-            if (this.kind === 'get') {
-                this.accessedValue = UNKNOWN_RETURN_EXPRESSION;
-                return (this.accessedValue = this.value.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, NODE_INTERACTION_UNKNOWN_CALL, SHARED_RECURSION_TRACKER, this));
-            }
-            else {
-                return (this.accessedValue = [this.value, false]);
-            }
-        }
-        return this.accessedValue;
-    }
-}
-
-class MethodDefinition extends MethodBase {
-    applyDeoptimizations() { }
-}
-
-class ObjectMember extends ExpressionEntity {
-    constructor(object, key) {
-        super();
-        this.object = object;
-        this.key = key;
-    }
-    deoptimizePath(path) {
-        this.object.deoptimizePath([this.key, ...path]);
-    }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        this.object.deoptimizeThisOnInteractionAtPath(interaction, [this.key, ...path], recursionTracker);
-    }
-    getLiteralValueAtPath(path, recursionTracker, origin) {
-        return this.object.getLiteralValueAtPath([this.key, ...path], recursionTracker, origin);
-    }
-    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
-        return this.object.getReturnExpressionWhenCalledAtPath([this.key, ...path], interaction, recursionTracker, origin);
-    }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        return this.object.hasEffectsOnInteractionAtPath([this.key, ...path], interaction, context);
-    }
-}
-
-class ClassNode extends NodeBase {
-    constructor() {
-        super(...arguments);
-        this.objectEntity = null;
-    }
-    createScope(parentScope) {
-        this.scope = new ChildScope(parentScope);
-    }
-    deoptimizeCache() {
-        this.getObjectEntity().deoptimizeAllProperties();
-    }
-    deoptimizePath(path) {
-        this.getObjectEntity().deoptimizePath(path);
-    }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        this.getObjectEntity().deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
-    }
-    getLiteralValueAtPath(path, recursionTracker, origin) {
-        return this.getObjectEntity().getLiteralValueAtPath(path, recursionTracker, origin);
-    }
-    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
-        return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
-    }
-    hasEffects(context) {
-        if (!this.deoptimized)
-            this.applyDeoptimizations();
-        const initEffect = this.superClass?.hasEffects(context) || this.body.hasEffects(context);
-        this.id?.markDeclarationReached();
-        return initEffect || super.hasEffects(context);
-    }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        return interaction.type === INTERACTION_CALLED && path.length === 0
-            ? !interaction.withNew ||
-                (this.classConstructor === null
-                    ? this.superClass?.hasEffectsOnInteractionAtPath(path, interaction, context)
-                    : this.classConstructor.hasEffectsOnInteractionAtPath(path, interaction, context)) ||
-                false
-            : this.getObjectEntity().hasEffectsOnInteractionAtPath(path, interaction, context);
-    }
-    include(context, includeChildrenRecursively) {
-        if (!this.deoptimized)
-            this.applyDeoptimizations();
-        this.included = true;
-        this.superClass?.include(context, includeChildrenRecursively);
-        this.body.include(context, includeChildrenRecursively);
-        if (this.id) {
-            this.id.markDeclarationReached();
-            this.id.include();
-        }
-    }
-    initialise() {
-        this.id?.declare('class', this);
-        for (const method of this.body.body) {
-            if (method instanceof MethodDefinition && method.kind === 'constructor') {
-                this.classConstructor = method;
-                return;
-            }
-        }
-        this.classConstructor = null;
-    }
-    applyDeoptimizations() {
-        this.deoptimized = true;
-        for (const definition of this.body.body) {
-            if (!(definition.static ||
-                (definition instanceof MethodDefinition && definition.kind === 'constructor'))) {
-                // Calls to methods are not tracked, ensure that the return value is deoptimized
-                definition.deoptimizePath(UNKNOWN_PATH);
-            }
-        }
-        this.context.requestTreeshakingPass();
-    }
-    getObjectEntity() {
-        if (this.objectEntity !== null) {
-            return this.objectEntity;
-        }
-        const staticProperties = [];
-        const dynamicMethods = [];
-        for (const definition of this.body.body) {
-            const properties = definition.static ? staticProperties : dynamicMethods;
-            const definitionKind = definition.kind;
-            // Note that class fields do not end up on the prototype
-            if (properties === dynamicMethods && !definitionKind)
-                continue;
-            const kind = definitionKind === 'set' || definitionKind === 'get' ? definitionKind : 'init';
-            let key;
-            if (definition.computed) {
-                const keyValue = definition.key.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
-                if (typeof keyValue === 'symbol') {
-                    properties.push({ key: UnknownKey, kind, property: definition });
-                    continue;
-                }
-                else {
-                    key = String(keyValue);
-                }
-            }
-            else {
-                key =
-                    definition.key instanceof Identifier
-                        ? definition.key.name
-                        : String(definition.key.value);
-            }
-            properties.push({ key, kind, property: definition });
-        }
-        staticProperties.unshift({
-            key: 'prototype',
-            kind: 'init',
-            property: new ObjectEntity(dynamicMethods, this.superClass ? new ObjectMember(this.superClass, 'prototype') : OBJECT_PROTOTYPE)
-        });
-        return (this.objectEntity = new ObjectEntity(staticProperties, this.superClass || OBJECT_PROTOTYPE));
-    }
-}
-
-class ClassDeclaration extends ClassNode {
-    initialise() {
-        super.initialise();
-        if (this.id !== null) {
-            this.id.variable.isId = true;
-        }
-    }
-    parseNode(esTreeNode) {
-        if (esTreeNode.id !== null) {
-            this.id = new Identifier(esTreeNode.id, this, this.scope.parent);
-        }
-        super.parseNode(esTreeNode);
-    }
-    render(code, options) {
-        const { exportNamesByVariable, format, snippets: { _, getPropertyAccess } } = options;
-        if (this.id) {
-            const { variable, name } = this.id;
-            if (format === 'system' && exportNamesByVariable.has(variable)) {
-                code.appendLeft(this.end, `${_}${getSystemExportStatement([variable], options)};`);
-            }
-            const renderedVariable = variable.getName(getPropertyAccess);
-            if (renderedVariable !== name) {
-                this.superClass?.render(code, options);
-                this.body.render(code, options);
-                code.prependRight(this.start, `let ${renderedVariable}${_}=${_}`);
-                code.prependLeft(this.end, ';');
-                return;
-            }
-        }
-        super.render(code, options);
-    }
-    applyDeoptimizations() {
-        super.applyDeoptimizations();
-        const { id, scope } = this;
-        if (id) {
-            const { name, variable } = id;
-            for (const accessedVariable of scope.accessedOutsideVariables.values()) {
-                if (accessedVariable !== variable) {
-                    accessedVariable.forbidName(name);
-                }
-            }
-        }
-    }
 }
 
 class ClassExpression extends ClassNode {
@@ -9878,19 +9150,39 @@
             expression.deoptimizePath(path);
         }
     }
-    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
-        return [
-            new MultiExpression(this.expressions.map(expression => expression.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin)[0])),
-            false
-        ];
+    getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin) {
+        return new MultiExpression(this.expressions.map(expression => expression.getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin)));
+    }
+    hasEffectsWhenAccessedAtPath(path, context) {
+        for (const expression of this.expressions) {
+            if (expression.hasEffectsWhenAccessedAtPath(path, context))
+                return true;
+        }
+        return false;
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
+    hasEffectsWhenAssignedAtPath(path, context) {
         for (const expression of this.expressions) {
-            if (expression.hasEffectsOnInteractionAtPath(path, interaction, context))
+            if (expression.hasEffectsWhenAssignedAtPath(path, context))
                 return true;
         }
         return false;
     }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        for (const expression of this.expressions) {
+            if (expression.hasEffectsWhenCalledAtPath(path, callOptions, context))
+                return true;
+        }
+        return false;
+    }
+    include(context, includeChildrenRecursively) {
+        // This is only relevant to include values that do not have an AST representation,
+        // such as UnknownArrayExpression. Thus we only need to include them once.
+        for (const expression of this.expressions) {
+            if (!expression.included) {
+                expression.include(context, includeChildrenRecursively);
+            }
+        }
+    }
 }
 
 class ConditionalExpression extends NodeBase {
@@ -9912,54 +9204,67 @@
     }
     deoptimizePath(path) {
         const usedBranch = this.getUsedBranch();
-        if (usedBranch) {
-            usedBranch.deoptimizePath(path);
-        }
-        else {
+        if (usedBranch === null) {
             this.consequent.deoptimizePath(path);
             this.alternate.deoptimizePath(path);
         }
+        else {
+            usedBranch.deoptimizePath(path);
+        }
     }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        this.consequent.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
-        this.alternate.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
+        this.consequent.deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker);
+        this.alternate.deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker);
     }
     getLiteralValueAtPath(path, recursionTracker, origin) {
         const usedBranch = this.getUsedBranch();
-        if (!usedBranch)
+        if (usedBranch === null)
             return UnknownValue;
         this.expressionsToBeDeoptimized.push(origin);
         return usedBranch.getLiteralValueAtPath(path, recursionTracker, origin);
     }
-    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
+    getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin) {
         const usedBranch = this.getUsedBranch();
-        if (!usedBranch)
-            return [
-                new MultiExpression([
-                    this.consequent.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin)[0],
-                    this.alternate.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin)[0]
-                ]),
-                false
-            ];
+        if (usedBranch === null)
+            return new MultiExpression([
+                this.consequent.getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin),
+                this.alternate.getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin)
+            ]);
         this.expressionsToBeDeoptimized.push(origin);
-        return usedBranch.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
+        return usedBranch.getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin);
     }
     hasEffects(context) {
         if (this.test.hasEffects(context))
             return true;
         const usedBranch = this.getUsedBranch();
-        if (!usedBranch) {
+        if (usedBranch === null) {
             return this.consequent.hasEffects(context) || this.alternate.hasEffects(context);
         }
         return usedBranch.hasEffects(context);
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
+    hasEffectsWhenAccessedAtPath(path, context) {
+        const usedBranch = this.getUsedBranch();
+        if (usedBranch === null) {
+            return (this.consequent.hasEffectsWhenAccessedAtPath(path, context) ||
+                this.alternate.hasEffectsWhenAccessedAtPath(path, context));
+        }
+        return usedBranch.hasEffectsWhenAccessedAtPath(path, context);
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        const usedBranch = this.getUsedBranch();
+        if (usedBranch === null) {
+            return (this.consequent.hasEffectsWhenAssignedAtPath(path, context) ||
+                this.alternate.hasEffectsWhenAssignedAtPath(path, context));
+        }
+        return usedBranch.hasEffectsWhenAssignedAtPath(path, context);
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
         const usedBranch = this.getUsedBranch();
-        if (!usedBranch) {
-            return (this.consequent.hasEffectsOnInteractionAtPath(path, interaction, context) ||
-                this.alternate.hasEffectsOnInteractionAtPath(path, interaction, context));
+        if (usedBranch === null) {
+            return (this.consequent.hasEffectsWhenCalledAtPath(path, callOptions, context) ||
+                this.alternate.hasEffectsWhenCalledAtPath(path, callOptions, context));
         }
-        return usedBranch.hasEffectsOnInteractionAtPath(path, interaction, context);
+        return usedBranch.hasEffectsWhenCalledAtPath(path, callOptions, context);
     }
     include(context, includeChildrenRecursively) {
         this.included = true;
@@ -9973,24 +9278,19 @@
             usedBranch.include(context, includeChildrenRecursively);
         }
     }
-    includeCallArguments(context, parameters) {
+    includeCallArguments(context, args) {
         const usedBranch = this.getUsedBranch();
-        if (usedBranch) {
-            usedBranch.includeCallArguments(context, parameters);
+        if (usedBranch === null) {
+            this.consequent.includeCallArguments(context, args);
+            this.alternate.includeCallArguments(context, args);
         }
         else {
-            this.consequent.includeCallArguments(context, parameters);
-            this.alternate.includeCallArguments(context, parameters);
+            usedBranch.includeCallArguments(context, args);
         }
     }
     render(code, options, { isCalleeOfRenderedParent, preventASI, renderedParentType, renderedSurroundingElement } = BLANK) {
         const usedBranch = this.getUsedBranch();
-        if (this.test.included) {
-            this.test.render(code, options, { renderedSurroundingElement });
-            this.consequent.render(code, options);
-            this.alternate.render(code, options);
-        }
-        else {
+        if (!this.test.included) {
             const colonPos = findFirstOccurrenceOutsideComment(code.original, ':', this.consequent.end);
             const inclusionStart = findNonWhiteSpace(code.original, (this.consequent.included
                 ? findFirstOccurrenceOutsideComment(code.original, '?', this.test.end)
@@ -10010,6 +9310,11 @@
                 renderedSurroundingElement: renderedSurroundingElement || this.parent.type
             });
         }
+        else {
+            this.test.render(code, options, { renderedSurroundingElement });
+            this.consequent.render(code, options);
+            this.alternate.render(code, options);
+        }
     }
     getUsedBranch() {
         if (this.isBranchResolutionAnalysed) {
@@ -10017,7 +9322,7 @@
         }
         this.isBranchResolutionAnalysed = true;
         const testValue = this.test.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
-        return typeof testValue === 'symbol'
+        return testValue === UnknownValue
             ? null
             : (this.usedBranch = testValue ? this.consequent : this.alternate);
     }
@@ -10052,14 +9357,13 @@
     hasEffects(context) {
         if (this.test.hasEffects(context))
             return true;
-        const { brokenFlow, ignore } = context;
-        const { breaks, continues } = ignore;
-        ignore.breaks = true;
-        ignore.continues = true;
+        const { brokenFlow, ignore: { breaks, continues } } = context;
+        context.ignore.breaks = true;
+        context.ignore.continues = true;
         if (this.body.hasEffects(context))
             return true;
-        ignore.breaks = breaks;
-        ignore.continues = continues;
+        context.ignore.breaks = breaks;
+        context.ignore.continues = continues;
         context.brokenFlow = brokenFlow;
         return false;
     }
@@ -10067,7 +9371,7 @@
         this.included = true;
         this.test.include(context, includeChildrenRecursively);
         const { brokenFlow } = context;
-        this.body.include(context, includeChildrenRecursively, { asSingleStatement: true });
+        this.body.includeAsSingleStatement(context, includeChildrenRecursively);
         context.brokenFlow = brokenFlow;
     }
 }
@@ -10078,130 +9382,14 @@
     }
 }
 
-class ExportAllDeclaration extends NodeBase {
-    hasEffects() {
-        return false;
-    }
-    initialise() {
-        this.context.addExport(this);
-    }
-    render(code, _options, nodeRenderOptions) {
-        code.remove(nodeRenderOptions.start, nodeRenderOptions.end);
-    }
-    applyDeoptimizations() { }
-}
-ExportAllDeclaration.prototype.needsBoundaries = true;
-
-class FunctionDeclaration extends FunctionNode {
-    initialise() {
-        super.initialise();
-        if (this.id !== null) {
-            this.id.variable.isId = true;
-        }
-    }
-    parseNode(esTreeNode) {
-        if (esTreeNode.id !== null) {
-            this.id = new Identifier(esTreeNode.id, this, this.scope.parent);
-        }
-        super.parseNode(esTreeNode);
-    }
-}
-
-// The header ends at the first non-white-space after "default"
-function getDeclarationStart(code, start) {
-    return findNonWhiteSpace(code, findFirstOccurrenceOutsideComment(code, 'default', start) + 7);
-}
-function getIdInsertPosition(code, declarationKeyword, endMarker, start) {
-    const declarationEnd = findFirstOccurrenceOutsideComment(code, declarationKeyword, start) + declarationKeyword.length;
-    code = code.slice(declarationEnd, findFirstOccurrenceOutsideComment(code, endMarker, declarationEnd));
-    const generatorStarPos = findFirstOccurrenceOutsideComment(code, '*');
-    if (generatorStarPos === -1) {
-        return declarationEnd;
-    }
-    return declarationEnd + generatorStarPos + 1;
-}
-class ExportDefaultDeclaration extends NodeBase {
-    include(context, includeChildrenRecursively) {
-        super.include(context, includeChildrenRecursively);
-        if (includeChildrenRecursively) {
-            this.context.includeVariableInModule(this.variable);
-        }
-    }
-    initialise() {
-        const declaration = this.declaration;
-        this.declarationName =
-            (declaration.id && declaration.id.name) || this.declaration.name;
-        this.variable = this.scope.addExportDefaultDeclaration(this.declarationName || this.context.getModuleName(), this, this.context);
-        this.context.addExport(this);
-    }
-    render(code, options, nodeRenderOptions) {
-        const { start, end } = nodeRenderOptions;
-        const declarationStart = getDeclarationStart(code.original, this.start);
-        if (this.declaration instanceof FunctionDeclaration) {
-            this.renderNamedDeclaration(code, declarationStart, 'function', '(', this.declaration.id === null, options);
-        }
-        else if (this.declaration instanceof ClassDeclaration) {
-            this.renderNamedDeclaration(code, declarationStart, 'class', '{', this.declaration.id === null, options);
-        }
-        else if (this.variable.getOriginalVariable() !== this.variable) {
-            // Remove altogether to prevent re-declaring the same variable
-            treeshakeNode(this, code, start, end);
-            return;
-        }
-        else if (this.variable.included) {
-            this.renderVariableDeclaration(code, declarationStart, options);
-        }
-        else {
-            code.remove(this.start, declarationStart);
-            this.declaration.render(code, options, {
-                renderedSurroundingElement: ExpressionStatement$1
-            });
-            if (code.original[this.end - 1] !== ';') {
-                code.appendLeft(this.end, ';');
-            }
-            return;
-        }
-        this.declaration.render(code, options);
-    }
-    applyDeoptimizations() { }
-    renderNamedDeclaration(code, declarationStart, declarationKeyword, endMarker, needsId, options) {
-        const { exportNamesByVariable, format, snippets: { getPropertyAccess } } = options;
-        const name = this.variable.getName(getPropertyAccess);
-        // Remove `export default`
-        code.remove(this.start, declarationStart);
-        if (needsId) {
-            code.appendLeft(getIdInsertPosition(code.original, declarationKeyword, endMarker, declarationStart), ` ${name}`);
-        }
-        if (format === 'system' &&
-            this.declaration instanceof ClassDeclaration &&
-            exportNamesByVariable.has(this.variable)) {
-            code.appendLeft(this.end, ` ${getSystemExportStatement([this.variable], options)};`);
-        }
-    }
-    renderVariableDeclaration(code, declarationStart, { format, exportNamesByVariable, snippets: { cnst, getPropertyAccess } }) {
-        const hasTrailingSemicolon = code.original.charCodeAt(this.end - 1) === 59; /*";"*/
-        const systemExportNames = format === 'system' && exportNamesByVariable.get(this.variable);
-        if (systemExportNames) {
-            code.overwrite(this.start, declarationStart, `${cnst} ${this.variable.getName(getPropertyAccess)} = exports('${systemExportNames[0]}', `);
-            code.appendRight(hasTrailingSemicolon ? this.end - 1 : this.end, ')' + (hasTrailingSemicolon ? '' : ';'));
-        }
-        else {
-            code.overwrite(this.start, declarationStart, `${cnst} ${this.variable.getName(getPropertyAccess)} = `);
-            if (!hasTrailingSemicolon) {
-                code.appendLeft(this.end, ';');
-            }
-        }
-    }
-}
-ExportDefaultDeclaration.prototype.needsBoundaries = true;
-
 class ExportNamedDeclaration extends NodeBase {
     bind() {
         // Do not bind specifiers
-        this.declaration?.bind();
+        if (this.declaration !== null)
+            this.declaration.bind();
     }
     hasEffects(context) {
-        return !!this.declaration?.hasEffects(context);
+        return this.declaration !== null && this.declaration.hasEffects(context);
     }
     initialise() {
         this.context.addExport(this);
@@ -10216,49 +9404,48 @@
             this.declaration.render(code, options, { end, start });
         }
     }
-    applyDeoptimizations() { }
 }
 ExportNamedDeclaration.prototype.needsBoundaries = true;
 
 class ExportSpecifier extends NodeBase {
-    applyDeoptimizations() { }
 }
 
 class ForInStatement extends NodeBase {
+    constructor() {
+        super(...arguments);
+        this.deoptimized = false;
+    }
     createScope(parentScope) {
         this.scope = new BlockScope(parentScope);
     }
     hasEffects(context) {
-        const { body, deoptimized, left, right } = this;
-        if (!deoptimized)
+        if (!this.deoptimized)
             this.applyDeoptimizations();
-        if (left.hasEffectsAsAssignmentTarget(context, false) || right.hasEffects(context))
+        if ((this.left &&
+            (this.left.hasEffects(context) ||
+                this.left.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context))) ||
+            (this.right && this.right.hasEffects(context)))
             return true;
-        const { brokenFlow, ignore } = context;
-        const { breaks, continues } = ignore;
-        ignore.breaks = true;
-        ignore.continues = true;
-        if (body.hasEffects(context))
+        const { brokenFlow, ignore: { breaks, continues } } = context;
+        context.ignore.breaks = true;
+        context.ignore.continues = true;
+        if (this.body.hasEffects(context))
             return true;
-        ignore.breaks = breaks;
-        ignore.continues = continues;
+        context.ignore.breaks = breaks;
+        context.ignore.continues = continues;
         context.brokenFlow = brokenFlow;
         return false;
     }
     include(context, includeChildrenRecursively) {
-        const { body, deoptimized, left, right } = this;
-        if (!deoptimized)
+        if (!this.deoptimized)
             this.applyDeoptimizations();
         this.included = true;
-        left.includeAsAssignmentTarget(context, includeChildrenRecursively || true, false);
-        right.include(context, includeChildrenRecursively);
+        this.left.include(context, includeChildrenRecursively || true);
+        this.right.include(context, includeChildrenRecursively);
         const { brokenFlow } = context;
-        body.include(context, includeChildrenRecursively, { asSingleStatement: true });
+        this.body.includeAsSingleStatement(context, includeChildrenRecursively);
         context.brokenFlow = brokenFlow;
     }
-    initialise() {
-        this.left.setAssignedValue(UNKNOWN_EXPRESSION);
-    }
     render(code, options) {
         this.left.render(code, options, NO_SEMICOLON);
         this.right.render(code, options, NO_SEMICOLON);
@@ -10276,6 +9463,10 @@
 }
 
 class ForOfStatement extends NodeBase {
+    constructor() {
+        super(...arguments);
+        this.deoptimized = false;
+    }
     createScope(parentScope) {
         this.scope = new BlockScope(parentScope);
     }
@@ -10286,19 +9477,15 @@
         return true;
     }
     include(context, includeChildrenRecursively) {
-        const { body, deoptimized, left, right } = this;
-        if (!deoptimized)
+        if (!this.deoptimized)
             this.applyDeoptimizations();
         this.included = true;
-        left.includeAsAssignmentTarget(context, includeChildrenRecursively || true, false);
-        right.include(context, includeChildrenRecursively);
+        this.left.include(context, includeChildrenRecursively || true);
+        this.right.include(context, includeChildrenRecursively);
         const { brokenFlow } = context;
-        body.include(context, includeChildrenRecursively, { asSingleStatement: true });
+        this.body.includeAsSingleStatement(context, includeChildrenRecursively);
         context.brokenFlow = brokenFlow;
     }
-    initialise() {
-        this.left.setAssignedValue(UNKNOWN_EXPRESSION);
-    }
     render(code, options) {
         this.left.render(code, options, NO_SEMICOLON);
         this.right.render(code, options, NO_SEMICOLON);
@@ -10320,34 +9507,39 @@
         this.scope = new BlockScope(parentScope);
     }
     hasEffects(context) {
-        if (this.init?.hasEffects(context) ||
-            this.test?.hasEffects(context) ||
-            this.update?.hasEffects(context))
+        if ((this.init && this.init.hasEffects(context)) ||
+            (this.test && this.test.hasEffects(context)) ||
+            (this.update && this.update.hasEffects(context)))
             return true;
-        const { brokenFlow, ignore } = context;
-        const { breaks, continues } = ignore;
-        ignore.breaks = true;
-        ignore.continues = true;
+        const { brokenFlow, ignore: { breaks, continues } } = context;
+        context.ignore.breaks = true;
+        context.ignore.continues = true;
         if (this.body.hasEffects(context))
             return true;
-        ignore.breaks = breaks;
-        ignore.continues = continues;
+        context.ignore.breaks = breaks;
+        context.ignore.continues = continues;
         context.brokenFlow = brokenFlow;
         return false;
     }
     include(context, includeChildrenRecursively) {
         this.included = true;
-        this.init?.include(context, includeChildrenRecursively, { asSingleStatement: true });
-        this.test?.include(context, includeChildrenRecursively);
+        if (this.init)
+            this.init.includeAsSingleStatement(context, includeChildrenRecursively);
+        if (this.test)
+            this.test.include(context, includeChildrenRecursively);
         const { brokenFlow } = context;
-        this.update?.include(context, includeChildrenRecursively);
-        this.body.include(context, includeChildrenRecursively, { asSingleStatement: true });
+        if (this.update)
+            this.update.include(context, includeChildrenRecursively);
+        this.body.includeAsSingleStatement(context, includeChildrenRecursively);
         context.brokenFlow = brokenFlow;
     }
     render(code, options) {
-        this.init?.render(code, options, NO_SEMICOLON);
-        this.test?.render(code, options, NO_SEMICOLON);
-        this.update?.render(code, options, NO_SEMICOLON);
+        if (this.init)
+            this.init.render(code, options, NO_SEMICOLON);
+        if (this.test)
+            this.test.render(code, options, NO_SEMICOLON);
+        if (this.update)
+            this.update.render(code, options, NO_SEMICOLON);
         this.body.render(code, options);
     }
 }
@@ -10387,11 +9579,10 @@
             return true;
         }
         const testValue = this.getTestValue();
-        if (typeof testValue === 'symbol') {
+        if (testValue === UnknownValue) {
             const { brokenFlow } = context;
             if (this.consequent.hasEffects(context))
                 return true;
-            // eslint-disable-next-line unicorn/consistent-destructuring
             const consequentBrokenFlow = context.brokenFlow;
             context.brokenFlow = brokenFlow;
             if (this.alternate === null)
@@ -10399,11 +9590,12 @@
             if (this.alternate.hasEffects(context))
                 return true;
             context.brokenFlow =
-                // eslint-disable-next-line unicorn/consistent-destructuring
                 context.brokenFlow < consequentBrokenFlow ? context.brokenFlow : consequentBrokenFlow;
             return false;
         }
-        return testValue ? this.consequent.hasEffects(context) : !!this.alternate?.hasEffects(context);
+        return testValue
+            ? this.consequent.hasEffects(context)
+            : this.alternate !== null && this.alternate.hasEffects(context);
     }
     include(context, includeChildrenRecursively) {
         this.included = true;
@@ -10412,7 +9604,7 @@
         }
         else {
             const testValue = this.getTestValue();
-            if (typeof testValue === 'symbol') {
+            if (testValue === UnknownValue) {
                 this.includeUnknownTest(context);
             }
             else {
@@ -10422,10 +9614,12 @@
     }
     parseNode(esTreeNode) {
         this.consequentScope = new TrackingScope(this.scope);
-        this.consequent = new (this.context.getNodeConstructor(esTreeNode.consequent.type))(esTreeNode.consequent, this, this.consequentScope);
+        this.consequent = new (this.context.nodeConstructors[esTreeNode.consequent.type] ||
+            this.context.nodeConstructors.UnknownNode)(esTreeNode.consequent, this, this.consequentScope);
         if (esTreeNode.alternate) {
             this.alternateScope = new TrackingScope(this.scope);
-            this.alternate = new (this.context.getNodeConstructor(esTreeNode.alternate.type))(esTreeNode.alternate, this, this.alternateScope);
+            this.alternate = new (this.context.nodeConstructors[esTreeNode.alternate.type] ||
+                this.context.nodeConstructors.UnknownNode)(esTreeNode.alternate, this, this.alternateScope);
         }
         super.parseNode(esTreeNode);
     }
@@ -10442,7 +9636,7 @@
         else {
             code.remove(this.start, this.consequent.start);
         }
-        if (this.consequent.included && (noTreeshake || typeof testValue === 'symbol' || testValue)) {
+        if (this.consequent.included && (noTreeshake || testValue === UnknownValue || testValue)) {
             this.consequent.render(code, options);
         }
         else {
@@ -10450,7 +9644,7 @@
             hoistedDeclarations.push(...this.consequentScope.hoistedDeclarations);
         }
         if (this.alternate) {
-            if (this.alternate.included && (noTreeshake || typeof testValue === 'symbol' || !testValue)) {
+            if (this.alternate.included && (noTreeshake || testValue === UnknownValue || !testValue)) {
                 if (includesIfElse) {
                     if (code.original.charCodeAt(this.alternate.start - 1) === 101) {
                         code.prependLeft(this.alternate.start, ' ');
@@ -10473,7 +9667,6 @@
         }
         this.renderHoistedDeclarations(hoistedDeclarations, code, getPropertyAccess);
     }
-    applyDeoptimizations() { }
     getTestValue() {
         if (this.testValue === unset) {
             return (this.testValue = this.test.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this));
@@ -10485,36 +9678,36 @@
             this.test.include(context, false);
         }
         if (testValue && this.consequent.shouldBeIncluded(context)) {
-            this.consequent.include(context, false, { asSingleStatement: true });
+            this.consequent.includeAsSingleStatement(context, false);
         }
-        if (!testValue && this.alternate?.shouldBeIncluded(context)) {
-            this.alternate.include(context, false, { asSingleStatement: true });
+        if (this.alternate !== null && !testValue && this.alternate.shouldBeIncluded(context)) {
+            this.alternate.includeAsSingleStatement(context, false);
         }
     }
     includeRecursively(includeChildrenRecursively, context) {
         this.test.include(context, includeChildrenRecursively);
         this.consequent.include(context, includeChildrenRecursively);
-        this.alternate?.include(context, includeChildrenRecursively);
+        if (this.alternate !== null) {
+            this.alternate.include(context, includeChildrenRecursively);
+        }
     }
     includeUnknownTest(context) {
         this.test.include(context, false);
         const { brokenFlow } = context;
         let consequentBrokenFlow = BROKEN_FLOW_NONE;
         if (this.consequent.shouldBeIncluded(context)) {
-            this.consequent.include(context, false, { asSingleStatement: true });
-            // eslint-disable-next-line unicorn/consistent-destructuring
+            this.consequent.includeAsSingleStatement(context, false);
             consequentBrokenFlow = context.brokenFlow;
             context.brokenFlow = brokenFlow;
         }
-        if (this.alternate?.shouldBeIncluded(context)) {
-            this.alternate.include(context, false, { asSingleStatement: true });
+        if (this.alternate !== null && this.alternate.shouldBeIncluded(context)) {
+            this.alternate.includeAsSingleStatement(context, false);
             context.brokenFlow =
-                // eslint-disable-next-line unicorn/consistent-destructuring
                 context.brokenFlow < consequentBrokenFlow ? context.brokenFlow : consequentBrokenFlow;
         }
     }
     renderHoistedDeclarations(hoistedDeclarations, code, getPropertyAccess) {
-        const hoistedVariables = [
+        const hoistedVars = [
             ...new Set(hoistedDeclarations.map(identifier => {
                 const variable = identifier.variable;
                 return variable.included ? variable.getName(getPropertyAccess) : '';
@@ -10522,10 +9715,10 @@
         ]
             .filter(Boolean)
             .join(', ');
-        if (hoistedVariables) {
+        if (hoistedVars) {
             const parentType = this.parent.type;
             const needsBraces = parentType !== Program$1 && parentType !== BlockStatement$1;
-            code.prependRight(this.start, `${needsBraces ? '{ ' : ''}var ${hoistedVariables}; `);
+            code.prependRight(this.start, `${needsBraces ? '{ ' : ''}var ${hoistedVars}; `);
             if (needsBraces) {
                 code.appendLeft(this.end, ` }`);
             }
@@ -10546,11 +9739,8 @@
     }
 }
 
-class ImportAttribute extends NodeBase {
-}
-
 class ImportDeclaration extends NodeBase {
-    // Do not bind specifiers or assertions
+    // Do not bind specifiers
     bind() { }
     hasEffects() {
         return false;
@@ -10561,38 +9751,38 @@
     render(code, _options, nodeRenderOptions) {
         code.remove(nodeRenderOptions.start, nodeRenderOptions.end);
     }
-    applyDeoptimizations() { }
 }
 ImportDeclaration.prototype.needsBoundaries = true;
 
 class ImportDefaultSpecifier extends NodeBase {
-    applyDeoptimizations() { }
 }
 
 const INTEROP_DEFAULT_VARIABLE = '_interopDefault';
-const INTEROP_DEFAULT_COMPAT_VARIABLE = '_interopDefaultCompat';
+const INTEROP_DEFAULT_LEGACY_VARIABLE = '_interopDefaultLegacy';
 const INTEROP_NAMESPACE_VARIABLE = '_interopNamespace';
-const INTEROP_NAMESPACE_COMPAT_VARIABLE = '_interopNamespaceCompat';
 const INTEROP_NAMESPACE_DEFAULT_VARIABLE = '_interopNamespaceDefault';
 const INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE = '_interopNamespaceDefaultOnly';
 const MERGE_NAMESPACES_VARIABLE = '_mergeNamespaces';
 const defaultInteropHelpersByInteropType = {
     auto: INTEROP_DEFAULT_VARIABLE,
-    compat: INTEROP_DEFAULT_COMPAT_VARIABLE,
     default: null,
     defaultOnly: null,
-    esModule: null
+    esModule: null,
+    false: null,
+    true: INTEROP_DEFAULT_LEGACY_VARIABLE
 };
 const isDefaultAProperty = (interopType, externalLiveBindings) => interopType === 'esModule' ||
-    (externalLiveBindings && (interopType === 'auto' || interopType === 'compat'));
+    (externalLiveBindings && (interopType === 'auto' || interopType === 'true'));
 const namespaceInteropHelpersByInteropType = {
     auto: INTEROP_NAMESPACE_VARIABLE,
-    compat: INTEROP_NAMESPACE_COMPAT_VARIABLE,
     default: INTEROP_NAMESPACE_DEFAULT_VARIABLE,
     defaultOnly: INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE,
-    esModule: null
+    esModule: null,
+    false: null,
+    true: INTEROP_NAMESPACE_VARIABLE
 };
-const canDefaultBeTakenFromNamespace = (interopType, externalLiveBindings) => interopType !== 'esModule' && isDefaultAProperty(interopType, externalLiveBindings);
+const canDefaultBeTakenFromNamespace = (interopType, externalLiveBindings) => isDefaultAProperty(interopType, externalLiveBindings) &&
+    defaultInteropHelpersByInteropType[interopType] === INTEROP_DEFAULT_VARIABLE;
 const getHelpersBlock = (additionalHelpers, accessedGlobals, indent, snippets, liveBindings, freeze, namespaceToStringTag) => {
     const usedHelpers = new Set(additionalHelpers);
     for (const variable of HELPER_NAMES) {
@@ -10605,14 +9795,14 @@
         : '').join('');
 };
 const HELPER_GENERATORS = {
-    [INTEROP_DEFAULT_COMPAT_VARIABLE](_t, snippets, liveBindings) {
+    [INTEROP_DEFAULT_LEGACY_VARIABLE](_t, snippets, liveBindings) {
         const { _, getDirectReturnFunction, n } = snippets;
         const [left, right] = getDirectReturnFunction(['e'], {
             functionReturn: true,
             lineBreakIndent: null,
-            name: INTEROP_DEFAULT_COMPAT_VARIABLE
+            name: INTEROP_DEFAULT_LEGACY_VARIABLE
         });
-        return (`${left}${getIsCompatNamespace(snippets)}${_}?${_}` +
+        return (`${left}e${_}&&${_}typeof e${_}===${_}'object'${_}&&${_}'default'${_}in e${_}?${_}` +
             `${liveBindings ? getDefaultLiveBinding(snippets) : getDefaultStatic(snippets)}${right}${n}${n}`);
     },
     [INTEROP_DEFAULT_VARIABLE](_t, snippets, liveBindings) {
@@ -10625,32 +9815,19 @@
         return (`${left}e${_}&&${_}e.__esModule${_}?${_}` +
             `${liveBindings ? getDefaultLiveBinding(snippets) : getDefaultStatic(snippets)}${right}${n}${n}`);
     },
-    [INTEROP_NAMESPACE_COMPAT_VARIABLE](t, snippets, liveBindings, freeze, namespaceToStringTag, usedHelpers) {
-        const { _, getDirectReturnFunction, n } = snippets;
-        if (usedHelpers.has(INTEROP_NAMESPACE_DEFAULT_VARIABLE)) {
-            const [left, right] = getDirectReturnFunction(['e'], {
-                functionReturn: true,
-                lineBreakIndent: null,
-                name: INTEROP_NAMESPACE_COMPAT_VARIABLE
-            });
-            return `${left}${getIsCompatNamespace(snippets)}${_}?${_}e${_}:${_}${INTEROP_NAMESPACE_DEFAULT_VARIABLE}(e)${right}${n}${n}`;
-        }
-        return (`function ${INTEROP_NAMESPACE_COMPAT_VARIABLE}(e)${_}{${n}` +
-            `${t}if${_}(${getIsCompatNamespace(snippets)})${_}return e;${n}` +
-            createNamespaceObject(t, t, snippets, liveBindings, freeze, namespaceToStringTag) +
-            `}${n}${n}`);
-    },
-    [INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE](_t, snippets, _liveBindings, freeze, namespaceToStringTag) {
-        const { getDirectReturnFunction, getObject, n } = snippets;
+    [INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE](_t, { _, getDirectReturnFunction, getObject, n }, _liveBindings, freeze, namespaceToStringTag) {
         const [left, right] = getDirectReturnFunction(['e'], {
             functionReturn: true,
             lineBreakIndent: null,
             name: INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE
         });
-        return `${left}${getFrozen(freeze, getWithToStringTag(namespaceToStringTag, getObject([
+        return `${left}${getFrozen(getObject([
             ['__proto__', 'null'],
+            ...(namespaceToStringTag
+                ? [[null, `[Symbol.toStringTag]:${_}'Module'`]]
+                : []),
             ['default', 'e']
-        ], { lineBreakIndent: null }), snippets))}${right}${n}${n}`;
+        ], { lineBreakIndent: null }), freeze)}${right}${n}${n}`;
     },
     [INTEROP_NAMESPACE_DEFAULT_VARIABLE](t, snippets, liveBindings, freeze, namespaceToStringTag) {
         const { _, n } = snippets;
@@ -10673,122 +9850,85 @@
             createNamespaceObject(t, t, snippets, liveBindings, freeze, namespaceToStringTag) +
             `}${n}${n}`);
     },
-    [MERGE_NAMESPACES_VARIABLE](t, snippets, liveBindings, freeze, namespaceToStringTag) {
-        const { _, cnst, n } = snippets;
-        const useForEach = cnst === 'var' && liveBindings;
+    [MERGE_NAMESPACES_VARIABLE](t, snippets, liveBindings, freeze) {
+        const { _, n } = snippets;
         return (`function ${MERGE_NAMESPACES_VARIABLE}(n, m)${_}{${n}` +
             `${t}${loopOverNamespaces(`{${n}` +
                 `${t}${t}${t}if${_}(k${_}!==${_}'default'${_}&&${_}!(k in n))${_}{${n}` +
-                (liveBindings
-                    ? useForEach
-                        ? copyOwnPropertyLiveBinding
-                        : copyPropertyLiveBinding
-                    : copyPropertyStatic)(t, t + t + t + t, snippets) +
+                (liveBindings ? copyPropertyLiveBinding : copyPropertyStatic)(t, t + t + t + t, snippets) +
                 `${t}${t}${t}}${n}` +
-                `${t}${t}}`, useForEach, t, snippets)}${n}` +
-            `${t}return ${getFrozen(freeze, getWithToStringTag(namespaceToStringTag, 'n', snippets))};${n}` +
+                `${t}${t}}`, !liveBindings, t, snippets)}${n}` +
+            `${t}return ${getFrozen('n', freeze)};${n}` +
             `}${n}${n}`);
     }
 };
 const getDefaultLiveBinding = ({ _, getObject }) => `e${_}:${_}${getObject([['default', 'e']], { lineBreakIndent: null })}`;
 const getDefaultStatic = ({ _, getPropertyAccess }) => `e${getPropertyAccess('default')}${_}:${_}e`;
-const getIsCompatNamespace = ({ _ }) => `e${_}&&${_}typeof e${_}===${_}'object'${_}&&${_}'default'${_}in e`;
-const createNamespaceObject = (t, index, snippets, liveBindings, freeze, namespaceToStringTag) => {
-    const { _, cnst, getObject, getPropertyAccess, n, s } = snippets;
+const createNamespaceObject = (t, i, snippets, liveBindings, freeze, namespaceToStringTag) => {
+    const { _, cnst, getPropertyAccess, n, s } = snippets;
     const copyProperty = `{${n}` +
-        (liveBindings ? copyNonDefaultOwnPropertyLiveBinding : copyPropertyStatic)(t, index + t + t, snippets) +
-        `${index}${t}}`;
-    return (`${index}${cnst} n${_}=${_}Object.create(null${namespaceToStringTag
-        ? `,${_}{${_}[Symbol.toStringTag]:${_}${getToStringTagValue(getObject)}${_}}`
-        : ''});${n}` +
-        `${index}if${_}(e)${_}{${n}` +
-        `${index}${t}${loopOverKeys(copyProperty, !liveBindings, snippets)}${n}` +
-        `${index}}${n}` +
-        `${index}n${getPropertyAccess('default')}${_}=${_}e;${n}` +
-        `${index}return ${getFrozen(freeze, 'n')}${s}${n}`);
+        (liveBindings ? copyNonDefaultPropertyLiveBinding : copyPropertyStatic)(t, i + t + t, snippets) +
+        `${i}${t}}`;
+    return (`${i}${cnst} n${_}=${_}${namespaceToStringTag
+        ? `{__proto__:${_}null,${_}[Symbol.toStringTag]:${_}'Module'}`
+        : 'Object.create(null)'};${n}` +
+        `${i}if${_}(e)${_}{${n}` +
+        `${i}${t}${loopOverKeys(copyProperty, !liveBindings, snippets)}${n}` +
+        `${i}}${n}` +
+        `${i}n${getPropertyAccess('default')}${_}=${_}e;${n}` +
+        `${i}return ${getFrozen('n', freeze)}${s}${n}`);
 };
-const loopOverKeys = (body, allowVariableLoopVariable, { _, cnst, getFunctionIntro, s }) => cnst !== 'var' || allowVariableLoopVariable
+const loopOverKeys = (body, allowVarLoopVariable, { _, cnst, getFunctionIntro, s }) => cnst !== 'var' || allowVarLoopVariable
     ? `for${_}(${cnst} k in e)${_}${body}`
     : `Object.keys(e).forEach(${getFunctionIntro(['k'], {
         isAsync: false,
         name: null
     })}${body})${s}`;
-const loopOverNamespaces = (body, useForEach, t, { _, cnst, getDirectReturnFunction, getFunctionIntro, n }) => {
-    if (useForEach) {
-        const [left, right] = getDirectReturnFunction(['e'], {
-            functionReturn: false,
-            lineBreakIndent: { base: t, t },
+const loopOverNamespaces = (body, allowVarLoopVariable, t, { _, cnst, getDirectReturnFunction, getFunctionIntro, n }) => {
+    if (cnst !== 'var' || allowVarLoopVariable) {
+        return (`for${_}(var i${_}=${_}0;${_}i${_}<${_}m.length;${_}i++)${_}{${n}` +
+            `${t}${t}${cnst} e${_}=${_}m[i];${n}` +
+            `${t}${t}for${_}(${cnst} k in e)${_}${body}${n}${t}}`);
+    }
+    const [left, right] = getDirectReturnFunction(['e'], {
+        functionReturn: false,
+        lineBreakIndent: { base: t, t },
+        name: null
+    });
+    return (`m.forEach(${left}` +
+        `Object.keys(e).forEach(${getFunctionIntro(['k'], {
+            isAsync: false,
             name: null
-        });
-        return (`m.forEach(${left}` +
-            `e${_}&&${_}typeof e${_}!==${_}'string'${_}&&${_}!Array.isArray(e)${_}&&${_}Object.keys(e).forEach(${getFunctionIntro(['k'], {
-                isAsync: false,
-                name: null
-            })}${body})${right});`);
-    }
-    return (`for${_}(var i${_}=${_}0;${_}i${_}<${_}m.length;${_}i++)${_}{${n}` +
-        `${t}${t}${cnst} e${_}=${_}m[i];${n}` +
-        `${t}${t}if${_}(typeof e${_}!==${_}'string'${_}&&${_}!Array.isArray(e))${_}{${_}for${_}(${cnst} k in e)${_}${body}${_}}${n}${t}}`);
+        })}${body})${right});`);
 };
-const copyNonDefaultOwnPropertyLiveBinding = (t, index, snippets) => {
+const copyNonDefaultPropertyLiveBinding = (t, i, snippets) => {
     const { _, n } = snippets;
-    return (`${index}if${_}(k${_}!==${_}'default')${_}{${n}` +
-        copyOwnPropertyLiveBinding(t, index + t, snippets) +
-        `${index}}${n}`);
+    return (`${i}if${_}(k${_}!==${_}'default')${_}{${n}` +
+        copyPropertyLiveBinding(t, i + t, snippets) +
+        `${i}}${n}`);
 };
-const copyOwnPropertyLiveBinding = (t, index, { _, cnst, getDirectReturnFunction, n }) => {
+const copyPropertyLiveBinding = (t, i, { _, cnst, getDirectReturnFunction, n }) => {
     const [left, right] = getDirectReturnFunction([], {
         functionReturn: true,
         lineBreakIndent: null,
         name: null
     });
-    return (`${index}${cnst} d${_}=${_}Object.getOwnPropertyDescriptor(e,${_}k);${n}` +
-        `${index}Object.defineProperty(n,${_}k,${_}d.get${_}?${_}d${_}:${_}{${n}` +
-        `${index}${t}enumerable:${_}true,${n}` +
-        `${index}${t}get:${_}${left}e[k]${right}${n}` +
-        `${index}});${n}`);
+    return (`${i}${cnst} d${_}=${_}Object.getOwnPropertyDescriptor(e,${_}k);${n}` +
+        `${i}Object.defineProperty(n,${_}k,${_}d.get${_}?${_}d${_}:${_}{${n}` +
+        `${i}${t}enumerable:${_}true,${n}` +
+        `${i}${t}get:${_}${left}e[k]${right}${n}` +
+        `${i}});${n}`);
 };
-const copyPropertyLiveBinding = (t, index, { _, cnst, getDirectReturnFunction, n }) => {
-    const [left, right] = getDirectReturnFunction([], {
-        functionReturn: true,
-        lineBreakIndent: null,
-        name: null
-    });
-    return (`${index}${cnst} d${_}=${_}Object.getOwnPropertyDescriptor(e,${_}k);${n}` +
-        `${index}if${_}(d)${_}{${n}` +
-        `${index}${t}Object.defineProperty(n,${_}k,${_}d.get${_}?${_}d${_}:${_}{${n}` +
-        `${index}${t}${t}enumerable:${_}true,${n}` +
-        `${index}${t}${t}get:${_}${left}e[k]${right}${n}` +
-        `${index}${t}});${n}` +
-        `${index}}${n}`);
-};
-const copyPropertyStatic = (_t, index, { _, n }) => `${index}n[k]${_}=${_}e[k];${n}`;
-const getFrozen = (freeze, fragment) => freeze ? `Object.freeze(${fragment})` : fragment;
-const getWithToStringTag = (namespaceToStringTag, fragment, { _, getObject }) => namespaceToStringTag
-    ? `Object.defineProperty(${fragment},${_}Symbol.toStringTag,${_}${getToStringTagValue(getObject)})`
-    : fragment;
+const copyPropertyStatic = (_t, i, { _, n }) => `${i}n[k]${_}=${_}e[k];${n}`;
+const getFrozen = (fragment, freeze) => freeze ? `Object.freeze(${fragment})` : fragment;
 const HELPER_NAMES = Object.keys(HELPER_GENERATORS);
-function getToStringTagValue(getObject) {
-    return getObject([['value', "'Module'"]], {
-        lineBreakIndent: null
-    });
-}
 
-// TODO once ImportExpression follows official ESTree specs with "null" as
-//  default, keys.ts should be updated
 class ImportExpression extends NodeBase {
     constructor() {
         super(...arguments);
         this.inlineNamespace = null;
-        this.assertions = null;
         this.mechanism = null;
-        this.namespaceExportName = undefined;
         this.resolution = null;
-        this.resolutionString = null;
-    }
-    // Do not bind assertions
-    bind() {
-        this.source.bind();
     }
     hasEffects() {
         return true;
@@ -10804,57 +9944,37 @@
     initialise() {
         this.context.addDynamicImport(this);
     }
-    parseNode(esTreeNode) {
-        // Keep the source AST to be used by renderDynamicImport
-        super.parseNode(esTreeNode, ['source']);
-    }
     render(code, options) {
-        const { snippets: { _, getDirectReturnFunction, getObject, getPropertyAccess } } = options;
         if (this.inlineNamespace) {
+            const { snippets: { getDirectReturnFunction, getPropertyAccess } } = options;
             const [left, right] = getDirectReturnFunction([], {
                 functionReturn: true,
                 lineBreakIndent: null,
                 name: null
             });
-            code.overwrite(this.start, this.end, `Promise.resolve().then(${left}${this.inlineNamespace.getName(getPropertyAccess)}${right})`);
+            code.overwrite(this.start, this.end, `Promise.resolve().then(${left}${this.inlineNamespace.getName(getPropertyAccess)}${right})`, { contentOnly: true });
             return;
         }
         if (this.mechanism) {
-            code.overwrite(this.start, findFirstOccurrenceOutsideComment(code.original, '(', this.start + 6) + 1, this.mechanism.left);
-            code.overwrite(this.end - 1, this.end, this.mechanism.right);
+            code.overwrite(this.start, findFirstOccurrenceOutsideComment(code.original, '(', this.start + 6) + 1, this.mechanism.left, { contentOnly: true });
+            code.overwrite(this.end - 1, this.end, this.mechanism.right, { contentOnly: true });
         }
-        if (this.resolutionString) {
-            code.overwrite(this.source.start, this.source.end, this.resolutionString);
-            if (this.namespaceExportName) {
-                const [left, right] = getDirectReturnFunction(['n'], {
-                    functionReturn: true,
-                    lineBreakIndent: null,
-                    name: null
-                });
-                code.prependLeft(this.end, `.then(${left}n.${this.namespaceExportName}${right})`);
-            }
-        }
-        else {
-            this.source.render(code, options);
-        }
-        if (this.assertions !== true) {
-            if (this.arguments) {
-                code.overwrite(this.source.end, this.end - 1, '', { contentOnly: true });
-            }
-            if (this.assertions) {
-                code.appendLeft(this.end - 1, `,${_}${getObject([['assert', this.assertions]], {
-                    lineBreakIndent: null
-                })}`);
-            }
+        this.source.render(code, options);
+    }
+    renderFinalResolution(code, resolution, namespaceExportName, { getDirectReturnFunction }) {
+        code.overwrite(this.source.start, this.source.end, resolution);
+        if (namespaceExportName) {
+            const [left, right] = getDirectReturnFunction(['n'], {
+                functionReturn: true,
+                lineBreakIndent: null,
+                name: null
+            });
+            code.prependLeft(this.end, `.then(${left}n.${namespaceExportName}${right})`);
         }
     }
-    setExternalResolution(exportMode, resolution, options, snippets, pluginDriver, accessedGlobalsByScope, resolutionString, namespaceExportName, assertions) {
+    setExternalResolution(exportMode, resolution, options, snippets, pluginDriver, accessedGlobalsByScope) {
         const { format } = options;
-        this.inlineNamespace = null;
         this.resolution = resolution;
-        this.resolutionString = resolutionString;
-        this.namespaceExportName = namespaceExportName;
-        this.assertions = assertions;
         const accessedGlobals = [...(accessedImportGlobals[format] || [])];
         let helper;
         ({ helper, mechanism: this.mechanism } = this.getDynamicImportMechanismAndHelper(resolution, exportMode, options, snippets, pluginDriver));
@@ -10868,8 +9988,7 @@
     setInternalResolution(inlineNamespace) {
         this.inlineNamespace = inlineNamespace;
     }
-    applyDeoptimizations() { }
-    getDynamicImportMechanismAndHelper(resolution, exportMode, { compact, dynamicImportFunction, dynamicImportInCjs, format, generatedCode: { arrowFunctions }, interop }, { _, getDirectReturnFunction, getDirectReturnIifeLeft }, pluginDriver) {
+    getDynamicImportMechanismAndHelper(resolution, exportMode, { compact, dynamicImportFunction, format, generatedCode: { arrowFunctions }, interop }, { _, getDirectReturnFunction, getDirectReturnIifeLeft }, pluginDriver) {
         const mechanism = pluginDriver.hookFirstSync('renderDynamicImport', [
             {
                 customResolution: typeof this.resolution === 'string' ? this.resolution : null,
@@ -10884,10 +10003,6 @@
         const hasDynamicTarget = !this.resolution || typeof this.resolution === 'string';
         switch (format) {
             case 'cjs': {
-                if (dynamicImportInCjs &&
-                    (!resolution || typeof resolution === 'string' || resolution instanceof ExternalModule)) {
-                    return { helper: null, mechanism: null };
-                }
                 const helper = getInteropHelper(resolution, exportMode, interop);
                 let left = `require(`;
                 let right = `)`;
@@ -10945,7 +10060,7 @@
                     mechanism: { left, right }
                 };
             }
-            case 'system': {
+            case 'system':
                 return {
                     helper: null,
                     mechanism: {
@@ -10953,8 +10068,7 @@
                         right: ')'
                     }
                 };
-            }
-            case 'es': {
+            case 'es':
                 if (dynamicImportFunction) {
                     return {
                         helper: null,
@@ -10964,14 +10078,13 @@
                         }
                     };
                 }
-            }
         }
         return { helper: null, mechanism: null };
     }
 }
 function getInteropHelper(resolution, exportMode, interop) {
     return exportMode === 'external'
-        ? namespaceInteropHelpersByInteropType[interop(resolution instanceof ExternalModule ? resolution.id : null)]
+        ? namespaceInteropHelpersByInteropType[String(interop(resolution instanceof ExternalModule ? resolution.id : null))]
         : exportMode === 'default'
             ? INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE
             : null;
@@ -10983,11 +10096,9 @@
 };
 
 class ImportNamespaceSpecifier extends NodeBase {
-    applyDeoptimizations() { }
 }
 
 class ImportSpecifier extends NodeBase {
-    applyDeoptimizations() { }
 }
 
 class LabeledStatement extends NodeBase {
@@ -11033,51 +10144,45 @@
         this.usedBranch = null;
     }
     deoptimizeCache() {
-        if (this.usedBranch) {
+        if (this.usedBranch !== null) {
             const unusedBranch = this.usedBranch === this.left ? this.right : this.left;
             this.usedBranch = null;
             unusedBranch.deoptimizePath(UNKNOWN_PATH);
             for (const expression of this.expressionsToBeDeoptimized) {
                 expression.deoptimizeCache();
             }
-            // Request another pass because we need to ensure "include" runs again if
-            // it is rendered
-            this.context.requestTreeshakingPass();
         }
     }
     deoptimizePath(path) {
         const usedBranch = this.getUsedBranch();
-        if (usedBranch) {
-            usedBranch.deoptimizePath(path);
-        }
-        else {
+        if (usedBranch === null) {
             this.left.deoptimizePath(path);
             this.right.deoptimizePath(path);
         }
+        else {
+            usedBranch.deoptimizePath(path);
+        }
     }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        this.left.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
-        this.right.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
+        this.left.deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker);
+        this.right.deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker);
     }
     getLiteralValueAtPath(path, recursionTracker, origin) {
         const usedBranch = this.getUsedBranch();
-        if (!usedBranch)
+        if (usedBranch === null)
             return UnknownValue;
         this.expressionsToBeDeoptimized.push(origin);
         return usedBranch.getLiteralValueAtPath(path, recursionTracker, origin);
     }
-    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
+    getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin) {
         const usedBranch = this.getUsedBranch();
-        if (!usedBranch)
-            return [
-                new MultiExpression([
-                    this.left.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin)[0],
-                    this.right.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin)[0]
-                ]),
-                false
-            ];
+        if (usedBranch === null)
+            return new MultiExpression([
+                this.left.getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin),
+                this.right.getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin)
+            ]);
         this.expressionsToBeDeoptimized.push(origin);
-        return usedBranch.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
+        return usedBranch.getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin);
     }
     hasEffects(context) {
         if (this.left.hasEffects(context)) {
@@ -11088,20 +10193,36 @@
         }
         return false;
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
+    hasEffectsWhenAccessedAtPath(path, context) {
+        const usedBranch = this.getUsedBranch();
+        if (usedBranch === null) {
+            return (this.left.hasEffectsWhenAccessedAtPath(path, context) ||
+                this.right.hasEffectsWhenAccessedAtPath(path, context));
+        }
+        return usedBranch.hasEffectsWhenAccessedAtPath(path, context);
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
         const usedBranch = this.getUsedBranch();
-        if (!usedBranch) {
-            return (this.left.hasEffectsOnInteractionAtPath(path, interaction, context) ||
-                this.right.hasEffectsOnInteractionAtPath(path, interaction, context));
+        if (usedBranch === null) {
+            return (this.left.hasEffectsWhenAssignedAtPath(path, context) ||
+                this.right.hasEffectsWhenAssignedAtPath(path, context));
         }
-        return usedBranch.hasEffectsOnInteractionAtPath(path, interaction, context);
+        return usedBranch.hasEffectsWhenAssignedAtPath(path, context);
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        const usedBranch = this.getUsedBranch();
+        if (usedBranch === null) {
+            return (this.left.hasEffectsWhenCalledAtPath(path, callOptions, context) ||
+                this.right.hasEffectsWhenCalledAtPath(path, callOptions, context));
+        }
+        return usedBranch.hasEffectsWhenCalledAtPath(path, callOptions, context);
     }
     include(context, includeChildrenRecursively) {
         this.included = true;
         const usedBranch = this.getUsedBranch();
         if (includeChildrenRecursively ||
             (usedBranch === this.right && this.left.shouldBeIncluded(context)) ||
-            !usedBranch) {
+            usedBranch === null) {
             this.left.include(context, includeChildrenRecursively);
             this.right.include(context, includeChildrenRecursively);
         }
@@ -11142,7 +10263,7 @@
         if (!this.isBranchResolutionAnalysed) {
             this.isBranchResolutionAnalysed = true;
             const leftValue = this.left.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
-            if (typeof leftValue === 'symbol') {
+            if (leftValue === UnknownValue) {
                 return null;
             }
             else {
@@ -11158,78 +10279,502 @@
     }
 }
 
+function spaces(i) {
+    let result = '';
+    while (i--)
+        result += ' ';
+    return result;
+}
+function tabsToSpaces(str) {
+    return str.replace(/^\t+/, match => match.split('\t').join('  '));
+}
+function getCodeFrame(source, line, column) {
+    let lines = source.split('\n');
+    const frameStart = Math.max(0, line - 3);
+    let frameEnd = Math.min(line + 2, lines.length);
+    lines = lines.slice(frameStart, frameEnd);
+    while (!/\S/.test(lines[lines.length - 1])) {
+        lines.pop();
+        frameEnd -= 1;
+    }
+    const digits = String(frameEnd).length;
+    return lines
+        .map((str, i) => {
+        const isErrorLine = frameStart + i + 1 === line;
+        let lineNum = String(i + frameStart + 1);
+        while (lineNum.length < digits)
+            lineNum = ` ${lineNum}`;
+        if (isErrorLine) {
+            const indicator = spaces(digits + 2 + tabsToSpaces(str.slice(0, column)).length) + '^';
+            return `${lineNum}: ${tabsToSpaces(str)}\n${indicator}`;
+        }
+        return `${lineNum}: ${tabsToSpaces(str)}`;
+    })
+        .join('\n');
+}
+
+function error(base) {
+    if (!(base instanceof Error))
+        base = Object.assign(new Error(base.message), base);
+    throw base;
+}
+function augmentCodeLocation(props, pos, source, id) {
+    if (typeof pos === 'object') {
+        const { line, column } = pos;
+        props.loc = { column, file: id, line };
+    }
+    else {
+        props.pos = pos;
+        const { line, column } = locate(source, pos, { offsetLine: 1 });
+        props.loc = { column, file: id, line };
+    }
+    if (props.frame === undefined) {
+        const { line, column } = props.loc;
+        props.frame = getCodeFrame(source, line, column);
+    }
+}
+var Errors;
+(function (Errors) {
+    Errors["ALREADY_CLOSED"] = "ALREADY_CLOSED";
+    Errors["ASSET_NOT_FINALISED"] = "ASSET_NOT_FINALISED";
+    Errors["ASSET_NOT_FOUND"] = "ASSET_NOT_FOUND";
+    Errors["ASSET_SOURCE_ALREADY_SET"] = "ASSET_SOURCE_ALREADY_SET";
+    Errors["ASSET_SOURCE_MISSING"] = "ASSET_SOURCE_MISSING";
+    Errors["BAD_LOADER"] = "BAD_LOADER";
+    Errors["CANNOT_EMIT_FROM_OPTIONS_HOOK"] = "CANNOT_EMIT_FROM_OPTIONS_HOOK";
+    Errors["CHUNK_NOT_GENERATED"] = "CHUNK_NOT_GENERATED";
+    Errors["CHUNK_INVALID"] = "CHUNK_INVALID";
+    Errors["CIRCULAR_REEXPORT"] = "CIRCULAR_REEXPORT";
+    Errors["CYCLIC_CROSS_CHUNK_REEXPORT"] = "CYCLIC_CROSS_CHUNK_REEXPORT";
+    Errors["DEPRECATED_FEATURE"] = "DEPRECATED_FEATURE";
+    Errors["EXTERNAL_SYNTHETIC_EXPORTS"] = "EXTERNAL_SYNTHETIC_EXPORTS";
+    Errors["FILE_NAME_CONFLICT"] = "FILE_NAME_CONFLICT";
+    Errors["FILE_NOT_FOUND"] = "FILE_NOT_FOUND";
+    Errors["INPUT_HOOK_IN_OUTPUT_PLUGIN"] = "INPUT_HOOK_IN_OUTPUT_PLUGIN";
+    Errors["INVALID_CHUNK"] = "INVALID_CHUNK";
+    Errors["INVALID_EXPORT_OPTION"] = "INVALID_EXPORT_OPTION";
+    Errors["INVALID_EXTERNAL_ID"] = "INVALID_EXTERNAL_ID";
+    Errors["INVALID_OPTION"] = "INVALID_OPTION";
+    Errors["INVALID_PLUGIN_HOOK"] = "INVALID_PLUGIN_HOOK";
+    Errors["INVALID_ROLLUP_PHASE"] = "INVALID_ROLLUP_PHASE";
+    Errors["MISSING_EXPORT"] = "MISSING_EXPORT";
+    Errors["MISSING_IMPLICIT_DEPENDANT"] = "MISSING_IMPLICIT_DEPENDANT";
+    Errors["MIXED_EXPORTS"] = "MIXED_EXPORTS";
+    Errors["NAMESPACE_CONFLICT"] = "NAMESPACE_CONFLICT";
+    Errors["AMBIGUOUS_EXTERNAL_NAMESPACES"] = "AMBIGUOUS_EXTERNAL_NAMESPACES";
+    Errors["NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE"] = "NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE";
+    Errors["PLUGIN_ERROR"] = "PLUGIN_ERROR";
+    Errors["PREFER_NAMED_EXPORTS"] = "PREFER_NAMED_EXPORTS";
+    Errors["SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT"] = "SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT";
+    Errors["UNEXPECTED_NAMED_IMPORT"] = "UNEXPECTED_NAMED_IMPORT";
+    Errors["UNRESOLVED_ENTRY"] = "UNRESOLVED_ENTRY";
+    Errors["UNRESOLVED_IMPORT"] = "UNRESOLVED_IMPORT";
+    Errors["VALIDATION_ERROR"] = "VALIDATION_ERROR";
+})(Errors || (Errors = {}));
+function errAssetNotFinalisedForFileName(name) {
+    return {
+        code: Errors.ASSET_NOT_FINALISED,
+        message: `Plugin error - Unable to get file name for asset "${name}". Ensure that the source is set and that generate is called first.`
+    };
+}
+function errCannotEmitFromOptionsHook() {
+    return {
+        code: Errors.CANNOT_EMIT_FROM_OPTIONS_HOOK,
+        message: `Cannot emit files or set asset sources in the "outputOptions" hook, use the "renderStart" hook instead.`
+    };
+}
+function errChunkNotGeneratedForFileName(name) {
+    return {
+        code: Errors.CHUNK_NOT_GENERATED,
+        message: `Plugin error - Unable to get file name for chunk "${name}". Ensure that generate is called first.`
+    };
+}
+function errChunkInvalid({ fileName, code }, exception) {
+    const errorProps = {
+        code: Errors.CHUNK_INVALID,
+        message: `Chunk "${fileName}" is not valid JavaScript: ${exception.message}.`
+    };
+    augmentCodeLocation(errorProps, exception.loc, code, fileName);
+    return errorProps;
+}
+function errCircularReexport(exportName, importedModule) {
+    return {
+        code: Errors.CIRCULAR_REEXPORT,
+        id: importedModule,
+        message: `"${exportName}" cannot be exported from ${relativeId(importedModule)} as it is a reexport that references itself.`
+    };
+}
+function errCyclicCrossChunkReexport(exportName, exporter, reexporter, importer) {
+    return {
+        code: Errors.CYCLIC_CROSS_CHUNK_REEXPORT,
+        exporter,
+        importer,
+        message: `Export "${exportName}" of module ${relativeId(exporter)} was reexported through module ${relativeId(reexporter)} while both modules are dependencies of each other and will end up in different chunks by current Rollup settings. This scenario is not well supported at the moment as it will produce a circular dependency between chunks and will likely lead to broken execution order.\nEither change the import in ${relativeId(importer)} to point directly to the exporting module or do not use "preserveModules" to ensure these modules end up in the same chunk.`,
+        reexporter
+    };
+}
+function errAssetReferenceIdNotFoundForSetSource(assetReferenceId) {
+    return {
+        code: Errors.ASSET_NOT_FOUND,
+        message: `Plugin error - Unable to set the source for unknown asset "${assetReferenceId}".`
+    };
+}
+function errAssetSourceAlreadySet(name) {
+    return {
+        code: Errors.ASSET_SOURCE_ALREADY_SET,
+        message: `Unable to set the source for asset "${name}", source already set.`
+    };
+}
+function errNoAssetSourceSet(assetName) {
+    return {
+        code: Errors.ASSET_SOURCE_MISSING,
+        message: `Plugin error creating asset "${assetName}" - no asset source set.`
+    };
+}
+function errBadLoader(id) {
+    return {
+        code: Errors.BAD_LOADER,
+        message: `Error loading ${relativeId(id)}: plugin load hook should return a string, a { code, map } object, or nothing/null`
+    };
+}
+function errDeprecation(deprecation) {
+    return {
+        code: Errors.DEPRECATED_FEATURE,
+        ...(typeof deprecation === 'string' ? { message: deprecation } : deprecation)
+    };
+}
+function errFileReferenceIdNotFoundForFilename(assetReferenceId) {
+    return {
+        code: Errors.FILE_NOT_FOUND,
+        message: `Plugin error - Unable to get file name for unknown file "${assetReferenceId}".`
+    };
+}
+function errFileNameConflict(fileName) {
+    return {
+        code: Errors.FILE_NAME_CONFLICT,
+        message: `The emitted file "${fileName}" overwrites a previously emitted file of the same name.`
+    };
+}
+function errInputHookInOutputPlugin(pluginName, hookName) {
+    return {
+        code: Errors.INPUT_HOOK_IN_OUTPUT_PLUGIN,
+        message: `The "${hookName}" hook used by the output plugin ${pluginName} is a build time hook and will not be run for that plugin. Either this plugin cannot be used as an output plugin, or it should have an option to configure it as an output plugin.`
+    };
+}
+function errCannotAssignModuleToChunk(moduleId, assignToAlias, currentAlias) {
+    return {
+        code: Errors.INVALID_CHUNK,
+        message: `Cannot assign ${relativeId(moduleId)} to the "${assignToAlias}" chunk as it is already in the "${currentAlias}" chunk.`
+    };
+}
+function errInvalidExportOptionValue(optionValue) {
+    return {
+        code: Errors.INVALID_EXPORT_OPTION,
+        message: `"output.exports" must be "default", "named", "none", "auto", or left unspecified (defaults to "auto"), received "${optionValue}"`,
+        url: `https://rollupjs.org/guide/en/#outputexports`
+    };
+}
+function errIncompatibleExportOptionValue(optionValue, keys, entryModule) {
+    return {
+        code: 'INVALID_EXPORT_OPTION',
+        message: `"${optionValue}" was specified for "output.exports", but entry module "${relativeId(entryModule)}" has the following exports: ${keys.join(', ')}`
+    };
+}
+function errInternalIdCannotBeExternal(source, importer) {
+    return {
+        code: Errors.INVALID_EXTERNAL_ID,
+        message: `'${source}' is imported as an external by ${relativeId(importer)}, but is already an existing non-external module id.`
+    };
+}
+function errInvalidOption(option, urlHash, explanation, value) {
+    return {
+        code: Errors.INVALID_OPTION,
+        message: `Invalid value ${value !== undefined ? `${JSON.stringify(value)} ` : ''}for option "${option}" - ${explanation}.`,
+        url: `https://rollupjs.org/guide/en/#${urlHash}`
+    };
+}
+function errInvalidRollupPhaseForAddWatchFile() {
+    return {
+        code: Errors.INVALID_ROLLUP_PHASE,
+        message: `Cannot call addWatchFile after the build has finished.`
+    };
+}
+function errInvalidRollupPhaseForChunkEmission() {
+    return {
+        code: Errors.INVALID_ROLLUP_PHASE,
+        message: `Cannot emit chunks after module loading has finished.`
+    };
+}
+function errMissingExport(exportName, importingModule, importedModule) {
+    return {
+        code: Errors.MISSING_EXPORT,
+        message: `'${exportName}' is not exported by ${relativeId(importedModule)}, imported by ${relativeId(importingModule)}`,
+        url: `https://rollupjs.org/guide/en/#error-name-is-not-exported-by-module`
+    };
+}
+function errImplicitDependantCannotBeExternal(unresolvedId, implicitlyLoadedBefore) {
+    return {
+        code: Errors.MISSING_IMPLICIT_DEPENDANT,
+        message: `Module "${relativeId(unresolvedId)}" that should be implicitly loaded before "${relativeId(implicitlyLoadedBefore)}" cannot be external.`
+    };
+}
+function errUnresolvedImplicitDependant(unresolvedId, implicitlyLoadedBefore) {
+    return {
+        code: Errors.MISSING_IMPLICIT_DEPENDANT,
+        message: `Module "${relativeId(unresolvedId)}" that should be implicitly loaded before "${relativeId(implicitlyLoadedBefore)}" could not be resolved.`
+    };
+}
+function errImplicitDependantIsNotIncluded(module) {
+    const implicitDependencies = Array.from(module.implicitlyLoadedBefore, dependency => relativeId(dependency.id)).sort();
+    return {
+        code: Errors.MISSING_IMPLICIT_DEPENDANT,
+        message: `Module "${relativeId(module.id)}" that should be implicitly loaded before ${printQuotedStringList(implicitDependencies)} is not included in the module graph. Either it was not imported by an included module or only via a tree-shaken dynamic import, or no imported bindings were used and it had otherwise no side-effects.`
+    };
+}
+function errMixedExport(facadeModuleId, name) {
+    return {
+        code: Errors.MIXED_EXPORTS,
+        id: facadeModuleId,
+        message: `Entry module "${relativeId(facadeModuleId)}" is using named and default exports together. Consumers of your bundle will have to use \`${name || 'chunk'}["default"]\` to access the default export, which may not be what you want. Use \`output.exports: "named"\` to disable this warning`,
+        url: `https://rollupjs.org/guide/en/#outputexports`
+    };
+}
+function errNamespaceConflict(name, reexportingModule, additionalExportAllModule) {
+    return {
+        code: Errors.NAMESPACE_CONFLICT,
+        message: `Conflicting namespaces: "${relativeId(reexportingModule.id)}" re-exports "${name}" from both "${relativeId(reexportingModule.exportsAll[name])}" and "${relativeId(additionalExportAllModule.exportsAll[name])}" (will be ignored)`,
+        name,
+        reexporter: reexportingModule.id,
+        sources: [reexportingModule.exportsAll[name], additionalExportAllModule.exportsAll[name]]
+    };
+}
+function errAmbiguousExternalNamespaces(name, reexportingModule, usedExternalModule, externalModules) {
+    return {
+        code: Errors.AMBIGUOUS_EXTERNAL_NAMESPACES,
+        message: `Ambiguous external namespace resolution: "${relativeId(reexportingModule)}" re-exports "${name}" from one of the external modules ${printQuotedStringList(externalModules.map(module => relativeId(module)))}, guessing "${relativeId(usedExternalModule)}".`,
+        name,
+        reexporter: reexportingModule,
+        sources: externalModules
+    };
+}
+function errNoTransformMapOrAstWithoutCode(pluginName) {
+    return {
+        code: Errors.NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE,
+        message: `The plugin "${pluginName}" returned a "map" or "ast" without returning ` +
+            'a "code". This will be ignored.'
+    };
+}
+function errPreferNamedExports(facadeModuleId) {
+    const file = relativeId(facadeModuleId);
+    return {
+        code: Errors.PREFER_NAMED_EXPORTS,
+        id: facadeModuleId,
+        message: `Entry module "${file}" is implicitly using "default" export mode, which means for CommonJS output that its default export is assigned to "module.exports". For many tools, such CommonJS output will not be interchangeable with the original ES module. If this is intended, explicitly set "output.exports" to either "auto" or "default", otherwise you might want to consider changing the signature of "${file}" to use named exports only.`,
+        url: `https://rollupjs.org/guide/en/#outputexports`
+    };
+}
+function errSyntheticNamedExportsNeedNamespaceExport(id, syntheticNamedExportsOption) {
+    return {
+        code: Errors.SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT,
+        id,
+        message: `Module "${relativeId(id)}" that is marked with 'syntheticNamedExports: ${JSON.stringify(syntheticNamedExportsOption)}' needs ${typeof syntheticNamedExportsOption === 'string' && syntheticNamedExportsOption !== 'default'
+            ? `an export named "${syntheticNamedExportsOption}"`
+            : 'a default export'} that does not reexport an unresolved named export of the same module.`
+    };
+}
+function errUnexpectedNamedImport(id, imported, isReexport) {
+    const importType = isReexport ? 'reexport' : 'import';
+    return {
+        code: Errors.UNEXPECTED_NAMED_IMPORT,
+        id,
+        message: `The named export "${imported}" was ${importType}ed from the external module ${relativeId(id)} even though its interop type is "defaultOnly". Either remove or change this ${importType} or change the value of the "output.interop" option.`,
+        url: 'https://rollupjs.org/guide/en/#outputinterop'
+    };
+}
+function errUnexpectedNamespaceReexport(id) {
+    return {
+        code: Errors.UNEXPECTED_NAMED_IMPORT,
+        id,
+        message: `There was a namespace "*" reexport from the external module ${relativeId(id)} even though its interop type is "defaultOnly". This will be ignored as namespace reexports only reexport named exports. If this is not intended, either remove or change this reexport or change the value of the "output.interop" option.`,
+        url: 'https://rollupjs.org/guide/en/#outputinterop'
+    };
+}
+function errEntryCannotBeExternal(unresolvedId) {
+    return {
+        code: Errors.UNRESOLVED_ENTRY,
+        message: `Entry module cannot be external (${relativeId(unresolvedId)}).`
+    };
+}
+function errUnresolvedEntry(unresolvedId) {
+    return {
+        code: Errors.UNRESOLVED_ENTRY,
+        message: `Could not resolve entry module (${relativeId(unresolvedId)}).`
+    };
+}
+function errUnresolvedImport(source, importer) {
+    return {
+        code: Errors.UNRESOLVED_IMPORT,
+        message: `Could not resolve '${source}' from ${relativeId(importer)}`
+    };
+}
+function errUnresolvedImportTreatedAsExternal(source, importer) {
+    return {
+        code: Errors.UNRESOLVED_IMPORT,
+        importer: relativeId(importer),
+        message: `'${source}' is imported by ${relativeId(importer)}, but could not be resolved – treating it as an external dependency`,
+        source,
+        url: 'https://rollupjs.org/guide/en/#warning-treating-module-as-external-dependency'
+    };
+}
+function errExternalSyntheticExports(source, importer) {
+    return {
+        code: Errors.EXTERNAL_SYNTHETIC_EXPORTS,
+        importer: relativeId(importer),
+        message: `External '${source}' can not have 'syntheticNamedExports' enabled.`,
+        source
+    };
+}
+function errFailedValidation(message) {
+    return {
+        code: Errors.VALIDATION_ERROR,
+        message
+    };
+}
+function errAlreadyClosed() {
+    return {
+        code: Errors.ALREADY_CLOSED,
+        message: 'Bundle is already closed, no more calls to "generate" or "write" are allowed.'
+    };
+}
+function warnDeprecation(deprecation, activeDeprecation, options) {
+    warnDeprecationWithOptions(deprecation, activeDeprecation, options.onwarn, options.strictDeprecations);
+}
+function warnDeprecationWithOptions(deprecation, activeDeprecation, warn, strictDeprecations) {
+    if (activeDeprecation || strictDeprecations) {
+        const warning = errDeprecation(deprecation);
+        if (strictDeprecations) {
+            return error(warning);
+        }
+        warn(warning);
+    }
+}
+
+const ASSET_PREFIX = 'ROLLUP_ASSET_URL_';
+const CHUNK_PREFIX = 'ROLLUP_CHUNK_URL_';
 const FILE_PREFIX = 'ROLLUP_FILE_URL_';
-const IMPORT = 'import';
 class MetaProperty extends NodeBase {
-    constructor() {
-        super(...arguments);
-        this.metaProperty = null;
-        this.preliminaryChunkId = null;
-        this.referenceId = null;
+    addAccessedGlobals(format, accessedGlobalsByScope) {
+        const metaProperty = this.metaProperty;
+        const accessedGlobals = (metaProperty &&
+            (metaProperty.startsWith(FILE_PREFIX) ||
+                metaProperty.startsWith(ASSET_PREFIX) ||
+                metaProperty.startsWith(CHUNK_PREFIX))
+            ? accessedFileUrlGlobals
+            : accessedMetaUrlGlobals)[format];
+        if (accessedGlobals.length > 0) {
+            this.scope.addAccessedGlobals(accessedGlobals, accessedGlobalsByScope);
+        }
     }
     getReferencedFileName(outputPluginDriver) {
-        const { meta: { name }, metaProperty } = this;
-        if (name === IMPORT && metaProperty?.startsWith(FILE_PREFIX)) {
-            return outputPluginDriver.getFileName(metaProperty.slice(FILE_PREFIX.length));
+        const metaProperty = this.metaProperty;
+        if (metaProperty && metaProperty.startsWith(FILE_PREFIX)) {
+            return outputPluginDriver.getFileName(metaProperty.substr(FILE_PREFIX.length));
         }
         return null;
     }
     hasEffects() {
         return false;
     }
-    hasEffectsOnInteractionAtPath(path, { type }) {
-        return path.length > 1 || type !== INTERACTION_ACCESSED;
+    hasEffectsWhenAccessedAtPath(path) {
+        return path.length > 1;
     }
     include() {
         if (!this.included) {
             this.included = true;
-            if (this.meta.name === IMPORT) {
+            if (this.meta.name === 'import') {
                 this.context.addImportMeta(this);
                 const parent = this.parent;
-                const metaProperty = (this.metaProperty =
+                this.metaProperty =
                     parent instanceof MemberExpression && typeof parent.propertyKey === 'string'
                         ? parent.propertyKey
-                        : null);
-                if (metaProperty?.startsWith(FILE_PREFIX)) {
-                    this.referenceId = metaProperty.slice(FILE_PREFIX.length);
-                }
+                        : null;
             }
         }
     }
-    render(code, { format, pluginDriver, snippets }) {
-        const { context: { module: { id: moduleId } }, meta: { name }, metaProperty, parent, preliminaryChunkId, referenceId, start, end } = this;
-        if (name !== IMPORT)
-            return;
-        const chunkId = preliminaryChunkId;
-        if (referenceId) {
-            const fileName = pluginDriver.getFileName(referenceId);
+    renderFinalMechanism(code, chunkId, format, snippets, outputPluginDriver) {
+        var _a;
+        const parent = this.parent;
+        const metaProperty = this.metaProperty;
+        if (metaProperty &&
+            (metaProperty.startsWith(FILE_PREFIX) ||
+                metaProperty.startsWith(ASSET_PREFIX) ||
+                metaProperty.startsWith(CHUNK_PREFIX))) {
+            let referenceId = null;
+            let assetReferenceId = null;
+            let chunkReferenceId = null;
+            let fileName;
+            if (metaProperty.startsWith(FILE_PREFIX)) {
+                referenceId = metaProperty.substr(FILE_PREFIX.length);
+                fileName = outputPluginDriver.getFileName(referenceId);
+            }
+            else if (metaProperty.startsWith(ASSET_PREFIX)) {
+                warnDeprecation(`Using the "${ASSET_PREFIX}" prefix to reference files is deprecated. Use the "${FILE_PREFIX}" prefix instead.`, true, this.context.options);
+                assetReferenceId = metaProperty.substr(ASSET_PREFIX.length);
+                fileName = outputPluginDriver.getFileName(assetReferenceId);
+            }
+            else {
+                warnDeprecation(`Using the "${CHUNK_PREFIX}" prefix to reference files is deprecated. Use the "${FILE_PREFIX}" prefix instead.`, true, this.context.options);
+                chunkReferenceId = metaProperty.substr(CHUNK_PREFIX.length);
+                fileName = outputPluginDriver.getFileName(chunkReferenceId);
+            }
             const relativePath = normalize(relative$1(dirname(chunkId), fileName));
-            const replacement = pluginDriver.hookFirstSync('resolveFileUrl', [
-                { chunkId, fileName, format, moduleId, referenceId, relativePath }
-            ]) || relativeUrlMechanisms[format](relativePath);
+            let replacement;
+            if (assetReferenceId !== null) {
+                replacement = outputPluginDriver.hookFirstSync('resolveAssetUrl', [
+                    {
+                        assetFileName: fileName,
+                        chunkId,
+                        format,
+                        moduleId: this.context.module.id,
+                        relativeAssetPath: relativePath
+                    }
+                ]);
+            }
+            if (!replacement) {
+                replacement =
+                    outputPluginDriver.hookFirstSync('resolveFileUrl', [
+                        {
+                            assetReferenceId,
+                            chunkId,
+                            chunkReferenceId,
+                            fileName,
+                            format,
+                            moduleId: this.context.module.id,
+                            referenceId: referenceId || assetReferenceId || chunkReferenceId,
+                            relativePath
+                        }
+                    ]) || relativeUrlMechanisms[format](relativePath);
+            }
             code.overwrite(parent.start, parent.end, replacement, { contentOnly: true });
             return;
         }
-        const replacement = pluginDriver.hookFirstSync('resolveImportMeta', [
+        const replacement = outputPluginDriver.hookFirstSync('resolveImportMeta', [
             metaProperty,
-            { chunkId, format, moduleId }
-        ]) || importMetaMechanisms[format]?.(metaProperty, { chunkId, snippets });
+            {
+                chunkId,
+                format,
+                moduleId: this.context.module.id
+            }
+        ]) || ((_a = importMetaMechanisms[format]) === null || _a === void 0 ? void 0 : _a.call(importMetaMechanisms, metaProperty, { chunkId, snippets }));
         if (typeof replacement === 'string') {
             if (parent instanceof MemberExpression) {
                 code.overwrite(parent.start, parent.end, replacement, { contentOnly: true });
             }
             else {
-                code.overwrite(start, end, replacement, { contentOnly: true });
+                code.overwrite(this.start, this.end, replacement, { contentOnly: true });
             }
         }
     }
-    setResolution(format, accessedGlobalsByScope, preliminaryChunkId) {
-        this.preliminaryChunkId = preliminaryChunkId;
-        const accessedGlobals = (this.metaProperty?.startsWith(FILE_PREFIX) ? accessedFileUrlGlobals : accessedMetaUrlGlobals)[format];
-        if (accessedGlobals.length > 0) {
-            this.scope.addAccessedGlobals(accessedGlobals, accessedGlobalsByScope);
-        }
-    }
 }
 const accessedMetaUrlGlobals = {
     amd: ['document', 'module', 'URL'],
@@ -11248,16 +10793,16 @@
     umd: ['document', 'require', 'URL']
 };
 const getResolveUrl = (path, URL = 'URL') => `new ${URL}(${path}).href`;
-const getRelativeUrlFromDocument = (relativePath, umd = false) => getResolveUrl(`'${escapeId(relativePath)}', ${umd ? `typeof document === 'undefined' ? location.href : ` : ''}document.currentScript && document.currentScript.src || document.baseURI`);
-const getGenericImportMetaMechanism = (getUrl) => (property, { chunkId }) => {
+const getRelativeUrlFromDocument = (relativePath, umd = false) => getResolveUrl(`'${relativePath}', ${umd ? `typeof document === 'undefined' ? location.href : ` : ''}document.currentScript && document.currentScript.src || document.baseURI`);
+const getGenericImportMetaMechanism = (getUrl) => (prop, { chunkId }) => {
     const urlMechanism = getUrl(chunkId);
-    return property === null
+    return prop === null
         ? `({ url: ${urlMechanism} })`
-        : property === 'url'
+        : prop === 'url'
             ? urlMechanism
             : 'undefined';
 };
-const getUrlFromDocument = (chunkId, umd = false) => `${umd ? `typeof document === 'undefined' ? location.href : ` : ''}(document.currentScript && document.currentScript.src || new URL('${escapeId(chunkId)}', document.baseURI).href)`;
+const getUrlFromDocument = (chunkId, umd = false) => `${umd ? `typeof document === 'undefined' ? location.href : ` : ''}(document.currentScript && document.currentScript.src || new URL('${chunkId}', document.baseURI).href)`;
 const relativeUrlMechanisms = {
     amd: relativePath => {
         if (relativePath[0] !== '.')
@@ -11274,56 +10819,38 @@
     amd: getGenericImportMetaMechanism(() => getResolveUrl(`module.uri, document.baseURI`)),
     cjs: getGenericImportMetaMechanism(chunkId => `(typeof document === 'undefined' ? ${getResolveUrl(`'file:' + __filename`, `(require('u' + 'rl').URL)`)} : ${getUrlFromDocument(chunkId)})`),
     iife: getGenericImportMetaMechanism(chunkId => getUrlFromDocument(chunkId)),
-    system: (property, { snippets: { getPropertyAccess } }) => property === null ? `module.meta` : `module.meta${getPropertyAccess(property)}`,
+    system: (prop, { snippets: { getPropertyAccess } }) => prop === null ? `module.meta` : `module.meta${getPropertyAccess(prop)}`,
     umd: getGenericImportMetaMechanism(chunkId => `(typeof document === 'undefined' && typeof location === 'undefined' ? ${getResolveUrl(`'file:' + __filename`, `(require('u' + 'rl').URL)`)} : ${getUrlFromDocument(chunkId, true)})`)
 };
 
 class NewExpression extends NodeBase {
-    hasEffects(context) {
-        try {
-            for (const argument of this.arguments) {
-                if (argument.hasEffects(context))
-                    return true;
-            }
-            if (this.context.options.treeshake.annotations &&
-                this.annotations) {
-                return false;
-            }
-            return (this.callee.hasEffects(context) ||
-                this.callee.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.interaction, context));
-        }
-        finally {
-            if (!this.deoptimized)
-                this.applyDeoptimizations();
-        }
-    }
-    hasEffectsOnInteractionAtPath(path, { type }) {
-        return path.length > 0 || type !== INTERACTION_ACCESSED;
+    constructor() {
+        super(...arguments);
+        this.deoptimized = false;
     }
-    include(context, includeChildrenRecursively) {
+    hasEffects(context) {
         if (!this.deoptimized)
             this.applyDeoptimizations();
-        if (includeChildrenRecursively) {
-            super.include(context, includeChildrenRecursively);
-        }
-        else {
-            this.included = true;
-            this.callee.include(context, false);
+        for (const argument of this.arguments) {
+            if (argument.hasEffects(context))
+                return true;
         }
-        this.callee.includeCallArguments(context, this.arguments);
+        if (this.context.options.treeshake.annotations &&
+            this.annotations)
+            return false;
+        return (this.callee.hasEffects(context) ||
+            this.callee.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.callOptions, context));
+    }
+    hasEffectsWhenAccessedAtPath(path) {
+        return path.length > 0;
     }
     initialise() {
-        this.interaction = {
+        this.callOptions = {
             args: this.arguments,
-            thisArg: null,
-            type: INTERACTION_CALLED,
+            thisParam: null,
             withNew: true
         };
     }
-    render(code, options) {
-        this.callee.render(code, options);
-        renderCallArguments(code, options, this);
-    }
     applyDeoptimizations() {
         this.deoptimized = true;
         for (const argument of this.arguments) {
@@ -11345,17 +10872,23 @@
     deoptimizePath(path) {
         this.getObjectEntity().deoptimizePath(path);
     }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        this.getObjectEntity().deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
+        this.getObjectEntity().deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker);
     }
     getLiteralValueAtPath(path, recursionTracker, origin) {
         return this.getObjectEntity().getLiteralValueAtPath(path, recursionTracker, origin);
     }
-    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
-        return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
+    getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin) {
+        return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin);
+    }
+    hasEffectsWhenAccessedAtPath(path, context) {
+        return this.getObjectEntity().hasEffectsWhenAccessedAtPath(path, context);
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        return this.getObjectEntity().hasEffectsWhenAssignedAtPath(path, context);
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        return this.getObjectEntity().hasEffectsOnInteractionAtPath(path, interaction, context);
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        return this.getObjectEntity().hasEffectsWhenCalledAtPath(path, callOptions, context);
     }
     render(code, options, { renderedSurroundingElement } = BLANK) {
         super.render(code, options);
@@ -11365,7 +10898,6 @@
             code.prependLeft(this.end, ')');
         }
     }
-    applyDeoptimizations() { }
     getObjectEntity() {
         if (this.objectEntity !== null) {
             return this.objectEntity;
@@ -11380,7 +10912,7 @@
             let key;
             if (property.computed) {
                 const keyValue = property.key.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
-                if (typeof keyValue === 'symbol') {
+                if (keyValue === UnknownValue) {
                     properties.push({ key: UnknownKey, kind: property.kind, property });
                     continue;
                 }
@@ -11410,49 +10942,10 @@
 class PrivateIdentifier extends NodeBase {
 }
 
-class Program extends NodeBase {
-    constructor() {
-        super(...arguments);
-        this.hasCachedEffect = false;
-    }
-    hasEffects(context) {
-        // We are caching here to later more efficiently identify side-effect-free modules
-        if (this.hasCachedEffect)
-            return true;
-        for (const node of this.body) {
-            if (node.hasEffects(context)) {
-                return (this.hasCachedEffect = true);
-            }
-        }
-        return false;
-    }
-    include(context, includeChildrenRecursively) {
-        this.included = true;
-        for (const node of this.body) {
-            if (includeChildrenRecursively || node.shouldBeIncluded(context)) {
-                node.include(context, includeChildrenRecursively);
-            }
-        }
-    }
-    render(code, options) {
-        let start = this.start;
-        if (code.original.startsWith('#!')) {
-            start = Math.min(code.original.indexOf('\n') + 1, this.end);
-            code.remove(0, start);
-        }
-        if (this.body.length > 0) {
-            renderStatementList(this.body, code, start, this.end, options);
-        }
-        else {
-            super.render(code, options);
-        }
-    }
-    applyDeoptimizations() { }
-}
-
 class Property extends MethodBase {
     constructor() {
         super(...arguments);
+        this.deoptimized = false;
         this.declarationInit = null;
     }
     declare(kind, init) {
@@ -11488,40 +10981,51 @@
 
 class PropertyDefinition extends NodeBase {
     deoptimizePath(path) {
-        this.value?.deoptimizePath(path);
+        var _a;
+        (_a = this.value) === null || _a === void 0 ? void 0 : _a.deoptimizePath(path);
     }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        this.value?.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
+        var _a;
+        (_a = this.value) === null || _a === void 0 ? void 0 : _a.deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker);
     }
     getLiteralValueAtPath(path, recursionTracker, origin) {
         return this.value
             ? this.value.getLiteralValueAtPath(path, recursionTracker, origin)
             : UnknownValue;
     }
-    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
+    getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin) {
         return this.value
-            ? this.value.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin)
-            : UNKNOWN_RETURN_EXPRESSION;
+            ? this.value.getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin)
+            : UNKNOWN_EXPRESSION;
     }
     hasEffects(context) {
-        return this.key.hasEffects(context) || (this.static && !!this.value?.hasEffects(context));
+        return (this.key.hasEffects(context) ||
+            (this.static && this.value !== null && this.value.hasEffects(context)));
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        return !this.value || this.value.hasEffectsOnInteractionAtPath(path, interaction, context);
+    hasEffectsWhenAccessedAtPath(path, context) {
+        return !this.value || this.value.hasEffectsWhenAccessedAtPath(path, context);
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        return !this.value || this.value.hasEffectsWhenAssignedAtPath(path, context);
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        return !this.value || this.value.hasEffectsWhenCalledAtPath(path, callOptions, context);
     }
-    applyDeoptimizations() { }
 }
 
 class ReturnStatement extends NodeBase {
     hasEffects(context) {
-        if (!context.ignore.returnYield || this.argument?.hasEffects(context))
+        if (!context.ignore.returnYield ||
+            (this.argument !== null && this.argument.hasEffects(context)))
             return true;
         context.brokenFlow = BROKEN_FLOW_ERROR_RETURN_LABEL;
         return false;
     }
     include(context, includeChildrenRecursively) {
         this.included = true;
-        this.argument?.include(context, includeChildrenRecursively);
+        if (this.argument) {
+            this.argument.include(context, includeChildrenRecursively);
+        }
         context.brokenFlow = BROKEN_FLOW_ERROR_RETURN_LABEL;
     }
     initialise() {
@@ -11541,8 +11045,8 @@
     deoptimizePath(path) {
         this.expressions[this.expressions.length - 1].deoptimizePath(path);
     }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        this.expressions[this.expressions.length - 1].deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
+        this.expressions[this.expressions.length - 1].deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker);
     }
     getLiteralValueAtPath(path, recursionTracker, origin) {
         return this.expressions[this.expressions.length - 1].getLiteralValueAtPath(path, recursionTracker, origin);
@@ -11554,8 +11058,15 @@
         }
         return false;
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        return this.expressions[this.expressions.length - 1].hasEffectsOnInteractionAtPath(path, interaction, context);
+    hasEffectsWhenAccessedAtPath(path, context) {
+        return (path.length > 0 &&
+            this.expressions[this.expressions.length - 1].hasEffectsWhenAccessedAtPath(path, context));
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        return this.expressions[this.expressions.length - 1].hasEffectsWhenAssignedAtPath(path, context);
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        return this.expressions[this.expressions.length - 1].hasEffectsWhenCalledAtPath(path, callOptions, context);
     }
     include(context, includeChildrenRecursively) {
         this.included = true;
@@ -11599,34 +11110,6 @@
     }
 }
 
-class StaticBlock extends NodeBase {
-    createScope(parentScope) {
-        this.scope = new BlockScope(parentScope);
-    }
-    hasEffects(context) {
-        for (const node of this.body) {
-            if (node.hasEffects(context))
-                return true;
-        }
-        return false;
-    }
-    include(context, includeChildrenRecursively) {
-        this.included = true;
-        for (const node of this.body) {
-            if (includeChildrenRecursively || node.shouldBeIncluded(context))
-                node.include(context, includeChildrenRecursively);
-        }
-    }
-    render(code, options) {
-        if (this.body.length > 0) {
-            renderStatementList(this.body, code, this.start + 1, this.end - 1, options);
-        }
-        else {
-            super.render(code, options);
-        }
-    }
-}
-
 class Super extends NodeBase {
     bind() {
         this.variable = this.scope.findVariable('this');
@@ -11634,9 +11117,6 @@
     deoptimizePath(path) {
         this.variable.deoptimizePath(path);
     }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        this.variable.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
-    }
     include() {
         if (!this.included) {
             this.included = true;
@@ -11647,7 +11127,7 @@
 
 class SwitchCase extends NodeBase {
     hasEffects(context) {
-        if (this.test?.hasEffects(context))
+        if (this.test && this.test.hasEffects(context))
             return true;
         for (const node of this.consequent) {
             if (context.brokenFlow)
@@ -11659,14 +11139,15 @@
     }
     include(context, includeChildrenRecursively) {
         this.included = true;
-        this.test?.include(context, includeChildrenRecursively);
+        if (this.test)
+            this.test.include(context, includeChildrenRecursively);
         for (const node of this.consequent) {
             if (includeChildrenRecursively || node.shouldBeIncluded(context))
                 node.include(context, includeChildrenRecursively);
         }
     }
     render(code, options, nodeRenderOptions) {
-        if (this.consequent.length > 0) {
+        if (this.consequent.length) {
             this.test && this.test.render(code, options);
             const testEnd = this.test
                 ? this.test.end
@@ -11688,21 +11169,19 @@
     hasEffects(context) {
         if (this.discriminant.hasEffects(context))
             return true;
-        const { brokenFlow, ignore } = context;
-        const { breaks } = ignore;
+        const { brokenFlow, ignore: { breaks } } = context;
         let minBrokenFlow = Infinity;
-        ignore.breaks = true;
+        context.ignore.breaks = true;
         for (const switchCase of this.cases) {
             if (switchCase.hasEffects(context))
                 return true;
-            // eslint-disable-next-line unicorn/consistent-destructuring
             minBrokenFlow = context.brokenFlow < minBrokenFlow ? context.brokenFlow : minBrokenFlow;
             context.brokenFlow = brokenFlow;
         }
         if (this.defaultCase !== null && !(minBrokenFlow === BROKEN_FLOW_BREAK_CONTINUE)) {
             context.brokenFlow = minBrokenFlow;
         }
-        ignore.breaks = breaks;
+        context.ignore.breaks = breaks;
         return false;
     }
     include(context, includeChildrenRecursively) {
@@ -11724,7 +11203,6 @@
             }
             if (isCaseIncluded) {
                 switchCase.include(context, includeChildrenRecursively);
-                // eslint-disable-next-line unicorn/consistent-destructuring
                 minBrokenFlow = minBrokenFlow < context.brokenFlow ? minBrokenFlow : context.brokenFlow;
                 context.brokenFlow = brokenFlow;
             }
@@ -11755,53 +11233,28 @@
     }
 }
 
-class TaggedTemplateExpression extends CallExpressionBase {
+class TaggedTemplateExpression extends NodeBase {
     bind() {
         super.bind();
         if (this.tag.type === Identifier$1) {
             const name = this.tag.name;
             const variable = this.scope.findVariable(name);
             if (variable.isNamespace) {
-                this.context.warn(errorCannotCallNamespace(name), this.start);
+                this.context.warn({
+                    code: 'CANNOT_CALL_NAMESPACE',
+                    message: `Cannot call a namespace ('${name}')`
+                }, this.start);
             }
         }
     }
     hasEffects(context) {
-        try {
-            for (const argument of this.quasi.expressions) {
-                if (argument.hasEffects(context))
-                    return true;
-            }
-            return (this.tag.hasEffects(context) ||
-                this.tag.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.interaction, context));
-        }
-        finally {
-            if (!this.deoptimized)
-                this.applyDeoptimizations();
-        }
-    }
-    include(context, includeChildrenRecursively) {
-        if (!this.deoptimized)
-            this.applyDeoptimizations();
-        if (includeChildrenRecursively) {
-            super.include(context, includeChildrenRecursively);
-        }
-        else {
-            this.included = true;
-            this.tag.include(context, includeChildrenRecursively);
-            this.quasi.include(context, includeChildrenRecursively);
-        }
-        this.tag.includeCallArguments(context, this.interaction.args);
-        const [returnExpression] = this.getReturnExpression();
-        if (!returnExpression.included) {
-            returnExpression.include(context, false);
-        }
+        return (super.hasEffects(context) ||
+            this.tag.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.callOptions, context));
     }
     initialise() {
-        this.interaction = {
-            args: [UNKNOWN_EXPRESSION, ...this.quasi.expressions],
-            thisArg: this.tag instanceof MemberExpression && !this.tag.variable ? this.tag.object : null,
-            type: INTERACTION_CALLED,
+        this.callOptions = {
+            args: NO_ARGS,
+            thisParam: null,
             withNew: false
         };
     }
@@ -11809,24 +11262,6 @@
         this.tag.render(code, options, { isCalleeOfRenderedParent: true });
         this.quasi.render(code, options);
     }
-    applyDeoptimizations() {
-        this.deoptimized = true;
-        if (this.interaction.thisArg) {
-            this.tag.deoptimizeThisOnInteractionAtPath(this.interaction, EMPTY_PATH, SHARED_RECURSION_TRACKER);
-        }
-        for (const argument of this.quasi.expressions) {
-            // This will make sure all properties of parameters behave as "unknown"
-            argument.deoptimizePath(UNKNOWN_PATH);
-        }
-        this.context.requestTreeshakingPass();
-    }
-    getReturnExpression(recursionTracker = SHARED_RECURSION_TRACKER) {
-        if (this.returnExpression === null) {
-            this.returnExpression = UNKNOWN_RETURN_EXPRESSION;
-            return (this.returnExpression = this.tag.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, this.interaction, recursionTracker, this));
-        }
-        return this.returnExpression;
-    }
 }
 
 class TemplateElement extends NodeBase {
@@ -11845,35 +11280,6 @@
     render() { }
 }
 
-class TemplateLiteral extends NodeBase {
-    deoptimizeThisOnInteractionAtPath() { }
-    getLiteralValueAtPath(path) {
-        if (path.length > 0 || this.quasis.length !== 1) {
-            return UnknownValue;
-        }
-        return this.quasis[0].value.cooked;
-    }
-    getReturnExpressionWhenCalledAtPath(path) {
-        if (path.length !== 1) {
-            return UNKNOWN_RETURN_EXPRESSION;
-        }
-        return getMemberReturnExpressionWhenCalled(literalStringMembers, path[0]);
-    }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        if (interaction.type === INTERACTION_ACCESSED) {
-            return path.length > 1;
-        }
-        if (interaction.type === INTERACTION_CALLED && path.length === 1) {
-            return hasMemberEffectWhenCalled(literalStringMembers, path[0], interaction, context);
-        }
-        return true;
-    }
-    render(code, options) {
-        code.indentExclusionRanges.push([this.start, this.end]);
-        super.render(code, options);
-    }
-}
-
 class UndefinedVariable extends Variable {
     constructor() {
         super('undefined');
@@ -11904,21 +11310,17 @@
             this.name = identifier.name;
         }
     }
-    forbidName(name) {
-        const original = this.getOriginalVariable();
-        if (original === this) {
-            super.forbidName(name);
-        }
-        else {
-            original.forbidName(name);
-        }
-    }
     getAssignedVariableName() {
         return (this.originalId && this.originalId.name) || null;
     }
     getBaseVariableName() {
         const original = this.getOriginalVariable();
-        return original === this ? super.getBaseVariableName() : original.getBaseVariableName();
+        if (original === this) {
+            return super.getBaseVariableName();
+        }
+        else {
+            return original.getBaseVariableName();
+        }
     }
     getDirectOriginalVariable() {
         return this.originalId &&
@@ -11933,9 +11335,12 @@
     }
     getName(getPropertyAccess) {
         const original = this.getOriginalVariable();
-        return original === this
-            ? super.getName(getPropertyAccess)
-            : original.getName(getPropertyAccess);
+        if (original === this) {
+            return super.getName(getPropertyAccess);
+        }
+        else {
+            return original.getName(getPropertyAccess);
+        }
     }
     getOriginalVariable() {
         if (this.originalVariable)
@@ -11993,15 +11398,16 @@
     deoptimizePath(path) {
         this.variable.deoptimizePath(path);
     }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
+        this.variable.deoptimizeThisOnEventAtPath(event, path, 
         // We rewrite the parameter so that a ThisVariable can detect self-mutations
-        this.variable.deoptimizeThisOnInteractionAtPath(interaction.thisArg === this ? { ...interaction, thisArg: this.variable } : interaction, path, recursionTracker);
+        thisParameter === this ? this.variable : thisParameter, recursionTracker);
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        if (path.length === 0) {
-            return interaction.type !== INTERACTION_ACCESSED;
-        }
-        return this.variable.hasEffectsOnInteractionAtPath(path, interaction, context);
+    hasEffectsWhenAccessedAtPath(path, context) {
+        return path.length > 0 && this.variable.hasEffectsWhenAccessedAtPath(path, context);
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        return this.variable.hasEffectsWhenAssignedAtPath(path, context);
     }
     include() {
         if (!this.included) {
@@ -12013,7 +11419,11 @@
         this.alias =
             this.scope.findLexicalBoundary() instanceof ModuleScope ? this.context.moduleContext : null;
         if (this.alias === 'undefined') {
-            this.context.warn(errorThisIsUndefined(), this.start);
+            this.context.warn({
+                code: 'THIS_IS_UNDEFINED',
+                message: `The 'this' keyword is equivalent to 'undefined' at the top level of an ES module, and has been rewritten`,
+                url: `https://rollupjs.org/guide/en/#error-this-is-undefined`
+            }, this.start);
         }
     }
     render(code) {
@@ -12052,31 +11462,34 @@
     hasEffects(context) {
         return ((this.context.options.treeshake.tryCatchDeoptimization
             ? this.block.body.length > 0
-            : this.block.hasEffects(context)) || !!this.finalizer?.hasEffects(context));
+            : this.block.hasEffects(context)) ||
+            (this.finalizer !== null && this.finalizer.hasEffects(context)));
     }
     include(context, includeChildrenRecursively) {
-        const tryCatchDeoptimization = this.context.options.treeshake
-            ?.tryCatchDeoptimization;
-        const { brokenFlow, includedLabels } = context;
+        var _a;
+        const tryCatchDeoptimization = (_a = this.context.options.treeshake) === null || _a === void 0 ? void 0 : _a.tryCatchDeoptimization;
+        const { brokenFlow } = context;
         if (!this.directlyIncluded || !tryCatchDeoptimization) {
             this.included = true;
             this.directlyIncluded = true;
             this.block.include(context, tryCatchDeoptimization ? INCLUDE_PARAMETERS : includeChildrenRecursively);
-            if (includedLabels.size > 0) {
-                this.includedLabelsAfterBlock = [...includedLabels];
+            if (context.includedLabels.size > 0) {
+                this.includedLabelsAfterBlock = [...context.includedLabels];
             }
             context.brokenFlow = brokenFlow;
         }
         else if (this.includedLabelsAfterBlock) {
             for (const label of this.includedLabelsAfterBlock) {
-                includedLabels.add(label);
+                context.includedLabels.add(label);
             }
         }
         if (this.handler !== null) {
             this.handler.include(context, includeChildrenRecursively);
             context.brokenFlow = brokenFlow;
         }
-        this.finalizer?.include(context, includeChildrenRecursively);
+        if (this.finalizer !== null) {
+            this.finalizer.include(context, includeChildrenRecursively);
+        }
     }
 }
 
@@ -12090,11 +11503,15 @@
     '~': value => ~value
 };
 class UnaryExpression extends NodeBase {
+    constructor() {
+        super(...arguments);
+        this.deoptimized = false;
+    }
     getLiteralValueAtPath(path, recursionTracker, origin) {
         if (path.length > 0)
             return UnknownValue;
         const argumentValue = this.argument.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);
-        if (typeof argumentValue === 'symbol')
+        if (argumentValue === UnknownValue)
             return UnknownValue;
         return unaryOperators[this.operator](argumentValue);
     }
@@ -12105,10 +11522,13 @@
             return false;
         return (this.argument.hasEffects(context) ||
             (this.operator === 'delete' &&
-                this.argument.hasEffectsOnInteractionAtPath(EMPTY_PATH, NODE_INTERACTION_UNKNOWN_ASSIGNMENT, context)));
+                this.argument.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context)));
     }
-    hasEffectsOnInteractionAtPath(path, { type }) {
-        return type !== INTERACTION_ACCESSED || path.length > (this.operator === 'void' ? 0 : 1);
+    hasEffectsWhenAccessedAtPath(path) {
+        if (this.operator === 'void') {
+            return path.length > 0;
+        }
+        return path.length > 1;
     }
     applyDeoptimizations() {
         this.deoptimized = true;
@@ -12129,22 +11549,18 @@
 }
 
 class UpdateExpression extends NodeBase {
-    hasEffects(context) {
-        if (!this.deoptimized)
-            this.applyDeoptimizations();
-        return this.argument.hasEffectsAsAssignmentTarget(context, true);
-    }
-    hasEffectsOnInteractionAtPath(path, { type }) {
-        return path.length > 1 || type !== INTERACTION_ACCESSED;
+    constructor() {
+        super(...arguments);
+        this.deoptimized = false;
     }
-    include(context, includeChildrenRecursively) {
+    hasEffects(context) {
         if (!this.deoptimized)
             this.applyDeoptimizations();
-        this.included = true;
-        this.argument.includeAsAssignmentTarget(context, includeChildrenRecursively, true);
+        return (this.argument.hasEffects(context) ||
+            this.argument.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context));
     }
-    initialise() {
-        this.argument.setAssignedValue(UNKNOWN_EXPRESSION);
+    hasEffectsWhenAccessedAtPath(path) {
+        return path.length > 1;
     }
     render(code, options) {
         const { exportNamesByVariable, format, snippets: { _ } } = options;
@@ -12179,186 +11595,6 @@
     }
 }
 
-function isReassignedExportsMember(variable, exportNamesByVariable) {
-    return (variable.renderBaseName !== null && exportNamesByVariable.has(variable) && variable.isReassigned);
-}
-
-function areAllDeclarationsIncludedAndNotExported(declarations, exportNamesByVariable) {
-    for (const declarator of declarations) {
-        if (!declarator.id.included)
-            return false;
-        if (declarator.id.type === Identifier$1) {
-            if (exportNamesByVariable.has(declarator.id.variable))
-                return false;
-        }
-        else {
-            const exportedVariables = [];
-            declarator.id.addExportedVariables(exportedVariables, exportNamesByVariable);
-            if (exportedVariables.length > 0)
-                return false;
-        }
-    }
-    return true;
-}
-class VariableDeclaration extends NodeBase {
-    deoptimizePath() {
-        for (const declarator of this.declarations) {
-            declarator.deoptimizePath(EMPTY_PATH);
-        }
-    }
-    hasEffectsOnInteractionAtPath() {
-        return false;
-    }
-    include(context, includeChildrenRecursively, { asSingleStatement } = BLANK) {
-        this.included = true;
-        for (const declarator of this.declarations) {
-            if (includeChildrenRecursively || declarator.shouldBeIncluded(context))
-                declarator.include(context, includeChildrenRecursively);
-            const { id, init } = declarator;
-            if (asSingleStatement) {
-                id.include(context, includeChildrenRecursively);
-            }
-            if (init &&
-                id.included &&
-                !init.included &&
-                (id instanceof ObjectPattern || id instanceof ArrayPattern)) {
-                init.include(context, includeChildrenRecursively);
-            }
-        }
-    }
-    initialise() {
-        for (const declarator of this.declarations) {
-            declarator.declareDeclarator(this.kind);
-        }
-    }
-    render(code, options, nodeRenderOptions = BLANK) {
-        if (areAllDeclarationsIncludedAndNotExported(this.declarations, options.exportNamesByVariable)) {
-            for (const declarator of this.declarations) {
-                declarator.render(code, options);
-            }
-            if (!nodeRenderOptions.isNoStatement &&
-                code.original.charCodeAt(this.end - 1) !== 59 /*";"*/) {
-                code.appendLeft(this.end, ';');
-            }
-        }
-        else {
-            this.renderReplacedDeclarations(code, options);
-        }
-    }
-    applyDeoptimizations() { }
-    renderDeclarationEnd(code, separatorString, lastSeparatorPos, actualContentEnd, renderedContentEnd, systemPatternExports, options) {
-        if (code.original.charCodeAt(this.end - 1) === 59 /*";"*/) {
-            code.remove(this.end - 1, this.end);
-        }
-        separatorString += ';';
-        if (lastSeparatorPos === null) {
-            code.appendLeft(renderedContentEnd, separatorString);
-        }
-        else {
-            if (code.original.charCodeAt(actualContentEnd - 1) === 10 /*"\n"*/ &&
-                (code.original.charCodeAt(this.end) === 10 /*"\n"*/ ||
-                    code.original.charCodeAt(this.end) === 13) /*"\r"*/) {
-                actualContentEnd--;
-                if (code.original.charCodeAt(actualContentEnd) === 13 /*"\r"*/) {
-                    actualContentEnd--;
-                }
-            }
-            if (actualContentEnd === lastSeparatorPos + 1) {
-                code.overwrite(lastSeparatorPos, renderedContentEnd, separatorString);
-            }
-            else {
-                code.overwrite(lastSeparatorPos, lastSeparatorPos + 1, separatorString);
-                code.remove(actualContentEnd, renderedContentEnd);
-            }
-        }
-        if (systemPatternExports.length > 0) {
-            code.appendLeft(renderedContentEnd, ` ${getSystemExportStatement(systemPatternExports, options)};`);
-        }
-    }
-    renderReplacedDeclarations(code, options) {
-        const separatedNodes = getCommaSeparatedNodesWithBoundaries(this.declarations, code, this.start + this.kind.length, this.end - (code.original.charCodeAt(this.end - 1) === 59 /*";"*/ ? 1 : 0));
-        let actualContentEnd, renderedContentEnd;
-        renderedContentEnd = findNonWhiteSpace(code.original, this.start + this.kind.length);
-        let lastSeparatorPos = renderedContentEnd - 1;
-        code.remove(this.start, lastSeparatorPos);
-        let isInDeclaration = false;
-        let hasRenderedContent = false;
-        let separatorString = '', leadingString, nextSeparatorString;
-        const aggregatedSystemExports = [];
-        const singleSystemExport = gatherSystemExportsAndGetSingleExport(separatedNodes, options, aggregatedSystemExports);
-        for (const { node, start, separator, contentEnd, end } of separatedNodes) {
-            if (!node.included) {
-                code.remove(start, end);
-                continue;
-            }
-            node.render(code, options);
-            leadingString = '';
-            nextSeparatorString = '';
-            if (!node.id.included ||
-                (node.id instanceof Identifier &&
-                    isReassignedExportsMember(node.id.variable, options.exportNamesByVariable))) {
-                if (hasRenderedContent) {
-                    separatorString += ';';
-                }
-                isInDeclaration = false;
-            }
-            else {
-                if (singleSystemExport && singleSystemExport === node.id.variable) {
-                    const operatorPos = findFirstOccurrenceOutsideComment(code.original, '=', node.id.end);
-                    renderSystemExportExpression(singleSystemExport, findNonWhiteSpace(code.original, operatorPos + 1), separator === null ? contentEnd : separator, code, options);
-                }
-                if (isInDeclaration) {
-                    separatorString += ',';
-                }
-                else {
-                    if (hasRenderedContent) {
-                        separatorString += ';';
-                    }
-                    leadingString += `${this.kind} `;
-                    isInDeclaration = true;
-                }
-            }
-            if (renderedContentEnd === lastSeparatorPos + 1) {
-                code.overwrite(lastSeparatorPos, renderedContentEnd, separatorString + leadingString);
-            }
-            else {
-                code.overwrite(lastSeparatorPos, lastSeparatorPos + 1, separatorString);
-                code.appendLeft(renderedContentEnd, leadingString);
-            }
-            actualContentEnd = contentEnd;
-            renderedContentEnd = end;
-            hasRenderedContent = true;
-            lastSeparatorPos = separator;
-            separatorString = nextSeparatorString;
-        }
-        this.renderDeclarationEnd(code, separatorString, lastSeparatorPos, actualContentEnd, renderedContentEnd, aggregatedSystemExports, options);
-    }
-}
-function gatherSystemExportsAndGetSingleExport(separatedNodes, options, aggregatedSystemExports) {
-    let singleSystemExport = null;
-    if (options.format === 'system') {
-        for (const { node } of separatedNodes) {
-            if (node.id instanceof Identifier &&
-                node.init &&
-                aggregatedSystemExports.length === 0 &&
-                options.exportNamesByVariable.get(node.id.variable)?.length === 1) {
-                singleSystemExport = node.id.variable;
-                aggregatedSystemExports.push(singleSystemExport);
-            }
-            else {
-                node.id.addExportedVariables(aggregatedSystemExports, options.exportNamesByVariable);
-            }
-        }
-        if (aggregatedSystemExports.length > 1) {
-            singleSystemExport = null;
-        }
-        else if (singleSystemExport) {
-            aggregatedSystemExports.length = 0;
-        }
-    }
-    return singleSystemExport;
-}
-
 class VariableDeclarator extends NodeBase {
     declareDeclarator(kind) {
         this.id.declare(kind, this.init || UNDEFINED_EXPRESSION);
@@ -12367,58 +11603,36 @@
         this.id.deoptimizePath(path);
     }
     hasEffects(context) {
-        if (!this.deoptimized)
-            this.applyDeoptimizations();
-        const initEffect = this.init?.hasEffects(context);
+        const initEffect = this.init !== null && this.init.hasEffects(context);
         this.id.markDeclarationReached();
         return initEffect || this.id.hasEffects(context);
     }
     include(context, includeChildrenRecursively) {
-        const { deoptimized, id, init } = this;
-        if (!deoptimized)
-            this.applyDeoptimizations();
         this.included = true;
-        init?.include(context, includeChildrenRecursively);
-        id.markDeclarationReached();
-        if (includeChildrenRecursively || id.shouldBeIncluded(context)) {
-            id.include(context, includeChildrenRecursively);
+        if (this.init) {
+            this.init.include(context, includeChildrenRecursively);
+        }
+        this.id.markDeclarationReached();
+        if (includeChildrenRecursively || this.id.shouldBeIncluded(context)) {
+            this.id.include(context, includeChildrenRecursively);
         }
     }
     render(code, options) {
-        const { exportNamesByVariable, snippets: { _, getPropertyAccess } } = options;
-        const { end, id, init, start } = this;
-        const renderId = id.included;
+        const { exportNamesByVariable, snippets: { _ } } = options;
+        const renderId = this.id.included;
         if (renderId) {
-            id.render(code, options);
+            this.id.render(code, options);
         }
         else {
-            const operatorPos = findFirstOccurrenceOutsideComment(code.original, '=', id.end);
-            code.remove(start, findNonWhiteSpace(code.original, operatorPos + 1));
-        }
-        if (init) {
-            if (id instanceof Identifier && init instanceof ClassExpression && !init.id) {
-                const renderedVariable = id.variable.getName(getPropertyAccess);
-                if (renderedVariable !== id.name) {
-                    code.appendLeft(init.start + 5, ` ${id.name}`);
-                }
-            }
-            init.render(code, options, renderId ? BLANK : { renderedSurroundingElement: ExpressionStatement$1 });
+            const operatorPos = findFirstOccurrenceOutsideComment(code.original, '=', this.id.end);
+            code.remove(this.start, findNonWhiteSpace(code.original, operatorPos + 1));
         }
-        else if (id instanceof Identifier &&
-            isReassignedExportsMember(id.variable, exportNamesByVariable)) {
-            code.appendLeft(end, `${_}=${_}void 0`);
+        if (this.init) {
+            this.init.render(code, options, renderId ? BLANK : { renderedSurroundingElement: ExpressionStatement$1 });
         }
-    }
-    applyDeoptimizations() {
-        this.deoptimized = true;
-        const { id, init } = this;
-        if (init && id instanceof Identifier && init instanceof ClassExpression && !init.id) {
-            const { name, variable } = id;
-            for (const accessedVariable of init.scope.accessedOutsideVariables.values()) {
-                if (accessedVariable !== variable) {
-                    accessedVariable.forbidName(name);
-                }
-            }
+        else if (this.id instanceof Identifier &&
+            isReassignedExportsMember(this.id.variable, exportNamesByVariable)) {
+            code.appendLeft(this.end, `${_}=${_}void 0`);
         }
     }
 }
@@ -12427,14 +11641,13 @@
     hasEffects(context) {
         if (this.test.hasEffects(context))
             return true;
-        const { brokenFlow, ignore } = context;
-        const { breaks, continues } = ignore;
-        ignore.breaks = true;
-        ignore.continues = true;
+        const { brokenFlow, ignore: { breaks, continues } } = context;
+        context.ignore.breaks = true;
+        context.ignore.continues = true;
         if (this.body.hasEffects(context))
             return true;
-        ignore.breaks = breaks;
-        ignore.continues = continues;
+        context.ignore.breaks = breaks;
+        context.ignore.continues = continues;
         context.brokenFlow = brokenFlow;
         return false;
     }
@@ -12442,16 +11655,20 @@
         this.included = true;
         this.test.include(context, includeChildrenRecursively);
         const { brokenFlow } = context;
-        this.body.include(context, includeChildrenRecursively, { asSingleStatement: true });
+        this.body.includeAsSingleStatement(context, includeChildrenRecursively);
         context.brokenFlow = brokenFlow;
     }
 }
 
 class YieldExpression extends NodeBase {
+    constructor() {
+        super(...arguments);
+        this.deoptimized = false;
+    }
     hasEffects(context) {
         if (!this.deoptimized)
             this.applyDeoptimizations();
-        return !(context.ignore.returnYield && !this.argument?.hasEffects(context));
+        return (!context.ignore.returnYield || (this.argument !== null && this.argument.hasEffects(context)));
     }
     render(code, options) {
         if (this.argument) {
@@ -12461,6 +11678,14 @@
             }
         }
     }
+    applyDeoptimizations() {
+        this.deoptimized = true;
+        const { argument } = this;
+        if (argument) {
+            argument.deoptimizePath(UNKNOWN_PATH);
+            this.context.requestTreeshakingPass();
+        }
+    }
 }
 
 const nodeConstructors = {
@@ -12495,7 +11720,6 @@
     FunctionExpression,
     Identifier,
     IfStatement,
-    ImportAttribute,
     ImportDeclaration,
     ImportDefaultSpecifier,
     ImportExpression,
@@ -12518,7 +11742,6 @@
     ReturnStatement,
     SequenceExpression,
     SpreadElement,
-    StaticBlock,
     Super,
     SwitchCase,
     SwitchStatement,
@@ -12564,38 +11787,12 @@
         this.references.push(identifier);
         this.name = identifier.name;
     }
-    deoptimizePath(path) {
-        if (path.length > 1) {
-            const key = path[0];
-            if (typeof key === 'string') {
-                this.getMemberVariables()[key]?.deoptimizePath(path.slice(1));
-            }
-        }
-    }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        if (path.length > 1 || (path.length === 1 && interaction.type === INTERACTION_CALLED)) {
-            const key = path[0];
-            if (typeof key === 'string') {
-                this.getMemberVariables()[key]?.deoptimizeThisOnInteractionAtPath(interaction, path.slice(1), recursionTracker);
-            }
-            else {
-                interaction.thisArg.deoptimizePath(UNKNOWN_PATH);
-            }
-        }
-    }
-    getLiteralValueAtPath(path) {
-        if (path[0] === SymbolToStringTag) {
-            return 'Module';
-        }
-        return UnknownValue;
-    }
     getMemberVariables() {
         if (this.memberVariables) {
             return this.memberVariables;
         }
         const memberVariables = Object.create(null);
-        const sortedExports = [...this.context.getExports(), ...this.context.getReexports()].sort();
-        for (const name of sortedExports) {
+        for (const name of this.context.getExports().concat(this.context.getReexports())) {
             if (name[0] !== '*' && name !== this.module.info.syntheticNamedExports) {
                 const exportedVariable = this.context.traceExport(name);
                 if (exportedVariable) {
@@ -12605,23 +11802,6 @@
         }
         return (this.memberVariables = memberVariables);
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        const { type } = interaction;
-        if (path.length === 0) {
-            // This can only be a call anyway
-            return true;
-        }
-        if (path.length === 1 && type !== INTERACTION_CALLED) {
-            return type === INTERACTION_ASSIGNED;
-        }
-        const key = path[0];
-        if (typeof key !== 'string') {
-            return true;
-        }
-        const memberVariable = this.getMemberVariables()[key];
-        return (!memberVariable ||
-            memberVariable.hasEffectsOnInteractionAtPath(path.slice(1), interaction, context));
-    }
     include() {
         this.included = true;
         this.context.includeAllExports();
@@ -12643,20 +11823,17 @@
             }
             return [name, original.getName(getPropertyAccess)];
         });
+        if (namespaceToStringTag) {
+            members.unshift([null, `[Symbol.toStringTag]:${_}'Module'`]);
+        }
         members.unshift([null, `__proto__:${_}null`]);
         let output = getObject(members, { lineBreakIndent: { base: '', t } });
         if (this.mergedNamespaces.length > 0) {
-            const assignmentArguments = this.mergedNamespaces.map(variable => variable.getName(getPropertyAccess));
-            output = `/*#__PURE__*/${MERGE_NAMESPACES_VARIABLE}(${output},${_}[${assignmentArguments.join(`,${_}`)}])`;
+            const assignmentArgs = this.mergedNamespaces.map(variable => variable.getName(getPropertyAccess));
+            output = `/*#__PURE__*/${MERGE_NAMESPACES_VARIABLE}(${output}, [${assignmentArgs.join(`,${_}`)}])`;
         }
-        else {
-            // The helper to merge namespaces will also take care of freezing and toStringTag
-            if (namespaceToStringTag) {
-                output = `/*#__PURE__*/Object.defineProperty(${output},${_}Symbol.toStringTag,${_}${getToStringTagValue(getObject)})`;
-            }
-            if (freeze) {
-                output = `/*#__PURE__*/Object.freeze(${output})`;
-            }
+        if (freeze) {
+            output = `/*#__PURE__*/Object.freeze(${output})`;
         }
         const name = this.getName(getPropertyAccess);
         output = `${cnst} ${name}${_}=${_}${output};`;
@@ -12722,181 +11899,142 @@
     }
 }
 
-var BuildPhase;
-(function (BuildPhase) {
-    BuildPhase[BuildPhase["LOAD_AND_PARSE"] = 0] = "LOAD_AND_PARSE";
-    BuildPhase[BuildPhase["ANALYSE"] = 1] = "ANALYSE";
-    BuildPhase[BuildPhase["GENERATE"] = 2] = "GENERATE";
-})(BuildPhase || (BuildPhase = {}));
-
 function getId(m) {
     return m.id;
 }
 
 function getOriginalLocation(sourcemapChain, location) {
-    const filteredSourcemapChain = sourcemapChain.filter((sourcemap) => !!sourcemap.mappings);
-    traceSourcemap: while (filteredSourcemapChain.length > 0) {
+    // This cast is guaranteed. If it were a missing Map, it wouldn't have a mappings.
+    const filteredSourcemapChain = sourcemapChain.filter(sourcemap => sourcemap.mappings);
+    while (filteredSourcemapChain.length > 0) {
         const sourcemap = filteredSourcemapChain.pop();
         const line = sourcemap.mappings[location.line - 1];
-        if (line) {
-            const filteredLine = line.filter((segment) => segment.length > 1);
-            const lastSegment = filteredLine[filteredLine.length - 1];
-            for (const segment of filteredLine) {
-                if (segment[0] >= location.column || segment === lastSegment) {
+        let locationFound = false;
+        if (line !== undefined) {
+            for (const segment of line) {
+                if (segment[0] >= location.column) {
+                    if (segment.length === 1)
+                        break;
                     location = {
                         column: segment[3],
-                        line: segment[2] + 1
+                        line: segment[2] + 1,
+                        name: segment.length === 5 ? sourcemap.names[segment[4]] : undefined,
+                        source: sourcemap.sources[segment[1]]
                     };
-                    continue traceSourcemap;
+                    locationFound = true;
+                    break;
                 }
             }
         }
-        throw new Error("Can't resolve original location of error.");
+        if (!locationFound) {
+            throw new Error("Can't resolve original location of error.");
+        }
     }
     return location;
 }
 
-function getAssertionsFromImportExpression(node) {
-    const assertProperty = node.arguments?.[0]?.properties.find((property) => getPropertyKey(property) === 'assert')?.value;
-    if (!assertProperty) {
-        return EMPTY_OBJECT;
-    }
-    const assertFields = assertProperty.properties
-        .map(property => {
-        const key = getPropertyKey(property);
-        if (typeof key === 'string' &&
-            typeof property.value.value === 'string') {
-            return [key, property.value.value];
-        }
-        return null;
-    })
-        .filter((property) => !!property);
-    if (assertFields.length > 0) {
-        return Object.fromEntries(assertFields);
-    }
-    return EMPTY_OBJECT;
-}
-const getPropertyKey = (property) => {
-    const key = property.key;
-    return key && (key.name || key.value);
-};
-function getAssertionsFromImportExportDeclaration(assertions) {
-    return assertions?.length
-        ? Object.fromEntries(assertions.map(assertion => [getPropertyKey(assertion), assertion.value.value]))
-        : EMPTY_OBJECT;
-}
-function doAssertionsDiffer(assertionA, assertionB) {
-    const keysA = Object.keys(assertionA);
-    return (keysA.length !== Object.keys(assertionB).length ||
-        keysA.some(key => assertionA[key] !== assertionB[key]));
-}
-
 const NOOP = () => { };
-let timers = new Map();
+let getStartTime = () => [0, 0];
+let getElapsedTime = () => 0;
+let getMemory = () => 0;
+let timers = {};
+const normalizeHrTime = (time) => time[0] * 1e3 + time[1] / 1e6;
+function setTimeHelpers() {
+    if (typeof process !== 'undefined' && typeof process.hrtime === 'function') {
+        getStartTime = process.hrtime.bind(process);
+        getElapsedTime = previous => normalizeHrTime(process.hrtime(previous));
+    }
+    else if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
+        getStartTime = () => [performance.now(), 0];
+        getElapsedTime = previous => performance.now() - previous[0];
+    }
+    if (typeof process !== 'undefined' && typeof process.memoryUsage === 'function') {
+        getMemory = () => process.memoryUsage().heapUsed;
+    }
+}
 function getPersistedLabel(label, level) {
     switch (level) {
-        case 1: {
+        case 1:
             return `# ${label}`;
-        }
-        case 2: {
+        case 2:
             return `## ${label}`;
-        }
-        case 3: {
+        case 3:
             return label;
-        }
-        default: {
+        default:
             return `${'  '.repeat(level - 4)}- ${label}`;
-        }
     }
 }
 function timeStartImpl(label, level = 3) {
     label = getPersistedLabel(label, level);
-    const startMemory = process$1.memoryUsage().heapUsed;
-    const startTime = performance.now();
-    const timer = timers.get(label);
-    if (timer === undefined) {
-        timers.set(label, {
+    if (!timers.hasOwnProperty(label)) {
+        timers[label] = {
             memory: 0,
-            startMemory,
-            startTime,
+            startMemory: undefined,
+            startTime: undefined,
             time: 0,
             totalMemory: 0
-        });
-    }
-    else {
-        timer.startMemory = startMemory;
-        timer.startTime = startTime;
+        };
     }
+    const currentMemory = getMemory();
+    timers[label].startTime = getStartTime();
+    timers[label].startMemory = currentMemory;
 }
 function timeEndImpl(label, level = 3) {
     label = getPersistedLabel(label, level);
-    const timer = timers.get(label);
-    if (timer !== undefined) {
-        const currentMemory = process$1.memoryUsage().heapUsed;
-        timer.memory += currentMemory - timer.startMemory;
-        timer.time += performance.now() - timer.startTime;
-        timer.totalMemory = Math.max(timer.totalMemory, currentMemory);
+    if (timers.hasOwnProperty(label)) {
+        const currentMemory = getMemory();
+        timers[label].time += getElapsedTime(timers[label].startTime);
+        timers[label].totalMemory = Math.max(timers[label].totalMemory, currentMemory);
+        timers[label].memory += currentMemory - timers[label].startMemory;
     }
 }
 function getTimings() {
     const newTimings = {};
-    for (const [label, { memory, time, totalMemory }] of timers) {
+    for (const [label, { time, memory, totalMemory }] of Object.entries(timers)) {
         newTimings[label] = [time, memory, totalMemory];
     }
     return newTimings;
 }
-let timeStart = NOOP;
-let timeEnd = NOOP;
-const TIMED_PLUGIN_HOOKS = [
-    'augmentChunkHash',
-    'buildEnd',
-    'buildStart',
-    'generateBundle',
-    'load',
-    'moduleParsed',
-    'options',
-    'outputOptions',
-    'renderChunk',
-    'renderDynamicImport',
-    'renderStart',
-    'resolveDynamicImport',
-    'resolveFileUrl',
-    'resolveId',
-    'resolveImportMeta',
-    'shouldTransformCachedModule',
-    'transform',
-    'writeBundle'
-];
+let timeStart = NOOP, timeEnd = NOOP;
+const TIMED_PLUGIN_HOOKS = {
+    load: true,
+    resolveDynamicImport: true,
+    resolveId: true,
+    transform: true
+};
 function getPluginWithTimers(plugin, index) {
-    for (const hook of TIMED_PLUGIN_HOOKS) {
-        if (hook in plugin) {
+    const timedPlugin = {};
+    for (const hook of Object.keys(plugin)) {
+        if (TIMED_PLUGIN_HOOKS[hook] === true) {
             let timerLabel = `plugin ${index}`;
             if (plugin.name) {
                 timerLabel += ` (${plugin.name})`;
             }
             timerLabel += ` - ${hook}`;
-            const handler = function (...parameters) {
+            timedPlugin[hook] = function (...args) {
                 timeStart(timerLabel, 4);
-                const result = hookFunction.apply(this, parameters);
+                let result = plugin[hook].apply(this === timedPlugin ? plugin : this, args);
                 timeEnd(timerLabel, 4);
+                if (result && typeof result.then === 'function') {
+                    timeStart(`${timerLabel} (async)`, 4);
+                    result = result.then((hookResult) => {
+                        timeEnd(`${timerLabel} (async)`, 4);
+                        return hookResult;
+                    });
+                }
                 return result;
             };
-            let hookFunction;
-            if (typeof plugin[hook].handler === 'function') {
-                hookFunction = plugin[hook].handler;
-                plugin[hook].handler = handler;
-            }
-            else {
-                hookFunction = plugin[hook];
-                plugin[hook] = handler;
-            }
+        }
+        else {
+            timedPlugin[hook] = plugin[hook];
         }
     }
-    return plugin;
+    return timedPlugin;
 }
 function initialiseTimers(inputOptions) {
     if (inputOptions.perf) {
-        timers = new Map();
+        timers = {};
+        setTimeHelpers();
         timeStart = timeStartImpl;
         timeEnd = timeEndImpl;
         inputOptions.plugins = inputOptions.plugins.map(getPluginWithTimers);
@@ -12915,7 +12053,7 @@
         for (const dependency of [...module.dependencies, ...module.implicitlyLoadedBefore]) {
             if (!(dependency instanceof ExternalModule) &&
                 !dependency.isExecuted &&
-                (dependency.info.moduleSideEffects || module.implicitlyLoadedBefore.has(dependency)) &&
+                (dependency.info.hasModuleSideEffects || module.implicitlyLoadedBefore.has(dependency)) &&
                 !visitedModules.has(dependency.id)) {
                 dependency.isExecuted = true;
                 visitedModules.add(dependency.id);
@@ -12929,11 +12067,11 @@
     identifier: null,
     localName: MISSING_EXPORT_SHIM_VARIABLE
 };
-function getVariableForExportNameRecursive(target, name, importerForSideEffects, isExportAllSearch, searchedNamesAndModules = new Map()) {
+function getVariableForExportNameRecursive(target, name, importerForSideEffects, isExportAllSearch, searchedNamesAndModules = new Map(), skipExternalNamespaceReexports) {
     const searchedModules = searchedNamesAndModules.get(name);
     if (searchedModules) {
         if (searchedModules.has(target)) {
-            return isExportAllSearch ? [null] : error(errorCircularReexport(name, target.id));
+            return isExportAllSearch ? null : error(errCircularReexport(name, target.id));
         }
         searchedModules.add(target);
     }
@@ -12943,11 +12081,12 @@
     return target.getVariableForExportName(name, {
         importerForSideEffects,
         isExportAllSearch,
-        searchedNamesAndModules
+        searchedNamesAndModules,
+        skipExternalNamespaceReexports
     });
 }
 function getAndExtendSideEffectModules(variable, module) {
-    const sideEffectModules = getOrCreate(module.sideEffectDependenciesByVariable, variable, getNewSet);
+    const sideEffectModules = getOrCreate(module.sideEffectDependenciesByVariable, variable, () => new Set());
     let currentVariable = variable;
     const referencedVariables = new Set([currentVariable]);
     while (true) {
@@ -12973,41 +12112,45 @@
     return sideEffectModules;
 }
 class Module {
-    constructor(graph, id, options, isEntry, moduleSideEffects, syntheticNamedExports, meta, assertions) {
+    constructor(graph, id, options, isEntry, hasModuleSideEffects, syntheticNamedExports, meta) {
         this.graph = graph;
         this.id = id;
         this.options = options;
         this.alternativeReexportModules = new Map();
+        this.ast = null;
         this.chunkFileNames = new Set();
-        this.chunkNames = [];
+        this.chunkName = null;
         this.cycles = new Set();
         this.dependencies = new Set();
         this.dynamicDependencies = new Set();
         this.dynamicImporters = [];
         this.dynamicImports = [];
         this.execIndex = Infinity;
+        this.exportAllSources = new Set();
+        this.exports = Object.create(null);
+        this.exportsAll = Object.create(null);
         this.implicitlyLoadedAfter = new Set();
         this.implicitlyLoadedBefore = new Set();
-        this.importDescriptions = new Map();
+        this.importDescriptions = Object.create(null);
         this.importMetas = [];
         this.importedFromNotTreeshaken = false;
         this.importers = [];
+        this.imports = new Set();
         this.includedDynamicImporters = [];
-        this.includedImports = new Set();
         this.isExecuted = false;
         this.isUserDefinedEntryPoint = false;
         this.needsExportShim = false;
+        this.preserveSignature = this.options.preserveEntrySignatures;
+        this.reexportDescriptions = Object.create(null);
         this.sideEffectDependenciesByVariable = new Map();
-        this.sourcesWithAssertions = new Map();
+        this.sources = new Set();
+        this.userChunkNames = new Set();
+        this.usesTopLevelAwait = false;
         this.allExportNames = null;
-        this.ast = null;
         this.exportAllModules = [];
-        this.exportAllSources = new Set();
         this.exportNamesByVariable = null;
         this.exportShimVariable = new ExportShimVariable(this);
-        this.exports = new Map();
-        this.namespaceReexportsByName = new Map();
-        this.reexportDescriptions = new Map();
+        this.namespaceReexportsByName = Object.create(null);
         this.relevantDependencies = null;
         this.syntheticExports = new Map();
         this.syntheticNamespace = null;
@@ -13015,142 +12158,92 @@
         this.transitiveReexports = null;
         this.excludeFromSourcemap = /\0/.test(id);
         this.context = options.moduleContext(id);
-        this.preserveSignature = this.options.preserveEntrySignatures;
         // eslint-disable-next-line @typescript-eslint/no-this-alias
         const module = this;
-        const { dynamicImports, dynamicImporters, exportAllSources, exports, implicitlyLoadedAfter, implicitlyLoadedBefore, importers, reexportDescriptions, sourcesWithAssertions } = this;
         this.info = {
-            assertions,
             ast: null,
             code: null,
-            get dynamicallyImportedIdResolutions() {
-                return dynamicImports
-                    .map(({ argument }) => typeof argument === 'string' && module.resolvedIds[argument])
-                    .filter(Boolean);
-            },
             get dynamicallyImportedIds() {
-                // We cannot use this.dynamicDependencies because this is needed before
-                // dynamicDependencies are populated
-                return dynamicImports.map(({ id }) => id).filter((id) => id != null);
-            },
-            get dynamicImporters() {
-                return dynamicImporters.sort();
-            },
-            get exportedBindings() {
-                const exportBindings = { '.': [...exports.keys()] };
-                for (const [name, { source }] of reexportDescriptions) {
-                    (exportBindings[source] ?? (exportBindings[source] = [])).push(name);
-                }
-                for (const source of exportAllSources) {
-                    (exportBindings[source] ?? (exportBindings[source] = [])).push('*');
-                }
-                return exportBindings;
-            },
-            get exports() {
-                return [
-                    ...exports.keys(),
-                    ...reexportDescriptions.keys(),
-                    ...[...exportAllSources].map(() => '*')
-                ];
-            },
-            get hasDefaultExport() {
-                // This information is only valid after parsing
-                if (!module.ast) {
-                    return null;
+                const dynamicallyImportedIds = [];
+                for (const { id } of module.dynamicImports) {
+                    if (id) {
+                        dynamicallyImportedIds.push(id);
+                    }
                 }
-                return module.exports.has('default') || reexportDescriptions.has('default');
+                return dynamicallyImportedIds;
             },
-            get hasModuleSideEffects() {
-                warnDeprecation('Accessing ModuleInfo.hasModuleSideEffects from plugins is deprecated. Please use ModuleInfo.moduleSideEffects instead.', URL_THIS_GETMODULEINFO, true, options);
-                return this.moduleSideEffects;
+            get dynamicImporters() {
+                return module.dynamicImporters.sort();
             },
+            hasModuleSideEffects,
             id,
             get implicitlyLoadedAfterOneOf() {
-                // eslint-disable-next-line unicorn/prefer-spread
-                return Array.from(implicitlyLoadedAfter, getId).sort();
+                return Array.from(module.implicitlyLoadedAfter, getId);
             },
             get implicitlyLoadedBefore() {
-                // eslint-disable-next-line unicorn/prefer-spread
-                return Array.from(implicitlyLoadedBefore, getId).sort();
-            },
-            get importedIdResolutions() {
-                // eslint-disable-next-line unicorn/prefer-spread
-                return Array.from(sourcesWithAssertions.keys(), source => module.resolvedIds[source]).filter(Boolean);
+                return Array.from(module.implicitlyLoadedBefore, getId);
             },
             get importedIds() {
-                // We cannot use this.dependencies because this is needed before
-                // dependencies are populated
-                // eslint-disable-next-line unicorn/prefer-spread
-                return Array.from(sourcesWithAssertions.keys(), source => module.resolvedIds[source]?.id).filter(Boolean);
+                return Array.from(module.sources, source => module.resolvedIds[source].id);
             },
             get importers() {
-                return importers.sort();
+                return module.importers.sort();
             },
             isEntry,
             isExternal: false,
-            get isIncluded() {
-                if (graph.phase !== BuildPhase.GENERATE) {
-                    return null;
-                }
-                return module.isIncluded();
-            },
-            meta: { ...meta },
-            moduleSideEffects,
+            meta,
             syntheticNamedExports
         };
-        // Hide the deprecated key so that it only warns when accessed explicitly
-        // eslint-disable-next-line unicorn/consistent-destructuring
-        Object.defineProperty(this.info, 'hasModuleSideEffects', {
-            enumerable: false
-        });
     }
     basename() {
         const base = basename(this.id);
-        const extension = extname(this.id);
-        return makeLegal(extension ? base.slice(0, -extension.length) : base);
+        const ext = extname(this.id);
+        return makeLegal(ext ? base.slice(0, -ext.length) : base);
     }
     bindReferences() {
         this.ast.bind();
     }
-    error(properties, pos) {
-        this.addLocationToLogProps(properties, pos);
-        return error(properties);
+    error(props, pos) {
+        this.addLocationToLogProps(props, pos);
+        return error(props);
     }
     getAllExportNames() {
         if (this.allExportNames) {
             return this.allExportNames;
         }
-        this.allExportNames = new Set([...this.exports.keys(), ...this.reexportDescriptions.keys()]);
+        const allExportNames = (this.allExportNames = new Set());
+        for (const name of Object.keys(this.exports)) {
+            allExportNames.add(name);
+        }
+        for (const name of Object.keys(this.reexportDescriptions)) {
+            allExportNames.add(name);
+        }
         for (const module of this.exportAllModules) {
             if (module instanceof ExternalModule) {
-                this.allExportNames.add(`*${module.id}`);
+                allExportNames.add(`*${module.id}`);
                 continue;
             }
             for (const name of module.getAllExportNames()) {
                 if (name !== 'default')
-                    this.allExportNames.add(name);
+                    allExportNames.add(name);
             }
         }
-        // We do not count the synthetic namespace as a regular export to hide it
-        // from entry signatures and namespace objects
-        if (typeof this.info.syntheticNamedExports === 'string') {
-            this.allExportNames.delete(this.info.syntheticNamedExports);
-        }
-        return this.allExportNames;
+        return allExportNames;
     }
     getDependenciesToBeIncluded() {
         if (this.relevantDependencies)
             return this.relevantDependencies;
-        this.relevantDependencies = new Set();
+        const relevantDependencies = new Set();
         const necessaryDependencies = new Set();
         const alwaysCheckedDependencies = new Set();
-        const dependencyVariables = new Set(this.includedImports);
+        let dependencyVariables = this.imports.keys();
         if (this.info.isEntry ||
             this.includedDynamicImporters.length > 0 ||
             this.namespace.included ||
             this.implicitlyLoadedAfter.size > 0) {
+            dependencyVariables = new Set(dependencyVariables);
             for (const exportName of [...this.getReexports(), ...this.getExports()]) {
-                const [exportedVariable] = this.getVariableForExportName(exportName);
+                const exportedVariable = this.getVariableForExportName(exportName);
                 if (exportedVariable) {
                     dependencyVariables.add(exportedVariable);
                 }
@@ -13171,18 +12264,18 @@
             }
             necessaryDependencies.add(variable.module);
         }
-        if (!this.options.treeshake || this.info.moduleSideEffects === 'no-treeshake') {
+        if (!this.options.treeshake || this.info.hasModuleSideEffects === 'no-treeshake') {
             for (const dependency of this.dependencies) {
-                this.relevantDependencies.add(dependency);
+                relevantDependencies.add(dependency);
             }
         }
         else {
-            this.addRelevantSideEffectDependencies(this.relevantDependencies, necessaryDependencies, alwaysCheckedDependencies);
+            this.addRelevantSideEffectDependencies(relevantDependencies, necessaryDependencies, alwaysCheckedDependencies);
         }
         for (const dependency of necessaryDependencies) {
-            this.relevantDependencies.add(dependency);
+            relevantDependencies.add(dependency);
         }
-        return this.relevantDependencies;
+        return (this.relevantDependencies = relevantDependencies);
     }
     getExportNamesByVariable() {
         if (this.exportNamesByVariable) {
@@ -13190,7 +12283,9 @@
         }
         const exportNamesByVariable = new Map();
         for (const exportName of this.getAllExportNames()) {
-            let [tracedVariable] = this.getVariableForExportName(exportName);
+            if (exportName === this.info.syntheticNamedExports)
+                continue;
+            let tracedVariable = this.getVariableForExportName(exportName);
             if (tracedVariable instanceof ExportDefaultVariable) {
                 tracedVariable = tracedVariable.getOriginalVariable();
             }
@@ -13209,7 +12304,7 @@
         return (this.exportNamesByVariable = exportNamesByVariable);
     }
     getExports() {
-        return [...this.exports.keys()];
+        return Object.keys(this.exports);
     }
     getReexports() {
         if (this.transitiveReexports) {
@@ -13217,7 +12312,10 @@
         }
         // to avoid infinite recursion when using circular `export * from X`
         this.transitiveReexports = [];
-        const reexports = new Set(this.reexportDescriptions.keys());
+        const reexports = new Set();
+        for (const name in this.reexportDescriptions) {
+            reexports.add(name);
+        }
         for (const module of this.exportAllModules) {
             if (module instanceof ExternalModule) {
                 reexports.add(`*${module.id}`);
@@ -13235,8 +12333,8 @@
         // only direct exports are counted here, not reexports at all
         const renderedExports = [];
         const removedExports = [];
-        for (const exportName of this.exports.keys()) {
-            const [variable] = this.getVariableForExportName(exportName);
+        for (const exportName in this.exports) {
+            const variable = this.getVariableForExportName(exportName);
             (variable && variable.included ? renderedExports : removedExports).push(exportName);
         }
         return { removedExports, renderedExports };
@@ -13244,79 +12342,85 @@
     getSyntheticNamespace() {
         if (this.syntheticNamespace === null) {
             this.syntheticNamespace = undefined;
-            [this.syntheticNamespace] = this.getVariableForExportName(typeof this.info.syntheticNamedExports === 'string'
+            this.syntheticNamespace = this.getVariableForExportName(typeof this.info.syntheticNamedExports === 'string'
                 ? this.info.syntheticNamedExports
-                : 'default', { onlyExplicit: true });
+                : 'default');
         }
         if (!this.syntheticNamespace) {
-            return error(errorSyntheticNamedExportsNeedNamespaceExport(this.id, this.info.syntheticNamedExports));
+            return error(errSyntheticNamedExportsNeedNamespaceExport(this.id, this.info.syntheticNamedExports));
         }
         return this.syntheticNamespace;
     }
-    getVariableForExportName(name, { importerForSideEffects, isExportAllSearch, onlyExplicit, searchedNamesAndModules } = EMPTY_OBJECT) {
+    getVariableForExportName(name, { importerForSideEffects, isExportAllSearch, searchedNamesAndModules, skipExternalNamespaceReexports } = EMPTY_OBJECT) {
         if (name[0] === '*') {
             if (name.length === 1) {
                 // export * from './other'
-                return [this.namespace];
+                return this.namespace;
+            }
+            else {
+                // export * from 'external'
+                const module = this.graph.modulesById.get(name.slice(1));
+                return module.getVariableForExportName('*');
             }
-            // export * from 'external'
-            const module = this.graph.modulesById.get(name.slice(1));
-            return module.getVariableForExportName('*');
         }
         // export { foo } from './other'
-        const reexportDeclaration = this.reexportDescriptions.get(name);
+        const reexportDeclaration = this.reexportDescriptions[name];
         if (reexportDeclaration) {
-            const [variable] = getVariableForExportNameRecursive(reexportDeclaration.module, reexportDeclaration.localName, importerForSideEffects, false, searchedNamesAndModules);
+            const variable = getVariableForExportNameRecursive(reexportDeclaration.module, reexportDeclaration.localName, importerForSideEffects, false, searchedNamesAndModules, false);
             if (!variable) {
-                return this.error(errorMissingExport(reexportDeclaration.localName, this.id, reexportDeclaration.module.id), reexportDeclaration.start);
+                return this.error(errMissingExport(reexportDeclaration.localName, this.id, reexportDeclaration.module.id), reexportDeclaration.start);
             }
             if (importerForSideEffects) {
                 setAlternativeExporterIfCyclic(variable, importerForSideEffects, this);
             }
-            return [variable];
+            return variable;
         }
-        const exportDeclaration = this.exports.get(name);
+        const exportDeclaration = this.exports[name];
         if (exportDeclaration) {
             if (exportDeclaration === MISSING_EXPORT_SHIM_DESCRIPTION) {
-                return [this.exportShimVariable];
+                return this.exportShimVariable;
             }
             const name = exportDeclaration.localName;
-            const variable = this.traceVariable(name, {
-                importerForSideEffects,
-                searchedNamesAndModules
-            });
+            const variable = this.traceVariable(name, importerForSideEffects);
             if (importerForSideEffects) {
-                getOrCreate(importerForSideEffects.sideEffectDependenciesByVariable, variable, getNewSet).add(this);
+                getOrCreate(importerForSideEffects.sideEffectDependenciesByVariable, variable, () => new Set()).add(this);
                 setAlternativeExporterIfCyclic(variable, importerForSideEffects, this);
             }
-            return [variable];
-        }
-        if (onlyExplicit) {
-            return [null];
+            return variable;
         }
         if (name !== 'default') {
-            const foundNamespaceReexport = this.namespaceReexportsByName.get(name) ??
-                this.getVariableFromNamespaceReexports(name, importerForSideEffects, searchedNamesAndModules);
-            this.namespaceReexportsByName.set(name, foundNamespaceReexport);
-            if (foundNamespaceReexport[0]) {
+            const foundNamespaceReexport = name in this.namespaceReexportsByName
+                ? this.namespaceReexportsByName[name]
+                : this.getVariableFromNamespaceReexports(name, importerForSideEffects, searchedNamesAndModules, skipExternalNamespaceReexports);
+            if (!skipExternalNamespaceReexports) {
+                this.namespaceReexportsByName[name] = foundNamespaceReexport;
+            }
+            if (foundNamespaceReexport) {
                 return foundNamespaceReexport;
             }
         }
         if (this.info.syntheticNamedExports) {
-            return [
-                getOrCreate(this.syntheticExports, name, () => new SyntheticNamedExportVariable(this.astContext, name, this.getSyntheticNamespace()))
-            ];
+            let syntheticExport = this.syntheticExports.get(name);
+            if (!syntheticExport) {
+                const syntheticNamespace = this.getSyntheticNamespace();
+                syntheticExport = new SyntheticNamedExportVariable(this.astContext, name, syntheticNamespace);
+                this.syntheticExports.set(name, syntheticExport);
+                return syntheticExport;
+            }
+            return syntheticExport;
         }
         // we don't want to create shims when we are just
         // probing export * modules for exports
-        if (!isExportAllSearch && this.options.shimMissingExports) {
-            this.shimMissingExport(name);
-            return [this.exportShimVariable];
+        if (!isExportAllSearch) {
+            if (this.options.shimMissingExports) {
+                this.shimMissingExport(name);
+                return this.exportShimVariable;
+            }
         }
-        return [null];
+        return null;
     }
     hasEffects() {
-        return (this.info.moduleSideEffects === 'no-treeshake' ||
+        return (this.info.hasModuleSideEffects === 'no-treeshake' ||
             (this.ast.included && this.ast.hasEffects(createHasEffectsContext())));
     }
     include() {
@@ -13329,9 +12433,9 @@
             markModuleAndImpureDependenciesAsExecuted(this);
             this.graph.needsTreeshakingPass = true;
         }
-        for (const exportName of this.exports.keys()) {
+        for (const exportName of this.getExports()) {
             if (includeNamespaceMembers || exportName !== this.info.syntheticNamedExports) {
-                const variable = this.getVariableForExportName(exportName)[0];
+                const variable = this.getVariableForExportName(exportName);
                 variable.deoptimizePath(UNKNOWN_PATH);
                 if (!variable.included) {
                     this.includeVariable(variable);
@@ -13339,7 +12443,7 @@
             }
         }
         for (const name of this.getReexports()) {
-            const [variable] = this.getVariableForExportName(name);
+            const variable = this.getVariableForExportName(name);
             if (variable) {
                 variable.deoptimizePath(UNKNOWN_PATH);
                 if (!variable.included) {
@@ -13359,13 +12463,16 @@
         this.includeAllExports(false);
     }
     isIncluded() {
-        // Modules where this.ast is missing have been loaded via this.load and are
-        // not yet fully processed, hence they cannot be included.
-        return (this.ast && (this.ast.included || this.namespace.included || this.importedFromNotTreeshaken));
+        return this.ast.included || this.namespace.included || this.importedFromNotTreeshaken;
     }
     linkImports() {
         this.addModulesToImportDescriptions(this.importDescriptions);
         this.addModulesToImportDescriptions(this.reexportDescriptions);
+        for (const name in this.exports) {
+            if (name !== 'default' && name !== this.info.syntheticNamedExports) {
+                this.exportsAll[name] = this.id;
+            }
+        }
         const externalExportAllModules = [];
         for (const source of this.exportAllSources) {
             const module = this.graph.modulesById.get(this.resolvedIds[source].id);
@@ -13374,21 +12481,24 @@
                 continue;
             }
             this.exportAllModules.push(module);
+            for (const name in module.exportsAll) {
+                if (name in this.exportsAll) {
+                    this.options.onwarn(errNamespaceConflict(name, this, module));
+                }
+                else {
+                    this.exportsAll[name] = module.exportsAll[name];
+                }
+            }
         }
         this.exportAllModules.push(...externalExportAllModules);
     }
     render(options) {
-        const source = this.magicString.clone();
-        this.ast.render(source, options);
-        source.trim();
-        const { usesTopLevelAwait } = this.astContext;
-        if (usesTopLevelAwait && options.format !== 'es' && options.format !== 'system') {
-            return error(errorInvalidFormatForTopLevelAwait(this.id, options.format));
-        }
-        return { source, usesTopLevelAwait };
+        const magicString = this.magicString.clone();
+        this.ast.render(magicString, options);
+        this.usesTopLevelAwait = this.astContext.usesTopLevelAwait;
+        return magicString;
     }
     setSource({ ast, code, customTransformCache, originalCode, originalSourcemap, resolvedIds, sourcemapChain, transformDependencies, transformFiles, ...moduleOptions }) {
-        timeStart('generate ast', 3);
         this.info.code = code;
         this.originalCode = originalCode;
         this.originalSourcemap = originalSourcemap;
@@ -13399,17 +12509,20 @@
         this.transformDependencies = transformDependencies;
         this.customTransformCache = customTransformCache;
         this.updateOptions(moduleOptions);
-        const moduleAst = ast ?? this.tryParse();
+        timeStart('generate ast', 3);
+        if (!ast) {
+            ast = this.tryParse();
+        }
         timeEnd('generate ast', 3);
-        timeStart('analyze ast', 3);
-        this.resolvedIds = resolvedIds ?? Object.create(null);
+        this.resolvedIds = resolvedIds || Object.create(null);
         // By default, `id` is the file name. Custom resolvers and loaders
         // can change that, but it makes sense to use it for the source file name
         const fileName = this.id;
-        this.magicString = new MagicString(code, {
+        this.magicString = new MagicString$1(code, {
             filename: (this.excludeFromSourcemap ? null : fileName),
             indentExclusionRanges: []
         });
+        timeStart('analyse ast', 3);
         this.astContext = {
             addDynamicImport: this.addDynamicImport.bind(this),
             addExport: this.addExport.bind(this),
@@ -13422,59 +12535,37 @@
             getExports: this.getExports.bind(this),
             getModuleExecIndex: () => this.execIndex,
             getModuleName: this.basename.bind(this),
-            getNodeConstructor: (name) => nodeConstructors[name] || nodeConstructors.UnknownNode,
             getReexports: this.getReexports.bind(this),
             importDescriptions: this.importDescriptions,
             includeAllExports: () => this.includeAllExports(true),
             includeDynamicImport: this.includeDynamicImport.bind(this),
             includeVariableInModule: this.includeVariableInModule.bind(this),
             magicString: this.magicString,
-            manualPureFunctions: this.graph.pureFunctions,
             module: this,
             moduleContext: this.context,
+            nodeConstructors,
             options: this.options,
             requestTreeshakingPass: () => (this.graph.needsTreeshakingPass = true),
-            traceExport: (name) => this.getVariableForExportName(name)[0],
+            traceExport: this.getVariableForExportName.bind(this),
             traceVariable: this.traceVariable.bind(this),
             usesTopLevelAwait: false,
             warn: this.warn.bind(this)
         };
         this.scope = new ModuleScope(this.graph.scope, this.astContext);
         this.namespace = new NamespaceVariable(this.astContext);
-        this.ast = new Program(moduleAst, { context: this.astContext, type: 'Module' }, this.scope);
-        // Assign AST directly if has existing one as there's no way to drop it from memory.
-        // If cache is enabled, also assign directly as otherwise it takes more CPU and memory to re-compute.
-        if (ast || this.options.cache !== false) {
-            this.info.ast = moduleAst;
-        }
-        else {
-            // Make lazy and apply LRU cache to not hog the memory
-            Object.defineProperty(this.info, 'ast', {
-                get: () => {
-                    if (this.graph.astLru.has(fileName)) {
-                        return this.graph.astLru.get(fileName);
-                    }
-                    else {
-                        const parsedAst = this.tryParse();
-                        this.graph.astLru.set(fileName, parsedAst);
-                        return parsedAst;
-                    }
-                }
-            });
-        }
-        timeEnd('analyze ast', 3);
+        this.ast = new Program(ast, { context: this.astContext, type: 'Module' }, this.scope);
+        this.info.ast = ast;
+        timeEnd('analyse ast', 3);
     }
     toJSON() {
         return {
-            assertions: this.info.assertions,
-            ast: this.info.ast,
+            ast: this.ast.esTreeNode,
             code: this.info.code,
             customTransformCache: this.customTransformCache,
-            // eslint-disable-next-line unicorn/prefer-spread
             dependencies: Array.from(this.dependencies, getId),
             id: this.id,
             meta: this.info.meta,
-            moduleSideEffects: this.info.moduleSideEffects,
+            moduleSideEffects: this.info.hasModuleSideEffects,
             originalCode: this.originalCode,
             originalSourcemap: this.originalSourcemap,
             resolvedIds: this.resolvedIds,
@@ -13484,39 +12575,60 @@
             transformFiles: this.transformFiles
         };
     }
-    traceVariable(name, { importerForSideEffects, isExportAllSearch, searchedNamesAndModules } = EMPTY_OBJECT) {
+    traceVariable(name, importerForSideEffects) {
         const localVariable = this.scope.variables.get(name);
         if (localVariable) {
             return localVariable;
         }
-        const importDescription = this.importDescriptions.get(name);
-        if (importDescription) {
-            const otherModule = importDescription.module;
-            if (otherModule instanceof Module && importDescription.name === '*') {
+        if (name in this.importDescriptions) {
+            const importDeclaration = this.importDescriptions[name];
+            const otherModule = importDeclaration.module;
+            if (otherModule instanceof Module && importDeclaration.name === '*') {
                 return otherModule.namespace;
             }
-            const [declaration] = getVariableForExportNameRecursive(otherModule, importDescription.name, importerForSideEffects || this, isExportAllSearch, searchedNamesAndModules);
+            const declaration = otherModule.getVariableForExportName(importDeclaration.name, {
+                importerForSideEffects: importerForSideEffects || this
+            });
             if (!declaration) {
-                return this.error(errorMissingExport(importDescription.name, this.id, otherModule.id), importDescription.start);
+                return this.error(errMissingExport(importDeclaration.name, this.id, otherModule.id), importDeclaration.start);
             }
             return declaration;
         }
         return null;
     }
+    tryParse() {
+        try {
+            return this.graph.contextParse(this.info.code);
+        }
+        catch (err) {
+            let message = err.message.replace(/ \(\d+:\d+\)$/, '');
+            if (this.id.endsWith('.json')) {
+                message += ' (Note that you need @rollup/plugin-json to import JSON files)';
+            }
+            else if (!this.id.endsWith('.js')) {
+                message += ' (Note that you need plugins to import files that are not JavaScript)';
+            }
+            return this.error({
+                code: 'PARSE_ERROR',
+                message,
+                parserError: err
+            }, err.pos);
+        }
+    }
     updateOptions({ meta, moduleSideEffects, syntheticNamedExports }) {
         if (moduleSideEffects != null) {
-            this.info.moduleSideEffects = moduleSideEffects;
+            this.info.hasModuleSideEffects = moduleSideEffects;
         }
         if (syntheticNamedExports != null) {
             this.info.syntheticNamedExports = syntheticNamedExports;
         }
         if (meta != null) {
-            Object.assign(this.info.meta, meta);
+            this.info.meta = { ...this.info.meta, ...meta };
         }
     }
-    warn(properties, pos) {
-        this.addLocationToLogProps(properties, pos);
-        this.options.onwarn(properties);
+    warn(props, pos) {
+        this.addLocationToLogProps(props, pos);
+        this.options.onwarn(props);
     }
     addDynamicImport(node) {
         let argument = node.source;
@@ -13533,23 +12645,23 @@
     addExport(node) {
         if (node instanceof ExportDefaultDeclaration) {
             // export default foo;
-            this.exports.set('default', {
+            this.exports.default = {
                 identifier: node.variable.getAssignedVariableName(),
                 localName: 'default'
-            });
+            };
         }
         else if (node instanceof ExportAllDeclaration) {
             const source = node.source.value;
-            this.addSource(source, node);
+            this.sources.add(source);
             if (node.exported) {
                 // export * as name from './other'
                 const name = node.exported.name;
-                this.reexportDescriptions.set(name, {
+                this.reexportDescriptions[name] = {
                     localName: '*',
                     module: null,
                     source,
                     start: node.start
-                });
+                };
             }
             else {
                 // export * from './other'
@@ -13559,15 +12671,15 @@
         else if (node.source instanceof Literal) {
             // export { name } from './other'
             const source = node.source.value;
-            this.addSource(source, node);
-            for (const { exported, local, start } of node.specifiers) {
-                const name = exported instanceof Literal ? exported.value : exported.name;
-                this.reexportDescriptions.set(name, {
-                    localName: local instanceof Literal ? local.value : local.name,
+            this.sources.add(source);
+            for (const specifier of node.specifiers) {
+                const name = specifier.exported.name;
+                this.reexportDescriptions[name] = {
+                    localName: specifier.local.name,
                     module: null,
                     source,
-                    start
-                });
+                    start: specifier.start
+                };
             }
         }
         else if (node.declaration) {
@@ -13577,51 +12689,50 @@
                 // export var foo = 1, bar = 2;
                 for (const declarator of declaration.declarations) {
                     for (const localName of extractAssignedNames(declarator.id)) {
-                        this.exports.set(localName, { identifier: null, localName });
+                        this.exports[localName] = { identifier: null, localName };
                     }
                 }
             }
             else {
                 // export function foo () {}
                 const localName = declaration.id.name;
-                this.exports.set(localName, { identifier: null, localName });
+                this.exports[localName] = { identifier: null, localName };
             }
         }
         else {
             // export { foo, bar, baz }
-            for (const { local, exported } of node.specifiers) {
-                // except for reexports, local must be an Identifier
-                const localName = local.name;
-                const exportedName = exported instanceof Identifier ? exported.name : exported.value;
-                this.exports.set(exportedName, { identifier: null, localName });
+            for (const specifier of node.specifiers) {
+                const localName = specifier.local.name;
+                const exportedName = specifier.exported.name;
+                this.exports[exportedName] = { identifier: null, localName };
             }
         }
     }
     addImport(node) {
         const source = node.source.value;
-        this.addSource(source, node);
+        this.sources.add(source);
         for (const specifier of node.specifiers) {
-            const name = specifier instanceof ImportDefaultSpecifier
+            const isDefault = specifier.type === ImportDefaultSpecifier$1;
+            const isNamespace = specifier.type === ImportNamespaceSpecifier$1;
+            const name = isDefault
                 ? 'default'
-                : specifier instanceof ImportNamespaceSpecifier
+                : isNamespace
                     ? '*'
-                    : specifier.imported instanceof Identifier
-                        ? specifier.imported.name
-                        : specifier.imported.value;
-            this.importDescriptions.set(specifier.local.name, {
+                    : specifier.imported.name;
+            this.importDescriptions[specifier.local.name] = {
                 module: null,
                 name,
                 source,
                 start: specifier.start
-            });
+            };
         }
     }
     addImportMeta(node) {
         this.importMetas.push(node);
     }
-    addLocationToLogProps(properties, pos) {
-        properties.id = this.id;
-        properties.pos = pos;
+    addLocationToLogProps(props, pos) {
+        props.id = this.id;
+        props.pos = pos;
         let code = this.info.code;
         const location = locate(code, pos, { offsetLine: 1 });
         if (location) {
@@ -13630,15 +12741,25 @@
                 ({ column, line } = getOriginalLocation(this.sourcemapChain, { column, line }));
                 code = this.originalCode;
             }
-            catch (error_) {
-                this.options.onwarn(errorInvalidSourcemapForError(error_, this.id, column, line, pos));
+            catch (err) {
+                this.options.onwarn({
+                    code: 'SOURCEMAP_ERROR',
+                    id: this.id,
+                    loc: {
+                        column,
+                        file: this.id,
+                        line
+                    },
+                    message: `Error when using sourcemap for reporting an error: ${err.message}`,
+                    pos
+                });
             }
-            augmentCodeLocation(properties, { column, line }, code, this.id);
+            augmentCodeLocation(props, { column, line }, code, this.id);
         }
     }
     addModulesToImportDescriptions(importDescription) {
-        for (const specifier of importDescription.values()) {
-            const { id } = this.resolvedIds[specifier.source];
+        for (const specifier of Object.values(importDescription)) {
+            const id = this.resolvedIds[specifier.source].id;
             specifier.module = this.graph.modulesById.get(id);
         }
     }
@@ -13654,7 +12775,7 @@
                     relevantDependencies.add(dependency);
                     continue;
                 }
-                if (!(dependency.info.moduleSideEffects || alwaysCheckedDependencies.has(dependency))) {
+                if (!(dependency.info.hasModuleSideEffects || alwaysCheckedDependencies.has(dependency))) {
                     continue;
                 }
                 if (dependency instanceof ExternalModule || dependency.hasEffects()) {
@@ -13667,80 +12788,66 @@
         addSideEffectDependencies(this.dependencies);
         addSideEffectDependencies(alwaysCheckedDependencies);
     }
-    addSource(source, declaration) {
-        const parsedAssertions = getAssertionsFromImportExportDeclaration(declaration.assertions);
-        const existingAssertions = this.sourcesWithAssertions.get(source);
-        if (existingAssertions) {
-            if (doAssertionsDiffer(existingAssertions, parsedAssertions)) {
-                this.warn(errorInconsistentImportAssertions(existingAssertions, parsedAssertions, source, this.id), declaration.start);
-            }
-        }
-        else {
-            this.sourcesWithAssertions.set(source, parsedAssertions);
-        }
-    }
-    getVariableFromNamespaceReexports(name, importerForSideEffects, searchedNamesAndModules) {
+    getVariableFromNamespaceReexports(name, importerForSideEffects, searchedNamesAndModules, skipExternalNamespaceReexports = false) {
         let foundSyntheticDeclaration = null;
-        const foundInternalDeclarations = new Map();
-        const foundExternalDeclarations = new Set();
-        for (const module of this.exportAllModules) {
-            // Synthetic namespaces should not hide "regular" exports of the same name
-            if (module.info.syntheticNamedExports === name) {
-                continue;
-            }
-            const [variable, indirectExternal] = getVariableForExportNameRecursive(module, name, importerForSideEffects, true, 
-            // We are creating a copy to handle the case where the same binding is
-            // imported through different namespace reexports gracefully
-            copyNameToModulesMap(searchedNamesAndModules));
-            if (module instanceof ExternalModule || indirectExternal) {
-                foundExternalDeclarations.add(variable);
-            }
-            else if (variable instanceof SyntheticNamedExportVariable) {
-                if (!foundSyntheticDeclaration) {
-                    foundSyntheticDeclaration = variable;
+        const skipExternalNamespaceValues = [{ searchedNamesAndModules, skipExternalNamespaces: true }];
+        if (!skipExternalNamespaceReexports) {
+            const clonedSearchedNamesAndModules = new Map();
+            for (const [name, modules] of searchedNamesAndModules || []) {
+                clonedSearchedNamesAndModules.set(name, new Set(modules));
+            }
+            skipExternalNamespaceValues.push({
+                searchedNamesAndModules: clonedSearchedNamesAndModules,
+                skipExternalNamespaces: false
+            });
+        }
+        for (const { skipExternalNamespaces, searchedNamesAndModules } of skipExternalNamespaceValues) {
+            const foundDeclarations = new Set();
+            for (const module of this.exportAllModules) {
+                if (module instanceof Module || !skipExternalNamespaces) {
+                    const declaration = getVariableForExportNameRecursive(module, name, importerForSideEffects, true, searchedNamesAndModules, skipExternalNamespaces);
+                    if (declaration) {
+                        if (!(declaration instanceof SyntheticNamedExportVariable)) {
+                            foundDeclarations.add(declaration);
+                        }
+                        else if (!foundSyntheticDeclaration) {
+                            foundSyntheticDeclaration = declaration;
+                        }
+                    }
                 }
             }
-            else if (variable) {
-                foundInternalDeclarations.set(variable, module);
-            }
-        }
-        if (foundInternalDeclarations.size > 0) {
-            const foundDeclarationList = [...foundInternalDeclarations];
-            const usedDeclaration = foundDeclarationList[0][0];
-            if (foundDeclarationList.length === 1) {
-                return [usedDeclaration];
+            if (foundDeclarations.size === 1) {
+                return [...foundDeclarations][0];
             }
-            this.options.onwarn(errorNamespaceConflict(name, this.id, foundDeclarationList.map(([, module]) => module.id)));
-            // TODO we are pretending it was not found while it should behave like "undefined"
-            return [null];
-        }
-        if (foundExternalDeclarations.size > 0) {
-            const foundDeclarationList = [...foundExternalDeclarations];
-            const usedDeclaration = foundDeclarationList[0];
-            if (foundDeclarationList.length > 1) {
-                this.options.onwarn(errorAmbiguousExternalNamespaces(name, this.id, usedDeclaration.module.id, foundDeclarationList.map(declaration => declaration.module.id)));
+            if (foundDeclarations.size > 1) {
+                if (skipExternalNamespaces) {
+                    return null;
+                }
+                const foundDeclarationList = [...foundDeclarations];
+                const usedDeclaration = foundDeclarationList[0];
+                this.options.onwarn(errAmbiguousExternalNamespaces(name, this.id, usedDeclaration.module.id, foundDeclarationList.map(declaration => declaration.module.id)));
+                return usedDeclaration;
             }
-            return [usedDeclaration, true];
         }
         if (foundSyntheticDeclaration) {
-            return [foundSyntheticDeclaration];
+            return foundSyntheticDeclaration;
         }
-        return [null];
+        return null;
     }
     includeAndGetAdditionalMergedNamespaces() {
         const externalNamespaces = new Set();
         const syntheticNamespaces = new Set();
         for (const module of [this, ...this.exportAllModules]) {
             if (module instanceof ExternalModule) {
-                const [externalVariable] = module.getVariableForExportName('*');
+                const externalVariable = module.getVariableForExportName('*');
                 externalVariable.include();
-                this.includedImports.add(externalVariable);
+                this.imports.add(externalVariable);
                 externalNamespaces.add(externalVariable);
             }
             else if (module.info.syntheticNamedExports) {
                 const syntheticNamespace = module.getSyntheticNamespace();
                 syntheticNamespace.include();
-                this.includedImports.add(syntheticNamespace);
+                this.imports.add(syntheticNamespace);
                 syntheticNamespaces.add(syntheticNamespace);
             }
         }
@@ -13758,7 +12865,7 @@
             variable.include();
             this.graph.needsTreeshakingPass = true;
             const variableModule = variable.module;
-            if (variableModule instanceof Module) {
+            if (variableModule && variableModule instanceof Module) {
                 if (!variableModule.isExecuted) {
                     markModuleAndImpureDependenciesAsExecuted(variableModule);
                 }
@@ -13777,20 +12884,17 @@
         this.includeVariable(variable);
         const variableModule = variable.module;
         if (variableModule && variableModule !== this) {
-            this.includedImports.add(variable);
+            this.imports.add(variable);
         }
     }
     shimMissingExport(name) {
-        this.options.onwarn(errorShimmedExport(this.id, name));
-        this.exports.set(name, MISSING_EXPORT_SHIM_DESCRIPTION);
-    }
-    tryParse() {
-        try {
-            return this.graph.contextParse(this.info.code);
-        }
-        catch (error_) {
-            return this.error(errorParseError(error_, this.id), error_.pos);
-        }
+        this.options.onwarn({
+            code: 'SHIMMED_EXPORT',
+            exporter: relativeId(this.id),
+            exportName: name,
+            message: `Missing export "${name}" has been shimmed in module ${relativeId(this.id)}.`
+        });
+        this.exports[name] = MISSING_EXPORT_SHIM_DESCRIPTION;
     }
 }
 // if there is a cyclic import in the reexport chain, we should not
@@ -13810,32 +12914,31 @@
         }
     }
 }
-const copyNameToModulesMap = (searchedNamesAndModules) => searchedNamesAndModules &&
-    // eslint-disable-next-line unicorn/prefer-spread
-    new Map(Array.from(searchedNamesAndModules, ([name, modules]) => [name, new Set(modules)]));
 
 function removeJsExtension(name) {
     return name.endsWith('.js') ? name.slice(0, -3) : name;
 }
 
 function getCompleteAmdId(options, chunkId) {
-    if (options.autoId) {
+    if (!options.autoId) {
+        return options.id || '';
+    }
+    else {
         return `${options.basePath ? options.basePath + '/' : ''}${removeJsExtension(chunkId)}`;
     }
-    return options.id ?? '';
 }
 
 function getExportBlock$1(exports, dependencies, namedExportsMode, interop, snippets, t, externalLiveBindings, mechanism = 'return ') {
-    const { _, getDirectReturnFunction, getFunctionIntro, getPropertyAccess, n, s } = snippets;
+    const { _, cnst, getDirectReturnFunction, getFunctionIntro, getPropertyAccess, n, s } = snippets;
     if (!namedExportsMode) {
         return `${n}${n}${mechanism}${getSingleDefaultExport(exports, dependencies, interop, externalLiveBindings, getPropertyAccess)};`;
     }
     let exportBlock = '';
-    for (const { defaultVariableName, importPath, isChunk, name, namedExportsMode: depNamedExportsMode, namespaceVariableName, reexports } of dependencies) {
+    for (const { defaultVariableName, id, isChunk, name, namedExportsMode: depNamedExportsMode, namespaceVariableName, reexports } of dependencies) {
         if (reexports && namedExportsMode) {
             for (const specifier of reexports) {
                 if (specifier.reexported !== '*') {
-                    const importName = getReexportedImportName(name, specifier.imported, depNamedExportsMode, isChunk, defaultVariableName, namespaceVariableName, interop, importPath, externalLiveBindings, getPropertyAccess);
+                    const importName = getReexportedImportName(name, specifier.imported, depNamedExportsMode, isChunk, defaultVariableName, namespaceVariableName, interop, id, externalLiveBindings, getPropertyAccess);
                     if (exportBlock)
                         exportBlock += n;
                     if (specifier.imported !== '*' && specifier.needsLiveBinding) {
@@ -13872,10 +12975,13 @@
                     if (exportBlock)
                         exportBlock += n;
                     const copyPropertyIfNecessary = `{${n}${t}if${_}(k${_}!==${_}'default'${_}&&${_}!exports.hasOwnProperty(k))${_}${getDefineProperty(name, specifier.needsLiveBinding, t, snippets)}${s}${n}}`;
-                    exportBlock += `Object.keys(${name}).forEach(${getFunctionIntro(['k'], {
-                        isAsync: false,
-                        name: null
-                    })}${copyPropertyIfNecessary});`;
+                    exportBlock +=
+                        cnst === 'var' && specifier.needsLiveBinding
+                            ? `Object.keys(${name}).forEach(${getFunctionIntro(['k'], {
+                                isAsync: false,
+                                name: null
+                            })}${copyPropertyIfNecessary});`
+                            : `for${_}(${cnst} k in ${name})${_}${copyPropertyIfNecessary}`;
                 }
             }
         }
@@ -13890,9 +12996,9 @@
         return exports[0].local;
     }
     else {
-        for (const { defaultVariableName, importPath, isChunk, name, namedExportsMode: depNamedExportsMode, namespaceVariableName, reexports } of dependencies) {
+        for (const { defaultVariableName, id, isChunk, name, namedExportsMode: depNamedExportsMode, namespaceVariableName, reexports } of dependencies) {
             if (reexports) {
-                return getReexportedImportName(name, reexports[0].imported, depNamedExportsMode, isChunk, defaultVariableName, namespaceVariableName, interop, importPath, externalLiveBindings, getPropertyAccess);
+                return getReexportedImportName(name, reexports[0].imported, depNamedExportsMode, isChunk, defaultVariableName, namespaceVariableName, interop, id, externalLiveBindings, getPropertyAccess);
             }
         }
     }
@@ -13900,7 +13006,7 @@
 function getReexportedImportName(moduleVariableName, imported, depNamedExportsMode, isChunk, defaultVariableName, namespaceVariableName, interop, moduleId, externalLiveBindings, getPropertyAccess) {
     if (imported === 'default') {
         if (!isChunk) {
-            const moduleInterop = interop(moduleId);
+            const moduleInterop = String(interop(moduleId));
             const variableName = defaultInteropHelpersByInteropType[moduleInterop]
                 ? defaultVariableName
                 : moduleVariableName;
@@ -13913,35 +13019,34 @@
             : moduleVariableName;
     }
     if (imported === '*') {
-        return (isChunk ? !depNamedExportsMode : namespaceInteropHelpersByInteropType[interop(moduleId)])
+        return (isChunk
+            ? !depNamedExportsMode
+            : namespaceInteropHelpersByInteropType[String(interop(moduleId))])
             ? namespaceVariableName
             : moduleVariableName;
     }
     return `${moduleVariableName}${getPropertyAccess(imported)}`;
 }
-function getEsModuleValue(getObject) {
-    return getObject([['value', 'true']], {
-        lineBreakIndent: null
-    });
+function getEsModuleExport(_) {
+    return `Object.defineProperty(exports,${_}'__esModule',${_}{${_}value:${_}true${_}});`;
+}
+function getNamespaceToStringExport(_) {
+    return `exports[Symbol.toStringTag]${_}=${_}'Module';`;
 }
-function getNamespaceMarkers(hasNamedExports, addEsModule, addNamespaceToStringTag, { _, getObject }) {
+function getNamespaceMarkers(hasNamedExports, addEsModule, addNamespaceToStringTag, _, n) {
+    let namespaceMarkers = '';
     if (hasNamedExports) {
         if (addEsModule) {
-            if (addNamespaceToStringTag) {
-                return `Object.defineProperties(exports,${_}${getObject([
-                    ['__esModule', getEsModuleValue(getObject)],
-                    [null, `[Symbol.toStringTag]:${_}${getToStringTagValue(getObject)}`]
-                ], {
-                    lineBreakIndent: null
-                })});`;
-            }
-            return `Object.defineProperty(exports,${_}'__esModule',${_}${getEsModuleValue(getObject)});`;
+            namespaceMarkers += getEsModuleExport(_);
         }
         if (addNamespaceToStringTag) {
-            return `Object.defineProperty(exports,${_}Symbol.toStringTag,${_}${getToStringTagValue(getObject)});`;
+            if (namespaceMarkers) {
+                namespaceMarkers += n;
+            }
+            namespaceMarkers += getNamespaceToStringExport(_);
         }
     }
-    return '';
+    return namespaceMarkers;
 }
 const getDefineProperty = (name, needsLiveBinding, t, { _, getDirectReturnFunction, n }) => {
     if (needsLiveBinding) {
@@ -13965,7 +13070,7 @@
         neededInteropHelpers.add(helper);
         interopStatements.push(`${cnst} ${helperVariableName}${_}=${_}/*#__PURE__*/${helper}(${dependencyVariableName});`);
     };
-    for (const { defaultVariableName, imports, importPath, isChunk, name, namedExportsMode, namespaceVariableName, reexports } of dependencies) {
+    for (const { defaultVariableName, imports, id, isChunk, name, namedExportsMode, namespaceVariableName, reexports } of dependencies) {
         if (isChunk) {
             for (const { imported, reexported } of [
                 ...(imports || []),
@@ -13980,7 +13085,7 @@
             }
         }
         else {
-            const moduleInterop = interop(importPath);
+            const moduleInterop = String(interop(id));
             let hasDefault = false;
             let hasNamespace = false;
             for (const { imported, reexported } of [
@@ -13998,10 +13103,12 @@
                         }
                     }
                 }
-                else if (imported === '*' && reexported !== '*' && !hasNamespace) {
-                    hasNamespace = true;
-                    helper = namespaceInteropHelpersByInteropType[moduleInterop];
-                    variableName = namespaceVariableName;
+                else if (imported === '*' && reexported !== '*') {
+                    if (!hasNamespace) {
+                        hasNamespace = true;
+                        helper = namespaceInteropHelpersByInteropType[moduleInterop];
+                        variableName = namespaceVariableName;
+                    }
                 }
                 if (helper) {
                     addInteropStatement(variableName, helper, name);
@@ -14012,144 +13119,90 @@
     return `${getHelpersBlock(neededInteropHelpers, accessedGlobals, indent, snippets, externalLiveBindings, freeze, namespaceToStringTag)}${interopStatements.length > 0 ? `${interopStatements.join(n)}${n}${n}` : ''}`;
 }
 
-function addJsExtension(name) {
-    return name.endsWith('.js') ? name : name + '.js';
-}
-
 // AMD resolution will only respect the AMD baseUrl if the .js extension is omitted.
 // The assumption is that this makes sense for all relative ids:
 // https://requirejs.org/docs/api.html#jsfiles
-function updateExtensionForRelativeAmdId(id, forceJsExtensionForImports) {
-    if (id[0] !== '.') {
-        return id;
-    }
-    return forceJsExtensionForImports ? addJsExtension(id) : removeJsExtension(id);
+function removeExtensionFromRelativeAmdId(id) {
+    return id[0] === '.' ? removeJsExtension(id) : id;
 }
 
-var _staticExports = {};
-var _static = {
-  get exports(){ return _staticExports; },
-  set exports(v){ _staticExports = v; },
-};
-
-const require$$0 = [
-	"assert",
-	"async_hooks",
-	"buffer",
-	"child_process",
-	"cluster",
-	"console",
-	"constants",
-	"crypto",
-	"dgram",
-	"diagnostics_channel",
-	"dns",
-	"domain",
-	"events",
-	"fs",
-	"http",
-	"http2",
-	"https",
-	"inspector",
-	"module",
-	"net",
-	"os",
-	"path",
-	"perf_hooks",
-	"process",
-	"punycode",
-	"querystring",
-	"readline",
-	"repl",
-	"stream",
-	"string_decoder",
-	"timers",
-	"tls",
-	"trace_events",
-	"tty",
-	"url",
-	"util",
-	"v8",
-	"vm",
-	"wasi",
-	"worker_threads",
-	"zlib"
-];
-
-(function (module) {
-	module.exports = require$$0;
-} (_static));
-
-const builtinModules = /*@__PURE__*/getDefaultExportFromCjs(_staticExports);
-
-const nodeBuiltins = new Set([
-    ...builtinModules,
-    // TODO
-    // remove once builtin-modules includes PR: https://github.com/sindresorhus/builtin-modules/pull/17
-    'assert/strict',
-    'dns/promises',
-    'fs/promises',
-    'path/posix',
-    'path/win32',
-    'readline/promises',
-    'stream/consumers',
-    'stream/promises',
-    'stream/web',
-    'timers/promises',
-    'util/types'
-]);
+const builtins = {
+    assert: true,
+    buffer: true,
+    console: true,
+    constants: true,
+    domain: true,
+    events: true,
+    http: true,
+    https: true,
+    os: true,
+    path: true,
+    process: true,
+    punycode: true,
+    querystring: true,
+    stream: true,
+    string_decoder: true,
+    timers: true,
+    tty: true,
+    url: true,
+    util: true,
+    vm: true,
+    zlib: true
+};
 function warnOnBuiltins(warn, dependencies) {
-    const externalBuiltins = dependencies
-        .map(({ importPath }) => importPath)
-        .filter(importPath => nodeBuiltins.has(importPath) || importPath.startsWith('node:'));
-    if (externalBuiltins.length === 0)
+    const externalBuiltins = dependencies.map(({ id }) => id).filter(id => id in builtins);
+    if (!externalBuiltins.length)
         return;
-    warn(errorMissingNodeBuiltins(externalBuiltins));
+    warn({
+        code: 'MISSING_NODE_BUILTINS',
+        message: `Creating a browser bundle that depends on Node.js built-in modules (${printQuotedStringList(externalBuiltins)}). You might need to include https://github.com/snowpackjs/rollup-plugin-polyfill-node`,
+        modules: externalBuiltins
+    });
 }
 
-function amd(magicString, { accessedGlobals, dependencies, exports, hasDefaultExport, hasExports, id, indent: t, intro, isEntryFacade, isModuleFacade, namedExportsMode, outro, snippets, onwarn }, { amd, esModule, externalLiveBindings, freeze, interop, namespaceToStringTag, strict }) {
-    warnOnBuiltins(onwarn, dependencies);
-    const deps = dependencies.map(m => `'${updateExtensionForRelativeAmdId(m.importPath, amd.forceJsExtensionForImports)}'`);
-    const parameters = dependencies.map(m => m.name);
+function amd(magicString, { accessedGlobals, dependencies, exports, hasExports, id, indent: t, intro, isEntryFacade, isModuleFacade, namedExportsMode, outro, snippets, warn }, { amd, esModule, externalLiveBindings, freeze, interop, namespaceToStringTag, strict }) {
+    warnOnBuiltins(warn, dependencies);
+    const deps = dependencies.map(m => `'${removeExtensionFromRelativeAmdId(m.id)}'`);
+    const args = dependencies.map(m => m.name);
     const { n, getNonArrowFunctionIntro, _ } = snippets;
     if (namedExportsMode && hasExports) {
-        parameters.unshift(`exports`);
+        args.unshift(`exports`);
         deps.unshift(`'exports'`);
     }
     if (accessedGlobals.has('require')) {
-        parameters.unshift('require');
+        args.unshift('require');
         deps.unshift(`'require'`);
     }
     if (accessedGlobals.has('module')) {
-        parameters.unshift('module');
+        args.unshift('module');
         deps.unshift(`'module'`);
     }
     const completeAmdId = getCompleteAmdId(amd, id);
-    const defineParameters = (completeAmdId ? `'${completeAmdId}',${_}` : ``) +
-        (deps.length > 0 ? `[${deps.join(`,${_}`)}],${_}` : ``);
+    const params = (completeAmdId ? `'${completeAmdId}',${_}` : ``) +
+        (deps.length ? `[${deps.join(`,${_}`)}],${_}` : ``);
     const useStrict = strict ? `${_}'use strict';` : '';
     magicString.prepend(`${intro}${getInteropBlock(dependencies, interop, externalLiveBindings, freeze, namespaceToStringTag, accessedGlobals, t, snippets)}`);
     const exportBlock = getExportBlock$1(exports, dependencies, namedExportsMode, interop, snippets, t, externalLiveBindings);
-    let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, isEntryFacade && (esModule === true || (esModule === 'if-default-prop' && hasDefaultExport)), isModuleFacade && namespaceToStringTag, snippets);
+    let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, isEntryFacade && esModule, isModuleFacade && namespaceToStringTag, _, n);
     if (namespaceMarkers) {
         namespaceMarkers = n + n + namespaceMarkers;
     }
-    magicString
-        .append(`${exportBlock}${namespaceMarkers}${outro}`)
+    magicString.append(`${exportBlock}${namespaceMarkers}${outro}`);
+    return (magicString
         .indent(t)
         // factory function should be wrapped by parentheses to avoid lazy parsing,
         // cf. https://v8.dev/blog/preparser#pife
-        .prepend(`${amd.define}(${defineParameters}(${getNonArrowFunctionIntro(parameters, {
+        .prepend(`${amd.define}(${params}(${getNonArrowFunctionIntro(args, {
         isAsync: false,
         name: null
     })}{${useStrict}${n}${n}`)
-        .append(`${n}${n}}));`);
+        .append(`${n}${n}}));`));
 }
 
-function cjs(magicString, { accessedGlobals, dependencies, exports, hasDefaultExport, hasExports, indent: t, intro, isEntryFacade, isModuleFacade, namedExportsMode, outro, snippets }, { compact, esModule, externalLiveBindings, freeze, interop, namespaceToStringTag, strict }) {
+function cjs(magicString, { accessedGlobals, dependencies, exports, hasExports, indent: t, intro, isEntryFacade, isModuleFacade, namedExportsMode, outro, snippets }, { compact, esModule, externalLiveBindings, freeze, interop, namespaceToStringTag, strict }) {
     const { _, n } = snippets;
     const useStrict = strict ? `'use strict';${n}${n}` : '';
-    let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, isEntryFacade && (esModule === true || (esModule === 'if-default-prop' && hasDefaultExport)), isModuleFacade && namespaceToStringTag, snippets);
+    let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, isEntryFacade && esModule, isModuleFacade && namespaceToStringTag, _, n);
     if (namespaceMarkers) {
         namespaceMarkers += n + n;
     }
@@ -14157,23 +13210,23 @@
     const interopBlock = getInteropBlock(dependencies, interop, externalLiveBindings, freeze, namespaceToStringTag, accessedGlobals, t, snippets);
     magicString.prepend(`${useStrict}${intro}${namespaceMarkers}${importBlock}${interopBlock}`);
     const exportBlock = getExportBlock$1(exports, dependencies, namedExportsMode, interop, snippets, t, externalLiveBindings, `module.exports${_}=${_}`);
-    magicString.append(`${exportBlock}${outro}`);
+    return magicString.append(`${exportBlock}${outro}`);
 }
 function getImportBlock$1(dependencies, { _, cnst, n }, compact) {
     let importBlock = '';
     let definingVariable = false;
-    for (const { importPath, name, reexports, imports } of dependencies) {
+    for (const { id, name, reexports, imports } of dependencies) {
         if (!reexports && !imports) {
             if (importBlock) {
                 importBlock += compact && !definingVariable ? ',' : `;${n}`;
             }
             definingVariable = false;
-            importBlock += `require('${importPath}')`;
+            importBlock += `require('${id}')`;
         }
         else {
             importBlock += compact && definingVariable ? ',' : `${importBlock ? `;${n}` : ''}${cnst} `;
             definingVariable = true;
-            importBlock += `${name}${_}=${_}require('${importPath}')`;
+            importBlock += `${name}${_}=${_}require('${id}')`;
         }
     }
     if (importBlock) {
@@ -14183,27 +13236,25 @@
 }
 
 function es(magicString, { accessedGlobals, indent: t, intro, outro, dependencies, exports, snippets }, { externalLiveBindings, freeze, namespaceToStringTag }) {
-    const { n } = snippets;
-    const importBlock = getImportBlock(dependencies, snippets);
+    const { _, n } = snippets;
+    const importBlock = getImportBlock(dependencies, _);
     if (importBlock.length > 0)
         intro += importBlock.join(n) + n + n;
     intro += getHelpersBlock(null, accessedGlobals, t, snippets, externalLiveBindings, freeze, namespaceToStringTag);
     if (intro)
         magicString.prepend(intro);
     const exportBlock = getExportBlock(exports, snippets);
-    if (exportBlock.length > 0)
+    if (exportBlock.length)
         magicString.append(n + n + exportBlock.join(n).trim());
     if (outro)
         magicString.append(outro);
-    magicString.trim();
+    return magicString.trim();
 }
-function getImportBlock(dependencies, { _ }) {
+function getImportBlock(dependencies, _) {
     const importBlock = [];
-    for (const { importPath, reexports, imports, name, assertions } of dependencies) {
-        const assertion = assertions ? `${_}assert${_}${assertions}` : '';
-        const pathWithAssertion = `'${importPath}'${assertion};`;
+    for (const { id, reexports, imports, name } of dependencies) {
         if (!reexports && !imports) {
-            importBlock.push(`import${_}${pathWithAssertion}`);
+            importBlock.push(`import${_}'${id}';`);
             continue;
         }
         if (imports) {
@@ -14222,17 +13273,22 @@
                 }
             }
             if (starImport) {
-                importBlock.push(`import${_}*${_}as ${starImport.local} from${_}${pathWithAssertion}`);
+                importBlock.push(`import${_}*${_}as ${starImport.local} from${_}'${id}';`);
             }
             if (defaultImport && importedNames.length === 0) {
-                importBlock.push(`import ${defaultImport.local} from${_}${pathWithAssertion}`);
+                importBlock.push(`import ${defaultImport.local} from${_}'${id}';`);
             }
             else if (importedNames.length > 0) {
                 importBlock.push(`import ${defaultImport ? `${defaultImport.local},${_}` : ''}{${_}${importedNames
-                    .map(specifier => specifier.imported === specifier.local
-                    ? specifier.imported
-                    : `${specifier.imported} as ${specifier.local}`)
-                    .join(`,${_}`)}${_}}${_}from${_}${pathWithAssertion}`);
+                    .map(specifier => {
+                    if (specifier.imported === specifier.local) {
+                        return specifier.imported;
+                    }
+                    else {
+                        return `${specifier.imported} as ${specifier.local}`;
+                    }
+                })
+                    .join(`,${_}`)}${_}}${_}from${_}'${id}';`);
             }
         }
         if (reexports) {
@@ -14251,12 +13307,12 @@
                 }
             }
             if (starExport) {
-                importBlock.push(`export${_}*${_}from${_}${pathWithAssertion}`);
+                importBlock.push(`export${_}*${_}from${_}'${id}';`);
             }
             if (namespaceReexports.length > 0) {
                 if (!imports ||
                     !imports.some(specifier => specifier.imported === '*' && specifier.local === name)) {
-                    importBlock.push(`import${_}*${_}as ${name} from${_}${pathWithAssertion}`);
+                    importBlock.push(`import${_}*${_}as ${name} from${_}'${id}';`);
                 }
                 for (const specifier of namespaceReexports) {
                     importBlock.push(`export${_}{${_}${name === specifier.reexported ? name : `${name} as ${specifier.reexported}`} };`);
@@ -14264,10 +13320,15 @@
             }
             if (namedReexports.length > 0) {
                 importBlock.push(`export${_}{${_}${namedReexports
-                    .map(specifier => specifier.imported === specifier.reexported
-                    ? specifier.imported
-                    : `${specifier.imported} as ${specifier.reexported}`)
-                    .join(`,${_}`)}${_}}${_}from${_}${pathWithAssertion}`);
+                    .map(specifier => {
+                    if (specifier.imported === specifier.reexported) {
+                        return specifier.imported;
+                    }
+                    else {
+                        return `${specifier.imported} as ${specifier.reexported}`;
+                    }
+                })
+                    .join(`,${_}`)}${_}}${_}from${_}'${id}';`);
             }
         }
     }
@@ -14284,7 +13345,7 @@
             ? specifier.local
             : `${specifier.local} as ${specifier.exported}`);
     }
-    if (exportDeclaration.length > 0) {
+    if (exportDeclaration.length) {
         exportBlock.push(`export${_}{${_}${exportDeclaration.join(`,${_}`)}${_}};`);
     }
     return exportBlock;
@@ -14302,20 +13363,20 @@
         propertyPath += getPropertyAccess(part);
         return `${propertyPath}${_}=${_}${propertyPath}${_}||${_}{}${s}`;
     })
-        .join(compact ? ',' : '\n') + (compact && parts.length > 0 ? ';' : '\n'));
+        .join(compact ? ',' : '\n') + (compact && parts.length ? ';' : '\n'));
 }
 function assignToDeepVariable(deepName, root, globals, assignment, { _, getPropertyAccess }) {
     const parts = deepName.split('.');
     parts[0] = (typeof globals === 'function' ? globals(parts[0]) : globals[parts[0]]) || parts[0];
     const last = parts.pop();
     let propertyPath = root;
-    let deepAssignment = [
-        ...parts.map(part => {
-            propertyPath += getPropertyAccess(part);
-            return `${propertyPath}${_}=${_}${propertyPath}${_}||${_}{}`;
-        }),
-        `${propertyPath}${getPropertyAccess(last)}`
-    ].join(`,${_}`) + `${_}=${_}${assignment}`;
+    let deepAssignment = parts
+        .map(part => {
+        propertyPath += getPropertyAccess(part);
+        return `${propertyPath}${_}=${_}${propertyPath}${_}||${_}{}`;
+    })
+        .concat(`${propertyPath}${getPropertyAccess(last)}`)
+        .join(`,${_}`) + `${_}=${_}${assignment}`;
     if (parts.length > 0) {
         deepAssignment = `(${deepAssignment})`;
     }
@@ -14323,51 +13384,57 @@
 }
 
 function trimEmptyImports(dependencies) {
-    let index = dependencies.length;
-    while (index--) {
-        const { imports, reexports } = dependencies[index];
+    let i = dependencies.length;
+    while (i--) {
+        const { imports, reexports } = dependencies[i];
         if (imports || reexports) {
-            return dependencies.slice(0, index + 1);
+            return dependencies.slice(0, i + 1);
         }
     }
     return [];
 }
 
-function iife(magicString, { accessedGlobals, dependencies, exports, hasDefaultExport, hasExports, indent: t, intro, namedExportsMode, outro, snippets, onwarn }, { compact, esModule, extend, freeze, externalLiveBindings, globals, interop, name, namespaceToStringTag, strict }) {
-    const { _, getNonArrowFunctionIntro, getPropertyAccess, n } = snippets;
-    const isNamespaced = name && name.includes('.');
+function iife(magicString, { accessedGlobals, dependencies, exports, hasExports, indent: t, intro, namedExportsMode, outro, snippets, warn }, { compact, esModule, extend, freeze, externalLiveBindings, globals, interop, name, namespaceToStringTag, strict }) {
+    const { _, cnst, getNonArrowFunctionIntro, getPropertyAccess, n } = snippets;
+    const isNamespaced = name && name.indexOf('.') !== -1;
     const useVariableAssignment = !extend && !isNamespaced;
     if (name && useVariableAssignment && !isLegal(name)) {
-        return error(errorIllegalIdentifierAsName(name));
+        return error({
+            code: 'ILLEGAL_IDENTIFIER_AS_NAME',
+            message: `Given name "${name}" is not a legal JS identifier. If you need this, you can try "output.extend: true".`
+        });
     }
-    warnOnBuiltins(onwarn, dependencies);
+    warnOnBuiltins(warn, dependencies);
     const external = trimEmptyImports(dependencies);
     const deps = external.map(dep => dep.globalName || 'null');
-    const parameters = external.map(m => m.name);
+    const args = external.map(m => m.name);
     if (hasExports && !name) {
-        onwarn(errorMissingNameOptionForIifeExport());
+        warn({
+            code: 'MISSING_NAME_OPTION_FOR_IIFE_EXPORT',
+            message: `If you do not supply "output.name", you may not be able to access the exports of an IIFE bundle.`
+        });
     }
     if (namedExportsMode && hasExports) {
         if (extend) {
             deps.unshift(`this${keypath(name, getPropertyAccess)}${_}=${_}this${keypath(name, getPropertyAccess)}${_}||${_}{}`);
-            parameters.unshift('exports');
+            args.unshift('exports');
         }
         else {
             deps.unshift('{}');
-            parameters.unshift('exports');
+            args.unshift('exports');
         }
     }
     const useStrict = strict ? `${t}'use strict';${n}` : '';
     const interopBlock = getInteropBlock(dependencies, interop, externalLiveBindings, freeze, namespaceToStringTag, accessedGlobals, t, snippets);
     magicString.prepend(`${intro}${interopBlock}`);
-    let wrapperIntro = `(${getNonArrowFunctionIntro(parameters, {
+    let wrapperIntro = `(${getNonArrowFunctionIntro(args, {
         isAsync: false,
         name: null
     })}{${n}${useStrict}${n}`;
     if (hasExports) {
         if (name && !(extend && namedExportsMode)) {
             wrapperIntro =
-                (useVariableAssignment ? `var ${name}` : `this${keypath(name, getPropertyAccess)}`) +
+                (useVariableAssignment ? `${cnst} ${name}` : `this${keypath(name, getPropertyAccess)}`) +
                     `${_}=${_}${wrapperIntro}`;
         }
         if (isNamespaced) {
@@ -14379,22 +13446,19 @@
         wrapperOutro = `${n}${n}${t}return exports;${wrapperOutro}`;
     }
     const exportBlock = getExportBlock$1(exports, dependencies, namedExportsMode, interop, snippets, t, externalLiveBindings);
-    let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, esModule === true || (esModule === 'if-default-prop' && hasDefaultExport), namespaceToStringTag, snippets);
+    let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, esModule, namespaceToStringTag, _, n);
     if (namespaceMarkers) {
         namespaceMarkers = n + n + namespaceMarkers;
     }
-    magicString
-        .append(`${exportBlock}${namespaceMarkers}${outro}`)
-        .indent(t)
-        .prepend(wrapperIntro)
-        .append(wrapperOutro);
+    magicString.append(`${exportBlock}${namespaceMarkers}${outro}`);
+    return magicString.indent(t).prepend(wrapperIntro).append(wrapperOutro);
 }
 
 function system(magicString, { accessedGlobals, dependencies, exports, hasExports, indent: t, intro, snippets, outro, usesTopLevelAwait }, { externalLiveBindings, freeze, name, namespaceToStringTag, strict, systemNullSetters }) {
     const { _, getFunctionIntro, getNonArrowFunctionIntro, n, s } = snippets;
     const { importBindings, setters, starExcludes } = analyzeDependencies(dependencies, exports, t, snippets);
     const registeredName = name ? `'${name}',${_}` : '';
-    const wrapperParameters = accessedGlobals.has('module')
+    const wrapperParams = accessedGlobals.has('module')
         ? ['exports', 'module']
         : hasExports
             ? ['exports']
@@ -14402,14 +13466,11 @@
     // factory function should be wrapped by parentheses to avoid lazy parsing,
     // cf. https://v8.dev/blog/preparser#pife
     let wrapperStart = `System.register(${registeredName}[` +
-        dependencies.map(({ importPath }) => `'${importPath}'`).join(`,${_}`) +
-        `],${_}(${getNonArrowFunctionIntro(wrapperParameters, {
-            isAsync: false,
-            name: null
-        })}{${n}${t}${strict ? "'use strict';" : ''}` +
+        dependencies.map(({ id }) => `'${id}'`).join(`,${_}`) +
+        `],${_}(${getNonArrowFunctionIntro(wrapperParams, { isAsync: false, name: null })}{${n}${t}${strict ? "'use strict';" : ''}` +
         getStarExcludesBlock(starExcludes, t, snippets) +
         getImportBindingsBlock(importBindings, t, snippets) +
-        `${n}${t}return${_}{${setters.length > 0
+        `${n}${t}return${_}{${setters.length
             ? `${n}${t}${t}setters:${_}[${setters
                 .map(setter => setter
                 ? `${getFunctionIntro(['module'], {
@@ -14426,16 +13487,13 @@
         name: null
     })}{${n}${n}`;
     const wrapperEnd = `${t}${t}})${n}${t}}${s}${n}}));`;
-    magicString
-        .prepend(intro +
+    magicString.prepend(intro +
         getHelpersBlock(null, accessedGlobals, t, snippets, externalLiveBindings, freeze, namespaceToStringTag) +
-        getHoistedExportsBlock(exports, t, snippets))
-        .append(`${outro}${n}${n}` +
+        getHoistedExportsBlock(exports, t, snippets));
+    magicString.append(`${outro}${n}${n}` +
         getSyntheticExportsBlock(exports, t, snippets) +
-        getMissingExportsBlock(exports, t, snippets))
-        .indent(`${t}${t}${t}`)
-        .append(wrapperEnd)
-        .prepend(wrapperStart);
+        getMissingExportsBlock(exports, t, snippets));
+    return magicString.indent(`${t}${t}${t}`).append(wrapperEnd).prepend(wrapperStart);
 }
 function analyzeDependencies(dependencies, exports, t, { _, cnst, getObject, getPropertyAccess, n }) {
     const importBindings = [];
@@ -14503,9 +13561,9 @@
     return starExcludes;
 };
 const getStarExcludesBlock = (starExcludes, t, { _, cnst, getObject, n }) => starExcludes
-    ? `${n}${t}${cnst} _starExcludes${_}=${_}${getObject([...starExcludes].map(property => [property, '1']), { lineBreakIndent: { base: t, t } })};`
+    ? `${n}${t}${cnst} _starExcludes${_}=${_}${getObject([...starExcludes].map(prop => [prop, '1']), { lineBreakIndent: { base: t, t } })};`
     : '';
-const getImportBindingsBlock = (importBindings, t, { _, n }) => (importBindings.length > 0 ? `${n}${t}var ${importBindings.join(`,${_}`)};` : '');
+const getImportBindingsBlock = (importBindings, t, { _, n }) => (importBindings.length ? `${n}${t}var ${importBindings.join(`,${_}`)};` : '');
 const getHoistedExportsBlock = (exports, t, snippets) => getExportsBlock(exports.filter(expt => expt.hoisted).map(expt => ({ name: expt.exported, value: expt.local })), t, snippets);
 function getExportsBlock(exports, t, { _, n }) {
     if (exports.length === 0) {
@@ -14525,138 +13583,273 @@
     .filter(expt => expt.local === MISSING_EXPORT_SHIM_VARIABLE)
     .map(expt => ({ name: expt.exported, value: MISSING_EXPORT_SHIM_VARIABLE })), t, snippets);
 
-function globalProperty(name, globalVariable, getPropertyAccess) {
+function globalProp(name, globalVar, getPropertyAccess) {
     if (!name)
         return 'null';
-    return `${globalVariable}${keypath(name, getPropertyAccess)}`;
+    return `${globalVar}${keypath(name, getPropertyAccess)}`;
 }
-function safeAccess(name, globalVariable, { _, getPropertyAccess }) {
-    let propertyPath = globalVariable;
+function safeAccess(name, globalVar, { _, getPropertyAccess }) {
+    let propertyPath = globalVar;
     return name
         .split('.')
         .map(part => (propertyPath += getPropertyAccess(part)))
         .join(`${_}&&${_}`);
 }
-function umd(magicString, { accessedGlobals, dependencies, exports, hasDefaultExport, hasExports, id, indent: t, intro, namedExportsMode, outro, snippets, onwarn }, { amd, compact, esModule, extend, externalLiveBindings, freeze, interop, name, namespaceToStringTag, globals, noConflict, strict }) {
+function umd(magicString, { accessedGlobals, dependencies, exports, hasExports, id, indent: t, intro, namedExportsMode, outro, snippets, warn }, { amd, compact, esModule, extend, externalLiveBindings, freeze, interop, name, namespaceToStringTag, globals, noConflict, strict }) {
     const { _, cnst, getFunctionIntro, getNonArrowFunctionIntro, getPropertyAccess, n, s } = snippets;
-    const factoryVariable = compact ? 'f' : 'factory';
-    const globalVariable = compact ? 'g' : 'global';
+    const factoryVar = compact ? 'f' : 'factory';
+    const globalVar = compact ? 'g' : 'global';
     if (hasExports && !name) {
-        return error(errorMissingNameOptionForUmdExport());
+        return error({
+            code: 'MISSING_NAME_OPTION_FOR_IIFE_EXPORT',
+            message: 'You must supply "output.name" for UMD bundles that have exports so that the exports are accessible in environments without a module loader.'
+        });
     }
-    warnOnBuiltins(onwarn, dependencies);
-    const amdDeps = dependencies.map(m => `'${updateExtensionForRelativeAmdId(m.importPath, amd.forceJsExtensionForImports)}'`);
-    const cjsDeps = dependencies.map(m => `require('${m.importPath}')`);
+    warnOnBuiltins(warn, dependencies);
+    const amdDeps = dependencies.map(m => `'${removeExtensionFromRelativeAmdId(m.id)}'`);
+    const cjsDeps = dependencies.map(m => `require('${m.id}')`);
     const trimmedImports = trimEmptyImports(dependencies);
-    const globalDeps = trimmedImports.map(module => globalProperty(module.globalName, globalVariable, getPropertyAccess));
-    const factoryParameters = trimmedImports.map(m => m.name);
+    const globalDeps = trimmedImports.map(module => globalProp(module.globalName, globalVar, getPropertyAccess));
+    const factoryParams = trimmedImports.map(m => m.name);
     if (namedExportsMode && (hasExports || noConflict)) {
         amdDeps.unshift(`'exports'`);
         cjsDeps.unshift(`exports`);
-        globalDeps.unshift(assignToDeepVariable(name, globalVariable, globals, `${extend ? `${globalProperty(name, globalVariable, getPropertyAccess)}${_}||${_}` : ''}{}`, snippets));
-        factoryParameters.unshift('exports');
+        globalDeps.unshift(assignToDeepVariable(name, globalVar, globals, `${extend ? `${globalProp(name, globalVar, getPropertyAccess)}${_}||${_}` : ''}{}`, snippets));
+        factoryParams.unshift('exports');
     }
     const completeAmdId = getCompleteAmdId(amd, id);
-    const amdParameters = (completeAmdId ? `'${completeAmdId}',${_}` : ``) +
-        (amdDeps.length > 0 ? `[${amdDeps.join(`,${_}`)}],${_}` : ``);
+    const amdParams = (completeAmdId ? `'${completeAmdId}',${_}` : ``) +
+        (amdDeps.length ? `[${amdDeps.join(`,${_}`)}],${_}` : ``);
     const define = amd.define;
     const cjsExport = !namedExportsMode && hasExports ? `module.exports${_}=${_}` : ``;
     const useStrict = strict ? `${_}'use strict';${n}` : ``;
     let iifeExport;
     if (noConflict) {
-        const noConflictExportsVariable = compact ? 'e' : 'exports';
+        const noConflictExportsVar = compact ? 'e' : 'exports';
         let factory;
         if (!namedExportsMode && hasExports) {
-            factory = `${cnst} ${noConflictExportsVariable}${_}=${_}${assignToDeepVariable(name, globalVariable, globals, `${factoryVariable}(${globalDeps.join(`,${_}`)})`, snippets)};`;
+            factory = `${cnst} ${noConflictExportsVar}${_}=${_}${assignToDeepVariable(name, globalVar, globals, `${factoryVar}(${globalDeps.join(`,${_}`)})`, snippets)};`;
         }
         else {
             const module = globalDeps.shift();
             factory =
-                `${cnst} ${noConflictExportsVariable}${_}=${_}${module};${n}` +
-                    `${t}${t}${factoryVariable}(${[noConflictExportsVariable, ...globalDeps].join(`,${_}`)});`;
+                `${cnst} ${noConflictExportsVar}${_}=${_}${module};${n}` +
+                    `${t}${t}${factoryVar}(${[noConflictExportsVar].concat(globalDeps).join(`,${_}`)});`;
         }
         iifeExport =
             `(${getFunctionIntro([], { isAsync: false, name: null })}{${n}` +
-                `${t}${t}${cnst} current${_}=${_}${safeAccess(name, globalVariable, snippets)};${n}` +
+                `${t}${t}${cnst} current${_}=${_}${safeAccess(name, globalVar, snippets)};${n}` +
                 `${t}${t}${factory}${n}` +
-                `${t}${t}${noConflictExportsVariable}.noConflict${_}=${_}${getFunctionIntro([], {
+                `${t}${t}${noConflictExportsVar}.noConflict${_}=${_}${getFunctionIntro([], {
                     isAsync: false,
                     name: null
                 })}{${_}` +
-                `${globalProperty(name, globalVariable, getPropertyAccess)}${_}=${_}current;${_}return ${noConflictExportsVariable}${s}${_}};${n}` +
+                `${globalProp(name, globalVar, getPropertyAccess)}${_}=${_}current;${_}return ${noConflictExportsVar}${s}${_}};${n}` +
                 `${t}})()`;
     }
     else {
-        iifeExport = `${factoryVariable}(${globalDeps.join(`,${_}`)})`;
+        iifeExport = `${factoryVar}(${globalDeps.join(`,${_}`)})`;
         if (!namedExportsMode && hasExports) {
-            iifeExport = assignToDeepVariable(name, globalVariable, globals, iifeExport, snippets);
+            iifeExport = assignToDeepVariable(name, globalVar, globals, iifeExport, snippets);
         }
     }
     const iifeNeedsGlobal = hasExports || (noConflict && namedExportsMode) || globalDeps.length > 0;
-    const wrapperParameters = [factoryVariable];
+    const wrapperParams = [factoryVar];
     if (iifeNeedsGlobal) {
-        wrapperParameters.unshift(globalVariable);
+        wrapperParams.unshift(globalVar);
     }
-    const globalArgument = iifeNeedsGlobal ? `this,${_}` : '';
+    const globalArg = iifeNeedsGlobal ? `this,${_}` : '';
     const iifeStart = iifeNeedsGlobal
-        ? `(${globalVariable}${_}=${_}typeof globalThis${_}!==${_}'undefined'${_}?${_}globalThis${_}:${_}${globalVariable}${_}||${_}self,${_}`
+        ? `(${globalVar}${_}=${_}typeof globalThis${_}!==${_}'undefined'${_}?${_}globalThis${_}:${_}${globalVar}${_}||${_}self,${_}`
         : '';
     const iifeEnd = iifeNeedsGlobal ? ')' : '';
     const cjsIntro = iifeNeedsGlobal
         ? `${t}typeof exports${_}===${_}'object'${_}&&${_}typeof module${_}!==${_}'undefined'${_}?` +
-            `${_}${cjsExport}${factoryVariable}(${cjsDeps.join(`,${_}`)})${_}:${n}`
+            `${_}${cjsExport}${factoryVar}(${cjsDeps.join(`,${_}`)})${_}:${n}`
         : '';
-    const wrapperIntro = `(${getNonArrowFunctionIntro(wrapperParameters, { isAsync: false, name: null })}{${n}` +
+    const wrapperIntro = `(${getNonArrowFunctionIntro(wrapperParams, { isAsync: false, name: null })}{${n}` +
         cjsIntro +
-        `${t}typeof ${define}${_}===${_}'function'${_}&&${_}${define}.amd${_}?${_}${define}(${amdParameters}${factoryVariable})${_}:${n}` +
+        `${t}typeof ${define}${_}===${_}'function'${_}&&${_}${define}.amd${_}?${_}${define}(${amdParams}${factoryVar})${_}:${n}` +
         `${t}${iifeStart}${iifeExport}${iifeEnd};${n}` +
         // factory function should be wrapped by parentheses to avoid lazy parsing,
         // cf. https://v8.dev/blog/preparser#pife
-        `})(${globalArgument}(${getNonArrowFunctionIntro(factoryParameters, {
+        `})(${globalArg}(${getNonArrowFunctionIntro(factoryParams, {
             isAsync: false,
             name: null
         })}{${useStrict}${n}`;
     const wrapperOutro = n + n + '}));';
     magicString.prepend(`${intro}${getInteropBlock(dependencies, interop, externalLiveBindings, freeze, namespaceToStringTag, accessedGlobals, t, snippets)}`);
     const exportBlock = getExportBlock$1(exports, dependencies, namedExportsMode, interop, snippets, t, externalLiveBindings);
-    let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, esModule === true || (esModule === 'if-default-prop' && hasDefaultExport), namespaceToStringTag, snippets);
+    let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, esModule, namespaceToStringTag, _, n);
     if (namespaceMarkers) {
         namespaceMarkers = n + n + namespaceMarkers;
     }
-    magicString
-        .append(`${exportBlock}${namespaceMarkers}${outro}`)
-        .trim()
-        .indent(t)
-        .append(wrapperOutro)
-        .prepend(wrapperIntro);
+    magicString.append(`${exportBlock}${namespaceMarkers}${outro}`);
+    return magicString.trim().indent(t).append(wrapperOutro).prepend(wrapperIntro);
 }
 
 const finalisers = { amd, cjs, es, iife, system, umd };
 
-const concatSeparator = (out, next) => (next ? `${out}\n${next}` : out);
-const concatDblSeparator = (out, next) => (next ? `${out}\n\n${next}` : out);
-async function createAddons(options, outputPluginDriver, chunk) {
-    try {
-        let [banner, footer, intro, outro] = await Promise.all([
-            outputPluginDriver.hookReduceValue('banner', options.banner(chunk), [chunk], concatSeparator),
-            outputPluginDriver.hookReduceValue('footer', options.footer(chunk), [chunk], concatSeparator),
-            outputPluginDriver.hookReduceValue('intro', options.intro(chunk), [chunk], concatDblSeparator),
-            outputPluginDriver.hookReduceValue('outro', options.outro(chunk), [chunk], concatDblSeparator)
-        ]);
-        if (intro)
-            intro += '\n\n';
-        if (outro)
-            outro = `\n\n${outro}`;
-        if (banner)
-            banner += '\n';
-        if (footer)
-            footer = '\n' + footer;
-        return { banner, footer, intro, outro };
+class Source {
+    constructor(filename, content) {
+        this.isOriginal = true;
+        this.filename = filename;
+        this.content = content;
+    }
+    traceSegment(line, column, name) {
+        return { column, line, name, source: this };
+    }
+}
+class Link {
+    constructor(map, sources) {
+        this.sources = sources;
+        this.names = map.names;
+        this.mappings = map.mappings;
+    }
+    traceMappings() {
+        const sources = [];
+        const sourcesContent = [];
+        const names = [];
+        const nameIndexMap = new Map();
+        const mappings = [];
+        for (const line of this.mappings) {
+            const tracedLine = [];
+            for (const segment of line) {
+                if (segment.length == 1)
+                    continue;
+                const source = this.sources[segment[1]];
+                if (!source)
+                    continue;
+                const traced = source.traceSegment(segment[2], segment[3], segment.length === 5 ? this.names[segment[4]] : '');
+                if (traced) {
+                    // newer sources are more likely to be used, so search backwards.
+                    let sourceIndex = sources.lastIndexOf(traced.source.filename);
+                    if (sourceIndex === -1) {
+                        sourceIndex = sources.length;
+                        sources.push(traced.source.filename);
+                        sourcesContent[sourceIndex] = traced.source.content;
+                    }
+                    else if (sourcesContent[sourceIndex] == null) {
+                        sourcesContent[sourceIndex] = traced.source.content;
+                    }
+                    else if (traced.source.content != null &&
+                        sourcesContent[sourceIndex] !== traced.source.content) {
+                        return error({
+                            message: `Multiple conflicting contents for sourcemap source ${traced.source.filename}`
+                        });
+                    }
+                    const tracedSegment = [
+                        segment[0],
+                        sourceIndex,
+                        traced.line,
+                        traced.column
+                    ];
+                    if (traced.name) {
+                        let nameIndex = nameIndexMap.get(traced.name);
+                        if (nameIndex === undefined) {
+                            nameIndex = names.length;
+                            names.push(traced.name);
+                            nameIndexMap.set(traced.name, nameIndex);
+                        }
+                        tracedSegment[4] = nameIndex;
+                    }
+                    tracedLine.push(tracedSegment);
+                }
+            }
+            mappings.push(tracedLine);
+        }
+        return { mappings, names, sources, sourcesContent };
     }
-    catch (error_) {
-        return error(errorAddonNotGenerated(error_.message, error_.hook, error_.plugin));
+    traceSegment(line, column, name) {
+        const segments = this.mappings[line];
+        if (!segments)
+            return null;
+        // binary search through segments for the given column
+        let i = 0;
+        let j = segments.length - 1;
+        while (i <= j) {
+            const m = (i + j) >> 1;
+            const segment = segments[m];
+            if (segment[0] === column) {
+                if (segment.length == 1)
+                    return null;
+                const source = this.sources[segment[1]];
+                if (!source)
+                    return null;
+                return source.traceSegment(segment[2], segment[3], segment.length === 5 ? this.names[segment[4]] : name);
+            }
+            if (segment[0] > column) {
+                j = m - 1;
+            }
+            else {
+                i = m + 1;
+            }
+        }
+        return null;
     }
 }
+function getLinkMap(warn) {
+    return function linkMap(source, map) {
+        if (map.mappings) {
+            return new Link(map, [source]);
+        }
+        warn({
+            code: 'SOURCEMAP_BROKEN',
+            message: `Sourcemap is likely to be incorrect: a plugin (${map.plugin}) was used to transform ` +
+                "files, but didn't generate a sourcemap for the transformation. Consult the plugin " +
+                'documentation for help',
+            plugin: map.plugin,
+            url: `https://rollupjs.org/guide/en/#warning-sourcemap-is-likely-to-be-incorrect`
+        });
+        return new Link({
+            mappings: [],
+            names: []
+        }, [source]);
+    };
+}
+function getCollapsedSourcemap(id, originalCode, originalSourcemap, sourcemapChain, linkMap) {
+    let source;
+    if (!originalSourcemap) {
+        source = new Source(id, originalCode);
+    }
+    else {
+        const sources = originalSourcemap.sources;
+        const sourcesContent = originalSourcemap.sourcesContent || [];
+        const directory = dirname(id) || '.';
+        const sourceRoot = originalSourcemap.sourceRoot || '.';
+        const baseSources = sources.map((source, i) => new Source(resolve(directory, sourceRoot, source), sourcesContent[i]));
+        source = new Link(originalSourcemap, baseSources);
+    }
+    return sourcemapChain.reduce(linkMap, source);
+}
+function collapseSourcemaps(file, map, modules, bundleSourcemapChain, excludeContent, warn) {
+    const linkMap = getLinkMap(warn);
+    const moduleSources = modules
+        .filter(module => !module.excludeFromSourcemap)
+        .map(module => getCollapsedSourcemap(module.id, module.originalCode, module.originalSourcemap, module.sourcemapChain, linkMap));
+    // DecodedSourceMap (from magic-string) uses a number[] instead of the more
+    // correct SourceMapSegment tuples. Cast it here to gain type safety.
+    let source = new Link(map, moduleSources);
+    source = bundleSourcemapChain.reduce(linkMap, source);
+    let { sources, sourcesContent, names, mappings } = source.traceMappings();
+    if (file) {
+        const directory = dirname(file);
+        sources = sources.map((source) => relative$1(directory, source));
+        file = basename(file);
+    }
+    sourcesContent = (excludeContent ? null : sourcesContent);
+    return new SourceMap({ file, mappings, names, sources, sourcesContent });
+}
+function collapseSourcemap(id, originalCode, originalSourcemap, sourcemapChain, warn) {
+    if (!sourcemapChain.length) {
+        return originalSourcemap;
+    }
+    const source = getCollapsedSourcemap(id, originalCode, originalSourcemap, sourcemapChain, getLinkMap(warn));
+    const map = source.traceMappings();
+    return { version: 3, ...map };
+}
+
+const createHash = () => createHash$1('sha256');
 
 const DECONFLICT_IMPORTED_VARIABLES_BY_FORMAT = {
     amd: deconflictImportsOther,
@@ -14666,69 +13859,68 @@
     system: deconflictImportsEsmOrSystem,
     umd: deconflictImportsOther
 };
-function deconflictChunk(modules, dependenciesToBeDeconflicted, imports, usedNames, format, interop, preserveModules, externalLiveBindings, chunkByModule, externalChunkByModule, syntheticExports, exportNamesByVariable, accessedGlobalsByScope, includedNamespaces) {
-    const reversedModules = [...modules].reverse();
+function deconflictChunk(modules, dependenciesToBeDeconflicted, imports, usedNames, format, interop, preserveModules, externalLiveBindings, chunkByModule, syntheticExports, exportNamesByVariable, accessedGlobalsByScope, includedNamespaces) {
+    const reversedModules = modules.slice().reverse();
     for (const module of reversedModules) {
         module.scope.addUsedOutsideNames(usedNames, format, exportNamesByVariable, accessedGlobalsByScope);
     }
     deconflictTopLevelVariables(usedNames, reversedModules, includedNamespaces);
-    DECONFLICT_IMPORTED_VARIABLES_BY_FORMAT[format](usedNames, imports, dependenciesToBeDeconflicted, interop, preserveModules, externalLiveBindings, chunkByModule, externalChunkByModule, syntheticExports);
+    DECONFLICT_IMPORTED_VARIABLES_BY_FORMAT[format](usedNames, imports, dependenciesToBeDeconflicted, interop, preserveModules, externalLiveBindings, chunkByModule, syntheticExports);
     for (const module of reversedModules) {
         module.scope.deconflict(format, exportNamesByVariable, accessedGlobalsByScope);
     }
 }
-function deconflictImportsEsmOrSystem(usedNames, imports, dependenciesToBeDeconflicted, _interop, preserveModules, _externalLiveBindings, chunkByModule, externalChunkByModule, syntheticExports) {
+function deconflictImportsEsmOrSystem(usedNames, imports, dependenciesToBeDeconflicted, _interop, preserveModules, _externalLiveBindings, chunkByModule, syntheticExports) {
     // This is needed for namespace reexports
     for (const dependency of dependenciesToBeDeconflicted.dependencies) {
-        if (preserveModules || dependency instanceof ExternalChunk) {
-            dependency.variableName = getSafeName(dependency.suggestedVariableName, usedNames, null);
+        if (preserveModules || dependency instanceof ExternalModule) {
+            dependency.variableName = getSafeName(dependency.suggestedVariableName, usedNames);
         }
     }
     for (const variable of imports) {
         const module = variable.module;
         const name = variable.name;
         if (variable.isNamespace && (preserveModules || module instanceof ExternalModule)) {
-            variable.setRenderNames(null, (module instanceof ExternalModule
-                ? externalChunkByModule.get(module)
-                : chunkByModule.get(module)).variableName);
+            variable.setRenderNames(null, (module instanceof ExternalModule ? module : chunkByModule.get(module)).variableName);
         }
         else if (module instanceof ExternalModule && name === 'default') {
             variable.setRenderNames(null, getSafeName([...module.exportedVariables].some(([exportedVariable, exportedName]) => exportedName === '*' && exportedVariable.included)
                 ? module.suggestedVariableName + '__default'
-                : module.suggestedVariableName, usedNames, variable.forbiddenNames));
+                : module.suggestedVariableName, usedNames));
         }
         else {
-            variable.setRenderNames(null, getSafeName(name, usedNames, variable.forbiddenNames));
+            variable.setRenderNames(null, getSafeName(name, usedNames));
         }
     }
     for (const variable of syntheticExports) {
-        variable.setRenderNames(null, getSafeName(variable.name, usedNames, variable.forbiddenNames));
+        variable.setRenderNames(null, getSafeName(variable.name, usedNames));
     }
 }
-function deconflictImportsOther(usedNames, imports, { deconflictedDefault, deconflictedNamespace, dependencies }, interop, preserveModules, externalLiveBindings, chunkByModule, externalChunkByModule) {
-    for (const chunk of dependencies) {
-        chunk.variableName = getSafeName(chunk.suggestedVariableName, usedNames, null);
+function deconflictImportsOther(usedNames, imports, { deconflictedDefault, deconflictedNamespace, dependencies }, interop, preserveModules, externalLiveBindings, chunkByModule) {
+    for (const chunkOrExternalModule of dependencies) {
+        chunkOrExternalModule.variableName = getSafeName(chunkOrExternalModule.suggestedVariableName, usedNames);
     }
-    for (const chunk of deconflictedNamespace) {
-        chunk.namespaceVariableName = getSafeName(`${chunk.suggestedVariableName}__namespace`, usedNames, null);
+    for (const externalModuleOrChunk of deconflictedNamespace) {
+        externalModuleOrChunk.namespaceVariableName = getSafeName(`${externalModuleOrChunk.suggestedVariableName}__namespace`, usedNames);
     }
     for (const externalModule of deconflictedDefault) {
-        externalModule.defaultVariableName =
-            deconflictedNamespace.has(externalModule) &&
-                canDefaultBeTakenFromNamespace(interop(externalModule.id), externalLiveBindings)
-                ? externalModule.namespaceVariableName
-                : getSafeName(`${externalModule.suggestedVariableName}__default`, usedNames, null);
+        if (deconflictedNamespace.has(externalModule) &&
+            canDefaultBeTakenFromNamespace(String(interop(externalModule.id)), externalLiveBindings)) {
+            externalModule.defaultVariableName = externalModule.namespaceVariableName;
+        }
+        else {
+            externalModule.defaultVariableName = getSafeName(`${externalModule.suggestedVariableName}__default`, usedNames);
+        }
     }
     for (const variable of imports) {
         const module = variable.module;
         if (module instanceof ExternalModule) {
-            const chunk = externalChunkByModule.get(module);
             const name = variable.name;
             if (name === 'default') {
-                const moduleInterop = interop(module.id);
+                const moduleInterop = String(interop(module.id));
                 const variableName = defaultInteropHelpersByInteropType[moduleInterop]
-                    ? chunk.defaultVariableName
-                    : chunk.variableName;
+                    ? module.defaultVariableName
+                    : module.variableName;
                 if (isDefaultAProperty(moduleInterop, externalLiveBindings)) {
                     variable.setRenderNames(variableName, 'default');
                 }
@@ -14737,13 +13929,13 @@
                 }
             }
             else if (name === '*') {
-                variable.setRenderNames(null, namespaceInteropHelpersByInteropType[interop(module.id)]
-                    ? chunk.namespaceVariableName
-                    : chunk.variableName);
+                variable.setRenderNames(null, namespaceInteropHelpersByInteropType[String(interop(module.id))]
+                    ? module.namespaceVariableName
+                    : module.variableName);
             }
             else {
                 // if the second parameter is `null`, it uses its "name" for the property name
-                variable.setRenderNames(chunk.variableName, null);
+                variable.setRenderNames(module.variableName, null);
             }
         }
         else {
@@ -14767,21 +13959,30 @@
                 // this will only happen for exports in some formats
                 !(variable.renderBaseName ||
                     (variable instanceof ExportDefaultVariable && variable.getOriginalVariable() !== variable))) {
-                variable.setRenderNames(null, getSafeName(variable.name, usedNames, variable.forbiddenNames));
+                variable.setRenderNames(null, getSafeName(variable.name, usedNames));
             }
         }
         if (includedNamespaces.has(module)) {
             const namespace = module.namespace;
-            namespace.setRenderNames(null, getSafeName(namespace.name, usedNames, namespace.forbiddenNames));
+            namespace.setRenderNames(null, getSafeName(namespace.name, usedNames));
         }
     }
 }
 
+const needsEscapeRegEx = /[\\'\r\n\u2028\u2029]/;
+const quoteNewlineRegEx = /(['\r\n\u2028\u2029])/g;
+const backSlashRegEx = /\\/g;
+function escapeId(id) {
+    if (!id.match(needsEscapeRegEx))
+        return id;
+    return id.replace(backSlashRegEx, '\\\\').replace(quoteNewlineRegEx, '\\$1');
+}
+
 function assignExportsToMangledNames(exports, exportsByName, exportNamesByVariable) {
     let nameIndex = 0;
     for (const variable of exports) {
-        let [exportName] = variable.name;
-        if (exportsByName.has(exportName)) {
+        let exportName = variable.name[0];
+        if (exportsByName[exportName]) {
             do {
                 exportName = toBase64(++nameIndex);
                 // skip past leading number identifiers
@@ -14789,9 +13990,9 @@
                     nameIndex += 9 * 64 ** (exportName.length - 1);
                     exportName = toBase64(nameIndex);
                 }
-            } while (RESERVED_NAMES$1.has(exportName) || exportsByName.has(exportName));
+            } while (RESERVED_NAMES[exportName] || exportsByName[exportName]);
         }
-        exportsByName.set(exportName, variable);
+        exportsByName[exportName] = variable;
         exportNamesByVariable.set(variable, [exportName]);
     }
 }
@@ -14799,34 +14000,37 @@
     for (const variable of exports) {
         let nameIndex = 0;
         let exportName = variable.name;
-        while (exportsByName.has(exportName)) {
+        while (exportsByName[exportName]) {
             exportName = variable.name + '$' + ++nameIndex;
         }
-        exportsByName.set(exportName, variable);
+        exportsByName[exportName] = variable;
         exportNamesByVariable.set(variable, [exportName]);
     }
 }
 
-function getExportMode(chunk, { exports: exportMode, name, format }, facadeModuleId, warn) {
+function getExportMode(chunk, { exports: exportMode, name, format }, unsetOptions, facadeModuleId, warn) {
     const exportKeys = chunk.getExportNames();
     if (exportMode === 'default') {
         if (exportKeys.length !== 1 || exportKeys[0] !== 'default') {
-            return error(errorIncompatibleExportOptionValue('default', exportKeys, facadeModuleId));
+            return error(errIncompatibleExportOptionValue('default', exportKeys, facadeModuleId));
         }
     }
-    else if (exportMode === 'none' && exportKeys.length > 0) {
-        return error(errorIncompatibleExportOptionValue('none', exportKeys, facadeModuleId));
+    else if (exportMode === 'none' && exportKeys.length) {
+        return error(errIncompatibleExportOptionValue('none', exportKeys, facadeModuleId));
     }
     if (exportMode === 'auto') {
         if (exportKeys.length === 0) {
             exportMode = 'none';
         }
         else if (exportKeys.length === 1 && exportKeys[0] === 'default') {
+            if (format === 'cjs' && unsetOptions.has('exports')) {
+                warn(errPreferNamedExports(facadeModuleId));
+            }
             exportMode = 'default';
         }
         else {
-            if (format !== 'es' && format !== 'system' && exportKeys.includes('default')) {
-                warn(errorMixedExport(facadeModuleId, name));
+            if (format !== 'es' && format !== 'system' && exportKeys.indexOf('default') !== -1) {
+                warn(errMixedExport(facadeModuleId, name));
             }
             exportMode = 'named';
         }
@@ -14849,10 +14053,10 @@
     }
     // Otherwise, we need to guess the multiple
     const min = spaced.reduce((previous, current) => {
-        const numberSpaces = /^ +/.exec(current)[0].length;
-        return Math.min(numberSpaces, previous);
+        const numSpaces = /^ +/.exec(current)[0].length;
+        return Math.min(numSpaces, previous);
     }, Infinity);
-    return ' '.repeat(min);
+    return new Array(min + 1).join(' ');
 }
 function getIndentString(modules, options) {
     if (options.indent !== true)
@@ -14865,14 +14069,14 @@
     return '\t';
 }
 
-function getStaticDependencies(chunk, orderedModules, chunkByModule, externalChunkByModule) {
+function getStaticDependencies(chunk, orderedModules, chunkByModule) {
     const staticDependencyBlocks = [];
     const handledDependencies = new Set();
     for (let modulePos = orderedModules.length - 1; modulePos >= 0; modulePos--) {
         const module = orderedModules[modulePos];
         if (!handledDependencies.has(module)) {
             const staticDependencies = [];
-            addStaticDependencies(module, staticDependencies, handledDependencies, chunk, chunkByModule, externalChunkByModule);
+            addStaticDependencies(module, staticDependencies, handledDependencies, chunk, chunkByModule);
             staticDependencyBlocks.unshift(staticDependencies);
         }
     }
@@ -14884,11 +14088,11 @@
     }
     return dependencies;
 }
-function addStaticDependencies(module, staticDependencies, handledModules, chunk, chunkByModule, externalChunkByModule) {
+function addStaticDependencies(module, staticDependencies, handledModules, chunk, chunkByModule) {
     const dependencies = module.getDependenciesToBeIncluded();
     for (const dependency of dependencies) {
         if (dependency instanceof ExternalModule) {
-            staticDependencies.push(externalChunkByModule.get(dependency));
+            staticDependencies.push(dependency);
             continue;
         }
         const dependencyChunk = chunkByModule.get(dependency);
@@ -14898,137 +14102,97 @@
         }
         if (!handledModules.has(dependency)) {
             handledModules.add(dependency);
-            addStaticDependencies(dependency, staticDependencies, handledModules, chunk, chunkByModule, externalChunkByModule);
+            addStaticDependencies(dependency, staticDependencies, handledModules, chunk, chunkByModule);
         }
     }
 }
 
-// Four random characters from the private use area to minimize risk of conflicts
-const hashPlaceholderLeft = '!~{';
-const hashPlaceholderRight = '}~';
-const hashPlaceholderOverhead = hashPlaceholderLeft.length + hashPlaceholderRight.length;
-// This is the size of a sha256
-const maxHashSize = 64;
-const defaultHashSize = 8;
-const getHashPlaceholderGenerator = () => {
-    let nextIndex = 0;
-    return (optionName, hashSize = defaultHashSize) => {
-        if (hashSize > maxHashSize) {
-            return error(errorFailedValidation(`Hashes cannot be longer than ${maxHashSize} characters, received ${hashSize}. Check the "${optionName}" option.`));
-        }
-        const placeholder = `${hashPlaceholderLeft}${toBase64(++nextIndex).padStart(hashSize - hashPlaceholderOverhead, '0')}${hashPlaceholderRight}`;
-        if (placeholder.length > hashSize) {
-            return error(errorFailedValidation(`To generate hashes for this number of chunks (currently ${nextIndex}), you need a minimum hash size of ${placeholder.length}, received ${hashSize}. Check the "${optionName}" option.`));
-        }
-        return placeholder;
-    };
-};
-const REPLACER_REGEX = new RegExp(`${hashPlaceholderLeft}[0-9a-zA-Z_$]{1,${maxHashSize - hashPlaceholderOverhead}}${hashPlaceholderRight}`, 'g');
-const replacePlaceholders = (code, hashesByPlaceholder) => code.replace(REPLACER_REGEX, placeholder => hashesByPlaceholder.get(placeholder) || placeholder);
-const replaceSinglePlaceholder = (code, placeholder, value) => code.replace(REPLACER_REGEX, match => (match === placeholder ? value : match));
-const replacePlaceholdersWithDefaultAndGetContainedPlaceholders = (code, placeholders) => {
-    const containedPlaceholders = new Set();
-    const transformedCode = code.replace(REPLACER_REGEX, placeholder => {
-        if (placeholders.has(placeholder)) {
-            containedPlaceholders.add(placeholder);
-            return `${hashPlaceholderLeft}${'0'.repeat(placeholder.length - hashPlaceholderOverhead)}${hashPlaceholderRight}`;
-        }
-        return placeholder;
-    });
-    return { containedPlaceholders, transformedCode };
-};
-
-const lowercaseBundleKeys = Symbol('bundleKeys');
-const FILE_PLACEHOLDER = {
-    type: 'placeholder'
-};
-const getOutputBundle = (outputBundleBase) => {
-    const reservedLowercaseBundleKeys = new Set();
-    return new Proxy(outputBundleBase, {
-        deleteProperty(target, key) {
-            if (typeof key === 'string') {
-                reservedLowercaseBundleKeys.delete(key.toLowerCase());
-            }
-            return Reflect.deleteProperty(target, key);
-        },
-        get(target, key) {
-            if (key === lowercaseBundleKeys) {
-                return reservedLowercaseBundleKeys;
-            }
-            return Reflect.get(target, key);
-        },
-        set(target, key, value) {
-            if (typeof key === 'string') {
-                reservedLowercaseBundleKeys.add(key.toLowerCase());
-            }
-            return Reflect.set(target, key, value);
-        }
-    });
-};
-const removeUnreferencedAssets = (outputBundle) => {
-    const unreferencedAssets = new Set();
-    const bundleEntries = Object.values(outputBundle);
-    for (const asset of bundleEntries) {
-        asset.type === 'asset' && asset.needsCodeReference && unreferencedAssets.add(asset.fileName);
+function decodedSourcemap(map) {
+    if (!map)
+        return null;
+    if (typeof map === 'string') {
+        map = JSON.parse(map);
     }
-    for (const chunk of bundleEntries) {
-        if (chunk.type === 'chunk') {
-            for (const referencedFile of chunk.referencedFiles) {
-                unreferencedAssets.has(referencedFile) && unreferencedAssets.delete(referencedFile);
-            }
-        }
+    if (map.mappings === '') {
+        return {
+            mappings: [],
+            names: [],
+            sources: [],
+            version: 3
+        };
     }
-    for (const file of unreferencedAssets) {
-        delete outputBundle[file];
+    let mappings;
+    if (typeof map.mappings === 'string') {
+        mappings = decode(map.mappings);
     }
-};
+    else {
+        mappings = map.mappings;
+    }
+    return { ...map, mappings };
+}
+
+function renderChunk({ code, options, outputPluginDriver, renderChunk, sourcemapChain }) {
+    const renderChunkReducer = (code, result, plugin) => {
+        if (result == null)
+            return code;
+        if (typeof result === 'string')
+            result = {
+                code: result,
+                map: undefined
+            };
+        // strict null check allows 'null' maps to not be pushed to the chain, while 'undefined' gets the missing map warning
+        if (result.map !== null) {
+            const map = decodedSourcemap(result.map);
+            sourcemapChain.push(map || { missing: true, plugin: plugin.name });
+        }
+        return result.code;
+    };
+    return outputPluginDriver.hookReduceArg0('renderChunk', [code, renderChunk, options], renderChunkReducer);
+}
 
 function renderNamePattern(pattern, patternName, replacements) {
     if (isPathFragment(pattern))
-        return error(errorFailedValidation(`Invalid pattern "${pattern}" for "${patternName}", patterns can be neither absolute nor relative paths. If you want your files to be stored in a subdirectory, write its name without a leading slash like this: subdirectory/pattern.`));
-    return pattern.replace(/\[(\w+)(:\d+)?]/g, (_match, type, size) => {
-        if (!replacements.hasOwnProperty(type) || (size && type !== 'hash')) {
-            return error(errorFailedValidation(`"[${type}${size || ''}]" is not a valid placeholder in the "${patternName}" pattern.`));
+        return error(errFailedValidation(`Invalid pattern "${pattern}" for "${patternName}", patterns can be neither absolute nor relative paths.`));
+    return pattern.replace(/\[(\w+)\]/g, (_match, type) => {
+        if (!replacements.hasOwnProperty(type)) {
+            return error(errFailedValidation(`"[${type}]" is not a valid placeholder in "${patternName}" pattern.`));
         }
-        const replacement = replacements[type](size && Number.parseInt(size.slice(1)));
+        const replacement = replacements[type]();
         if (isPathFragment(replacement))
-            return error(errorFailedValidation(`Invalid substitution "${replacement}" for placeholder "[${type}]" in "${patternName}" pattern, can be neither absolute nor relative path.`));
+            return error(errFailedValidation(`Invalid substitution "${replacement}" for placeholder "[${type}]" in "${patternName}" pattern, can be neither absolute nor relative path.`));
         return replacement;
     });
 }
-function makeUnique(name, { [lowercaseBundleKeys]: reservedLowercaseBundleKeys }) {
-    if (!reservedLowercaseBundleKeys.has(name.toLowerCase()))
+function makeUnique(name, existingNames) {
+    const existingNamesLowercase = new Set(Object.keys(existingNames).map(key => key.toLowerCase()));
+    if (!existingNamesLowercase.has(name.toLocaleLowerCase()))
         return name;
-    const extension = extname(name);
-    name = name.slice(0, Math.max(0, name.length - extension.length));
+    const ext = extname(name);
+    name = name.substr(0, name.length - ext.length);
     let uniqueName, uniqueIndex = 1;
-    while (reservedLowercaseBundleKeys.has((uniqueName = name + ++uniqueIndex + extension).toLowerCase()))
+    while (existingNamesLowercase.has((uniqueName = name + ++uniqueIndex + ext).toLowerCase()))
         ;
     return uniqueName;
 }
 
-const NON_ASSET_EXTENSIONS = new Set([
-    '.js',
-    '.jsx',
-    '.ts',
-    '.tsx',
-    '.mjs',
-    '.mts',
-    '.cjs',
-    '.cts'
-]);
-function getGlobalName(chunk, globals, hasExports, warn) {
-    const globalName = typeof globals === 'function' ? globals(chunk.id) : globals[chunk.id];
+const NON_ASSET_EXTENSIONS = ['.js', '.jsx', '.ts', '.tsx'];
+function getGlobalName(module, globals, hasExports, warn) {
+    const globalName = typeof globals === 'function' ? globals(module.id) : globals[module.id];
     if (globalName) {
         return globalName;
     }
     if (hasExports) {
-        warn(errorMissingGlobalName(chunk.id, chunk.variableName));
-        return chunk.variableName;
+        warn({
+            code: 'MISSING_GLOBAL_NAME',
+            guess: module.variableName,
+            message: `No name was provided for external module '${module.id}' in output.globals – guessing '${module.variableName}'`,
+            source: module.id
+        });
+        return module.variableName;
     }
 }
 class Chunk {
-    constructor(orderedModules, inputOptions, outputOptions, unsetOptions, pluginDriver, modulesById, chunkByModule, externalChunkByModule, facadeChunkByModule, includedNamespaces, manualChunkAlias, getPlaceholder, bundle, inputBase, snippets) {
+    constructor(orderedModules, inputOptions, outputOptions, unsetOptions, pluginDriver, modulesById, chunkByModule, facadeChunkByModule, includedNamespaces, manualChunkAlias) {
         this.orderedModules = orderedModules;
         this.inputOptions = inputOptions;
         this.outputOptions = outputOptions;
@@ -15036,47 +14200,43 @@
         this.pluginDriver = pluginDriver;
         this.modulesById = modulesById;
         this.chunkByModule = chunkByModule;
-        this.externalChunkByModule = externalChunkByModule;
         this.facadeChunkByModule = facadeChunkByModule;
         this.includedNamespaces = includedNamespaces;
         this.manualChunkAlias = manualChunkAlias;
-        this.getPlaceholder = getPlaceholder;
-        this.bundle = bundle;
-        this.inputBase = inputBase;
-        this.snippets = snippets;
         this.entryModules = [];
         this.exportMode = 'named';
         this.facadeModule = null;
+        this.id = null;
         this.namespaceVariableName = '';
+        this.needsExportsShim = false;
         this.variableName = '';
         this.accessedGlobalsByScope = new Map();
         this.dependencies = new Set();
+        this.dynamicDependencies = new Set();
         this.dynamicEntryModules = [];
         this.dynamicName = null;
         this.exportNamesByVariable = new Map();
         this.exports = new Set();
-        this.exportsByName = new Map();
+        this.exportsByName = Object.create(null);
         this.fileName = null;
         this.implicitEntryModules = [];
         this.implicitlyLoadedBefore = new Set();
         this.imports = new Set();
-        this.includedDynamicImports = null;
-        this.includedReexportsByModule = new Map();
-        // This may be updated in the constructor
+        this.indentString = undefined;
         this.isEmpty = true;
         this.name = null;
-        this.needsExportsShim = false;
-        this.preRenderedChunkInfo = null;
-        this.preliminaryFileName = null;
-        this.renderedChunkInfo = null;
         this.renderedDependencies = null;
+        this.renderedExports = null;
+        this.renderedHash = undefined;
+        this.renderedModuleSources = new Map();
         this.renderedModules = Object.create(null);
+        this.renderedSource = null;
         this.sortedExportNames = null;
         this.strictFacade = false;
+        this.usedModules = undefined;
         this.execIndex = orderedModules.length > 0 ? orderedModules[0].execIndex : Infinity;
         const chunkModules = new Set(orderedModules);
         for (const module of orderedModules) {
-            chunkByModule.set(module, this);
             if (module.namespace.included) {
                 includedNamespaces.add(module);
             }
@@ -15102,19 +14262,17 @@
         }
         this.suggestedVariableName = makeLegal(this.generateVariableName());
     }
-    static generateFacade(inputOptions, outputOptions, unsetOptions, pluginDriver, modulesById, chunkByModule, externalChunkByModule, facadeChunkByModule, includedNamespaces, facadedModule, facadeName, getPlaceholder, bundle, inputBase, snippets) {
-        const chunk = new Chunk([], inputOptions, outputOptions, unsetOptions, pluginDriver, modulesById, chunkByModule, externalChunkByModule, facadeChunkByModule, includedNamespaces, null, getPlaceholder, bundle, inputBase, snippets);
+    static generateFacade(inputOptions, outputOptions, unsetOptions, pluginDriver, modulesById, chunkByModule, facadeChunkByModule, includedNamespaces, facadedModule, facadeName) {
+        const chunk = new Chunk([], inputOptions, outputOptions, unsetOptions, pluginDriver, modulesById, chunkByModule, facadeChunkByModule, includedNamespaces, null);
         chunk.assignFacadeName(facadeName, facadedModule);
         if (!facadeChunkByModule.has(facadedModule)) {
             facadeChunkByModule.set(facadedModule, chunk);
         }
         for (const dependency of facadedModule.getDependenciesToBeIncluded()) {
-            chunk.dependencies.add(dependency instanceof Module
-                ? chunkByModule.get(dependency)
-                : externalChunkByModule.get(dependency));
+            chunk.dependencies.add(dependency instanceof Module ? chunkByModule.get(dependency) : dependency);
         }
         if (!chunk.dependencies.has(chunkByModule.get(facadedModule)) &&
-            facadedModule.info.moduleSideEffects &&
+            facadedModule.info.hasModuleSideEffects &&
             facadedModule.hasEffects()) {
             chunk.dependencies.add(chunkByModule.get(facadedModule));
         }
@@ -15127,6 +14285,17 @@
         const moduleExportNamesByVariable = module.getExportNamesByVariable();
         for (const exposedVariable of this.exports) {
             if (!moduleExportNamesByVariable.has(exposedVariable)) {
+                if (moduleExportNamesByVariable.size === 0 &&
+                    module.isUserDefinedEntryPoint &&
+                    module.preserveSignature === 'strict' &&
+                    this.unsetOptions.has('preserveEntrySignatures')) {
+                    this.inputOptions.onwarn({
+                        code: 'EMPTY_FACADE',
+                        id: module.id,
+                        message: `To preserve the export signature of the entry module "${relativeId(module.id)}", an empty facade chunk was created. This often happens when creating a bundle for a web app where chunks are placed in script tags and exports are ignored. In this case it is recommended to set "preserveEntrySignatures: false" to avoid this and reduce the number of chunks. Otherwise if this is intentional, set "preserveEntrySignatures: 'strict'" explicitly to silence this warning.`,
+                        url: 'https://rollupjs.org/guide/en/#preserveentrysignatures'
+                    });
+                }
                 return false;
             }
         }
@@ -15137,25 +14306,6 @@
         }
         return true;
     }
-    finalizeChunk(code, map, hashesByPlaceholder) {
-        const renderedChunkInfo = this.getRenderedChunkInfo();
-        const finalize = (code) => replacePlaceholders(code, hashesByPlaceholder);
-        const fileName = (this.fileName = finalize(renderedChunkInfo.fileName));
-        return {
-            ...renderedChunkInfo,
-            code,
-            dynamicImports: renderedChunkInfo.dynamicImports.map(finalize),
-            fileName,
-            implicitlyLoadedBefore: renderedChunkInfo.implicitlyLoadedBefore.map(finalize),
-            importedBindings: Object.fromEntries(Object.entries(renderedChunkInfo.importedBindings).map(([fileName, bindings]) => [
-                finalize(fileName),
-                bindings
-            ])),
-            imports: renderedChunkInfo.imports.map(finalize),
-            map,
-            referencedFiles: renderedChunkInfo.referencedFiles.map(finalize)
-        };
-    }
     generateExports() {
         this.sortedExportNames = null;
         const remainingExports = new Set(this.exports);
@@ -15165,7 +14315,7 @@
             for (const [variable, exportNames] of exportNamesByVariable) {
                 this.exportNamesByVariable.set(variable, [...exportNames]);
                 for (const exportName of exportNames) {
-                    this.exportsByName.set(exportName, variable);
+                    this.exportsByName[exportName] = variable;
                 }
                 remainingExports.delete(variable);
             }
@@ -15177,12 +14327,13 @@
             assignExportsToNames(remainingExports, this.exportsByName, this.exportNamesByVariable);
         }
         if (this.outputOptions.preserveModules || (this.facadeModule && this.facadeModule.info.isEntry))
-            this.exportMode = getExportMode(this, this.outputOptions, this.facadeModule.id, this.inputOptions.onwarn);
+            this.exportMode = getExportMode(this, this.outputOptions, this.unsetOptions, this.facadeModule.id, this.inputOptions.onwarn);
     }
     generateFacades() {
+        var _a;
         const facades = [];
         const entryModules = new Set([...this.entryModules, ...this.implicitEntryModules]);
-        const exposedVariables = new Set(this.dynamicEntryModules.map(({ namespace }) => namespace));
+        const exposedVariables = new Set(this.dynamicEntryModules.map(module => module.namespace));
         for (const module of entryModules) {
             if (module.preserveSignature) {
                 for (const exportedVariable of module.getExportNamesByVariable().keys()) {
@@ -15191,16 +14342,12 @@
             }
         }
         for (const module of entryModules) {
-            // eslint-disable-next-line unicorn/prefer-spread
-            const requiredFacades = Array.from(new Set(module.chunkNames.filter(({ isUserDefined }) => isUserDefined).map(({ name }) => name)), 
-            // mapping must run after Set 'name' dedupe
-            name => ({
+            const requiredFacades = Array.from(module.userChunkNames, name => ({
                 name
             }));
             if (requiredFacades.length === 0 && module.isUserDefinedEntryPoint) {
                 requiredFacades.push({});
             }
-            // eslint-disable-next-line unicorn/prefer-spread
             requiredFacades.push(...Array.from(module.chunkFileNames, fileName => ({ fileName })));
             if (requiredFacades.length === 0) {
                 requiredFacades.push({});
@@ -15208,7 +14355,7 @@
             if (!this.facadeModule) {
                 const needsStrictFacade = module.preserveSignature === 'strict' ||
                     (module.preserveSignature === 'exports-only' &&
-                        module.getExportNamesByVariable().size > 0);
+                        module.getExportNamesByVariable().size !== 0);
                 if (!needsStrictFacade ||
                     this.outputOptions.preserveModules ||
                     this.canModuleBeFacade(module, exposedVariables)) {
@@ -15217,11 +14364,11 @@
                     if (module.preserveSignature) {
                         this.strictFacade = needsStrictFacade;
                     }
-                    this.assignFacadeName(requiredFacades.shift(), module, this.outputOptions.preserveModules);
+                    this.assignFacadeName(requiredFacades.shift(), module);
                 }
             }
             for (const facadeName of requiredFacades) {
-                facades.push(Chunk.generateFacade(this.inputOptions, this.outputOptions, this.unsetOptions, this.pluginDriver, this.modulesById, this.chunkByModule, this.externalChunkByModule, this.facadeChunkByModule, this.includedNamespaces, module, facadeName, this.getPlaceholder, this.bundle, this.inputBase, this.snippets));
+                facades.push(Chunk.generateFacade(this.inputOptions, this.outputOptions, this.unsetOptions, this.pluginDriver, this.modulesById, this.chunkByModule, this.facadeChunkByModule, this.includedNamespaces, module, facadeName));
             }
         }
         for (const module of this.dynamicEntryModules) {
@@ -15238,77 +14385,113 @@
                 this.canModuleBeFacade(module, exposedVariables)) {
                 this.strictFacade = true;
             }
-            else if (!this.facadeChunkByModule.get(module)?.strictFacade) {
+            else if (!((_a = this.facadeChunkByModule.get(module)) === null || _a === void 0 ? void 0 : _a.strictFacade)) {
                 this.includedNamespaces.add(module);
                 this.exports.add(module.namespace);
             }
         }
-        if (!this.outputOptions.preserveModules) {
-            this.addNecessaryImportsForFacades();
-        }
         return facades;
     }
-    getChunkName() {
-        return (this.name ?? (this.name = this.outputOptions.sanitizeFileName(this.getFallbackChunkName())));
-    }
-    getExportNames() {
-        return (this.sortedExportNames ?? (this.sortedExportNames = [...this.exportsByName.keys()].sort()));
-    }
-    getFileName() {
-        return this.fileName || this.getPreliminaryFileName().fileName;
-    }
-    getImportPath(importer) {
-        return escapeId(getImportPath(importer, this.getFileName(), this.outputOptions.format === 'amd' && !this.outputOptions.amd.forceJsExtensionForImports, true));
-    }
-    getPreliminaryFileName() {
-        if (this.preliminaryFileName) {
-            return this.preliminaryFileName;
-        }
-        let fileName;
-        let hashPlaceholder = null;
-        const { chunkFileNames, entryFileNames, file, format, preserveModules } = this.outputOptions;
-        if (file) {
-            fileName = basename(file);
-        }
-        else if (this.fileName === null) {
-            const [pattern, patternName] = preserveModules || this.facadeModule?.isUserDefinedEntryPoint
-                ? [entryFileNames, 'output.entryFileNames']
-                : [chunkFileNames, 'output.chunkFileNames'];
-            fileName = renderNamePattern(typeof pattern === 'function' ? pattern(this.getPreRenderedChunkInfo()) : pattern, patternName, {
-                format: () => format,
-                hash: size => hashPlaceholder || (hashPlaceholder = this.getPlaceholder(patternName, size)),
+    generateId(addons, options, existingNames, includeHash) {
+        if (this.fileName !== null) {
+            return this.fileName;
+        }
+        const [pattern, patternName] = this.facadeModule && this.facadeModule.isUserDefinedEntryPoint
+            ? [options.entryFileNames, 'output.entryFileNames']
+            : [options.chunkFileNames, 'output.chunkFileNames'];
+        return makeUnique(renderNamePattern(typeof pattern === 'function' ? pattern(this.getChunkInfo()) : pattern, patternName, {
+            format: () => options.format,
+            hash: () => includeHash
+                ? this.computeContentHashWithDependencies(addons, options, existingNames)
+                : '[hash]',
+            name: () => this.getChunkName()
+        }), existingNames);
+    }
+    generateIdPreserveModules(preserveModulesRelativeDir, options, existingNames, unsetOptions) {
+        const id = this.orderedModules[0].id;
+        const sanitizedId = this.outputOptions.sanitizeFileName(id);
+        let path;
+        if (isAbsolute(id)) {
+            const extension = extname(id);
+            const pattern = unsetOptions.has('entryFileNames')
+                ? '[name][assetExtname].js'
+                : options.entryFileNames;
+            const currentDir = dirname(sanitizedId);
+            const fileName = renderNamePattern(typeof pattern === 'function' ? pattern(this.getChunkInfo()) : pattern, 'output.entryFileNames', {
+                assetExtname: () => (NON_ASSET_EXTENSIONS.includes(extension) ? '' : extension),
+                ext: () => extension.substr(1),
+                extname: () => extension,
+                format: () => options.format,
                 name: () => this.getChunkName()
             });
-            if (!hashPlaceholder) {
-                fileName = makeUnique(fileName, this.bundle);
+            const currentPath = `${currentDir}/${fileName}`;
+            const { preserveModulesRoot } = options;
+            if (preserveModulesRoot && currentPath.startsWith(preserveModulesRoot)) {
+                path = currentPath.slice(preserveModulesRoot.length).replace(/^[\\/]/, '');
+            }
+            else {
+                path = relative(preserveModulesRelativeDir, currentPath);
             }
         }
         else {
-            fileName = this.fileName;
+            path = `_virtual/${basename(sanitizedId)}`;
         }
-        if (!hashPlaceholder) {
-            this.bundle[fileName] = FILE_PLACEHOLDER;
-        }
-        // Caching is essential to not conflict with the file name reservation above
-        return (this.preliminaryFileName = { fileName, hashPlaceholder });
+        return makeUnique(normalize(path), existingNames);
     }
-    getRenderedChunkInfo() {
-        if (this.renderedChunkInfo) {
-            return this.renderedChunkInfo;
-        }
-        return (this.renderedChunkInfo = {
-            ...this.getPreRenderedChunkInfo(),
-            dynamicImports: this.getDynamicDependencies().map(resolveFileName),
-            fileName: this.getFileName(),
-            // eslint-disable-next-line unicorn/prefer-spread
-            implicitlyLoadedBefore: Array.from(this.implicitlyLoadedBefore, resolveFileName),
-            importedBindings: getImportedBindingsPerDependency(this.getRenderedDependencies(), resolveFileName),
-            // eslint-disable-next-line unicorn/prefer-spread
-            imports: Array.from(this.dependencies, resolveFileName),
+    getChunkInfo() {
+        const facadeModule = this.facadeModule;
+        const getChunkName = this.getChunkName.bind(this);
+        return {
+            exports: this.getExportNames(),
+            facadeModuleId: facadeModule && facadeModule.id,
+            isDynamicEntry: this.dynamicEntryModules.length > 0,
+            isEntry: facadeModule !== null && facadeModule.info.isEntry,
+            isImplicitEntry: this.implicitEntryModules.length > 0,
             modules: this.renderedModules,
+            get name() {
+                return getChunkName();
+            },
+            type: 'chunk'
+        };
+    }
+    getChunkInfoWithFileNames() {
+        return Object.assign(this.getChunkInfo(), {
+            code: undefined,
+            dynamicImports: Array.from(this.dynamicDependencies, getId),
+            fileName: this.id,
+            implicitlyLoadedBefore: Array.from(this.implicitlyLoadedBefore, getId),
+            importedBindings: this.getImportedBindingsPerDependency(),
+            imports: Array.from(this.dependencies, getId),
+            map: undefined,
             referencedFiles: this.getReferencedFiles()
         });
     }
+    getChunkName() {
+        return (this.name || (this.name = this.outputOptions.sanitizeFileName(this.getFallbackChunkName())));
+    }
+    getExportNames() {
+        return (this.sortedExportNames || (this.sortedExportNames = Object.keys(this.exportsByName).sort()));
+    }
+    getRenderedHash() {
+        if (this.renderedHash)
+            return this.renderedHash;
+        const hash = createHash();
+        const hashAugmentation = this.pluginDriver.hookReduceValueSync('augmentChunkHash', '', [this.getChunkInfo()], (augmentation, pluginHash) => {
+            if (pluginHash) {
+                augmentation += pluginHash;
+            }
+            return augmentation;
+        });
+        hash.update(hashAugmentation);
+        hash.update(this.renderedSource.toString());
+        hash.update(this.getExportNames()
+            .map(exportName => {
+            const variable = this.exportsByName[exportName];
+            return `${relativeId(variable.module.id).replace(/\\/g, '/')}:${variable.name}:${exportName}`;
+        })
+            .join(','));
+        return (this.renderedHash = hash.digest('hex'));
+    }
     getVariableExportName(variable) {
         if (this.outputOptions.preserveModules && variable instanceof NamespaceVariable) {
             return '*';
@@ -15316,107 +14499,231 @@
         return this.exportNamesByVariable.get(variable)[0];
     }
     link() {
-        this.dependencies = getStaticDependencies(this, this.orderedModules, this.chunkByModule, this.externalChunkByModule);
+        this.dependencies = getStaticDependencies(this, this.orderedModules, this.chunkByModule);
         for (const module of this.orderedModules) {
-            this.addImplicitlyLoadedBeforeFromModule(module);
+            this.addDependenciesToChunk(module.dynamicDependencies, this.dynamicDependencies);
+            this.addDependenciesToChunk(module.implicitlyLoadedBefore, this.implicitlyLoadedBefore);
             this.setUpChunkImportsAndExportsForModule(module);
         }
     }
-    async render() {
-        const { dependencies, exportMode, facadeModule, inputOptions: { onwarn }, outputOptions, pluginDriver, snippets } = this;
-        const { format, hoistTransitiveImports, preserveModules } = outputOptions;
-        // for static and dynamic entry points, add transitive dependencies to this
-        // chunk's dependencies to avoid loading latency
-        if (hoistTransitiveImports && !preserveModules && facadeModule !== null) {
-            for (const dep of dependencies) {
+    // prerender allows chunk hashes and names to be generated before finalizing
+    preRender(options, inputBase, snippets) {
+        const { _, getPropertyAccess, n } = snippets;
+        const magicString = new Bundle$1({ separator: `${n}${n}` });
+        this.usedModules = [];
+        this.indentString = getIndentString(this.orderedModules, options);
+        const renderOptions = {
+            dynamicImportFunction: options.dynamicImportFunction,
+            exportNamesByVariable: this.exportNamesByVariable,
+            format: options.format,
+            freeze: options.freeze,
+            indent: this.indentString,
+            namespaceToStringTag: options.namespaceToStringTag,
+            outputPluginDriver: this.pluginDriver,
+            snippets
+        };
+        // for static and dynamic entry points, inline the execution list to avoid loading latency
+        if (options.hoistTransitiveImports &&
+            !this.outputOptions.preserveModules &&
+            this.facadeModule !== null) {
+            for (const dep of this.dependencies) {
                 if (dep instanceof Chunk)
                     this.inlineChunkDependencies(dep);
             }
         }
-        const preliminaryFileName = this.getPreliminaryFileName();
-        const { accessedGlobals, indent, magicString, renderedSource, usedModules, usesTopLevelAwait } = this.renderModules(preliminaryFileName.fileName);
-        const renderedDependencies = [...this.getRenderedDependencies().values()];
-        const renderedExports = exportMode === 'none' ? [] : this.getChunkExportDeclarations(format);
-        let hasExports = renderedExports.length > 0;
-        let hasDefaultExport = false;
-        for (const renderedDependence of renderedDependencies) {
-            const { reexports } = renderedDependence;
-            if (reexports?.length) {
-                hasExports = true;
-                if (!hasDefaultExport && reexports.some(reexport => reexport.reexported === 'default')) {
-                    hasDefaultExport = true;
+        this.prepareModulesForRendering(snippets);
+        this.setIdentifierRenderResolutions(options);
+        let hoistedSource = '';
+        const renderedModules = this.renderedModules;
+        for (const module of this.orderedModules) {
+            let renderedLength = 0;
+            if (module.isIncluded() || this.includedNamespaces.has(module)) {
+                const source = module.render(renderOptions).trim();
+                renderedLength = source.length();
+                if (renderedLength) {
+                    if (options.compact && source.lastLine().indexOf('//') !== -1)
+                        source.append('\n');
+                    this.renderedModuleSources.set(module, source);
+                    magicString.addSource(source);
+                    this.usedModules.push(module);
                 }
-                if (format === 'es') {
-                    renderedDependence.reexports = reexports.filter(
-                    // eslint-disable-next-line unicorn/prefer-array-some
-                    ({ reexported }) => !renderedExports.find(({ exported }) => exported === reexported));
+                const namespace = module.namespace;
+                if (this.includedNamespaces.has(module) && !this.outputOptions.preserveModules) {
+                    const rendered = namespace.renderBlock(renderOptions);
+                    if (namespace.renderFirst())
+                        hoistedSource += n + rendered;
+                    else
+                        magicString.addSource(new MagicString$1(rendered));
                 }
             }
+            const { renderedExports, removedExports } = module.getRenderedExports();
+            const { renderedModuleSources } = this;
+            renderedModules[module.id] = {
+                get code() {
+                    var _a, _b;
+                    return (_b = (_a = renderedModuleSources.get(module)) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : null;
+                },
+                originalLength: module.originalCode.length,
+                removedExports,
+                renderedExports,
+                renderedLength
+            };
+        }
+        if (hoistedSource)
+            magicString.prepend(hoistedSource + n + n);
+        if (this.needsExportsShim) {
+            magicString.prepend(`${n}${snippets.cnst} ${MISSING_EXPORT_SHIM_VARIABLE}${_}=${_}void 0;${n}${n}`);
+        }
+        if (options.compact) {
+            this.renderedSource = magicString;
+        }
+        else {
+            this.renderedSource = magicString.trim();
+        }
+        this.renderedHash = undefined;
+        if (this.isEmpty && this.getExportNames().length === 0 && this.dependencies.size === 0) {
+            const chunkName = this.getChunkName();
+            this.inputOptions.onwarn({
+                chunkName,
+                code: 'EMPTY_BUNDLE',
+                message: `Generated an empty chunk: "${chunkName}"`
+            });
+        }
+        this.setExternalRenderPaths(options, inputBase);
+        this.renderedDependencies = this.getChunkDependencyDeclarations(options, getPropertyAccess);
+        this.renderedExports =
+            this.exportMode === 'none'
+                ? []
+                : this.getChunkExportDeclarations(options.format, getPropertyAccess);
+    }
+    async render(options, addons, outputChunk, snippets) {
+        timeStart('render format', 2);
+        const format = options.format;
+        const finalise = finalisers[format];
+        if (options.dynamicImportFunction && format !== 'es') {
+            this.inputOptions.onwarn(errInvalidOption('output.dynamicImportFunction', 'outputdynamicImportFunction', 'this option is ignored for formats other than "es"'));
+        }
+        // populate ids in the rendered declarations only here
+        // as chunk ids known only after prerender
+        for (const dependency of this.dependencies) {
+            const renderedDependency = this.renderedDependencies.get(dependency);
+            if (dependency instanceof ExternalModule) {
+                const originalId = dependency.renderPath;
+                renderedDependency.id = escapeId(dependency.renormalizeRenderPath ? this.getRelativePath(originalId, false) : originalId);
+            }
+            else {
+                renderedDependency.namedExportsMode = dependency.exportMode !== 'default';
+                renderedDependency.id = escapeId(this.getRelativePath(dependency.id, false));
+            }
         }
-        if (!hasDefaultExport) {
-            for (const { exported } of renderedExports) {
-                if (exported === 'default') {
-                    hasDefaultExport = true;
-                    break;
+        this.finaliseDynamicImports(options, snippets);
+        this.finaliseImportMetas(format, snippets);
+        const hasExports = this.renderedExports.length !== 0 ||
+            [...this.renderedDependencies.values()].some(dep => (dep.reexports && dep.reexports.length !== 0));
+        let usesTopLevelAwait = false;
+        const accessedGlobals = new Set();
+        for (const module of this.orderedModules) {
+            if (module.usesTopLevelAwait) {
+                usesTopLevelAwait = true;
+            }
+            const accessedGlobalVariables = this.accessedGlobalsByScope.get(module.scope);
+            if (accessedGlobalVariables) {
+                for (const name of accessedGlobalVariables) {
+                    accessedGlobals.add(name);
                 }
             }
         }
-        const { intro, outro, banner, footer } = await createAddons(outputOptions, pluginDriver, this.getRenderedChunkInfo());
-        finalisers[format](renderedSource, {
+        if (usesTopLevelAwait && format !== 'es' && format !== 'system') {
+            return error({
+                code: 'INVALID_TLA_FORMAT',
+                message: `Module format ${format} does not support top-level await. Use the "es" or "system" output formats rather.`
+            });
+        }
+        /* istanbul ignore next */
+        if (!this.id) {
+            throw new Error('Internal Error: expecting chunk id');
+        }
+        const magicString = finalise(this.renderedSource, {
             accessedGlobals,
-            dependencies: renderedDependencies,
-            exports: renderedExports,
-            hasDefaultExport,
+            dependencies: [...this.renderedDependencies.values()],
+            exports: this.renderedExports,
             hasExports,
-            id: preliminaryFileName.fileName,
-            indent,
-            intro,
-            isEntryFacade: preserveModules || (facadeModule !== null && facadeModule.info.isEntry),
-            isModuleFacade: facadeModule !== null,
-            namedExportsMode: exportMode !== 'default',
-            onwarn,
-            outro,
+            id: this.id,
+            indent: this.indentString,
+            intro: addons.intro,
+            isEntryFacade: this.outputOptions.preserveModules ||
+                (this.facadeModule !== null && this.facadeModule.info.isEntry),
+            isModuleFacade: this.facadeModule !== null,
+            namedExportsMode: this.exportMode !== 'default',
+            outro: addons.outro,
             snippets,
-            usesTopLevelAwait
-        }, outputOptions);
-        if (banner)
-            magicString.prepend(banner);
-        if (footer)
-            magicString.append(footer);
-        return {
-            chunk: this,
-            magicString,
-            preliminaryFileName,
-            usedModules
-        };
-    }
-    addImplicitlyLoadedBeforeFromModule(baseModule) {
-        const { chunkByModule, implicitlyLoadedBefore } = this;
-        for (const module of baseModule.implicitlyLoadedBefore) {
-            const chunk = chunkByModule.get(module);
-            if (chunk && chunk !== this) {
-                implicitlyLoadedBefore.add(chunk);
-            }
+            usesTopLevelAwait,
+            warn: this.inputOptions.onwarn
+        }, options);
+        if (addons.banner)
+            magicString.prepend(addons.banner);
+        if (addons.footer)
+            magicString.append(addons.footer);
+        const prevCode = magicString.toString();
+        timeEnd('render format', 2);
+        let map = null;
+        const chunkSourcemapChain = [];
+        let code = await renderChunk({
+            code: prevCode,
+            options,
+            outputPluginDriver: this.pluginDriver,
+            renderChunk: outputChunk,
+            sourcemapChain: chunkSourcemapChain
+        });
+        if (options.sourcemap) {
+            timeStart('sourcemap', 2);
+            let file;
+            if (options.file)
+                file = resolve(options.sourcemapFile || options.file);
+            else if (options.dir)
+                file = resolve(options.dir, this.id);
+            else
+                file = resolve(this.id);
+            const decodedMap = magicString.generateDecodedMap({});
+            map = collapseSourcemaps(file, decodedMap, this.usedModules, chunkSourcemapChain, options.sourcemapExcludeSources, this.inputOptions.onwarn);
+            map.sources = map.sources
+                .map(sourcePath => {
+                const { sourcemapPathTransform } = options;
+                if (sourcemapPathTransform) {
+                    const newSourcePath = sourcemapPathTransform(sourcePath, `${file}.map`);
+                    if (typeof newSourcePath !== 'string') {
+                        error(errFailedValidation(`sourcemapPathTransform function must return a string.`));
+                    }
+                    return newSourcePath;
+                }
+                return sourcePath;
+            })
+                .map(normalize);
+            timeEnd('sourcemap', 2);
         }
+        if (!options.compact && code[code.length - 1] !== '\n')
+            code += '\n';
+        return { code, map };
     }
-    addNecessaryImportsForFacades() {
-        for (const [module, variables] of this.includedReexportsByModule) {
-            if (this.includedNamespaces.has(module)) {
-                for (const variable of variables) {
-                    this.imports.add(variable);
+    addDependenciesToChunk(moduleDependencies, chunkDependencies) {
+        for (const module of moduleDependencies) {
+            if (module instanceof Module) {
+                const chunk = this.chunkByModule.get(module);
+                if (chunk && chunk !== this) {
+                    chunkDependencies.add(chunk);
                 }
             }
+            else {
+                chunkDependencies.add(module);
+            }
         }
     }
-    assignFacadeName({ fileName, name }, facadedModule, preservePath) {
+    assignFacadeName({ fileName, name }, facadedModule) {
         if (fileName) {
             this.fileName = fileName;
         }
         else {
-            this.name = this.outputOptions.sanitizeFileName(name ||
-                (preservePath
-                    ? this.getPreserveModulesChunkNameFromModule(facadedModule)
-                    : getChunkNameFromModule(facadedModule)));
+            this.name = this.outputOptions.sanitizeFileName(name || getChunkNameFromModule(facadedModule));
         }
     }
     checkCircularDependencyImport(variable, importingModule) {
@@ -15429,19 +14736,41 @@
                 if (alternativeReexportModule) {
                     const exportingChunk = this.chunkByModule.get(alternativeReexportModule);
                     if (exportingChunk && exportingChunk !== exportChunk) {
-                        this.inputOptions.onwarn(errorCyclicCrossChunkReexport(variableModule.getExportNamesByVariable().get(variable)[0], variableModule.id, alternativeReexportModule.id, importingModule.id));
+                        this.inputOptions.onwarn(errCyclicCrossChunkReexport(variableModule.getExportNamesByVariable().get(variable)[0], variableModule.id, alternativeReexportModule.id, importingModule.id));
                     }
                     importingModule = alternativeReexportModule;
                 }
             } while (alternativeReexportModule);
         }
     }
+    computeContentHashWithDependencies(addons, options, existingNames) {
+        const hash = createHash();
+        hash.update([addons.intro, addons.outro, addons.banner, addons.footer].map(addon => addon || '').join(':'));
+        hash.update(options.format);
+        const dependenciesForHashing = new Set([this]);
+        for (const current of dependenciesForHashing) {
+            if (current instanceof ExternalModule) {
+                hash.update(':' + current.renderPath);
+            }
+            else {
+                hash.update(current.getRenderedHash());
+                hash.update(current.generateId(addons, options, existingNames, false));
+            }
+            if (current instanceof ExternalModule)
+                continue;
+            for (const dependency of [...current.dependencies, ...current.dynamicDependencies]) {
+                dependenciesForHashing.add(dependency);
+            }
+        }
+        return hash.digest('hex').substr(0, 8);
+    }
     ensureReexportsAreAvailableForModule(module) {
-        const includedReexports = [];
         const map = module.getExportNamesByVariable();
         for (const exportedVariable of map.keys()) {
             const isSynthetic = exportedVariable instanceof SyntheticNamedExportVariable;
-            const importedVariable = isSynthetic ? exportedVariable.getBaseVariable() : exportedVariable;
+            const importedVariable = isSynthetic
+                ? exportedVariable.getBaseVariable()
+                : exportedVariable;
             if (!(importedVariable instanceof NamespaceVariable && this.outputOptions.preserveModules)) {
                 this.checkCircularDependencyImport(importedVariable, module);
                 const exportingModule = importedVariable.module;
@@ -15449,7 +14778,6 @@
                     const chunk = this.chunkByModule.get(exportingModule);
                     if (chunk && chunk !== this) {
                         chunk.exports.add(importedVariable);
-                        includedReexports.push(importedVariable);
                         if (isSynthetic) {
                             this.imports.add(importedVariable);
                         }
@@ -15457,8 +14785,34 @@
                 }
             }
         }
-        if (includedReexports.length > 0) {
-            this.includedReexportsByModule.set(module, includedReexports);
+    }
+    finaliseDynamicImports(options, snippets) {
+        const stripKnownJsExtensions = options.format === 'amd';
+        for (const [module, code] of this.renderedModuleSources) {
+            for (const { node, resolution } of module.dynamicImports) {
+                const chunk = this.chunkByModule.get(resolution);
+                const facadeChunk = this.facadeChunkByModule.get(resolution);
+                if (!resolution || !node.included || chunk === this) {
+                    continue;
+                }
+                const renderedResolution = resolution instanceof Module
+                    ? `'${this.getRelativePath((facadeChunk || chunk).id, stripKnownJsExtensions)}'`
+                    : resolution instanceof ExternalModule
+                        ? `'${resolution.renormalizeRenderPath
+                            ? this.getRelativePath(resolution.renderPath, stripKnownJsExtensions)
+                            : resolution.renderPath}'`
+                        : resolution;
+                node.renderFinalResolution(code, renderedResolution, resolution instanceof Module &&
+                    !(facadeChunk === null || facadeChunk === void 0 ? void 0 : facadeChunk.strictFacade) &&
+                    chunk.exportNamesByVariable.get(resolution.namespace)[0], snippets);
+            }
+        }
+    }
+    finaliseImportMetas(format, snippets) {
+        for (const [module, code] of this.renderedModuleSources) {
+            for (const importMeta of module.importMetas) {
+                importMeta.renderFinalMechanism(code, this.id, format, snippets, this.pluginDriver);
+            }
         }
     }
     generateVariableName() {
@@ -15470,40 +14824,48 @@
             this.dynamicEntryModules[0] ||
             this.orderedModules[this.orderedModules.length - 1];
         if (moduleForNaming) {
-            return getChunkNameFromModule(moduleForNaming);
+            return moduleForNaming.chunkName || getAliasName(moduleForNaming.id);
         }
         return 'chunk';
     }
-    getChunkExportDeclarations(format) {
+    getChunkDependencyDeclarations(options, getPropertyAccess) {
+        const importSpecifiers = this.getImportSpecifiers(getPropertyAccess);
+        const reexportSpecifiers = this.getReexportSpecifiers();
+        const dependencyDeclaration = new Map();
+        for (const dep of this.dependencies) {
+            const imports = importSpecifiers.get(dep) || null;
+            const reexports = reexportSpecifiers.get(dep) || null;
+            const namedExportsMode = dep instanceof ExternalModule || dep.exportMode !== 'default';
+            dependencyDeclaration.set(dep, {
+                defaultVariableName: dep.defaultVariableName,
+                globalName: (dep instanceof ExternalModule &&
+                    (options.format === 'umd' || options.format === 'iife') &&
+                    getGlobalName(dep, options.globals, (imports || reexports) !== null, this.inputOptions.onwarn)),
+                id: undefined,
+                imports,
+                isChunk: dep instanceof Chunk,
+                name: dep.variableName,
+                namedExportsMode,
+                namespaceVariableName: dep.namespaceVariableName,
+                reexports
+            });
+        }
+        return dependencyDeclaration;
+    }
+    getChunkExportDeclarations(format, getPropertyAccess) {
         const exports = [];
         for (const exportName of this.getExportNames()) {
             if (exportName[0] === '*')
                 continue;
-            const variable = this.exportsByName.get(exportName);
+            const variable = this.exportsByName[exportName];
             if (!(variable instanceof SyntheticNamedExportVariable)) {
                 const module = variable.module;
-                if (module) {
-                    const chunk = this.chunkByModule.get(module);
-                    if (chunk !== this) {
-                        if (!chunk || format !== 'es') {
-                            continue;
-                        }
-                        const chunkDep = this.renderedDependencies.get(chunk);
-                        if (!chunkDep) {
-                            continue;
-                        }
-                        const { imports, reexports } = chunkDep;
-                        const importedByReexported = reexports?.find(({ reexported }) => reexported === exportName);
-                        const isImported = imports?.find(({ imported }) => imported === importedByReexported?.imported);
-                        if (!isImported) {
-                            continue;
-                        }
-                    }
-                }
+                if (module && this.chunkByModule.get(module) !== this)
+                    continue;
             }
             let expression = null;
             let hoisted = false;
-            let local = variable.getName(this.snippets.getPropertyAccess);
+            let local = variable.getName(getPropertyAccess);
             if (variable instanceof LocalVariable) {
                 for (const declaration of variable.declarations) {
                     if (declaration.parent instanceof FunctionDeclaration ||
@@ -15537,17 +14899,17 @@
             if (addNonNamespacesAndInteropHelpers || variable.isNamespace) {
                 const module = variable.module;
                 if (module instanceof ExternalModule) {
-                    const chunk = this.externalChunkByModule.get(module);
-                    dependencies.add(chunk);
+                    dependencies.add(module);
                     if (addNonNamespacesAndInteropHelpers) {
                         if (variable.name === 'default') {
-                            if (defaultInteropHelpersByInteropType[interop(module.id)]) {
-                                deconflictedDefault.add(chunk);
+                            if (defaultInteropHelpersByInteropType[String(interop(module.id))]) {
+                                deconflictedDefault.add(module);
                             }
                         }
-                        else if (variable.name === '*' &&
-                            namespaceInteropHelpersByInteropType[interop(module.id)]) {
-                            deconflictedNamespace.add(chunk);
+                        else if (variable.name === '*') {
+                            if (namespaceInteropHelpersByInteropType[String(interop(module.id))]) {
+                                deconflictedNamespace.add(module);
+                            }
                         }
                     }
                 }
@@ -15571,25 +14933,6 @@
         }
         return { deconflictedDefault, deconflictedNamespace, dependencies };
     }
-    getDynamicDependencies() {
-        return this.getIncludedDynamicImports()
-            .map(resolvedDynamicImport => resolvedDynamicImport.facadeChunk ||
-            resolvedDynamicImport.chunk ||
-            resolvedDynamicImport.externalChunk ||
-            resolvedDynamicImport.resolution)
-            .filter((resolution) => resolution !== this &&
-            (resolution instanceof Chunk || resolution instanceof ExternalChunk));
-    }
-    getDynamicImportStringAndAssertions(resolution, fileName) {
-        if (resolution instanceof ExternalModule) {
-            const chunk = this.externalChunkByModule.get(resolution);
-            return [`'${chunk.getImportPath(fileName)}'`, chunk.getImportAssertions(this.snippets)];
-        }
-        return [
-            resolution || '',
-            (this.outputOptions.format === 'es' && this.outputOptions.externalImportAssertions) || null
-        ];
-    }
     getFallbackChunkName() {
         if (this.manualChunkAlias) {
             return this.manualChunkAlias;
@@ -15602,7 +14945,7 @@
         }
         return getAliasName(this.orderedModules[this.orderedModules.length - 1].id);
     }
-    getImportSpecifiers() {
+    getImportSpecifiers(getPropertyAccess) {
         const { interop } = this.outputOptions;
         const importsByDependency = new Map();
         for (const variable of this.imports) {
@@ -15610,88 +14953,40 @@
             let dependency;
             let imported;
             if (module instanceof ExternalModule) {
-                dependency = this.externalChunkByModule.get(module);
+                dependency = module;
                 imported = variable.name;
                 if (imported !== 'default' && imported !== '*' && interop(module.id) === 'defaultOnly') {
-                    return error(errorUnexpectedNamedImport(module.id, imported, false));
+                    return error(errUnexpectedNamedImport(module.id, imported, false));
                 }
             }
             else {
                 dependency = this.chunkByModule.get(module);
                 imported = dependency.getVariableExportName(variable);
             }
-            getOrCreate(importsByDependency, dependency, getNewArray).push({
+            getOrCreate(importsByDependency, dependency, () => []).push({
                 imported,
-                local: variable.getName(this.snippets.getPropertyAccess)
+                local: variable.getName(getPropertyAccess)
             });
         }
         return importsByDependency;
     }
-    getIncludedDynamicImports() {
-        if (this.includedDynamicImports) {
-            return this.includedDynamicImports;
-        }
-        const includedDynamicImports = [];
-        for (const module of this.orderedModules) {
-            for (const { node, resolution } of module.dynamicImports) {
-                if (!node.included) {
-                    continue;
+    getImportedBindingsPerDependency() {
+        const importSpecifiers = {};
+        for (const [dependency, declaration] of this.renderedDependencies) {
+            const specifiers = new Set();
+            if (declaration.imports) {
+                for (const { imported } of declaration.imports) {
+                    specifiers.add(imported);
                 }
-                includedDynamicImports.push(resolution instanceof Module
-                    ? {
-                        chunk: this.chunkByModule.get(resolution),
-                        externalChunk: null,
-                        facadeChunk: this.facadeChunkByModule.get(resolution),
-                        node,
-                        resolution
-                    }
-                    : resolution instanceof ExternalModule
-                        ? {
-                            chunk: null,
-                            externalChunk: this.externalChunkByModule.get(resolution),
-                            facadeChunk: null,
-                            node,
-                            resolution
-                        }
-                        : { chunk: null, externalChunk: null, facadeChunk: null, node, resolution });
             }
+            if (declaration.reexports) {
+                for (const { imported } of declaration.reexports) {
+                    specifiers.add(imported);
+                }
+            }
+            importSpecifiers[dependency.id] = [...specifiers];
         }
-        return (this.includedDynamicImports = includedDynamicImports);
-    }
-    getPreRenderedChunkInfo() {
-        if (this.preRenderedChunkInfo) {
-            return this.preRenderedChunkInfo;
-        }
-        const { dynamicEntryModules, facadeModule, implicitEntryModules, orderedModules } = this;
-        return (this.preRenderedChunkInfo = {
-            exports: this.getExportNames(),
-            facadeModuleId: facadeModule && facadeModule.id,
-            isDynamicEntry: dynamicEntryModules.length > 0,
-            isEntry: !!facadeModule?.info.isEntry,
-            isImplicitEntry: implicitEntryModules.length > 0,
-            moduleIds: orderedModules.map(({ id }) => id),
-            name: this.getChunkName(),
-            type: 'chunk'
-        });
-    }
-    getPreserveModulesChunkNameFromModule(module) {
-        const predefinedChunkName = getPredefinedChunkNameFromModule(module);
-        if (predefinedChunkName)
-            return predefinedChunkName;
-        const { preserveModulesRoot, sanitizeFileName } = this.outputOptions;
-        const sanitizedId = sanitizeFileName(normalize(module.id.split(QUERY_HASH_REGEX, 1)[0]));
-        const extensionName = extname(sanitizedId);
-        const idWithoutExtension = NON_ASSET_EXTENSIONS.has(extensionName)
-            ? sanitizedId.slice(0, -extensionName.length)
-            : sanitizedId;
-        if (isAbsolute(idWithoutExtension)) {
-            return preserveModulesRoot && resolve(idWithoutExtension).startsWith(preserveModulesRoot)
-                ? idWithoutExtension.slice(preserveModulesRoot.length).replace(/^[/\\]/, '')
-                : relative(this.inputBase, idWithoutExtension);
-        }
-        else {
-            return `_virtual/${basename(idWithoutExtension)}`;
-        }
+        return importSpecifiers;
     }
     getReexportSpecifiers() {
         const { externalLiveBindings, interop } = this.outputOptions;
@@ -15701,16 +14996,16 @@
             let imported;
             let needsLiveBinding = false;
             if (exportName[0] === '*') {
-                const id = exportName.slice(1);
+                const id = exportName.substr(1);
                 if (interop(id) === 'defaultOnly') {
-                    this.inputOptions.onwarn(errorUnexpectedNamespaceReexport(id));
+                    this.inputOptions.onwarn(errUnexpectedNamespaceReexport(id));
                 }
                 needsLiveBinding = externalLiveBindings;
-                dependency = this.externalChunkByModule.get(this.modulesById.get(id));
+                dependency = this.modulesById.get(id);
                 imported = exportName = '*';
             }
             else {
-                const variable = this.exportsByName.get(exportName);
+                const variable = this.exportsByName[exportName];
                 if (variable instanceof SyntheticNamedExportVariable)
                     continue;
                 const module = variable.module;
@@ -15722,17 +15017,17 @@
                     needsLiveBinding = variable.isReassigned;
                 }
                 else {
-                    dependency = this.externalChunkByModule.get(module);
+                    dependency = module;
                     imported = variable.name;
                     if (imported !== 'default' && imported !== '*' && interop(module.id) === 'defaultOnly') {
-                        return error(errorUnexpectedNamedImport(module.id, imported, true));
+                        return error(errUnexpectedNamedImport(module.id, imported, true));
                     }
                     needsLiveBinding =
                         externalLiveBindings &&
-                            (imported !== 'default' || isDefaultAProperty(interop(module.id), true));
+                            (imported !== 'default' || isDefaultAProperty(String(interop(module.id)), true));
                 }
             }
-            getOrCreate(reexportSpecifiers, dependency, getNewArray).push({
+            getOrCreate(reexportSpecifiers, dependency, () => []).push({
                 imported,
                 needsLiveBinding,
                 reexported: exportName
@@ -15741,46 +15036,27 @@
         return reexportSpecifiers;
     }
     getReferencedFiles() {
-        const referencedFiles = new Set();
+        const referencedFiles = [];
         for (const module of this.orderedModules) {
             for (const meta of module.importMetas) {
                 const fileName = meta.getReferencedFileName(this.pluginDriver);
                 if (fileName) {
-                    referencedFiles.add(fileName);
+                    referencedFiles.push(fileName);
                 }
             }
         }
-        return [...referencedFiles];
+        return referencedFiles;
     }
-    getRenderedDependencies() {
-        if (this.renderedDependencies) {
-            return this.renderedDependencies;
+    getRelativePath(targetPath, stripJsExtension) {
+        let relativePath = normalize(relative(dirname(this.id), targetPath));
+        if (stripJsExtension && relativePath.endsWith('.js')) {
+            relativePath = relativePath.slice(0, -3);
         }
-        const importSpecifiers = this.getImportSpecifiers();
-        const reexportSpecifiers = this.getReexportSpecifiers();
-        const renderedDependencies = new Map();
-        const fileName = this.getFileName();
-        for (const dep of this.dependencies) {
-            const imports = importSpecifiers.get(dep) || null;
-            const reexports = reexportSpecifiers.get(dep) || null;
-            const namedExportsMode = dep instanceof ExternalChunk || dep.exportMode !== 'default';
-            const importPath = dep.getImportPath(fileName);
-            renderedDependencies.set(dep, {
-                assertions: dep instanceof ExternalChunk ? dep.getImportAssertions(this.snippets) : null,
-                defaultVariableName: dep.defaultVariableName,
-                globalName: dep instanceof ExternalChunk &&
-                    (this.outputOptions.format === 'umd' || this.outputOptions.format === 'iife') &&
-                    getGlobalName(dep, this.outputOptions.globals, (imports || reexports) !== null, this.inputOptions.onwarn),
-                importPath,
-                imports,
-                isChunk: dep instanceof Chunk,
-                name: dep.variableName,
-                namedExportsMode,
-                namespaceVariableName: dep.namespaceVariableName,
-                reexports
-            });
-        }
-        return (this.renderedDependencies = renderedDependencies);
+        if (relativePath === '..')
+            return '../../' + basename(targetPath);
+        if (relativePath === '')
+            return '../' + basename(targetPath);
+        return relativePath.startsWith('../') ? relativePath : './' + relativePath;
     }
     inlineChunkDependencies(chunk) {
         for (const dep of chunk.dependencies) {
@@ -15792,108 +15068,45 @@
             }
         }
     }
-    // This method changes properties on the AST before rendering and must not be async
-    renderModules(fileName) {
-        const { accessedGlobalsByScope, dependencies, exportNamesByVariable, includedNamespaces, inputOptions: { onwarn }, isEmpty, orderedModules, outputOptions, pluginDriver, renderedModules, snippets } = this;
-        const { compact, dynamicImportFunction, format, freeze, namespaceToStringTag, preserveModules } = outputOptions;
-        const { _, cnst, n } = snippets;
-        this.setDynamicImportResolutions(fileName);
-        this.setImportMetaResolutions(fileName);
-        this.setIdentifierRenderResolutions();
-        const magicString = new Bundle$1({ separator: `${n}${n}` });
-        const indent = getIndentString(orderedModules, outputOptions);
-        const usedModules = [];
-        let hoistedSource = '';
-        const accessedGlobals = new Set();
-        const renderedModuleSources = new Map();
-        const renderOptions = {
-            dynamicImportFunction,
-            exportNamesByVariable,
-            format,
-            freeze,
-            indent,
-            namespaceToStringTag,
-            pluginDriver,
-            snippets
-        };
-        let usesTopLevelAwait = false;
-        for (const module of orderedModules) {
-            let renderedLength = 0;
-            let source;
-            if (module.isIncluded() || includedNamespaces.has(module)) {
-                const rendered = module.render(renderOptions);
-                ({ source } = rendered);
-                usesTopLevelAwait || (usesTopLevelAwait = rendered.usesTopLevelAwait);
-                renderedLength = source.length();
-                if (renderedLength) {
-                    if (compact && source.lastLine().includes('//'))
-                        source.append('\n');
-                    renderedModuleSources.set(module, source);
-                    magicString.addSource(source);
-                    usedModules.push(module);
-                }
-                const namespace = module.namespace;
-                if (includedNamespaces.has(module) && !preserveModules) {
-                    const rendered = namespace.renderBlock(renderOptions);
-                    if (namespace.renderFirst())
-                        hoistedSource += n + rendered;
-                    else
-                        magicString.addSource(new MagicString(rendered));
-                }
-                const accessedGlobalVariables = accessedGlobalsByScope.get(module.scope);
-                if (accessedGlobalVariables) {
-                    for (const name of accessedGlobalVariables) {
-                        accessedGlobals.add(name);
+    prepareModulesForRendering(snippets) {
+        var _a;
+        const accessedGlobalsByScope = this.accessedGlobalsByScope;
+        for (const module of this.orderedModules) {
+            for (const { node, resolution } of module.dynamicImports) {
+                if (node.included) {
+                    if (resolution instanceof Module) {
+                        const chunk = this.chunkByModule.get(resolution);
+                        if (chunk === this) {
+                            node.setInternalResolution(resolution.namespace);
+                        }
+                        else {
+                            node.setExternalResolution(((_a = this.facadeChunkByModule.get(resolution)) === null || _a === void 0 ? void 0 : _a.exportMode) || chunk.exportMode, resolution, this.outputOptions, snippets, this.pluginDriver, accessedGlobalsByScope);
+                        }
+                    }
+                    else {
+                        node.setExternalResolution('external', resolution, this.outputOptions, snippets, this.pluginDriver, accessedGlobalsByScope);
                     }
                 }
             }
-            const { renderedExports, removedExports } = module.getRenderedExports();
-            renderedModules[module.id] = {
-                get code() {
-                    return source?.toString() ?? null;
-                },
-                originalLength: module.originalCode.length,
-                removedExports,
-                renderedExports,
-                renderedLength
-            };
-        }
-        if (hoistedSource)
-            magicString.prepend(hoistedSource + n + n);
-        // eslint-disable-next-line unicorn/consistent-destructuring
-        if (this.needsExportsShim) {
-            magicString.prepend(`${n}${cnst} ${MISSING_EXPORT_SHIM_VARIABLE}${_}=${_}void 0;${n}${n}`);
-        }
-        const renderedSource = compact ? magicString : magicString.trim();
-        if (isEmpty && this.getExportNames().length === 0 && dependencies.size === 0) {
-            onwarn(errorEmptyChunk(this.getChunkName()));
-        }
-        return { accessedGlobals, indent, magicString, renderedSource, usedModules, usesTopLevelAwait };
-    }
-    setDynamicImportResolutions(fileName) {
-        const { accessedGlobalsByScope, outputOptions, pluginDriver, snippets } = this;
-        for (const resolvedDynamicImport of this.getIncludedDynamicImports()) {
-            if (resolvedDynamicImport.chunk) {
-                const { chunk, facadeChunk, node, resolution } = resolvedDynamicImport;
-                if (chunk === this) {
-                    node.setInternalResolution(resolution.namespace);
-                }
-                else {
-                    node.setExternalResolution((facadeChunk || chunk).exportMode, resolution, outputOptions, snippets, pluginDriver, accessedGlobalsByScope, `'${(facadeChunk || chunk).getImportPath(fileName)}'`, !facadeChunk?.strictFacade && chunk.exportNamesByVariable.get(resolution.namespace)[0], null);
-                }
+            for (const importMeta of module.importMetas) {
+                importMeta.addAccessedGlobals(this.outputOptions.format, accessedGlobalsByScope);
             }
-            else {
-                const { node, resolution } = resolvedDynamicImport;
-                const [resolutionString, assertions] = this.getDynamicImportStringAndAssertions(resolution, fileName);
-                node.setExternalResolution('external', resolution, outputOptions, snippets, pluginDriver, accessedGlobalsByScope, resolutionString, false, assertions);
+            if (this.includedNamespaces.has(module) && !this.outputOptions.preserveModules) {
+                module.namespace.prepare(accessedGlobalsByScope);
+            }
+        }
+    }
+    setExternalRenderPaths(options, inputBase) {
+        for (const dependency of [...this.dependencies, ...this.dynamicDependencies]) {
+            if (dependency instanceof ExternalModule) {
+                dependency.setRenderPath(options, inputBase);
             }
         }
     }
-    setIdentifierRenderResolutions() {
-        const { format, interop, namespaceToStringTag, preserveModules, externalLiveBindings } = this.outputOptions;
+    setIdentifierRenderResolutions({ format, interop, namespaceToStringTag }) {
         const syntheticExports = new Set();
         for (const exportName of this.getExportNames()) {
-            const exportVariable = this.exportsByName.get(exportName);
+            const exportVariable = this.exportsByName[exportName];
             if (format !== 'es' &&
                 format !== 'system' &&
                 exportVariable.isReassigned &&
@@ -15921,45 +15134,32 @@
             usedNames.add('Symbol');
         }
         switch (format) {
-            case 'system': {
+            case 'system':
                 usedNames.add('module').add('exports');
                 break;
-            }
-            case 'es': {
+            case 'es':
                 break;
-            }
-            case 'cjs': {
+            case 'cjs':
                 usedNames.add('module').add('require').add('__filename').add('__dirname');
-            }
             // fallthrough
-            default: {
+            default:
                 usedNames.add('exports');
                 for (const helper of HELPER_NAMES) {
                     usedNames.add(helper);
                 }
-            }
-        }
-        deconflictChunk(this.orderedModules, this.getDependenciesToBeDeconflicted(format !== 'es' && format !== 'system', format === 'amd' || format === 'umd' || format === 'iife', interop), this.imports, usedNames, format, interop, preserveModules, externalLiveBindings, this.chunkByModule, this.externalChunkByModule, syntheticExports, this.exportNamesByVariable, this.accessedGlobalsByScope, this.includedNamespaces);
-    }
-    setImportMetaResolutions(fileName) {
-        const { accessedGlobalsByScope, includedNamespaces, orderedModules, outputOptions: { format, preserveModules } } = this;
-        for (const module of orderedModules) {
-            for (const importMeta of module.importMetas) {
-                importMeta.setResolution(format, accessedGlobalsByScope, fileName);
-            }
-            if (includedNamespaces.has(module) && !preserveModules) {
-                module.namespace.prepare(accessedGlobalsByScope);
-            }
         }
+        deconflictChunk(this.orderedModules, this.getDependenciesToBeDeconflicted(format !== 'es' && format !== 'system', format === 'amd' || format === 'umd' || format === 'iife', interop), this.imports, usedNames, format, interop, this.outputOptions.preserveModules, this.outputOptions.externalLiveBindings, this.chunkByModule, syntheticExports, this.exportNamesByVariable, this.accessedGlobalsByScope, this.includedNamespaces);
     }
     setUpChunkImportsAndExportsForModule(module) {
-        const moduleImports = new Set(module.includedImports);
+        const moduleImports = new Set(module.imports);
         // when we are not preserving modules, we need to make all namespace variables available for
         // rendering the namespace object
-        if (!this.outputOptions.preserveModules && this.includedNamespaces.has(module)) {
-            const memberVariables = module.namespace.getMemberVariables();
-            for (const variable of Object.values(memberVariables)) {
-                moduleImports.add(variable);
+        if (!this.outputOptions.preserveModules) {
+            if (this.includedNamespaces.has(module)) {
+                const memberVariables = module.namespace.getMemberVariables();
+                for (const variable of Object.values(memberVariables)) {
+                    moduleImports.add(variable);
+                }
             }
         }
         for (let variable of moduleImports) {
@@ -15996,62 +15196,340 @@
     }
 }
 function getChunkNameFromModule(module) {
-    return getPredefinedChunkNameFromModule(module) ?? getAliasName(module.id);
+    return module.chunkName || getAliasName(module.id);
+}
+
+var BuildPhase;
+(function (BuildPhase) {
+    BuildPhase[BuildPhase["LOAD_AND_PARSE"] = 0] = "LOAD_AND_PARSE";
+    BuildPhase[BuildPhase["ANALYSE"] = 1] = "ANALYSE";
+    BuildPhase[BuildPhase["GENERATE"] = 2] = "GENERATE";
+})(BuildPhase || (BuildPhase = {}));
+
+function generateAssetFileName(name, source, outputOptions, bundle) {
+    const emittedName = outputOptions.sanitizeFileName(name || 'asset');
+    return makeUnique(renderNamePattern(typeof outputOptions.assetFileNames === 'function'
+        ? outputOptions.assetFileNames({ name, source, type: 'asset' })
+        : outputOptions.assetFileNames, 'output.assetFileNames', {
+        ext: () => extname(emittedName).substr(1),
+        extname: () => extname(emittedName),
+        hash() {
+            const hash = createHash();
+            hash.update(emittedName);
+            hash.update(':');
+            hash.update(source);
+            return hash.digest('hex').substr(0, 8);
+        },
+        name: () => emittedName.substr(0, emittedName.length - extname(emittedName).length)
+    }), bundle);
+}
+function reserveFileNameInBundle(fileName, bundle, warn) {
+    if (fileName in bundle) {
+        warn(errFileNameConflict(fileName));
+    }
+    bundle[fileName] = FILE_PLACEHOLDER;
+}
+const FILE_PLACEHOLDER = {
+    type: 'placeholder'
+};
+function hasValidType(emittedFile) {
+    return Boolean(emittedFile &&
+        (emittedFile.type === 'asset' ||
+            emittedFile.type === 'chunk'));
+}
+function hasValidName(emittedFile) {
+    const validatedName = emittedFile.fileName || emittedFile.name;
+    return !validatedName || (typeof validatedName === 'string' && !isPathFragment(validatedName));
 }
-function getPredefinedChunkNameFromModule(module) {
-    return (module.chunkNames.find(({ isUserDefined }) => isUserDefined)?.name ?? module.chunkNames[0]?.name);
+function getValidSource(source, emittedFile, fileReferenceId) {
+    if (!(typeof source === 'string' || source instanceof Uint8Array)) {
+        const assetName = emittedFile.fileName || emittedFile.name || fileReferenceId;
+        return error(errFailedValidation(`Could not set source for ${typeof assetName === 'string' ? `asset "${assetName}"` : 'unnamed asset'}, asset source needs to be a string, Uint8Array or Buffer.`));
+    }
+    return source;
+}
+function getAssetFileName(file, referenceId) {
+    if (typeof file.fileName !== 'string') {
+        return error(errAssetNotFinalisedForFileName(file.name || referenceId));
+    }
+    return file.fileName;
 }
-function getImportedBindingsPerDependency(renderedDependencies, resolveFileName) {
-    const importedBindingsPerDependency = {};
-    for (const [dependency, declaration] of renderedDependencies) {
-        const specifiers = new Set();
-        if (declaration.imports) {
-            for (const { imported } of declaration.imports) {
-                specifiers.add(imported);
+function getChunkFileName(file, facadeChunkByModule) {
+    var _a;
+    const fileName = file.fileName || (file.module && ((_a = facadeChunkByModule === null || facadeChunkByModule === void 0 ? void 0 : facadeChunkByModule.get(file.module)) === null || _a === void 0 ? void 0 : _a.id));
+    if (!fileName)
+        return error(errChunkNotGeneratedForFileName(file.fileName || file.name));
+    return fileName;
+}
+class FileEmitter {
+    constructor(graph, options, baseFileEmitter) {
+        this.graph = graph;
+        this.options = options;
+        this.bundle = null;
+        this.facadeChunkByModule = null;
+        this.outputOptions = null;
+        this.assertAssetsFinalized = () => {
+            for (const [referenceId, emittedFile] of this.filesByReferenceId.entries()) {
+                if (emittedFile.type === 'asset' && typeof emittedFile.fileName !== 'string')
+                    return error(errNoAssetSourceSet(emittedFile.name || referenceId));
             }
-        }
-        if (declaration.reexports) {
-            for (const { imported } of declaration.reexports) {
-                specifiers.add(imported);
+        };
+        this.emitFile = (emittedFile) => {
+            if (!hasValidType(emittedFile)) {
+                return error(errFailedValidation(`Emitted files must be of type "asset" or "chunk", received "${emittedFile && emittedFile.type}".`));
+            }
+            if (!hasValidName(emittedFile)) {
+                return error(errFailedValidation(`The "fileName" or "name" properties of emitted files must be strings that are neither absolute nor relative paths, received "${emittedFile.fileName || emittedFile.name}".`));
+            }
+            if (emittedFile.type === 'chunk') {
+                return this.emitChunk(emittedFile);
             }
+            else {
+                return this.emitAsset(emittedFile);
+            }
+        };
+        this.getFileName = (fileReferenceId) => {
+            const emittedFile = this.filesByReferenceId.get(fileReferenceId);
+            if (!emittedFile)
+                return error(errFileReferenceIdNotFoundForFilename(fileReferenceId));
+            if (emittedFile.type === 'chunk') {
+                return getChunkFileName(emittedFile, this.facadeChunkByModule);
+            }
+            else {
+                return getAssetFileName(emittedFile, fileReferenceId);
+            }
+        };
+        this.setAssetSource = (referenceId, requestedSource) => {
+            const consumedFile = this.filesByReferenceId.get(referenceId);
+            if (!consumedFile)
+                return error(errAssetReferenceIdNotFoundForSetSource(referenceId));
+            if (consumedFile.type !== 'asset') {
+                return error(errFailedValidation(`Asset sources can only be set for emitted assets but "${referenceId}" is an emitted chunk.`));
+            }
+            if (consumedFile.source !== undefined) {
+                return error(errAssetSourceAlreadySet(consumedFile.name || referenceId));
+            }
+            const source = getValidSource(requestedSource, consumedFile, referenceId);
+            if (this.bundle) {
+                this.finalizeAsset(consumedFile, source, referenceId, this.bundle);
+            }
+            else {
+                consumedFile.source = source;
+            }
+        };
+        this.setOutputBundle = (outputBundle, outputOptions, facadeChunkByModule) => {
+            this.outputOptions = outputOptions;
+            this.bundle = outputBundle;
+            this.facadeChunkByModule = facadeChunkByModule;
+            for (const emittedFile of this.filesByReferenceId.values()) {
+                if (emittedFile.fileName) {
+                    reserveFileNameInBundle(emittedFile.fileName, this.bundle, this.options.onwarn);
+                }
+            }
+            for (const [referenceId, consumedFile] of this.filesByReferenceId.entries()) {
+                if (consumedFile.type === 'asset' && consumedFile.source !== undefined) {
+                    this.finalizeAsset(consumedFile, consumedFile.source, referenceId, this.bundle);
+                }
+            }
+        };
+        this.filesByReferenceId = baseFileEmitter
+            ? new Map(baseFileEmitter.filesByReferenceId)
+            : new Map();
+    }
+    assignReferenceId(file, idBase) {
+        let referenceId;
+        do {
+            const hash = createHash();
+            if (referenceId) {
+                hash.update(referenceId);
+            }
+            else {
+                hash.update(idBase);
+            }
+            referenceId = hash.digest('hex').substr(0, 8);
+        } while (this.filesByReferenceId.has(referenceId));
+        this.filesByReferenceId.set(referenceId, file);
+        return referenceId;
+    }
+    emitAsset(emittedAsset) {
+        const source = typeof emittedAsset.source !== 'undefined'
+            ? getValidSource(emittedAsset.source, emittedAsset, null)
+            : undefined;
+        const consumedAsset = {
+            fileName: emittedAsset.fileName,
+            name: emittedAsset.name,
+            source,
+            type: 'asset'
+        };
+        const referenceId = this.assignReferenceId(consumedAsset, emittedAsset.fileName || emittedAsset.name || emittedAsset.type);
+        if (this.bundle) {
+            if (emittedAsset.fileName) {
+                reserveFileNameInBundle(emittedAsset.fileName, this.bundle, this.options.onwarn);
+            }
+            if (source !== undefined) {
+                this.finalizeAsset(consumedAsset, source, referenceId, this.bundle);
+            }
+        }
+        return referenceId;
+    }
+    emitChunk(emittedChunk) {
+        if (this.graph.phase > BuildPhase.LOAD_AND_PARSE) {
+            return error(errInvalidRollupPhaseForChunkEmission());
+        }
+        if (typeof emittedChunk.id !== 'string') {
+            return error(errFailedValidation(`Emitted chunks need to have a valid string id, received "${emittedChunk.id}"`));
+        }
+        const consumedChunk = {
+            fileName: emittedChunk.fileName,
+            module: null,
+            name: emittedChunk.name || emittedChunk.id,
+            type: 'chunk'
+        };
+        this.graph.moduleLoader
+            .emitChunk(emittedChunk)
+            .then(module => (consumedChunk.module = module))
+            .catch(() => {
+            // Avoid unhandled Promise rejection as the error will be thrown later
+            // once module loading has finished
+        });
+        return this.assignReferenceId(consumedChunk, emittedChunk.id);
+    }
+    finalizeAsset(consumedFile, source, referenceId, bundle) {
+        const fileName = consumedFile.fileName ||
+            findExistingAssetFileNameWithSource(bundle, source) ||
+            generateAssetFileName(consumedFile.name, source, this.outputOptions, bundle);
+        // We must not modify the original assets to avoid interaction between outputs
+        const assetWithFileName = { ...consumedFile, fileName, source };
+        this.filesByReferenceId.set(referenceId, assetWithFileName);
+        const { options } = this;
+        bundle[fileName] = {
+            fileName,
+            get isAsset() {
+                warnDeprecation('Accessing "isAsset" on files in the bundle is deprecated, please use "type === \'asset\'" instead', true, options);
+                return true;
+            },
+            name: consumedFile.name,
+            source,
+            type: 'asset'
+        };
+    }
+}
+function findExistingAssetFileNameWithSource(bundle, source) {
+    for (const [fileName, outputFile] of Object.entries(bundle)) {
+        if (outputFile.type === 'asset' && areSourcesEqual(source, outputFile.source))
+            return fileName;
+    }
+    return null;
+}
+function areSourcesEqual(sourceA, sourceB) {
+    if (typeof sourceA === 'string') {
+        return sourceA === sourceB;
+    }
+    if (typeof sourceB === 'string') {
+        return false;
+    }
+    if ('equals' in sourceA) {
+        return sourceA.equals(sourceB);
+    }
+    if (sourceA.length !== sourceB.length) {
+        return false;
+    }
+    for (let index = 0; index < sourceA.length; index++) {
+        if (sourceA[index] !== sourceB[index]) {
+            return false;
         }
-        importedBindingsPerDependency[resolveFileName(dependency)] = [...specifiers];
     }
-    return importedBindingsPerDependency;
+    return true;
 }
-const QUERY_HASH_REGEX = /[#?]/;
-const resolveFileName = (dependency) => dependency.getFileName();
 
-/**
- * Concatenate a number of iterables to a new iterable without fully evaluating
- * their iterators. Useful when e.g. working with large sets or lists and when
- * there is a chance that the iterators will not be fully exhausted.
- */
-function* concatLazy(...iterables) {
-    for (const iterable of iterables) {
-        yield* iterable;
+const concatSep = (out, next) => (next ? `${out}\n${next}` : out);
+const concatDblSep = (out, next) => (next ? `${out}\n\n${next}` : out);
+async function createAddons(options, outputPluginDriver) {
+    try {
+        let [banner, footer, intro, outro] = await Promise.all([
+            outputPluginDriver.hookReduceValue('banner', options.banner(), [], concatSep),
+            outputPluginDriver.hookReduceValue('footer', options.footer(), [], concatSep),
+            outputPluginDriver.hookReduceValue('intro', options.intro(), [], concatDblSep),
+            outputPluginDriver.hookReduceValue('outro', options.outro(), [], concatDblSep)
+        ]);
+        if (intro)
+            intro += '\n\n';
+        if (outro)
+            outro = `\n\n${outro}`;
+        if (banner.length)
+            banner += '\n';
+        if (footer.length)
+            footer = '\n' + footer;
+        return { banner, footer, intro, outro };
+    }
+    catch (err) {
+        return error({
+            code: 'ADDON_ERROR',
+            message: `Could not retrieve ${err.hook}. Check configuration of plugin ${err.plugin}.
+\tError Message: ${err.message}`
+        });
     }
 }
 
-function getChunkAssignments(entries, manualChunkAliasByEntry, minChunkSize) {
+function getChunkAssignments(entryModules, manualChunkAliasByEntry) {
     const chunkDefinitions = [];
     const modulesInManualChunks = new Set(manualChunkAliasByEntry.keys());
     const manualChunkModulesByAlias = Object.create(null);
     for (const [entry, alias] of manualChunkAliasByEntry) {
-        addStaticDependenciesToManualChunk(entry, (manualChunkModulesByAlias[alias] || (manualChunkModulesByAlias[alias] = [])), modulesInManualChunks);
+        const chunkModules = (manualChunkModulesByAlias[alias] =
+            manualChunkModulesByAlias[alias] || []);
+        addStaticDependenciesToManualChunk(entry, chunkModules, modulesInManualChunks);
     }
     for (const [alias, modules] of Object.entries(manualChunkModulesByAlias)) {
         chunkDefinitions.push({ alias, modules });
     }
-    const { allEntries, dependentEntriesByModule, dynamicallyDependentEntriesByDynamicEntry } = analyzeModuleGraph(entries);
-    const staticEntries = new Set(entries);
-    const assignedEntriesByModule = new Map();
-    for (const entry of allEntries) {
+    const assignedEntryPointsByModule = new Map();
+    const { dependentEntryPointsByModule, dynamicEntryModules } = analyzeModuleGraph(entryModules);
+    const dynamicallyDependentEntryPointsByDynamicEntry = getDynamicDependentEntryPoints(dependentEntryPointsByModule, dynamicEntryModules);
+    const staticEntries = new Set(entryModules);
+    function assignEntryToStaticDependencies(entry, dynamicDependentEntryPoints) {
+        const modulesToHandle = new Set([entry]);
+        for (const module of modulesToHandle) {
+            const assignedEntryPoints = getOrCreate(assignedEntryPointsByModule, module, () => new Set());
+            if (dynamicDependentEntryPoints &&
+                areEntryPointsContainedOrDynamicallyDependent(dynamicDependentEntryPoints, dependentEntryPointsByModule.get(module))) {
+                continue;
+            }
+            else {
+                assignedEntryPoints.add(entry);
+            }
+            for (const dependency of module.getDependenciesToBeIncluded()) {
+                if (!(dependency instanceof ExternalModule || modulesInManualChunks.has(dependency))) {
+                    modulesToHandle.add(dependency);
+                }
+            }
+        }
+    }
+    function areEntryPointsContainedOrDynamicallyDependent(entryPoints, containedIn) {
+        const entriesToCheck = new Set(entryPoints);
+        for (const entry of entriesToCheck) {
+            if (!containedIn.has(entry)) {
+                if (staticEntries.has(entry))
+                    return false;
+                const dynamicallyDependentEntryPoints = dynamicallyDependentEntryPointsByDynamicEntry.get(entry);
+                for (const dependentEntry of dynamicallyDependentEntryPoints) {
+                    entriesToCheck.add(dependentEntry);
+                }
+            }
+        }
+        return true;
+    }
+    for (const entry of entryModules) {
         if (!modulesInManualChunks.has(entry)) {
-            assignEntryToStaticDependencies(entry, dependentEntriesByModule, assignedEntriesByModule, modulesInManualChunks, staticEntries, dynamicallyDependentEntriesByDynamicEntry);
+            assignEntryToStaticDependencies(entry, null);
         }
     }
-    chunkDefinitions.push(...createChunks(allEntries, assignedEntriesByModule, minChunkSize));
+    for (const entry of dynamicEntryModules) {
+        if (!modulesInManualChunks.has(entry)) {
+            assignEntryToStaticDependencies(entry, dynamicallyDependentEntryPointsByDynamicEntry.get(entry));
+        }
+    }
+    chunkDefinitions.push(...createChunks([...entryModules, ...dynamicEntryModules], assignedEntryPointsByModule));
     return chunkDefinitions;
 }
 function addStaticDependenciesToManualChunk(entry, manualChunkModules, modulesInManualChunks) {
@@ -16066,155 +15544,54 @@
         }
     }
 }
-function analyzeModuleGraph(entries) {
-    const dynamicEntries = new Set();
-    const dependentEntriesByModule = new Map();
-    const allEntries = new Set(entries);
-    for (const currentEntry of allEntries) {
+function analyzeModuleGraph(entryModules) {
+    const dynamicEntryModules = new Set();
+    const dependentEntryPointsByModule = new Map();
+    const entriesToHandle = new Set(entryModules);
+    for (const currentEntry of entriesToHandle) {
         const modulesToHandle = new Set([currentEntry]);
         for (const module of modulesToHandle) {
-            getOrCreate(dependentEntriesByModule, module, getNewSet).add(currentEntry);
+            getOrCreate(dependentEntryPointsByModule, module, () => new Set()).add(currentEntry);
             for (const dependency of module.getDependenciesToBeIncluded()) {
                 if (!(dependency instanceof ExternalModule)) {
                     modulesToHandle.add(dependency);
                 }
             }
             for (const { resolution } of module.dynamicImports) {
-                if (resolution instanceof Module &&
-                    resolution.includedDynamicImporters.length > 0 &&
-                    !allEntries.has(resolution)) {
-                    dynamicEntries.add(resolution);
-                    allEntries.add(resolution);
+                if (resolution instanceof Module && resolution.includedDynamicImporters.length > 0) {
+                    dynamicEntryModules.add(resolution);
+                    entriesToHandle.add(resolution);
                 }
             }
             for (const dependency of module.implicitlyLoadedBefore) {
-                if (!allEntries.has(dependency)) {
-                    dynamicEntries.add(dependency);
-                    allEntries.add(dependency);
-                }
+                dynamicEntryModules.add(dependency);
+                entriesToHandle.add(dependency);
             }
         }
     }
-    return {
-        allEntries,
-        dependentEntriesByModule,
-        dynamicallyDependentEntriesByDynamicEntry: getDynamicallyDependentEntriesByDynamicEntry(dependentEntriesByModule, dynamicEntries)
-    };
+    return { dependentEntryPointsByModule, dynamicEntryModules };
 }
-function getDynamicallyDependentEntriesByDynamicEntry(dependentEntriesByModule, dynamicEntries) {
-    const dynamicallyDependentEntriesByDynamicEntry = new Map();
-    for (const dynamicEntry of dynamicEntries) {
-        const dynamicallyDependentEntries = getOrCreate(dynamicallyDependentEntriesByDynamicEntry, dynamicEntry, getNewSet);
+function getDynamicDependentEntryPoints(dependentEntryPointsByModule, dynamicEntryModules) {
+    const dynamicallyDependentEntryPointsByDynamicEntry = new Map();
+    for (const dynamicEntry of dynamicEntryModules) {
+        const dynamicDependentEntryPoints = getOrCreate(dynamicallyDependentEntryPointsByDynamicEntry, dynamicEntry, () => new Set());
         for (const importer of [
             ...dynamicEntry.includedDynamicImporters,
             ...dynamicEntry.implicitlyLoadedAfter
         ]) {
-            for (const entry of dependentEntriesByModule.get(importer)) {
-                dynamicallyDependentEntries.add(entry);
+            for (const entryPoint of dependentEntryPointsByModule.get(importer)) {
+                dynamicDependentEntryPoints.add(entryPoint);
             }
         }
     }
-    return dynamicallyDependentEntriesByDynamicEntry;
+    return dynamicallyDependentEntryPointsByDynamicEntry;
 }
-function assignEntryToStaticDependencies(entry, dependentEntriesByModule, assignedEntriesByModule, modulesInManualChunks, staticEntries, dynamicallyDependentEntriesByDynamicEntry) {
-    const dynamicallyDependentEntries = dynamicallyDependentEntriesByDynamicEntry.get(entry);
-    const modulesToHandle = new Set([entry]);
-    for (const module of modulesToHandle) {
-        const assignedEntries = getOrCreate(assignedEntriesByModule, module, getNewSet);
-        if (dynamicallyDependentEntries &&
-            isModuleAlreadyLoaded(dynamicallyDependentEntries, dependentEntriesByModule.get(module), staticEntries, dynamicallyDependentEntriesByDynamicEntry)) {
-            continue;
-        }
-        else {
-            assignedEntries.add(entry);
-        }
-        for (const dependency of module.getDependenciesToBeIncluded()) {
-            if (!(dependency instanceof ExternalModule || modulesInManualChunks.has(dependency))) {
-                modulesToHandle.add(dependency);
-            }
-        }
-    }
-}
-const MAX_ENTRIES_TO_CHECK_FOR_SHARED_DEPENDENCIES = 3;
-// An approach to further speed this up might be
-// - first, create chunks without looking for modules already in memory
-// - all modules that are in the same chunk after this will behave the same
-//   -> Do not iterate by module but by equivalence group and merge chunks
-function isModuleAlreadyLoaded(dynamicallyDependentEntries, containedIn, staticEntries, dynamicallyDependentEntriesByDynamicEntry) {
-    if (dynamicallyDependentEntries.size > MAX_ENTRIES_TO_CHECK_FOR_SHARED_DEPENDENCIES) {
-        return false;
-    }
-    const entriesToCheck = new Set(dynamicallyDependentEntries);
-    for (const entry of entriesToCheck) {
-        if (!containedIn.has(entry)) {
-            if (staticEntries.has(entry)) {
-                return false;
-            }
-            const dynamicallyDependentEntries = dynamicallyDependentEntriesByDynamicEntry.get(entry);
-            if (dynamicallyDependentEntries.size > MAX_ENTRIES_TO_CHECK_FOR_SHARED_DEPENDENCIES) {
-                return false;
-            }
-            for (const dependentEntry of dynamicallyDependentEntries) {
-                entriesToCheck.add(dependentEntry);
-            }
-        }
-    }
-    return true;
-}
-function createChunks(allEntries, assignedEntriesByModule, minChunkSize) {
-    const chunkModulesBySignature = getChunkModulesBySignature(assignedEntriesByModule, allEntries);
-    return minChunkSize === 0
-        ? Object.values(chunkModulesBySignature).map(modules => ({
-            alias: null,
-            modules
-        }))
-        : getOptimizedChunks(chunkModulesBySignature, minChunkSize);
-}
-function getOptimizedChunks(chunkModulesBySignature, minChunkSize) {
-    timeStart('optimize chunks', 3);
-    const { chunksToBeMerged, unmergeableChunks } = getMergeableChunks(chunkModulesBySignature, minChunkSize);
-    for (const sourceChunk of chunksToBeMerged) {
-        chunksToBeMerged.delete(sourceChunk);
-        let closestChunk = null;
-        let closestChunkDistance = Infinity;
-        const { signature, size, modules } = sourceChunk;
-        for (const targetChunk of concatLazy(chunksToBeMerged, unmergeableChunks)) {
-            const distance = getSignatureDistance(signature, targetChunk.signature, !chunksToBeMerged.has(targetChunk));
-            if (distance === 1) {
-                closestChunk = targetChunk;
-                break;
-            }
-            else if (distance < closestChunkDistance) {
-                closestChunk = targetChunk;
-                closestChunkDistance = distance;
-            }
-        }
-        if (closestChunk) {
-            closestChunk.modules.push(...modules);
-            if (chunksToBeMerged.has(closestChunk)) {
-                closestChunk.signature = mergeSignatures(signature, closestChunk.signature);
-                if ((closestChunk.size += size) > minChunkSize) {
-                    chunksToBeMerged.delete(closestChunk);
-                    unmergeableChunks.push(closestChunk);
-                }
-            }
-        }
-        else {
-            unmergeableChunks.push(sourceChunk);
-        }
-    }
-    timeEnd('optimize chunks', 3);
-    return unmergeableChunks;
-}
-const CHAR_DEPENDENT = 'X';
-const CHAR_INDEPENDENT = '_';
-const CHAR_CODE_DEPENDENT = CHAR_DEPENDENT.charCodeAt(0);
-function getChunkModulesBySignature(assignedEntriesByModule, allEntries) {
+function createChunks(allEntryPoints, assignedEntryPointsByModule) {
     const chunkModules = Object.create(null);
-    for (const [module, assignedEntries] of assignedEntriesByModule) {
+    for (const [module, assignedEntryPoints] of assignedEntryPointsByModule) {
         let chunkSignature = '';
-        for (const entry of allEntries) {
-            chunkSignature += assignedEntries.has(entry) ? CHAR_DEPENDENT : CHAR_INDEPENDENT;
+        for (const entry of allEntryPoints) {
+            chunkSignature += assignedEntryPoints.has(entry) ? 'X' : '_';
         }
         const chunk = chunkModules[chunkSignature];
         if (chunk) {
@@ -16224,56 +15601,10 @@
             chunkModules[chunkSignature] = [module];
         }
     }
-    return chunkModules;
-}
-function getMergeableChunks(chunkModulesBySignature, minChunkSize) {
-    const chunksToBeMerged = new Set();
-    const unmergeableChunks = [];
-    const alias = null;
-    for (const [signature, modules] of Object.entries(chunkModulesBySignature)) {
-        let size = 0;
-        checkModules: {
-            for (const module of modules) {
-                if (module.hasEffects()) {
-                    break checkModules;
-                }
-                size += module.magicString.toString().length;
-                if (size > minChunkSize) {
-                    break checkModules;
-                }
-            }
-            chunksToBeMerged.add({ alias, modules, signature, size });
-            continue;
-        }
-        unmergeableChunks.push({ alias, modules, signature, size: null });
-    }
-    return { chunksToBeMerged, unmergeableChunks };
-}
-function getSignatureDistance(sourceSignature, targetSignature, enforceSubset) {
-    let distance = 0;
-    const { length } = sourceSignature;
-    for (let index = 0; index < length; index++) {
-        const sourceValue = sourceSignature.charCodeAt(index);
-        if (sourceValue !== targetSignature.charCodeAt(index)) {
-            if (enforceSubset && sourceValue === CHAR_CODE_DEPENDENT) {
-                return Infinity;
-            }
-            distance++;
-        }
-    }
-    return distance;
-}
-function mergeSignatures(sourceSignature, targetSignature) {
-    let signature = '';
-    const { length } = sourceSignature;
-    for (let index = 0; index < length; index++) {
-        signature +=
-            sourceSignature.charCodeAt(index) === CHAR_CODE_DEPENDENT ||
-                targetSignature.charCodeAt(index) === CHAR_CODE_DEPENDENT
-                ? CHAR_DEPENDENT
-                : CHAR_INDEPENDENT;
-    }
-    return signature;
+    return Object.values(chunkModules).map(modules => ({
+        alias: null,
+        modules
+    }));
 }
 
 // ported from https://github.com/substack/node-commondir
@@ -16284,11 +15615,11 @@
         return dirname(files[0]);
     const commonSegments = files.slice(1).reduce((commonSegments, file) => {
         const pathSegements = file.split(/\/+|\\+/);
-        let index;
-        for (index = 0; commonSegments[index] === pathSegements[index] &&
-            index < Math.min(commonSegments.length, pathSegements.length); index++)
+        let i;
+        for (i = 0; commonSegments[i] === pathSegements[i] &&
+            i < Math.min(commonSegments.length, pathSegements.length); i++)
             ;
-        return commonSegments.slice(0, index);
+        return commonSegments.slice(0, i);
     }, files[0].split(/\/+|\\+/));
     // Windows correctly handles paths with forward-slashes
     return commonSegments.length > 1 ? commonSegments.join('/') : '/';
@@ -16330,28 +15661,28 @@
         module.execIndex = nextExecIndex++;
         analysedModules.add(module);
     };
-    for (const currentEntry of entryModules) {
-        if (!parents.has(currentEntry)) {
-            parents.set(currentEntry, null);
-            analyseModule(currentEntry);
+    for (const curEntry of entryModules) {
+        if (!parents.has(curEntry)) {
+            parents.set(curEntry, null);
+            analyseModule(curEntry);
         }
     }
-    for (const currentEntry of dynamicImports) {
-        if (!parents.has(currentEntry)) {
-            parents.set(currentEntry, null);
-            analyseModule(currentEntry);
+    for (const curEntry of dynamicImports) {
+        if (!parents.has(curEntry)) {
+            parents.set(curEntry, null);
+            analyseModule(curEntry);
         }
     }
     return { cyclePaths, orderedModules };
 }
 function getCyclePath(module, parent, parents) {
     const cycleSymbol = Symbol(module.id);
-    const path = [module.id];
+    const path = [relativeId(module.id)];
     let nextModule = parent;
     module.cycles.add(cycleSymbol);
     while (nextModule !== module) {
         nextModule.cycles.add(cycleSymbol);
-        path.push(nextModule.id);
+        path.push(relativeId(nextModule.id));
         nextModule = parents.get(nextModule);
     }
     path.push(path[0]);
@@ -16362,16 +15693,16 @@
 function getGenerateCodeSnippets({ compact, generatedCode: { arrowFunctions, constBindings, objectShorthand, reservedNamesAsProps } }) {
     const { _, n, s } = compact ? { _: '', n: '', s: '' } : { _: ' ', n: '\n', s: ';' };
     const cnst = constBindings ? 'const' : 'var';
-    const getNonArrowFunctionIntro = (parameters, { isAsync, name }) => `${isAsync ? `async ` : ''}function${name ? ` ${name}` : ''}${_}(${parameters.join(`,${_}`)})${_}`;
+    const getNonArrowFunctionIntro = (params, { isAsync, name }) => `${isAsync ? `async ` : ''}function${name ? ` ${name}` : ''}${_}(${params.join(`,${_}`)})${_}`;
     const getFunctionIntro = arrowFunctions
-        ? (parameters, { isAsync, name }) => {
-            const singleParameter = parameters.length === 1;
-            const asyncString = isAsync ? `async${singleParameter ? ' ' : _}` : '';
-            return `${name ? `${cnst} ${name}${_}=${_}` : ''}${asyncString}${singleParameter ? parameters[0] : `(${parameters.join(`,${_}`)})`}${_}=>${_}`;
+        ? (params, { isAsync, name }) => {
+            const singleParam = params.length === 1;
+            const asyncString = isAsync ? `async${singleParam ? ' ' : _}` : '';
+            return `${name ? `${cnst} ${name}${_}=${_}` : ''}${asyncString}${singleParam ? params[0] : `(${params.join(`,${_}`)})`}${_}=>${_}`;
         }
         : getNonArrowFunctionIntro;
-    const getDirectReturnFunction = (parameters, { functionReturn, lineBreakIndent, name }) => [
-        `${getFunctionIntro(parameters, {
+    const getDirectReturnFunction = (params, { functionReturn, lineBreakIndent, name }) => [
+        `${getFunctionIntro(params, {
             isAsync: false,
             name
         })}${arrowFunctions
@@ -16383,15 +15714,15 @@
             ? `${name ? ';' : ''}${lineBreakIndent ? `${n}${lineBreakIndent.base}` : ''}`
             : `${s}${lineBreakIndent ? `${n}${lineBreakIndent.base}` : _}}`
     ];
-    const isValidPropertyName = reservedNamesAsProps
-        ? (name) => validPropertyName.test(name)
-        : (name) => !RESERVED_NAMES$1.has(name) && validPropertyName.test(name);
+    const isValidPropName = reservedNamesAsProps
+        ? (name) => validPropName.test(name)
+        : (name) => !RESERVED_NAMES[name] && validPropName.test(name);
     return {
         _,
         cnst,
         getDirectReturnFunction,
-        getDirectReturnIifeLeft: (parameters, returned, { needsArrowReturnParens, needsWrappedFunction }) => {
-            const [left, right] = getDirectReturnFunction(parameters, {
+        getDirectReturnIifeLeft: (params, returned, { needsArrowReturnParens, needsWrappedFunction }) => {
+            const [left, right] = getDirectReturnFunction(params, {
                 functionReturn: true,
                 lineBreakIndent: null,
                 name: null
@@ -16406,373 +15737,20 @@
                 .map(([key, value]) => {
                 if (key === null)
                     return `${prefix}${value}`;
-                const needsQuotes = !isValidPropertyName(key);
+                const needsQuotes = !isValidPropName(key);
                 return key === value && objectShorthand && !needsQuotes
                     ? prefix + key
                     : `${prefix}${needsQuotes ? `'${key}'` : key}:${_}${value}`;
             })
                 .join(`,`)}${fields.length === 0 ? '' : lineBreakIndent ? `${n}${lineBreakIndent.base}` : _}}`;
         },
-        getPropertyAccess: (name) => isValidPropertyName(name) ? `.${name}` : `[${JSON.stringify(name)}]`,
+        getPropertyAccess: (name) => isValidPropName(name) ? `.${name}` : `[${JSON.stringify(name)}]`,
         n,
         s
     };
 }
 const wrapIfNeeded = (code, needsParens) => needsParens ? `(${code})` : code;
-const validPropertyName = /^(?!\d)[\w$]+$/;
-
-class Source {
-    constructor(filename, content) {
-        this.isOriginal = true;
-        this.filename = filename;
-        this.content = content;
-    }
-    traceSegment(line, column, name) {
-        return { column, line, name, source: this };
-    }
-}
-class Link {
-    constructor(map, sources) {
-        this.sources = sources;
-        this.names = map.names;
-        this.mappings = map.mappings;
-    }
-    traceMappings() {
-        const sources = [];
-        const sourceIndexMap = new Map();
-        const sourcesContent = [];
-        const names = [];
-        const nameIndexMap = new Map();
-        const mappings = [];
-        for (const line of this.mappings) {
-            const tracedLine = [];
-            for (const segment of line) {
-                if (segment.length === 1)
-                    continue;
-                const source = this.sources[segment[1]];
-                if (!source)
-                    continue;
-                const traced = source.traceSegment(segment[2], segment[3], segment.length === 5 ? this.names[segment[4]] : '');
-                if (traced) {
-                    const { column, line, name, source: { content, filename } } = traced;
-                    let sourceIndex = sourceIndexMap.get(filename);
-                    if (sourceIndex === undefined) {
-                        sourceIndex = sources.length;
-                        sources.push(filename);
-                        sourceIndexMap.set(filename, sourceIndex);
-                        sourcesContent[sourceIndex] = content;
-                    }
-                    else if (sourcesContent[sourceIndex] == null) {
-                        sourcesContent[sourceIndex] = content;
-                    }
-                    else if (content != null && sourcesContent[sourceIndex] !== content) {
-                        return error(errorConflictingSourcemapSources(filename));
-                    }
-                    const tracedSegment = [segment[0], sourceIndex, line, column];
-                    if (name) {
-                        let nameIndex = nameIndexMap.get(name);
-                        if (nameIndex === undefined) {
-                            nameIndex = names.length;
-                            names.push(name);
-                            nameIndexMap.set(name, nameIndex);
-                        }
-                        tracedSegment[4] = nameIndex;
-                    }
-                    tracedLine.push(tracedSegment);
-                }
-            }
-            mappings.push(tracedLine);
-        }
-        return { mappings, names, sources, sourcesContent };
-    }
-    traceSegment(line, column, name) {
-        const segments = this.mappings[line];
-        if (!segments)
-            return null;
-        // binary search through segments for the given column
-        let searchStart = 0;
-        let searchEnd = segments.length - 1;
-        while (searchStart <= searchEnd) {
-            const m = (searchStart + searchEnd) >> 1;
-            const segment = segments[m];
-            // If a sourcemap does not have sufficient resolution to contain a
-            // necessary mapping, e.g. because it only contains line information, we
-            // use the best approximation we could find
-            if (segment[0] === column || searchStart === searchEnd) {
-                if (segment.length == 1)
-                    return null;
-                const source = this.sources[segment[1]];
-                if (!source)
-                    return null;
-                return source.traceSegment(segment[2], segment[3], segment.length === 5 ? this.names[segment[4]] : name);
-            }
-            if (segment[0] > column) {
-                searchEnd = m - 1;
-            }
-            else {
-                searchStart = m + 1;
-            }
-        }
-        return null;
-    }
-}
-function getLinkMap(warn) {
-    return function linkMap(source, map) {
-        if (map.mappings) {
-            return new Link(map, [source]);
-        }
-        warn(errorSourcemapBroken(map.plugin));
-        return new Link({
-            mappings: [],
-            names: []
-        }, [source]);
-    };
-}
-function getCollapsedSourcemap(id, originalCode, originalSourcemap, sourcemapChain, linkMap) {
-    let source;
-    if (originalSourcemap) {
-        const sources = originalSourcemap.sources;
-        const sourcesContent = originalSourcemap.sourcesContent || [];
-        const directory = dirname(id) || '.';
-        const sourceRoot = originalSourcemap.sourceRoot || '.';
-        const baseSources = sources.map((source, index) => new Source(resolve(directory, sourceRoot, source), sourcesContent[index]));
-        source = new Link(originalSourcemap, baseSources);
-    }
-    else {
-        source = new Source(id, originalCode);
-    }
-    return sourcemapChain.reduce(linkMap, source);
-}
-function collapseSourcemaps(file, map, modules, bundleSourcemapChain, excludeContent, warn) {
-    const linkMap = getLinkMap(warn);
-    const moduleSources = modules
-        .filter(module => !module.excludeFromSourcemap)
-        .map(module => getCollapsedSourcemap(module.id, module.originalCode, module.originalSourcemap, module.sourcemapChain, linkMap));
-    const link = new Link(map, moduleSources);
-    const source = bundleSourcemapChain.reduce(linkMap, link);
-    let { sources, sourcesContent, names, mappings } = source.traceMappings();
-    if (file) {
-        const directory = dirname(file);
-        sources = sources.map((source) => relative$1(directory, source));
-        file = basename(file);
-    }
-    sourcesContent = (excludeContent ? null : sourcesContent);
-    return new SourceMap({ file, mappings, names, sources, sourcesContent });
-}
-function collapseSourcemap(id, originalCode, originalSourcemap, sourcemapChain, warn) {
-    if (sourcemapChain.length === 0) {
-        return originalSourcemap;
-    }
-    const source = getCollapsedSourcemap(id, originalCode, originalSourcemap, sourcemapChain, getLinkMap(warn));
-    const map = source.traceMappings();
-    return { version: 3, ...map };
-}
-
-const createHash = () => createHash$1('sha256');
-
-function decodedSourcemap(map) {
-    if (!map)
-        return null;
-    if (typeof map === 'string') {
-        map = JSON.parse(map);
-    }
-    if (map.mappings === '') {
-        return {
-            mappings: [],
-            names: [],
-            sources: [],
-            version: 3
-        };
-    }
-    const mappings = typeof map.mappings === 'string' ? decode(map.mappings) : map.mappings;
-    return { ...map, mappings };
-}
-
-async function renderChunks(chunks, bundle, pluginDriver, outputOptions, onwarn) {
-    timeStart('render chunks', 2);
-    reserveEntryChunksInBundle(chunks);
-    const renderedChunks = await Promise.all(chunks.map(chunk => chunk.render()));
-    timeEnd('render chunks', 2);
-    timeStart('transform chunks', 2);
-    const chunkGraph = getChunkGraph(chunks);
-    const { nonHashedChunksWithPlaceholders, renderedChunksByPlaceholder, hashDependenciesByPlaceholder } = await transformChunksAndGenerateContentHashes(renderedChunks, chunkGraph, outputOptions, pluginDriver, onwarn);
-    const hashesByPlaceholder = generateFinalHashes(renderedChunksByPlaceholder, hashDependenciesByPlaceholder, bundle);
-    addChunksToBundle(renderedChunksByPlaceholder, hashesByPlaceholder, bundle, nonHashedChunksWithPlaceholders, pluginDriver, outputOptions);
-    timeEnd('transform chunks', 2);
-}
-function reserveEntryChunksInBundle(chunks) {
-    for (const chunk of chunks) {
-        if (chunk.facadeModule && chunk.facadeModule.isUserDefinedEntryPoint) {
-            // reserves name in bundle as side effect if it does not contain a hash
-            chunk.getPreliminaryFileName();
-        }
-    }
-}
-function getChunkGraph(chunks) {
-    return Object.fromEntries(chunks.map(chunk => {
-        const renderedChunkInfo = chunk.getRenderedChunkInfo();
-        return [renderedChunkInfo.fileName, renderedChunkInfo];
-    }));
-}
-async function transformChunk(magicString, fileName, usedModules, chunkGraph, options, outputPluginDriver, onwarn) {
-    let map = null;
-    const sourcemapChain = [];
-    let code = await outputPluginDriver.hookReduceArg0('renderChunk', [magicString.toString(), chunkGraph[fileName], options, { chunks: chunkGraph }], (code, result, plugin) => {
-        if (result == null)
-            return code;
-        if (typeof result === 'string')
-            result = {
-                code: result,
-                map: undefined
-            };
-        // strict null check allows 'null' maps to not be pushed to the chain, while 'undefined' gets the missing map warning
-        if (result.map !== null) {
-            const map = decodedSourcemap(result.map);
-            sourcemapChain.push(map || { missing: true, plugin: plugin.name });
-        }
-        return result.code;
-    });
-    const { compact, dir, file, sourcemap, sourcemapExcludeSources, sourcemapFile, sourcemapPathTransform } = options;
-    if (!compact && code[code.length - 1] !== '\n')
-        code += '\n';
-    if (sourcemap) {
-        timeStart('sourcemaps', 3);
-        let resultingFile;
-        if (file)
-            resultingFile = resolve(sourcemapFile || file);
-        else if (dir)
-            resultingFile = resolve(dir, fileName);
-        else
-            resultingFile = resolve(fileName);
-        const decodedMap = magicString.generateDecodedMap({});
-        map = collapseSourcemaps(resultingFile, decodedMap, usedModules, sourcemapChain, sourcemapExcludeSources, onwarn);
-        map.sources = map.sources
-            .map(sourcePath => {
-            if (sourcemapPathTransform) {
-                const newSourcePath = sourcemapPathTransform(sourcePath, `${resultingFile}.map`);
-                if (typeof newSourcePath !== 'string') {
-                    error(errorFailedValidation(`sourcemapPathTransform function must return a string.`));
-                }
-                return newSourcePath;
-            }
-            return sourcePath;
-        })
-            .map(normalize);
-        timeEnd('sourcemaps', 3);
-    }
-    return {
-        code,
-        map
-    };
-}
-async function transformChunksAndGenerateContentHashes(renderedChunks, chunkGraph, outputOptions, pluginDriver, onwarn) {
-    const nonHashedChunksWithPlaceholders = [];
-    const renderedChunksByPlaceholder = new Map();
-    const hashDependenciesByPlaceholder = new Map();
-    const placeholders = new Set();
-    for (const { preliminaryFileName: { hashPlaceholder } } of renderedChunks) {
-        if (hashPlaceholder)
-            placeholders.add(hashPlaceholder);
-    }
-    await Promise.all(renderedChunks.map(async ({ chunk, preliminaryFileName: { fileName, hashPlaceholder }, magicString, usedModules }) => {
-        const transformedChunk = {
-            chunk,
-            fileName,
-            ...(await transformChunk(magicString, fileName, usedModules, chunkGraph, outputOptions, pluginDriver, onwarn))
-        };
-        const { code } = transformedChunk;
-        if (hashPlaceholder) {
-            const hash = createHash();
-            // To create a reproducible content-only hash, all placeholders are
-            // replaced with the same value before hashing
-            const { containedPlaceholders, transformedCode } = replacePlaceholdersWithDefaultAndGetContainedPlaceholders(code, placeholders);
-            hash.update(transformedCode);
-            const hashAugmentation = pluginDriver.hookReduceValueSync('augmentChunkHash', '', [chunk.getRenderedChunkInfo()], (augmentation, pluginHash) => {
-                if (pluginHash) {
-                    augmentation += pluginHash;
-                }
-                return augmentation;
-            });
-            if (hashAugmentation) {
-                hash.update(hashAugmentation);
-            }
-            renderedChunksByPlaceholder.set(hashPlaceholder, transformedChunk);
-            hashDependenciesByPlaceholder.set(hashPlaceholder, {
-                containedPlaceholders,
-                contentHash: hash.digest('hex')
-            });
-        }
-        else {
-            nonHashedChunksWithPlaceholders.push(transformedChunk);
-        }
-    }));
-    return {
-        hashDependenciesByPlaceholder,
-        nonHashedChunksWithPlaceholders,
-        renderedChunksByPlaceholder
-    };
-}
-function generateFinalHashes(renderedChunksByPlaceholder, hashDependenciesByPlaceholder, bundle) {
-    const hashesByPlaceholder = new Map();
-    for (const [placeholder, { fileName }] of renderedChunksByPlaceholder) {
-        let hash = createHash();
-        const hashDependencyPlaceholders = new Set([placeholder]);
-        for (const dependencyPlaceholder of hashDependencyPlaceholders) {
-            const { containedPlaceholders, contentHash } = hashDependenciesByPlaceholder.get(dependencyPlaceholder);
-            hash.update(contentHash);
-            for (const containedPlaceholder of containedPlaceholders) {
-                // When looping over a map, setting an entry only causes a new iteration if the key is new
-                hashDependencyPlaceholders.add(containedPlaceholder);
-            }
-        }
-        let finalFileName;
-        let finalHash;
-        do {
-            // In case of a hash collision, create a hash of the hash
-            if (finalHash) {
-                hash = createHash();
-                hash.update(finalHash);
-            }
-            finalHash = hash.digest('hex').slice(0, placeholder.length);
-            finalFileName = replaceSinglePlaceholder(fileName, placeholder, finalHash);
-        } while (bundle[lowercaseBundleKeys].has(finalFileName.toLowerCase()));
-        bundle[finalFileName] = FILE_PLACEHOLDER;
-        hashesByPlaceholder.set(placeholder, finalHash);
-    }
-    return hashesByPlaceholder;
-}
-function addChunksToBundle(renderedChunksByPlaceholder, hashesByPlaceholder, bundle, nonHashedChunksWithPlaceholders, pluginDriver, options) {
-    for (const { chunk, code, fileName, map } of renderedChunksByPlaceholder.values()) {
-        let updatedCode = replacePlaceholders(code, hashesByPlaceholder);
-        const finalFileName = replacePlaceholders(fileName, hashesByPlaceholder);
-        if (map) {
-            map.file = replacePlaceholders(map.file, hashesByPlaceholder);
-            updatedCode += emitSourceMapAndGetComment(finalFileName, map, pluginDriver, options);
-        }
-        bundle[finalFileName] = chunk.finalizeChunk(updatedCode, map, hashesByPlaceholder);
-    }
-    for (const { chunk, code, fileName, map } of nonHashedChunksWithPlaceholders) {
-        let updatedCode = hashesByPlaceholder.size > 0 ? replacePlaceholders(code, hashesByPlaceholder) : code;
-        if (map) {
-            updatedCode += emitSourceMapAndGetComment(fileName, map, pluginDriver, options);
-        }
-        bundle[fileName] = chunk.finalizeChunk(updatedCode, map, hashesByPlaceholder);
-    }
-}
-function emitSourceMapAndGetComment(fileName, map, pluginDriver, { sourcemap, sourcemapBaseUrl }) {
-    let url;
-    if (sourcemap === 'inline') {
-        url = map.toUrl();
-    }
-    else {
-        const sourcemapFileName = `${basename(fileName)}.map`;
-        url = sourcemapBaseUrl
-            ? new URL(sourcemapFileName, sourcemapBaseUrl).toString()
-            : sourcemapFileName;
-        pluginDriver.emitFile({ fileName: `${fileName}.map`, source: map.toString(), type: 'asset' });
-    }
-    return sourcemap === 'hidden' ? '' : `//# ${SOURCEMAPPING_URL}=${url}\n`;
-}
+const validPropName = /^(?!\d)[\w$]+$/;
 
 class Bundle {
     constructor(outputOptions, unsetOptions, inputOptions, pluginDriver, graph) {
@@ -16786,41 +15764,48 @@
     }
     async generate(isWrite) {
         timeStart('GENERATE', 1);
-        const outputBundleBase = Object.create(null);
-        const outputBundle = getOutputBundle(outputBundleBase);
-        this.pluginDriver.setOutputBundle(outputBundle, this.outputOptions);
+        const outputBundle = Object.create(null);
+        this.pluginDriver.setOutputBundle(outputBundle, this.outputOptions, this.facadeChunkByModule);
         try {
-            timeStart('initialize render', 2);
             await this.pluginDriver.hookParallel('renderStart', [this.outputOptions, this.inputOptions]);
-            timeEnd('initialize render', 2);
             timeStart('generate chunks', 2);
-            const getHashPlaceholder = getHashPlaceholderGenerator();
-            const chunks = await this.generateChunks(outputBundle, getHashPlaceholder);
+            const chunks = await this.generateChunks();
             if (chunks.length > 1) {
                 validateOptionsForMultiChunkOutput(this.outputOptions, this.inputOptions.onwarn);
             }
-            this.pluginDriver.setChunkInformation(this.facadeChunkByModule);
-            for (const chunk of chunks) {
-                chunk.generateExports();
-            }
+            const inputBase = commondir(getAbsoluteEntryModulePaths(chunks));
             timeEnd('generate chunks', 2);
-            await renderChunks(chunks, outputBundle, this.pluginDriver, this.outputOptions, this.inputOptions.onwarn);
-        }
-        catch (error_) {
-            await this.pluginDriver.hookParallel('renderError', [error_]);
-            throw error_;
+            timeStart('render modules', 2);
+            // We need to create addons before prerender because at the moment, there
+            // can be no async code between prerender and render due to internal state
+            const addons = await createAddons(this.outputOptions, this.pluginDriver);
+            const snippets = getGenerateCodeSnippets(this.outputOptions);
+            this.prerenderChunks(chunks, inputBase, snippets);
+            timeEnd('render modules', 2);
+            await this.addFinalizedChunksToBundle(chunks, inputBase, addons, outputBundle, snippets);
+        }
+        catch (err) {
+            await this.pluginDriver.hookParallel('renderError', [err]);
+            throw err;
         }
-        removeUnreferencedAssets(outputBundle);
-        timeStart('generate bundle', 2);
         await this.pluginDriver.hookSeq('generateBundle', [
             this.outputOptions,
             outputBundle,
             isWrite
         ]);
         this.finaliseAssets(outputBundle);
-        timeEnd('generate bundle', 2);
         timeEnd('GENERATE', 1);
-        return outputBundleBase;
+        return outputBundle;
+    }
+    async addFinalizedChunksToBundle(chunks, inputBase, addons, outputBundle, snippets) {
+        this.assignChunkIds(chunks, inputBase, addons, outputBundle);
+        for (const chunk of chunks) {
+            outputBundle[chunk.id] = chunk.getChunkInfoWithFileNames();
+        }
+        await Promise.all(chunks.map(async (chunk) => {
+            const outputChunk = outputBundle[chunk.id];
+            Object.assign(outputChunk, await chunk.render(this.outputOptions, addons, outputChunk, snippets));
+        }));
     }
     async addManualChunks(manualChunks) {
         const manualChunkAliasByEntry = new Map();
@@ -16835,9 +15820,31 @@
         }
         return manualChunkAliasByEntry;
     }
+    assignChunkIds(chunks, inputBase, addons, bundle) {
+        const entryChunks = [];
+        const otherChunks = [];
+        for (const chunk of chunks) {
+            (chunk.facadeModule && chunk.facadeModule.isUserDefinedEntryPoint
+                ? entryChunks
+                : otherChunks).push(chunk);
+        }
+        // make sure entry chunk names take precedence with regard to deconflicting
+        const chunksForNaming = entryChunks.concat(otherChunks);
+        for (const chunk of chunksForNaming) {
+            if (this.outputOptions.file) {
+                chunk.id = basename(this.outputOptions.file);
+            }
+            else if (this.outputOptions.preserveModules) {
+                chunk.id = chunk.generateIdPreserveModules(inputBase, this.outputOptions, bundle, this.unsetOptions);
+            }
+            else {
+                chunk.id = chunk.generateId(addons, this.outputOptions, bundle, true);
+            }
+            bundle[chunk.id] = FILE_PLACEHOLDER;
+        }
+    }
     assignManualChunks(getManualChunk) {
-        // eslint-disable-next-line unicorn/prefer-module
-        const manualChunkAliasesWithEntry = [];
+        const manualChunkAliasByEntry = new Map();
         const manualChunksApi = {
             getModuleIds: () => this.graph.modulesById.keys(),
             getModuleInfo: this.graph.getModuleInfo
@@ -16846,53 +15853,53 @@
             if (module instanceof Module) {
                 const manualChunkAlias = getManualChunk(module.id, manualChunksApi);
                 if (typeof manualChunkAlias === 'string') {
-                    manualChunkAliasesWithEntry.push([manualChunkAlias, module]);
+                    addModuleToManualChunk(manualChunkAlias, module, manualChunkAliasByEntry);
                 }
             }
         }
-        manualChunkAliasesWithEntry.sort(([aliasA], [aliasB]) => aliasA > aliasB ? 1 : aliasA < aliasB ? -1 : 0);
-        const manualChunkAliasByEntry = new Map();
-        for (const [alias, module] of manualChunkAliasesWithEntry) {
-            addModuleToManualChunk(alias, module, manualChunkAliasByEntry);
-        }
         return manualChunkAliasByEntry;
     }
-    finaliseAssets(bundle) {
-        if (this.outputOptions.validate) {
-            for (const file of Object.values(bundle)) {
-                if ('code' in file) {
-                    try {
-                        this.graph.contextParse(file.code, {
-                            ecmaVersion: 'latest'
-                        });
-                    }
-                    catch (error_) {
-                        this.inputOptions.onwarn(errorChunkInvalid(file, error_));
-                    }
+    finaliseAssets(outputBundle) {
+        for (const file of Object.values(outputBundle)) {
+            if (!file.type) {
+                warnDeprecation('A plugin is directly adding properties to the bundle object in the "generateBundle" hook. This is deprecated and will be removed in a future Rollup version, please use "this.emitFile" instead.', true, this.inputOptions);
+                file.type = 'asset';
+            }
+            if (this.outputOptions.validate && typeof file.code == 'string') {
+                try {
+                    this.graph.contextParse(file.code, {
+                        allowHashBang: true,
+                        ecmaVersion: 'latest'
+                    });
+                }
+                catch (err) {
+                    this.inputOptions.onwarn(errChunkInvalid(file, err));
                 }
             }
         }
         this.pluginDriver.finaliseAssets();
     }
-    async generateChunks(bundle, getHashPlaceholder) {
-        const { experimentalMinChunkSize, inlineDynamicImports, manualChunks, preserveModules } = this.outputOptions;
+    async generateChunks() {
+        const { manualChunks } = this.outputOptions;
         const manualChunkAliasByEntry = typeof manualChunks === 'object'
             ? await this.addManualChunks(manualChunks)
             : this.assignManualChunks(manualChunks);
-        const snippets = getGenerateCodeSnippets(this.outputOptions);
-        const includedModules = getIncludedModules(this.graph.modulesById);
-        const inputBase = commondir(getAbsoluteEntryModulePaths(includedModules, preserveModules));
-        const externalChunkByModule = getExternalChunkByModule(this.graph.modulesById, this.outputOptions, inputBase);
         const chunks = [];
         const chunkByModule = new Map();
-        for (const { alias, modules } of inlineDynamicImports
-            ? [{ alias: null, modules: includedModules }]
-            : preserveModules
-                ? includedModules.map(module => ({ alias: null, modules: [module] }))
-                : getChunkAssignments(this.graph.entryModules, manualChunkAliasByEntry, experimentalMinChunkSize)) {
+        for (const { alias, modules } of this.outputOptions.inlineDynamicImports
+            ? [{ alias: null, modules: getIncludedModules(this.graph.modulesById) }]
+            : this.outputOptions.preserveModules
+                ? getIncludedModules(this.graph.modulesById).map(module => ({
+                    alias: null,
+                    modules: [module]
+                }))
+                : getChunkAssignments(this.graph.entryModules, manualChunkAliasByEntry)) {
             sortByExecutionOrder(modules);
-            const chunk = new Chunk(modules, this.inputOptions, this.outputOptions, this.unsetOptions, this.pluginDriver, this.graph.modulesById, chunkByModule, externalChunkByModule, this.facadeChunkByModule, this.includedNamespaces, alias, getHashPlaceholder, bundle, inputBase, snippets);
+            const chunk = new Chunk(modules, this.inputOptions, this.outputOptions, this.unsetOptions, this.pluginDriver, this.graph.modulesById, chunkByModule, this.facadeChunkByModule, this.includedNamespaces, alias);
             chunks.push(chunk);
+            for (const module of modules) {
+                chunkByModule.set(module, chunk);
+            }
         }
         for (const chunk of chunks) {
             chunk.link();
@@ -16903,67 +15910,48 @@
         }
         return [...chunks, ...facades];
     }
-}
-function validateOptionsForMultiChunkOutput(outputOptions, onWarn) {
-    if (outputOptions.format === 'umd' || outputOptions.format === 'iife')
-        return error(errorInvalidOption('output.format', URL_OUTPUT_FORMAT, 'UMD and IIFE output formats are not supported for code-splitting builds', outputOptions.format));
-    if (typeof outputOptions.file === 'string')
-        return error(errorInvalidOption('output.file', URL_OUTPUT_DIR, 'when building multiple chunks, the "output.dir" option must be used, not "output.file". To inline dynamic imports, set the "inlineDynamicImports" option'));
-    if (outputOptions.sourcemapFile)
-        return error(errorInvalidOption('output.sourcemapFile', URL_OUTPUT_SOURCEMAPFILE, '"output.sourcemapFile" is only supported for single-file builds'));
-    if (!outputOptions.amd.autoId && outputOptions.amd.id)
-        onWarn(errorInvalidOption('output.amd.id', URL_OUTPUT_AMD_ID, 'this option is only properly supported for single-file builds. Use "output.amd.autoId" and "output.amd.basePath" instead'));
-}
-function getIncludedModules(modulesById) {
-    const includedModules = [];
-    for (const module of modulesById.values()) {
-        if (module instanceof Module &&
-            (module.isIncluded() || module.info.isEntry || module.includedDynamicImporters.length > 0)) {
-            includedModules.push(module);
+    prerenderChunks(chunks, inputBase, snippets) {
+        for (const chunk of chunks) {
+            chunk.generateExports();
+        }
+        for (const chunk of chunks) {
+            chunk.preRender(this.outputOptions, inputBase, snippets);
         }
     }
-    return includedModules;
 }
-function getAbsoluteEntryModulePaths(includedModules, preserveModules) {
+function getAbsoluteEntryModulePaths(chunks) {
     const absoluteEntryModulePaths = [];
-    for (const module of includedModules) {
-        if ((module.info.isEntry || preserveModules) && isAbsolute(module.id)) {
-            absoluteEntryModulePaths.push(module.id);
+    for (const chunk of chunks) {
+        for (const entryModule of chunk.entryModules) {
+            if (isAbsolute(entryModule.id)) {
+                absoluteEntryModulePaths.push(entryModule.id);
+            }
         }
     }
     return absoluteEntryModulePaths;
 }
-function getExternalChunkByModule(modulesById, outputOptions, inputBase) {
-    const externalChunkByModule = new Map();
-    for (const module of modulesById.values()) {
-        if (module instanceof ExternalModule) {
-            externalChunkByModule.set(module, new ExternalChunk(module, outputOptions, inputBase));
-        }
-    }
-    return externalChunkByModule;
+function validateOptionsForMultiChunkOutput(outputOptions, onWarn) {
+    if (outputOptions.format === 'umd' || outputOptions.format === 'iife')
+        return error(errInvalidOption('output.format', 'outputformat', 'UMD and IIFE output formats are not supported for code-splitting builds', outputOptions.format));
+    if (typeof outputOptions.file === 'string')
+        return error(errInvalidOption('output.file', 'outputdir', 'when building multiple chunks, the "output.dir" option must be used, not "output.file". To inline dynamic imports, set the "inlineDynamicImports" option'));
+    if (outputOptions.sourcemapFile)
+        return error(errInvalidOption('output.sourcemapFile', 'outputsourcemapfile', '"output.sourcemapFile" is only supported for single-file builds'));
+    if (!outputOptions.amd.autoId && outputOptions.amd.id)
+        onWarn(errInvalidOption('output.amd.id', 'outputamd', 'this option is only properly supported for single-file builds. Use "output.amd.autoId" and "output.amd.basePath" instead'));
+}
+function getIncludedModules(modulesById) {
+    return [...modulesById.values()].filter(module => module instanceof Module &&
+        (module.isIncluded() || module.info.isEntry || module.includedDynamicImporters.length > 0));
 }
 function addModuleToManualChunk(alias, module, manualChunkAliasByEntry) {
     const existingAlias = manualChunkAliasByEntry.get(module);
     if (typeof existingAlias === 'string' && existingAlias !== alias) {
-        return error(errorCannotAssignModuleToChunk(module.id, alias, existingAlias));
+        return error(errCannotAssignModuleToChunk(module.id, alias, existingAlias));
     }
     manualChunkAliasByEntry.set(module, alias);
 }
 
-// This file was generated. Do not modify manually!
-var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
-
-// This file was generated. Do not modify manually!
-var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
-
-// This file was generated. Do not modify manually!
-var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0898-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
-
-// This file was generated. Do not modify manually!
-var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ca\ua7d0\ua7d1\ua7d3\ua7d5-\ua7d9\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
-
-// These are a run-length and offset encoded representation of the
-
 // Reserved word lists for various dialects of the language
 
 var reservedWords = {
@@ -16978,7 +15966,7 @@
 
 var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
 
-var keywords$1 = {
+var keywords = {
   5: ecma5AndLessKeywords,
   "5module": ecma5AndLessKeywords + " export import",
   6: ecma5AndLessKeywords + " const class extends export import super"
@@ -16988,9 +15976,31 @@
 
 // ## Character categories
 
+// Big ugly regular expressions that match characters in the
+// whitespace, identifier, and identifier-start categories. These
+// are only applied when a character is found to actually have a
+// code point above 128.
+// Generated by `bin/generate-identifier-regex.js`.
+var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08c7\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\u9ffc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7ca\ua7f5-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
+var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf\u1ac0\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
+
 var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
 var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
 
+nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
+
+// These are a run-length and offset encoded representation of the
+// >0xffff code points that are a valid part of identifiers. The
+// offset starts at 0x10000, and each pair of numbers represents an
+// offset to the next range, and then a size of the range. They were
+// generated by bin/generate-identifier-regex.js
+
+// eslint-disable-next-line comma-spacing
+var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,349,41,7,1,79,28,11,0,9,21,107,20,28,22,13,52,76,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,190,0,80,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,43,8,8952,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42717,35,4148,12,221,3,5761,15,7472,3104,541,1507,4938];
+
+// eslint-disable-next-line comma-spacing
+var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,370,1,154,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,82,0,12,1,19628,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,4759,9,787719,239];
+
 // This has a complexity linear to the value of the code. The
 // assumption is that looking up astral identifier characters is
 // rare.
@@ -17075,17 +16085,17 @@
 
 // Map keyword names to token types.
 
-var keywords = {};
+var keywords$1 = {};
 
 // Succinct definitions of keyword token types
 function kw(name, options) {
   if ( options === void 0 ) options = {};
 
   options.keyword = name;
-  return keywords[name] = new TokenType(name, options)
+  return keywords$1[name] = new TokenType(name, options)
 }
 
-var types$1 = {
+var types = {
   num: new TokenType("num", startsExpr),
   regexp: new TokenType("regexp", startsExpr),
   string: new TokenType("string", startsExpr),
@@ -17194,17 +16204,6 @@
   return code === 10 || code === 13 || code === 0x2028 || code === 0x2029
 }
 
-function nextLineBreak(code, from, end) {
-  if ( end === void 0 ) end = code.length;
-
-  for (var i = from; i < end; i++) {
-    var next = code.charCodeAt(i);
-    if (isNewLine(next))
-      { return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1 }
-  }
-  return -1
-}
-
 var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
 
 var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
@@ -17213,9 +16212,11 @@
 var hasOwnProperty = ref.hasOwnProperty;
 var toString = ref.toString;
 
-var hasOwn = Object.hasOwn || (function (obj, propName) { return (
-  hasOwnProperty.call(obj, propName)
-); });
+// Checks if an object has a property.
+
+function has(obj, propName) {
+  return hasOwnProperty.call(obj, propName)
+}
 
 var isArray = Array.isArray || (function (obj) { return (
   toString.call(obj) === "[object Array]"
@@ -17225,15 +16226,6 @@
   return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
 }
 
-function codePointToString(code) {
-  // UTF-16 Decoding
-  if (code <= 0xFFFF) { return String.fromCharCode(code) }
-  code -= 0x10000;
-  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
-}
-
-var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
-
 // These are used when `options.locations` is on, for the
 // `startLoc` and `endLoc` properties.
 
@@ -17260,10 +16252,14 @@
 
 function getLineInfo(input, offset) {
   for (var line = 1, cur = 0;;) {
-    var nextBreak = nextLineBreak(input, cur, offset);
-    if (nextBreak < 0) { return new Position(line, offset - cur) }
-    ++line;
-    cur = nextBreak;
+    lineBreakG.lastIndex = cur;
+    var match = lineBreakG.exec(input);
+    if (match && match.index < offset) {
+      ++line;
+      cur = match.index + match[0].length;
+    } else {
+      return new Position(line, offset - cur)
+    }
   }
 }
 
@@ -17273,10 +16269,10 @@
 var defaultOptions = {
   // `ecmaVersion` indicates the ECMAScript version to parse. Must be
   // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
-  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
-  // (the latest version the library supports). This influences
-  // support for strict mode, the set of reserved words, and support
-  // for new syntax features.
+  // (2019), 11 (2020), 12 (2021), 13 (2022), or `"latest"` (the
+  // latest version the library supports). This influences support
+  // for strict mode, the set of reserved words, and support for
+  // new syntax features.
   ecmaVersion: null,
   // `sourceType` indicates the mode the code should be parsed in.
   // Can be either `"script"` or `"module"`. This influences global
@@ -17310,9 +16306,8 @@
   // When enabled, super identifiers are not constrained to
   // appearing in methods and do not raise an error when they appear elsewhere.
   allowSuperOutsideMethod: null,
-  // When enabled, hashbang directive in the beginning of file is
-  // allowed and treated as a line comment. Enabled by default when
-  // `ecmaVersion` >= 2023.
+  // When enabled, hashbang directive in the beginning of file
+  // is allowed and treated as a line comment.
   allowHashBang: false,
   // When `locations` is on, `loc` properties holding objects with
   // `start` and `end` properties in `{line, column}` form (with
@@ -17370,7 +16365,7 @@
   var options = {};
 
   for (var opt in defaultOptions)
-    { options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt]; }
+    { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }
 
   if (options.ecmaVersion === "latest") {
     options.ecmaVersion = 1e8;
@@ -17387,9 +16382,6 @@
   if (options.allowReserved == null)
     { options.allowReserved = options.ecmaVersion < 5; }
 
-  if (opts.allowHashBang == null)
-    { options.allowHashBang = options.ecmaVersion >= 14; }
-
   if (isArray(options.onToken)) {
     var tokens = options.onToken;
     options.onToken = function (token) { return tokens.push(token); };
@@ -17445,7 +16437,7 @@
 var Parser = function Parser(options, input, startPos) {
   this.options = options = getOptions(options);
   this.sourceFile = options.sourceFile;
-  this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
+  this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
   var reserved = "";
   if (options.allowReserved !== true) {
     reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
@@ -17476,7 +16468,7 @@
 
   // Properties of the current token:
   // Its type
-  this.type = types$1.eof;
+  this.type = types.eof;
   // For tokens that include more information than their type, the value
   this.value = null;
   // Its start and end offset
@@ -17536,11 +16528,8 @@
 };
 
 prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };
-
 prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit };
-
 prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit };
-
 prototypeAccessors.canAwait.get = function () {
   for (var i = this.scopeStack.length - 1; i >= 0; i--) {
     var scope = this.scopeStack[i];
@@ -17549,25 +16538,20 @@
   }
   return (this.inModule && this.options.ecmaVersion >= 13) || this.options.allowAwaitOutsideFunction
 };
-
 prototypeAccessors.allowSuper.get = function () {
   var ref = this.currentThisScope();
     var flags = ref.flags;
     var inClassFieldInit = ref.inClassFieldInit;
   return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod
 };
-
 prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };
-
 prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };
-
 prototypeAccessors.allowNewDotTarget.get = function () {
   var ref = this.currentThisScope();
     var flags = ref.flags;
     var inClassFieldInit = ref.inClassFieldInit;
   return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit
 };
-
 prototypeAccessors.inClassStaticBlock.get = function () {
   return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0
 };
@@ -17597,13 +16581,12 @@
 
 Object.defineProperties( Parser.prototype, prototypeAccessors );
 
-var pp$9 = Parser.prototype;
+var pp = Parser.prototype;
 
 // ## Parser utilities
 
 var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
-pp$9.strictDirective = function(start) {
-  if (this.options.ecmaVersion < 5) { return false }
+pp.strictDirective = function(start) {
   for (;;) {
     // Try to find string literal.
     skipWhiteSpace.lastIndex = start;
@@ -17631,7 +16614,7 @@
 // Predicate that tests whether the next token is of the given
 // type, and if yes, consumes it as a side effect.
 
-pp$9.eat = function(type) {
+pp.eat = function(type) {
   if (this.type === type) {
     this.next();
     return true
@@ -17642,13 +16625,13 @@
 
 // Tests whether parsed token is a contextual keyword.
 
-pp$9.isContextual = function(name) {
-  return this.type === types$1.name && this.value === name && !this.containsEsc
+pp.isContextual = function(name) {
+  return this.type === types.name && this.value === name && !this.containsEsc
 };
 
 // Consumes contextual keyword if possible.
 
-pp$9.eatContextual = function(name) {
+pp.eatContextual = function(name) {
   if (!this.isContextual(name)) { return false }
   this.next();
   return true
@@ -17656,19 +16639,19 @@
 
 // Asserts that following token is given contextual keyword.
 
-pp$9.expectContextual = function(name) {
+pp.expectContextual = function(name) {
   if (!this.eatContextual(name)) { this.unexpected(); }
 };
 
 // Test whether a semicolon can be inserted at the current position.
 
-pp$9.canInsertSemicolon = function() {
-  return this.type === types$1.eof ||
-    this.type === types$1.braceR ||
+pp.canInsertSemicolon = function() {
+  return this.type === types.eof ||
+    this.type === types.braceR ||
     lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
 };
 
-pp$9.insertSemicolon = function() {
+pp.insertSemicolon = function() {
   if (this.canInsertSemicolon()) {
     if (this.options.onInsertedSemicolon)
       { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
@@ -17679,11 +16662,11 @@
 // Consume a semicolon, or, failing that, see if we are allowed to
 // pretend that there is a semicolon at this position.
 
-pp$9.semicolon = function() {
-  if (!this.eat(types$1.semi) && !this.insertSemicolon()) { this.unexpected(); }
+pp.semicolon = function() {
+  if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }
 };
 
-pp$9.afterTrailingComma = function(tokType, notNext) {
+pp.afterTrailingComma = function(tokType, notNext) {
   if (this.type === tokType) {
     if (this.options.onTrailingComma)
       { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
@@ -17696,34 +16679,34 @@
 // Expect a token of a given type. If found, consume it, otherwise,
 // raise an unexpected token error.
 
-pp$9.expect = function(type) {
+pp.expect = function(type) {
   this.eat(type) || this.unexpected();
 };
 
 // Raise an unexpected token error.
 
-pp$9.unexpected = function(pos) {
+pp.unexpected = function(pos) {
   this.raise(pos != null ? pos : this.start, "Unexpected token");
 };
 
-var DestructuringErrors = function DestructuringErrors() {
+function DestructuringErrors() {
   this.shorthandAssign =
   this.trailingComma =
   this.parenthesizedAssign =
   this.parenthesizedBind =
   this.doubleProto =
     -1;
-};
+}
 
-pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
+pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
   if (!refDestructuringErrors) { return }
   if (refDestructuringErrors.trailingComma > -1)
     { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
   var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
-  if (parens > -1) { this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern"); }
+  if (parens > -1) { this.raiseRecoverable(parens, "Parenthesized pattern"); }
 };
 
-pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
+pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
   if (!refDestructuringErrors) { return false }
   var shorthandAssign = refDestructuringErrors.shorthandAssign;
   var doubleProto = refDestructuringErrors.doubleProto;
@@ -17734,20 +16717,20 @@
     { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
 };
 
-pp$9.checkYieldAwaitInDefaultParams = function() {
+pp.checkYieldAwaitInDefaultParams = function() {
   if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
     { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
   if (this.awaitPos)
     { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
 };
 
-pp$9.isSimpleAssignTarget = function(expr) {
+pp.isSimpleAssignTarget = function(expr) {
   if (expr.type === "ParenthesizedExpression")
     { return this.isSimpleAssignTarget(expr.expression) }
   return expr.type === "Identifier" || expr.type === "MemberExpression"
 };
 
-var pp$8 = Parser.prototype;
+var pp$1 = Parser.prototype;
 
 // ### Statement parsing
 
@@ -17756,10 +16739,10 @@
 // `program` argument.  If present, the statements will be appended
 // to its body instead of creating a new node.
 
-pp$8.parseTopLevel = function(node) {
+pp$1.parseTopLevel = function(node) {
   var exports = Object.create(null);
   if (!node.body) { node.body = []; }
-  while (this.type !== types$1.eof) {
+  while (this.type !== types.eof) {
     var stmt = this.parseStatement(null, true, exports);
     node.body.push(stmt);
   }
@@ -17778,7 +16761,7 @@
 
 var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};
 
-pp$8.isLet = function(context) {
+pp$1.isLet = function(context) {
   if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
   skipWhiteSpace.lastIndex = this.pos;
   var skip = skipWhiteSpace.exec(this.input);
@@ -17804,7 +16787,7 @@
 // check 'async [no LineTerminator here] function'
 // - 'async /*foo*/ function' is OK.
 // - 'async /*\n*/ function' is invalid.
-pp$8.isAsyncFunction = function() {
+pp$1.isAsyncFunction = function() {
   if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
     { return false }
 
@@ -17824,11 +16807,11 @@
 // `if (foo) /blah/.exec(foo)`, where looking at the previous token
 // does not help.
 
-pp$8.parseStatement = function(context, topLevel, exports) {
+pp$1.parseStatement = function(context, topLevel, exports) {
   var starttype = this.type, node = this.startNode(), kind;
 
   if (this.isLet(context)) {
-    starttype = types$1._var;
+    starttype = types._var;
     kind = "let";
   }
 
@@ -17837,35 +16820,35 @@
   // complexity.
 
   switch (starttype) {
-  case types$1._break: case types$1._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
-  case types$1._debugger: return this.parseDebuggerStatement(node)
-  case types$1._do: return this.parseDoStatement(node)
-  case types$1._for: return this.parseForStatement(node)
-  case types$1._function:
+  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
+  case types._debugger: return this.parseDebuggerStatement(node)
+  case types._do: return this.parseDoStatement(node)
+  case types._for: return this.parseForStatement(node)
+  case types._function:
     // Function as sole body of either an if statement or a labeled statement
     // works, but not when it is part of a labeled statement that is the sole
     // body of an if statement.
     if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
     return this.parseFunctionStatement(node, false, !context)
-  case types$1._class:
+  case types._class:
     if (context) { this.unexpected(); }
     return this.parseClass(node, true)
-  case types$1._if: return this.parseIfStatement(node)
-  case types$1._return: return this.parseReturnStatement(node)
-  case types$1._switch: return this.parseSwitchStatement(node)
-  case types$1._throw: return this.parseThrowStatement(node)
-  case types$1._try: return this.parseTryStatement(node)
-  case types$1._const: case types$1._var:
+  case types._if: return this.parseIfStatement(node)
+  case types._return: return this.parseReturnStatement(node)
+  case types._switch: return this.parseSwitchStatement(node)
+  case types._throw: return this.parseThrowStatement(node)
+  case types._try: return this.parseTryStatement(node)
+  case types._const: case types._var:
     kind = kind || this.value;
     if (context && kind !== "var") { this.unexpected(); }
     return this.parseVarStatement(node, kind)
-  case types$1._while: return this.parseWhileStatement(node)
-  case types$1._with: return this.parseWithStatement(node)
-  case types$1.braceL: return this.parseBlock(true, node)
-  case types$1.semi: return this.parseEmptyStatement(node)
-  case types$1._export:
-  case types$1._import:
-    if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
+  case types._while: return this.parseWhileStatement(node)
+  case types._with: return this.parseWithStatement(node)
+  case types.braceL: return this.parseBlock(true, node)
+  case types.semi: return this.parseEmptyStatement(node)
+  case types._export:
+  case types._import:
+    if (this.options.ecmaVersion > 10 && starttype === types._import) {
       skipWhiteSpace.lastIndex = this.pos;
       var skip = skipWhiteSpace.exec(this.input);
       var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
@@ -17879,7 +16862,7 @@
       if (!this.inModule)
         { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
     }
-    return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports)
+    return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)
 
     // If the statement does not start with a statement keyword or a
     // brace, it's an ExpressionStatement or LabeledStatement. We
@@ -17894,17 +16877,17 @@
     }
 
     var maybeName = this.value, expr = this.parseExpression();
-    if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon))
+    if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon))
       { return this.parseLabeledStatement(node, maybeName, expr, context) }
     else { return this.parseExpressionStatement(node, expr) }
   }
 };
 
-pp$8.parseBreakContinueStatement = function(node, keyword) {
+pp$1.parseBreakContinueStatement = function(node, keyword) {
   var isBreak = keyword === "break";
   this.next();
-  if (this.eat(types$1.semi) || this.insertSemicolon()) { node.label = null; }
-  else if (this.type !== types$1.name) { this.unexpected(); }
+  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
+  else if (this.type !== types.name) { this.unexpected(); }
   else {
     node.label = this.parseIdent();
     this.semicolon();
@@ -17924,21 +16907,21 @@
   return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
 };
 
-pp$8.parseDebuggerStatement = function(node) {
+pp$1.parseDebuggerStatement = function(node) {
   this.next();
   this.semicolon();
   return this.finishNode(node, "DebuggerStatement")
 };
 
-pp$8.parseDoStatement = function(node) {
+pp$1.parseDoStatement = function(node) {
   this.next();
   this.labels.push(loopLabel);
   node.body = this.parseStatement("do");
   this.labels.pop();
-  this.expect(types$1._while);
+  this.expect(types._while);
   node.test = this.parseParenExpression();
   if (this.options.ecmaVersion >= 6)
-    { this.eat(types$1.semi); }
+    { this.eat(types.semi); }
   else
     { this.semicolon(); }
   return this.finishNode(node, "DoWhileStatement")
@@ -17952,25 +16935,25 @@
 // part (semicolon immediately after the opening parenthesis), it
 // is a regular `for` loop.
 
-pp$8.parseForStatement = function(node) {
+pp$1.parseForStatement = function(node) {
   this.next();
   var awaitAt = (this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await")) ? this.lastTokStart : -1;
   this.labels.push(loopLabel);
   this.enterScope(0);
-  this.expect(types$1.parenL);
-  if (this.type === types$1.semi) {
+  this.expect(types.parenL);
+  if (this.type === types.semi) {
     if (awaitAt > -1) { this.unexpected(awaitAt); }
     return this.parseFor(node, null)
   }
   var isLet = this.isLet();
-  if (this.type === types$1._var || this.type === types$1._const || isLet) {
+  if (this.type === types._var || this.type === types._const || isLet) {
     var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
     this.next();
     this.parseVar(init$1, true, kind);
     this.finishNode(init$1, "VariableDeclaration");
-    if ((this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
+    if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
       if (this.options.ecmaVersion >= 9) {
-        if (this.type === types$1._in) {
+        if (this.type === types._in) {
           if (awaitAt > -1) { this.unexpected(awaitAt); }
         } else { node.await = awaitAt > -1; }
       }
@@ -17982,9 +16965,9 @@
   var startsWithLet = this.isContextual("let"), isForOf = false;
   var refDestructuringErrors = new DestructuringErrors;
   var init = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
-  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
+  if (this.type === types._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
     if (this.options.ecmaVersion >= 9) {
-      if (this.type === types$1._in) {
+      if (this.type === types._in) {
         if (awaitAt > -1) { this.unexpected(awaitAt); }
       } else { node.await = awaitAt > -1; }
     }
@@ -17999,21 +16982,21 @@
   return this.parseFor(node, init)
 };
 
-pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
+pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
   this.next();
-  return this.parseFunction(node, FUNC_STATEMENT$1 | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
+  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
 };
 
-pp$8.parseIfStatement = function(node) {
+pp$1.parseIfStatement = function(node) {
   this.next();
   node.test = this.parseParenExpression();
   // allow function declarations in branches, but only in non-strict mode
   node.consequent = this.parseStatement("if");
-  node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
+  node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
   return this.finishNode(node, "IfStatement")
 };
 
-pp$8.parseReturnStatement = function(node) {
+pp$1.parseReturnStatement = function(node) {
   if (!this.inFunction && !this.options.allowReturnOutsideFunction)
     { this.raise(this.start, "'return' outside of function"); }
   this.next();
@@ -18022,16 +17005,16 @@
   // optional arguments, we eagerly look for a semicolon or the
   // possibility to insert one.
 
-  if (this.eat(types$1.semi) || this.insertSemicolon()) { node.argument = null; }
+  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
   else { node.argument = this.parseExpression(); this.semicolon(); }
   return this.finishNode(node, "ReturnStatement")
 };
 
-pp$8.parseSwitchStatement = function(node) {
+pp$1.parseSwitchStatement = function(node) {
   this.next();
   node.discriminant = this.parseParenExpression();
   node.cases = [];
-  this.expect(types$1.braceL);
+  this.expect(types.braceL);
   this.labels.push(switchLabel);
   this.enterScope(0);
 
@@ -18040,9 +17023,9 @@
   // adding statements to.
 
   var cur;
-  for (var sawDefault = false; this.type !== types$1.braceR;) {
-    if (this.type === types$1._case || this.type === types$1._default) {
-      var isCase = this.type === types$1._case;
+  for (var sawDefault = false; this.type !== types.braceR;) {
+    if (this.type === types._case || this.type === types._default) {
+      var isCase = this.type === types._case;
       if (cur) { this.finishNode(cur, "SwitchCase"); }
       node.cases.push(cur = this.startNode());
       cur.consequent = [];
@@ -18054,7 +17037,7 @@
         sawDefault = true;
         cur.test = null;
       }
-      this.expect(types$1.colon);
+      this.expect(types.colon);
     } else {
       if (!cur) { this.unexpected(); }
       cur.consequent.push(this.parseStatement(null));
@@ -18067,7 +17050,7 @@
   return this.finishNode(node, "SwitchStatement")
 };
 
-pp$8.parseThrowStatement = function(node) {
+pp$1.parseThrowStatement = function(node) {
   this.next();
   if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
     { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
@@ -18078,21 +17061,21 @@
 
 // Reused empty array added for node fields that are always empty.
 
-var empty$1 = [];
+var empty = [];
 
-pp$8.parseTryStatement = function(node) {
+pp$1.parseTryStatement = function(node) {
   this.next();
   node.block = this.parseBlock();
   node.handler = null;
-  if (this.type === types$1._catch) {
+  if (this.type === types._catch) {
     var clause = this.startNode();
     this.next();
-    if (this.eat(types$1.parenL)) {
+    if (this.eat(types.parenL)) {
       clause.param = this.parseBindingAtom();
       var simple = clause.param.type === "Identifier";
       this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
       this.checkLValPattern(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
-      this.expect(types$1.parenR);
+      this.expect(types.parenR);
     } else {
       if (this.options.ecmaVersion < 10) { this.unexpected(); }
       clause.param = null;
@@ -18102,20 +17085,20 @@
     this.exitScope();
     node.handler = this.finishNode(clause, "CatchClause");
   }
-  node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
+  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
   if (!node.handler && !node.finalizer)
     { this.raise(node.start, "Missing catch or finally clause"); }
   return this.finishNode(node, "TryStatement")
 };
 
-pp$8.parseVarStatement = function(node, kind) {
+pp$1.parseVarStatement = function(node, kind) {
   this.next();
   this.parseVar(node, false, kind);
   this.semicolon();
   return this.finishNode(node, "VariableDeclaration")
 };
 
-pp$8.parseWhileStatement = function(node) {
+pp$1.parseWhileStatement = function(node) {
   this.next();
   node.test = this.parseParenExpression();
   this.labels.push(loopLabel);
@@ -18124,7 +17107,7 @@
   return this.finishNode(node, "WhileStatement")
 };
 
-pp$8.parseWithStatement = function(node) {
+pp$1.parseWithStatement = function(node) {
   if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
   this.next();
   node.object = this.parseParenExpression();
@@ -18132,12 +17115,12 @@
   return this.finishNode(node, "WithStatement")
 };
 
-pp$8.parseEmptyStatement = function(node) {
+pp$1.parseEmptyStatement = function(node) {
   this.next();
   return this.finishNode(node, "EmptyStatement")
 };
 
-pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
+pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {
   for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
     {
     var label = list[i$1];
@@ -18145,7 +17128,7 @@
     if (label.name === maybeName)
       { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
   } }
-  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
+  var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
   for (var i = this.labels.length - 1; i >= 0; i--) {
     var label$1 = this.labels[i];
     if (label$1.statementStart === node.start) {
@@ -18161,7 +17144,7 @@
   return this.finishNode(node, "LabeledStatement")
 };
 
-pp$8.parseExpressionStatement = function(node, expr) {
+pp$1.parseExpressionStatement = function(node, expr) {
   node.expression = expr;
   this.semicolon();
   return this.finishNode(node, "ExpressionStatement")
@@ -18171,14 +17154,14 @@
 // strict"` declarations when `allowStrict` is true (used for
 // function bodies).
 
-pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
+pp$1.parseBlock = function(createNewLexicalScope, node, exitStrict) {
   if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
   if ( node === void 0 ) node = this.startNode();
 
   node.body = [];
-  this.expect(types$1.braceL);
+  this.expect(types.braceL);
   if (createNewLexicalScope) { this.enterScope(0); }
-  while (this.type !== types$1.braceR) {
+  while (this.type !== types.braceR) {
     var stmt = this.parseStatement(null);
     node.body.push(stmt);
   }
@@ -18192,13 +17175,13 @@
 // `parseStatement` will already have parsed the init statement or
 // expression.
 
-pp$8.parseFor = function(node, init) {
+pp$1.parseFor = function(node, init) {
   node.init = init;
-  this.expect(types$1.semi);
-  node.test = this.type === types$1.semi ? null : this.parseExpression();
-  this.expect(types$1.semi);
-  node.update = this.type === types$1.parenR ? null : this.parseExpression();
-  this.expect(types$1.parenR);
+  this.expect(types.semi);
+  node.test = this.type === types.semi ? null : this.parseExpression();
+  this.expect(types.semi);
+  node.update = this.type === types.parenR ? null : this.parseExpression();
+  this.expect(types.parenR);
   node.body = this.parseStatement("for");
   this.exitScope();
   this.labels.pop();
@@ -18208,8 +17191,8 @@
 // Parse a `for`/`in` and `for`/`of` loop, which are almost
 // same from parser's perspective.
 
-pp$8.parseForIn = function(node, init) {
-  var isForIn = this.type === types$1._in;
+pp$1.parseForIn = function(node, init) {
+  var isForIn = this.type === types._in;
   this.next();
 
   if (
@@ -18230,7 +17213,7 @@
   }
   node.left = init;
   node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
-  this.expect(types$1.parenR);
+  this.expect(types.parenR);
   node.body = this.parseStatement("for");
   this.exitScope();
   this.labels.pop();
@@ -18239,50 +17222,50 @@
 
 // Parse a list of variable declarations.
 
-pp$8.parseVar = function(node, isFor, kind) {
+pp$1.parseVar = function(node, isFor, kind) {
   node.declarations = [];
   node.kind = kind;
   for (;;) {
     var decl = this.startNode();
     this.parseVarId(decl, kind);
-    if (this.eat(types$1.eq)) {
+    if (this.eat(types.eq)) {
       decl.init = this.parseMaybeAssign(isFor);
-    } else if (kind === "const" && !(this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
+    } else if (kind === "const" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
       this.unexpected();
-    } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
+    } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) {
       this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
     } else {
       decl.init = null;
     }
     node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
-    if (!this.eat(types$1.comma)) { break }
+    if (!this.eat(types.comma)) { break }
   }
   return node
 };
 
-pp$8.parseVarId = function(decl, kind) {
+pp$1.parseVarId = function(decl, kind) {
   decl.id = this.parseBindingAtom();
   this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
 };
 
-var FUNC_STATEMENT$1 = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID$1 = 4;
+var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
 
 // Parse a function declaration or literal (depending on the
 // `statement & FUNC_STATEMENT`).
 
 // Remove `allowExpressionBody` for 7.0.0, as it is only called with false
-pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
+pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
   this.initFunction(node);
   if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
-    if (this.type === types$1.star && (statement & FUNC_HANGING_STATEMENT))
+    if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))
       { this.unexpected(); }
-    node.generator = this.eat(types$1.star);
+    node.generator = this.eat(types.star);
   }
   if (this.options.ecmaVersion >= 8)
     { node.async = !!isAsync; }
 
-  if (statement & FUNC_STATEMENT$1) {
-    node.id = (statement & FUNC_NULLABLE_ID$1) && this.type !== types$1.name ? null : this.parseIdent();
+  if (statement & FUNC_STATEMENT) {
+    node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();
     if (node.id && !(statement & FUNC_HANGING_STATEMENT))
       // If it is a regular function declaration in sloppy mode, then it is
       // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
@@ -18297,8 +17280,8 @@
   this.awaitIdentPos = 0;
   this.enterScope(functionFlags(node.async, node.generator));
 
-  if (!(statement & FUNC_STATEMENT$1))
-    { node.id = this.type === types$1.name ? this.parseIdent() : null; }
+  if (!(statement & FUNC_STATEMENT))
+    { node.id = this.type === types.name ? this.parseIdent() : null; }
 
   this.parseFunctionParams(node);
   this.parseFunctionBody(node, allowExpressionBody, false, forInit);
@@ -18306,19 +17289,19 @@
   this.yieldPos = oldYieldPos;
   this.awaitPos = oldAwaitPos;
   this.awaitIdentPos = oldAwaitIdentPos;
-  return this.finishNode(node, (statement & FUNC_STATEMENT$1) ? "FunctionDeclaration" : "FunctionExpression")
+  return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
 };
 
-pp$8.parseFunctionParams = function(node) {
-  this.expect(types$1.parenL);
-  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
+pp$1.parseFunctionParams = function(node) {
+  this.expect(types.parenL);
+  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
   this.checkYieldAwaitInDefaultParams();
 };
 
 // Parse a class declaration or literal (depending on the
 // `isStatement` parameter).
 
-pp$8.parseClass = function(node, isStatement) {
+pp$1.parseClass = function(node, isStatement) {
   this.next();
 
   // ecma-262 14.6 Class Definitions
@@ -18332,8 +17315,8 @@
   var classBody = this.startNode();
   var hadConstructor = false;
   classBody.body = [];
-  this.expect(types$1.braceL);
-  while (this.type !== types$1.braceR) {
+  this.expect(types.braceL);
+  while (this.type !== types.braceR) {
     var element = this.parseClassElement(node.superClass !== null);
     if (element) {
       classBody.body.push(element);
@@ -18352,8 +17335,8 @@
   return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
 };
 
-pp$8.parseClassElement = function(constructorAllowsSuper) {
-  if (this.eat(types$1.semi)) { return null }
+pp$1.parseClassElement = function(constructorAllowsSuper) {
+  if (this.eat(types.semi)) { return null }
 
   var ecmaVersion = this.options.ecmaVersion;
   var node = this.startNode();
@@ -18365,11 +17348,11 @@
 
   if (this.eatContextual("static")) {
     // Parse static init block
-    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
+    if (ecmaVersion >= 13 && this.eat(types.braceL)) {
       this.parseClassStaticBlock(node);
       return node
     }
-    if (this.isClassElementNameStart() || this.type === types$1.star) {
+    if (this.isClassElementNameStart() || this.type === types.star) {
       isStatic = true;
     } else {
       keyName = "static";
@@ -18377,13 +17360,13 @@
   }
   node.static = isStatic;
   if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
-    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
+    if ((this.isClassElementNameStart() || this.type === types.star) && !this.canInsertSemicolon()) {
       isAsync = true;
     } else {
       keyName = "async";
     }
   }
-  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
+  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types.star)) {
     isGenerator = true;
   }
   if (!keyName && !isAsync && !isGenerator) {
@@ -18410,7 +17393,7 @@
   }
 
   // Parse element value
-  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
+  if (ecmaVersion < 13 || this.type === types.parenL || kind !== "method" || isGenerator || isAsync) {
     var isConstructor = !node.static && checkKeyName(node, "constructor");
     var allowsDirectSuper = isConstructor && constructorAllowsSuper;
     // Couldn't move this check into the 'parseClassMethod' method for backward compatibility.
@@ -18424,19 +17407,19 @@
   return node
 };
 
-pp$8.isClassElementNameStart = function() {
+pp$1.isClassElementNameStart = function() {
   return (
-    this.type === types$1.name ||
-    this.type === types$1.privateId ||
-    this.type === types$1.num ||
-    this.type === types$1.string ||
-    this.type === types$1.bracketL ||
+    this.type === types.name ||
+    this.type === types.privateId ||
+    this.type === types.num ||
+    this.type === types.string ||
+    this.type === types.bracketL ||
     this.type.keyword
   )
 };
 
-pp$8.parseClassElementName = function(element) {
-  if (this.type === types$1.privateId) {
+pp$1.parseClassElementName = function(element) {
+  if (this.type === types.privateId) {
     if (this.value === "constructor") {
       this.raise(this.start, "Classes can't have an element named '#constructor'");
     }
@@ -18447,7 +17430,7 @@
   }
 };
 
-pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
+pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
   // Check key and flags
   var key = method.key;
   if (method.kind === "constructor") {
@@ -18471,14 +17454,14 @@
   return this.finishNode(method, "MethodDefinition")
 };
 
-pp$8.parseClassField = function(field) {
+pp$1.parseClassField = function(field) {
   if (checkKeyName(field, "constructor")) {
     this.raise(field.key.start, "Classes can't have a field named 'constructor'");
   } else if (field.static && checkKeyName(field, "prototype")) {
     this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
   }
 
-  if (this.eat(types$1.eq)) {
+  if (this.eat(types.eq)) {
     // To raise SyntaxError if 'arguments' exists in the initializer.
     var scope = this.currentThisScope();
     var inClassFieldInit = scope.inClassFieldInit;
@@ -18493,13 +17476,13 @@
   return this.finishNode(field, "PropertyDefinition")
 };
 
-pp$8.parseClassStaticBlock = function(node) {
+pp$1.parseClassStaticBlock = function(node) {
   node.body = [];
 
   var oldLabels = this.labels;
   this.labels = [];
   this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
-  while (this.type !== types$1.braceR) {
+  while (this.type !== types.braceR) {
     var stmt = this.parseStatement(null);
     node.body.push(stmt);
   }
@@ -18510,8 +17493,8 @@
   return this.finishNode(node, "StaticBlock")
 };
 
-pp$8.parseClassId = function(node, isStatement) {
-  if (this.type === types$1.name) {
+pp$1.parseClassId = function(node, isStatement) {
+  if (this.type === types.name) {
     node.id = this.parseIdent();
     if (isStatement)
       { this.checkLValSimple(node.id, BIND_LEXICAL, false); }
@@ -18522,17 +17505,17 @@
   }
 };
 
-pp$8.parseClassSuper = function(node) {
-  node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(false) : null;
+pp$1.parseClassSuper = function(node) {
+  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts(false) : null;
 };
 
-pp$8.enterClassBody = function() {
+pp$1.enterClassBody = function() {
   var element = {declared: Object.create(null), used: []};
   this.privateNameStack.push(element);
   return element.declared
 };
 
-pp$8.exitClassBody = function() {
+pp$1.exitClassBody = function() {
   var ref = this.privateNameStack.pop();
   var declared = ref.declared;
   var used = ref.used;
@@ -18540,7 +17523,7 @@
   var parent = len === 0 ? null : this.privateNameStack[len - 1];
   for (var i = 0; i < used.length; ++i) {
     var id = used[i];
-    if (!hasOwn(declared, id.name)) {
+    if (!has(declared, id.name)) {
       if (parent) {
         parent.used.push(id);
       } else {
@@ -18587,33 +17570,33 @@
 
 // Parses module export declaration.
 
-pp$8.parseExport = function(node, exports) {
+pp$1.parseExport = function(node, exports) {
   this.next();
   // export * from '...'
-  if (this.eat(types$1.star)) {
+  if (this.eat(types.star)) {
     if (this.options.ecmaVersion >= 11) {
       if (this.eatContextual("as")) {
-        node.exported = this.parseModuleExportName();
-        this.checkExport(exports, node.exported, this.lastTokStart);
+        node.exported = this.parseIdent(true);
+        this.checkExport(exports, node.exported.name, this.lastTokStart);
       } else {
         node.exported = null;
       }
     }
     this.expectContextual("from");
-    if (this.type !== types$1.string) { this.unexpected(); }
+    if (this.type !== types.string) { this.unexpected(); }
     node.source = this.parseExprAtom();
     this.semicolon();
     return this.finishNode(node, "ExportAllDeclaration")
   }
-  if (this.eat(types$1._default)) { // export default ...
+  if (this.eat(types._default)) { // export default ...
     this.checkExport(exports, "default", this.lastTokStart);
     var isAsync;
-    if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
+    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
       var fNode = this.startNode();
       this.next();
       if (isAsync) { this.next(); }
-      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT$1 | FUNC_NULLABLE_ID$1, false, isAsync);
-    } else if (this.type === types$1._class) {
+      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
+    } else if (this.type === types._class) {
       var cNode = this.startNode();
       node.declaration = this.parseClass(cNode, "nullableID");
     } else {
@@ -18628,14 +17611,14 @@
     if (node.declaration.type === "VariableDeclaration")
       { this.checkVariableExport(exports, node.declaration.declarations); }
     else
-      { this.checkExport(exports, node.declaration.id, node.declaration.id.start); }
+      { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
     node.specifiers = [];
     node.source = null;
   } else { // export { x, y as z } [from '...']
     node.declaration = null;
     node.specifiers = this.parseExportSpecifiers(exports);
     if (this.eatContextual("from")) {
-      if (this.type !== types$1.string) { this.unexpected(); }
+      if (this.type !== types.string) { this.unexpected(); }
       node.source = this.parseExprAtom();
     } else {
       for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
@@ -18645,10 +17628,6 @@
         this.checkUnreserved(spec.local);
         // check if export is defined
         this.checkLocalExport(spec.local);
-
-        if (spec.local.type === "Literal") {
-          this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
-        }
       }
 
       node.source = null;
@@ -18658,19 +17637,17 @@
   return this.finishNode(node, "ExportNamedDeclaration")
 };
 
-pp$8.checkExport = function(exports, name, pos) {
+pp$1.checkExport = function(exports, name, pos) {
   if (!exports) { return }
-  if (typeof name !== "string")
-    { name = name.type === "Identifier" ? name.name : name.value; }
-  if (hasOwn(exports, name))
+  if (has(exports, name))
     { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
   exports[name] = true;
 };
 
-pp$8.checkPatternExport = function(exports, pat) {
+pp$1.checkPatternExport = function(exports, pat) {
   var type = pat.type;
   if (type === "Identifier")
-    { this.checkExport(exports, pat, pat.start); }
+    { this.checkExport(exports, pat.name, pat.start); }
   else if (type === "ObjectPattern")
     { for (var i = 0, list = pat.properties; i < list.length; i += 1)
       {
@@ -18694,7 +17671,7 @@
     { this.checkPatternExport(exports, pat.expression); }
 };
 
-pp$8.checkVariableExport = function(exports, decls) {
+pp$1.checkVariableExport = function(exports, decls) {
   if (!exports) { return }
   for (var i = 0, list = decls; i < list.length; i += 1)
     {
@@ -18704,7 +17681,7 @@
   }
 };
 
-pp$8.shouldParseExportStatement = function() {
+pp$1.shouldParseExportStatement = function() {
   return this.type.keyword === "var" ||
     this.type.keyword === "const" ||
     this.type.keyword === "class" ||
@@ -18715,24 +17692,20 @@
 
 // Parses a comma-separated list of module exports.
 
-pp$8.parseExportSpecifiers = function(exports) {
+pp$1.parseExportSpecifiers = function(exports) {
   var nodes = [], first = true;
   // export { x, y as z } [from '...']
-  this.expect(types$1.braceL);
-  while (!this.eat(types$1.braceR)) {
+  this.expect(types.braceL);
+  while (!this.eat(types.braceR)) {
     if (!first) {
-      this.expect(types$1.comma);
-      if (this.afterTrailingComma(types$1.braceR)) { break }
+      this.expect(types.comma);
+      if (this.afterTrailingComma(types.braceR)) { break }
     } else { first = false; }
 
     var node = this.startNode();
-    node.local = this.parseModuleExportName();
-    node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
-    this.checkExport(
-      exports,
-      node.exported,
-      node.exported.start
-    );
+    node.local = this.parseIdent(true);
+    node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
+    this.checkExport(exports, node.exported.name, node.exported.start);
     nodes.push(this.finishNode(node, "ExportSpecifier"));
   }
   return nodes
@@ -18740,16 +17713,16 @@
 
 // Parses import declaration.
 
-pp$8.parseImport = function(node) {
+pp$1.parseImport = function(node) {
   this.next();
   // import '...'
-  if (this.type === types$1.string) {
-    node.specifiers = empty$1;
+  if (this.type === types.string) {
+    node.specifiers = empty;
     node.source = this.parseExprAtom();
   } else {
     node.specifiers = this.parseImportSpecifiers();
     this.expectContextual("from");
-    node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
+    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
   }
   this.semicolon();
   return this.finishNode(node, "ImportDeclaration")
@@ -18757,17 +17730,17 @@
 
 // Parses a comma-separated list of module imports.
 
-pp$8.parseImportSpecifiers = function() {
+pp$1.parseImportSpecifiers = function() {
   var nodes = [], first = true;
-  if (this.type === types$1.name) {
+  if (this.type === types.name) {
     // import defaultObj, { x, y as z } from '...'
     var node = this.startNode();
     node.local = this.parseIdent();
     this.checkLValSimple(node.local, BIND_LEXICAL);
     nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
-    if (!this.eat(types$1.comma)) { return nodes }
+    if (!this.eat(types.comma)) { return nodes }
   }
-  if (this.type === types$1.star) {
+  if (this.type === types.star) {
     var node$1 = this.startNode();
     this.next();
     this.expectContextual("as");
@@ -18776,15 +17749,15 @@
     nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
     return nodes
   }
-  this.expect(types$1.braceL);
-  while (!this.eat(types$1.braceR)) {
+  this.expect(types.braceL);
+  while (!this.eat(types.braceR)) {
     if (!first) {
-      this.expect(types$1.comma);
-      if (this.afterTrailingComma(types$1.braceR)) { break }
+      this.expect(types.comma);
+      if (this.afterTrailingComma(types.braceR)) { break }
     } else { first = false; }
 
     var node$2 = this.startNode();
-    node$2.imported = this.parseModuleExportName();
+    node$2.imported = this.parseIdent(true);
     if (this.eatContextual("as")) {
       node$2.local = this.parseIdent();
     } else {
@@ -18797,26 +17770,14 @@
   return nodes
 };
 
-pp$8.parseModuleExportName = function() {
-  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
-    var stringLiteral = this.parseLiteral(this.value);
-    if (loneSurrogate.test(stringLiteral.value)) {
-      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
-    }
-    return stringLiteral
-  }
-  return this.parseIdent(true)
-};
-
 // Set `ExpressionStatement#directive` property for directive prologues.
-pp$8.adaptDirectivePrologue = function(statements) {
+pp$1.adaptDirectivePrologue = function(statements) {
   for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
     statements[i].directive = statements[i].expression.raw.slice(1, -1);
   }
 };
-pp$8.isDirectiveCandidate = function(statement) {
+pp$1.isDirectiveCandidate = function(statement) {
   return (
-    this.options.ecmaVersion >= 5 &&
     statement.type === "ExpressionStatement" &&
     statement.expression.type === "Literal" &&
     typeof statement.expression.value === "string" &&
@@ -18825,12 +17786,12 @@
   )
 };
 
-var pp$7 = Parser.prototype;
+var pp$2 = Parser.prototype;
 
 // Convert existing expression atom to assignable pattern
 // if possible.
 
-pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
+pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
   if (this.options.ecmaVersion >= 6 && node) {
     switch (node.type) {
     case "Identifier":
@@ -18911,7 +17872,7 @@
 
 // Convert list of expression atoms to binding list.
 
-pp$7.toAssignableList = function(exprList, isBinding) {
+pp$2.toAssignableList = function(exprList, isBinding) {
   var end = exprList.length;
   for (var i = 0; i < end; i++) {
     var elt = exprList[i];
@@ -18927,19 +17888,19 @@
 
 // Parses spread element.
 
-pp$7.parseSpread = function(refDestructuringErrors) {
+pp$2.parseSpread = function(refDestructuringErrors) {
   var node = this.startNode();
   this.next();
   node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
   return this.finishNode(node, "SpreadElement")
 };
 
-pp$7.parseRestBinding = function() {
+pp$2.parseRestBinding = function() {
   var node = this.startNode();
   this.next();
 
   // RestElement inside of a function parameter must be an identifier
-  if (this.options.ecmaVersion === 6 && this.type !== types$1.name)
+  if (this.options.ecmaVersion === 6 && this.type !== types.name)
     { this.unexpected(); }
 
   node.argument = this.parseBindingAtom();
@@ -18949,36 +17910,36 @@
 
 // Parses lvalue (assignable) atom.
 
-pp$7.parseBindingAtom = function() {
+pp$2.parseBindingAtom = function() {
   if (this.options.ecmaVersion >= 6) {
     switch (this.type) {
-    case types$1.bracketL:
+    case types.bracketL:
       var node = this.startNode();
       this.next();
-      node.elements = this.parseBindingList(types$1.bracketR, true, true);
+      node.elements = this.parseBindingList(types.bracketR, true, true);
       return this.finishNode(node, "ArrayPattern")
 
-    case types$1.braceL:
+    case types.braceL:
       return this.parseObj(true)
     }
   }
   return this.parseIdent()
 };
 
-pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
+pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
   var elts = [], first = true;
   while (!this.eat(close)) {
     if (first) { first = false; }
-    else { this.expect(types$1.comma); }
-    if (allowEmpty && this.type === types$1.comma) {
+    else { this.expect(types.comma); }
+    if (allowEmpty && this.type === types.comma) {
       elts.push(null);
     } else if (allowTrailingComma && this.afterTrailingComma(close)) {
       break
-    } else if (this.type === types$1.ellipsis) {
+    } else if (this.type === types.ellipsis) {
       var rest = this.parseRestBinding();
       this.parseBindingListItem(rest);
       elts.push(rest);
-      if (this.type === types$1.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
+      if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
       this.expect(close);
       break
     } else {
@@ -18990,15 +17951,15 @@
   return elts
 };
 
-pp$7.parseBindingListItem = function(param) {
+pp$2.parseBindingListItem = function(param) {
   return param
 };
 
 // Parses assignment pattern around given atom if possible.
 
-pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
+pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
   left = left || this.parseBindingAtom();
-  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) { return left }
+  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }
   var node = this.startNodeAt(startPos, startLoc);
   node.left = left;
   node.right = this.parseMaybeAssign();
@@ -19069,7 +18030,7 @@
 // duplicate argument names. checkClashes is ignored if the provided construct
 // is an assignment (i.e., bindingType is BIND_NONE).
 
-pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
+pp$2.checkLValSimple = function(expr, bindingType, checkClashes) {
   if ( bindingType === void 0 ) bindingType = BIND_NONE;
 
   var isBind = bindingType !== BIND_NONE;
@@ -19082,7 +18043,7 @@
       if (bindingType === BIND_LEXICAL && expr.name === "let")
         { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
       if (checkClashes) {
-        if (hasOwn(checkClashes, expr.name))
+        if (has(checkClashes, expr.name))
           { this.raiseRecoverable(expr.start, "Argument name clash"); }
         checkClashes[expr.name] = true;
       }
@@ -19107,7 +18068,7 @@
   }
 };
 
-pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
+pp$2.checkLValPattern = function(expr, bindingType, checkClashes) {
   if ( bindingType === void 0 ) bindingType = BIND_NONE;
 
   switch (expr.type) {
@@ -19132,7 +18093,7 @@
   }
 };
 
-pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
+pp$2.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
   if ( bindingType === void 0 ) bindingType = BIND_NONE;
 
   switch (expr.type) {
@@ -19164,7 +18125,7 @@
   this.generator = !!generator;
 };
 
-var types = {
+var types$1 = {
   b_stat: new TokContext("{", false),
   b_expr: new TokContext("{", true),
   b_tmpl: new TokContext("${", false),
@@ -19177,38 +18138,38 @@
   f_gen: new TokContext("function", false, false, null, true)
 };
 
-var pp$6 = Parser.prototype;
+var pp$3 = Parser.prototype;
 
-pp$6.initialContext = function() {
-  return [types.b_stat]
+pp$3.initialContext = function() {
+  return [types$1.b_stat]
 };
 
-pp$6.curContext = function() {
+pp$3.curContext = function() {
   return this.context[this.context.length - 1]
 };
 
-pp$6.braceIsBlock = function(prevType) {
+pp$3.braceIsBlock = function(prevType) {
   var parent = this.curContext();
-  if (parent === types.f_expr || parent === types.f_stat)
+  if (parent === types$1.f_expr || parent === types$1.f_stat)
     { return true }
-  if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr))
+  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))
     { return !parent.isExpr }
 
   // The check for `tt.name && exprAllowed` detects whether we are
   // after a `yield` or `of` construct. See the `updateContext` for
   // `tt.name`.
-  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed)
+  if (prevType === types._return || prevType === types.name && this.exprAllowed)
     { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
-  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow)
+  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)
     { return true }
-  if (prevType === types$1.braceL)
-    { return parent === types.b_stat }
-  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name)
+  if (prevType === types.braceL)
+    { return parent === types$1.b_stat }
+  if (prevType === types._var || prevType === types._const || prevType === types.name)
     { return false }
   return !this.exprAllowed
 };
 
-pp$6.inGeneratorContext = function() {
+pp$3.inGeneratorContext = function() {
   for (var i = this.context.length - 1; i >= 1; i--) {
     var context = this.context[i];
     if (context.token === "function")
@@ -19217,9 +18178,9 @@
   return false
 };
 
-pp$6.updateContext = function(prevType) {
+pp$3.updateContext = function(prevType) {
   var update, type = this.type;
-  if (type.keyword && prevType === types$1.dot)
+  if (type.keyword && prevType === types.dot)
     { this.exprAllowed = false; }
   else if (update = type.updateContext)
     { update.call(this, prevType); }
@@ -19227,9 +18188,8 @@
     { this.exprAllowed = type.beforeExpr; }
 };
 
-// Used to handle egde cases when token context could not be inferred correctly during tokenization phase
-
-pp$6.overrideContext = function(tokenCtx) {
+// Used to handle egde case when token context could not be inferred correctly in tokenize phase
+pp$3.overrideContext = function(tokenCtx) {
   if (this.curContext() !== tokenCtx) {
     this.context[this.context.length - 1] = tokenCtx;
   }
@@ -19237,71 +18197,71 @@
 
 // Token-specific context update code
 
-types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
+types.parenR.updateContext = types.braceR.updateContext = function() {
   if (this.context.length === 1) {
     this.exprAllowed = true;
     return
   }
   var out = this.context.pop();
-  if (out === types.b_stat && this.curContext().token === "function") {
+  if (out === types$1.b_stat && this.curContext().token === "function") {
     out = this.context.pop();
   }
   this.exprAllowed = !out.isExpr;
 };
 
-types$1.braceL.updateContext = function(prevType) {
-  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
+types.braceL.updateContext = function(prevType) {
+  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
   this.exprAllowed = true;
 };
 
-types$1.dollarBraceL.updateContext = function() {
-  this.context.push(types.b_tmpl);
+types.dollarBraceL.updateContext = function() {
+  this.context.push(types$1.b_tmpl);
   this.exprAllowed = true;
 };
 
-types$1.parenL.updateContext = function(prevType) {
-  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
-  this.context.push(statementParens ? types.p_stat : types.p_expr);
+types.parenL.updateContext = function(prevType) {
+  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
+  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
   this.exprAllowed = true;
 };
 
-types$1.incDec.updateContext = function() {
+types.incDec.updateContext = function() {
   // tokExprAllowed stays unchanged
 };
 
-types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
-  if (prevType.beforeExpr && prevType !== types$1._else &&
-      !(prevType === types$1.semi && this.curContext() !== types.p_stat) &&
-      !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
-      !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat))
-    { this.context.push(types.f_expr); }
+types._function.updateContext = types._class.updateContext = function(prevType) {
+  if (prevType.beforeExpr && prevType !== types._else &&
+      !(prevType === types.semi && this.curContext() !== types$1.p_stat) &&
+      !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
+      !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))
+    { this.context.push(types$1.f_expr); }
   else
-    { this.context.push(types.f_stat); }
+    { this.context.push(types$1.f_stat); }
   this.exprAllowed = false;
 };
 
-types$1.backQuote.updateContext = function() {
-  if (this.curContext() === types.q_tmpl)
+types.backQuote.updateContext = function() {
+  if (this.curContext() === types$1.q_tmpl)
     { this.context.pop(); }
   else
-    { this.context.push(types.q_tmpl); }
+    { this.context.push(types$1.q_tmpl); }
   this.exprAllowed = false;
 };
 
-types$1.star.updateContext = function(prevType) {
-  if (prevType === types$1._function) {
+types.star.updateContext = function(prevType) {
+  if (prevType === types._function) {
     var index = this.context.length - 1;
-    if (this.context[index] === types.f_expr)
-      { this.context[index] = types.f_expr_gen; }
+    if (this.context[index] === types$1.f_expr)
+      { this.context[index] = types$1.f_expr_gen; }
     else
-      { this.context[index] = types.f_gen; }
+      { this.context[index] = types$1.f_gen; }
   }
   this.exprAllowed = true;
 };
 
-types$1.name.updateContext = function(prevType) {
+types.name.updateContext = function(prevType) {
   var allowed = false;
-  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
+  if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
     if (this.value === "of" && !this.exprAllowed ||
         this.value === "yield" && this.inGeneratorContext())
       { allowed = true; }
@@ -19311,14 +18271,14 @@
 
 // A recursive descent parser operates by defining functions for all
 
-var pp$5 = Parser.prototype;
+var pp$4 = Parser.prototype;
 
 // Check if property name clashes with already added.
 // Object/class getters and setters are not allowed to clash —
 // either with each other or with an init property — and in
 // strict mode, init properties are also not allowed to be repeated.
 
-pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
+pp$4.checkPropClash = function(prop, propHash, refDestructuringErrors) {
   if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
     { return }
   if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
@@ -19335,12 +18295,10 @@
     if (name === "__proto__" && kind === "init") {
       if (propHash.proto) {
         if (refDestructuringErrors) {
-          if (refDestructuringErrors.doubleProto < 0) {
-            refDestructuringErrors.doubleProto = key.start;
-          }
-        } else {
-          this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
-        }
+          if (refDestructuringErrors.doubleProto < 0)
+            { refDestructuringErrors.doubleProto = key.start; }
+          // Backwards-compat kludge. Can be removed in version 6.0
+        } else { this.raiseRecoverable(key.start, "Redefinition of __proto__ property"); }
       }
       propHash.proto = true;
     }
@@ -19382,13 +18340,13 @@
 // and object pattern might appear (so it's possible to raise
 // delayed syntax error at correct position).
 
-pp$5.parseExpression = function(forInit, refDestructuringErrors) {
+pp$4.parseExpression = function(forInit, refDestructuringErrors) {
   var startPos = this.start, startLoc = this.startLoc;
   var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
-  if (this.type === types$1.comma) {
+  if (this.type === types.comma) {
     var node = this.startNodeAt(startPos, startLoc);
     node.expressions = [expr];
-    while (this.eat(types$1.comma)) { node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors)); }
+    while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors)); }
     return this.finishNode(node, "SequenceExpression")
   }
   return expr
@@ -19397,7 +18355,7 @@
 // Parse an assignment expression. This includes applications of
 // operators like `+=`.
 
-pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
+pp$4.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
   if (this.isContextual("yield")) {
     if (this.inGenerator) { return this.parseYield(forInit) }
     // The tokenizer will assume an expression is allowed after
@@ -19405,11 +18363,10 @@
     else { this.exprAllowed = false; }
   }
 
-  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
+  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;
   if (refDestructuringErrors) {
     oldParenAssign = refDestructuringErrors.parenthesizedAssign;
     oldTrailingComma = refDestructuringErrors.trailingComma;
-    oldDoubleProto = refDestructuringErrors.doubleProto;
     refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
   } else {
     refDestructuringErrors = new DestructuringErrors;
@@ -19417,7 +18374,7 @@
   }
 
   var startPos = this.start, startLoc = this.startLoc;
-  if (this.type === types$1.parenL || this.type === types$1.name) {
+  if (this.type === types.parenL || this.type === types.name) {
     this.potentialArrowAt = this.start;
     this.potentialArrowInForAwait = forInit === "await";
   }
@@ -19426,21 +18383,20 @@
   if (this.type.isAssign) {
     var node = this.startNodeAt(startPos, startLoc);
     node.operator = this.value;
-    if (this.type === types$1.eq)
+    if (this.type === types.eq)
       { left = this.toAssignable(left, false, refDestructuringErrors); }
     if (!ownDestructuringErrors) {
       refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
     }
     if (refDestructuringErrors.shorthandAssign >= left.start)
       { refDestructuringErrors.shorthandAssign = -1; } // reset because shorthand default was used correctly
-    if (this.type === types$1.eq)
+    if (this.type === types.eq)
       { this.checkLValPattern(left); }
     else
       { this.checkLValSimple(left); }
     node.left = left;
     this.next();
     node.right = this.parseMaybeAssign(forInit);
-    if (oldDoubleProto > -1) { refDestructuringErrors.doubleProto = oldDoubleProto; }
     return this.finishNode(node, "AssignmentExpression")
   } else {
     if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
@@ -19452,15 +18408,15 @@
 
 // Parse a ternary conditional (`?:`) operator.
 
-pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
+pp$4.parseMaybeConditional = function(forInit, refDestructuringErrors) {
   var startPos = this.start, startLoc = this.startLoc;
   var expr = this.parseExprOps(forInit, refDestructuringErrors);
   if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
-  if (this.eat(types$1.question)) {
+  if (this.eat(types.question)) {
     var node = this.startNodeAt(startPos, startLoc);
     node.test = expr;
     node.consequent = this.parseMaybeAssign();
-    this.expect(types$1.colon);
+    this.expect(types.colon);
     node.alternate = this.parseMaybeAssign(forInit);
     return this.finishNode(node, "ConditionalExpression")
   }
@@ -19469,7 +18425,7 @@
 
 // Start the precedence parser.
 
-pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
+pp$4.parseExprOps = function(forInit, refDestructuringErrors) {
   var startPos = this.start, startLoc = this.startLoc;
   var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
   if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
@@ -19482,23 +18438,23 @@
 // defer further parser to one of its callers when it encounters an
 // operator that has a lower precedence than the set it is parsing.
 
-pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
+pp$4.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
   var prec = this.type.binop;
-  if (prec != null && (!forInit || this.type !== types$1._in)) {
+  if (prec != null && (!forInit || this.type !== types._in)) {
     if (prec > minPrec) {
-      var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
-      var coalesce = this.type === types$1.coalesce;
+      var logical = this.type === types.logicalOR || this.type === types.logicalAND;
+      var coalesce = this.type === types.coalesce;
       if (coalesce) {
         // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.
         // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.
-        prec = types$1.logicalAND.binop;
+        prec = types.logicalAND.binop;
       }
       var op = this.value;
       this.next();
       var startPos = this.start, startLoc = this.startLoc;
       var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
       var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
-      if ((logical && this.type === types$1.coalesce) || (coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND))) {
+      if ((logical && this.type === types.coalesce) || (coalesce && (this.type === types.logicalOR || this.type === types.logicalAND))) {
         this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
       }
       return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit)
@@ -19507,8 +18463,7 @@
   return left
 };
 
-pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
-  if (right.type === "PrivateIdentifier") { this.raise(right.start, "Private identifier can only be left side of binary expression"); }
+pp$4.buildBinary = function(startPos, startLoc, left, right, op, logical) {
   var node = this.startNodeAt(startPos, startLoc);
   node.left = left;
   node.operator = op;
@@ -19518,13 +18473,13 @@
 
 // Parse unary operators, both prefix and postfix.
 
-pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
+pp$4.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
   var startPos = this.start, startLoc = this.startLoc, expr;
   if (this.isContextual("await") && this.canAwait) {
     expr = this.parseAwait(forInit);
     sawUnary = true;
   } else if (this.type.prefix) {
-    var node = this.startNode(), update = this.type === types$1.incDec;
+    var node = this.startNode(), update = this.type === types.incDec;
     node.operator = this.value;
     node.prefix = true;
     this.next();
@@ -19538,11 +18493,6 @@
       { this.raiseRecoverable(node.start, "Private fields can not be deleted"); }
     else { sawUnary = true; }
     expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
-  } else if (!sawUnary && this.type === types$1.privateId) {
-    if (forInit || this.privateNameStack.length === 0) { this.unexpected(); }
-    expr = this.parsePrivateIdent();
-    // only could be private fields in 'in', such as #x in obj
-    if (this.type !== types$1._in) { this.unexpected(); }
   } else {
     expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
     if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
@@ -19557,7 +18507,7 @@
     }
   }
 
-  if (!incDec && this.eat(types$1.starstar)) {
+  if (!incDec && this.eat(types.starstar)) {
     if (sawUnary)
       { this.unexpected(this.lastTokStart); }
     else
@@ -19576,7 +18526,7 @@
 
 // Parse call, dot, and `[]`-subscript expressions.
 
-pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
+pp$4.parseExprSubscripts = function(refDestructuringErrors, forInit) {
   var startPos = this.start, startLoc = this.startLoc;
   var expr = this.parseExprAtom(refDestructuringErrors, forInit);
   if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
@@ -19590,7 +18540,7 @@
   return result
 };
 
-pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
+pp$4.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
   var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
       this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&
       this.potentialArrowAt === base.start;
@@ -19613,19 +18563,19 @@
   }
 };
 
-pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
+pp$4.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
   var optionalSupported = this.options.ecmaVersion >= 11;
-  var optional = optionalSupported && this.eat(types$1.questionDot);
+  var optional = optionalSupported && this.eat(types.questionDot);
   if (noCalls && optional) { this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions"); }
 
-  var computed = this.eat(types$1.bracketL);
-  if (computed || (optional && this.type !== types$1.parenL && this.type !== types$1.backQuote) || this.eat(types$1.dot)) {
+  var computed = this.eat(types.bracketL);
+  if (computed || (optional && this.type !== types.parenL && this.type !== types.backQuote) || this.eat(types.dot)) {
     var node = this.startNodeAt(startPos, startLoc);
     node.object = base;
     if (computed) {
       node.property = this.parseExpression();
-      this.expect(types$1.bracketR);
-    } else if (this.type === types$1.privateId && base.type !== "Super") {
+      this.expect(types.bracketR);
+    } else if (this.type === types.privateId && base.type !== "Super") {
       node.property = this.parsePrivateIdent();
     } else {
       node.property = this.parseIdent(this.options.allowReserved !== "never");
@@ -19635,13 +18585,13 @@
       node.optional = optional;
     }
     base = this.finishNode(node, "MemberExpression");
-  } else if (!noCalls && this.eat(types$1.parenL)) {
+  } else if (!noCalls && this.eat(types.parenL)) {
     var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
     this.yieldPos = 0;
     this.awaitPos = 0;
     this.awaitIdentPos = 0;
-    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
-    if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
+    var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
+    if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types.arrow)) {
       this.checkPatternErrors(refDestructuringErrors, false);
       this.checkYieldAwaitInDefaultParams();
       if (this.awaitIdentPos > 0)
@@ -19662,7 +18612,7 @@
       node$1.optional = optional;
     }
     base = this.finishNode(node$1, "CallExpression");
-  } else if (this.type === types$1.backQuote) {
+  } else if (this.type === types.backQuote) {
     if (optional || optionalChained) {
       this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
     }
@@ -19679,19 +18629,19 @@
 // `new`, or an expression wrapped in punctuation like `()`, `[]`,
 // or `{}`.
 
-pp$5.parseExprAtom = function(refDestructuringErrors, forInit) {
+pp$4.parseExprAtom = function(refDestructuringErrors, forInit) {
   // If a division operator appears in an expression position, the
   // tokenizer got confused, and we force it to read a regexp instead.
-  if (this.type === types$1.slash) { this.readRegexp(); }
+  if (this.type === types.slash) { this.readRegexp(); }
 
   var node, canBeArrow = this.potentialArrowAt === this.start;
   switch (this.type) {
-  case types$1._super:
+  case types._super:
     if (!this.allowSuper)
       { this.raise(this.start, "'super' keyword outside a method"); }
     node = this.startNode();
     this.next();
-    if (this.type === types$1.parenL && !this.allowDirectSuper)
+    if (this.type === types.parenL && !this.allowDirectSuper)
       { this.raise(node.start, "super() call outside constructor of a subclass"); }
     // The `super` keyword can appear at below:
     // SuperProperty:
@@ -19699,52 +18649,52 @@
     //     super . IdentifierName
     // SuperCall:
     //     super ( Arguments )
-    if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL)
+    if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)
       { this.unexpected(); }
     return this.finishNode(node, "Super")
 
-  case types$1._this:
+  case types._this:
     node = this.startNode();
     this.next();
     return this.finishNode(node, "ThisExpression")
 
-  case types$1.name:
+  case types.name:
     var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
     var id = this.parseIdent(false);
-    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
-      this.overrideContext(types.f_expr);
+    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function)) {
+      this.overrideContext(types$1.f_expr);
       return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit)
     }
     if (canBeArrow && !this.canInsertSemicolon()) {
-      if (this.eat(types$1.arrow))
+      if (this.eat(types.arrow))
         { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit) }
-      if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc &&
+      if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc &&
           (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
         id = this.parseIdent(false);
-        if (this.canInsertSemicolon() || !this.eat(types$1.arrow))
+        if (this.canInsertSemicolon() || !this.eat(types.arrow))
           { this.unexpected(); }
         return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit)
       }
     }
     return id
 
-  case types$1.regexp:
+  case types.regexp:
     var value = this.value;
     node = this.parseLiteral(value.value);
     node.regex = {pattern: value.pattern, flags: value.flags};
     return node
 
-  case types$1.num: case types$1.string:
+  case types.num: case types.string:
     return this.parseLiteral(this.value)
 
-  case types$1._null: case types$1._true: case types$1._false:
+  case types._null: case types._true: case types._false:
     node = this.startNode();
-    node.value = this.type === types$1._null ? null : this.type === types$1._true;
+    node.value = this.type === types._null ? null : this.type === types._true;
     node.raw = this.type.keyword;
     this.next();
     return this.finishNode(node, "Literal")
 
-  case types$1.parenL:
+  case types.parenL:
     var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
     if (refDestructuringErrors) {
       if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
@@ -19754,31 +18704,31 @@
     }
     return expr
 
-  case types$1.bracketL:
+  case types.bracketL:
     node = this.startNode();
     this.next();
-    node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
+    node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
     return this.finishNode(node, "ArrayExpression")
 
-  case types$1.braceL:
-    this.overrideContext(types.b_expr);
+  case types.braceL:
+    this.overrideContext(types$1.b_expr);
     return this.parseObj(false, refDestructuringErrors)
 
-  case types$1._function:
+  case types._function:
     node = this.startNode();
     this.next();
     return this.parseFunction(node, 0)
 
-  case types$1._class:
+  case types._class:
     return this.parseClass(this.startNode(), false)
 
-  case types$1._new:
+  case types._new:
     return this.parseNew()
 
-  case types$1.backQuote:
+  case types.backQuote:
     return this.parseTemplate()
 
-  case types$1._import:
+  case types._import:
     if (this.options.ecmaVersion >= 11) {
       return this.parseExprImport()
     } else {
@@ -19790,7 +18740,7 @@
   }
 };
 
-pp$5.parseExprImport = function() {
+pp$4.parseExprImport = function() {
   var node = this.startNode();
 
   // Consume `import` as an identifier for `import.meta`.
@@ -19799,9 +18749,9 @@
   var meta = this.parseIdent(true);
 
   switch (this.type) {
-  case types$1.parenL:
+  case types.parenL:
     return this.parseDynamicImport(node)
-  case types$1.dot:
+  case types.dot:
     node.meta = meta;
     return this.parseImportMeta(node)
   default:
@@ -19809,16 +18759,16 @@
   }
 };
 
-pp$5.parseDynamicImport = function(node) {
+pp$4.parseDynamicImport = function(node) {
   this.next(); // skip `(`
 
   // Parse node.source.
   node.source = this.parseMaybeAssign();
 
   // Verify ending.
-  if (!this.eat(types$1.parenR)) {
+  if (!this.eat(types.parenR)) {
     var errorPos = this.start;
-    if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
+    if (this.eat(types.comma) && this.eat(types.parenR)) {
       this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
     } else {
       this.unexpected(errorPos);
@@ -19828,7 +18778,7 @@
   return this.finishNode(node, "ImportExpression")
 };
 
-pp$5.parseImportMeta = function(node) {
+pp$4.parseImportMeta = function(node) {
   this.next(); // skip `.`
 
   var containsEsc = this.containsEsc;
@@ -19844,7 +18794,7 @@
   return this.finishNode(node, "MetaProperty")
 };
 
-pp$5.parseLiteral = function(value) {
+pp$4.parseLiteral = function(value) {
   var node = this.startNode();
   node.value = value;
   node.raw = this.input.slice(this.start, this.end);
@@ -19853,14 +18803,14 @@
   return this.finishNode(node, "Literal")
 };
 
-pp$5.parseParenExpression = function() {
-  this.expect(types$1.parenL);
+pp$4.parseParenExpression = function() {
+  this.expect(types.parenL);
   var val = this.parseExpression();
-  this.expect(types$1.parenR);
+  this.expect(types.parenR);
   return val
 };
 
-pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
+pp$4.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
   var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
   if (this.options.ecmaVersion >= 6) {
     this.next();
@@ -19871,24 +18821,24 @@
     this.yieldPos = 0;
     this.awaitPos = 0;
     // Do not save awaitIdentPos to allow checking awaits nested in parameters
-    while (this.type !== types$1.parenR) {
-      first ? first = false : this.expect(types$1.comma);
-      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
+    while (this.type !== types.parenR) {
+      first ? first = false : this.expect(types.comma);
+      if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
         lastIsComma = true;
         break
-      } else if (this.type === types$1.ellipsis) {
+      } else if (this.type === types.ellipsis) {
         spreadStart = this.start;
         exprList.push(this.parseParenItem(this.parseRestBinding()));
-        if (this.type === types$1.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
+        if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
         break
       } else {
         exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
       }
     }
     var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
-    this.expect(types$1.parenR);
+    this.expect(types.parenR);
 
-    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
+    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
       this.checkPatternErrors(refDestructuringErrors, false);
       this.checkYieldAwaitInDefaultParams();
       this.yieldPos = oldYieldPos;
@@ -19922,12 +18872,12 @@
   }
 };
 
-pp$5.parseParenItem = function(item) {
+pp$4.parseParenItem = function(item) {
   return item
 };
 
-pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
-  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit)
+pp$4.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
+  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, forInit)
 };
 
 // New's precedence is slightly tricky. It must allow its argument to
@@ -19936,13 +18886,13 @@
 // argument to parseSubscripts to prevent it from consuming the
 // argument list.
 
-var empty = [];
+var empty$1 = [];
 
-pp$5.parseNew = function() {
+pp$4.parseNew = function() {
   if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword new"); }
   var node = this.startNode();
   var meta = this.parseIdent(true);
-  if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {
+  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
     node.meta = meta;
     var containsEsc = this.containsEsc;
     node.property = this.parseIdent(true);
@@ -19954,23 +18904,23 @@
       { this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block"); }
     return this.finishNode(node, "MetaProperty")
   }
-  var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types$1._import;
+  var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;
   node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);
   if (isImport && node.callee.type === "ImportExpression") {
     this.raise(startPos, "Cannot use new with import()");
   }
-  if (this.eat(types$1.parenL)) { node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false); }
-  else { node.arguments = empty; }
+  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }
+  else { node.arguments = empty$1; }
   return this.finishNode(node, "NewExpression")
 };
 
 // Parse template expression.
 
-pp$5.parseTemplateElement = function(ref) {
+pp$4.parseTemplateElement = function(ref) {
   var isTagged = ref.isTagged;
 
   var elem = this.startNode();
-  if (this.type === types$1.invalidTemplate) {
+  if (this.type === types.invalidTemplate) {
     if (!isTagged) {
       this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
     }
@@ -19985,11 +18935,11 @@
     };
   }
   this.next();
-  elem.tail = this.type === types$1.backQuote;
+  elem.tail = this.type === types.backQuote;
   return this.finishNode(elem, "TemplateElement")
 };
 
-pp$5.parseTemplate = function(ref) {
+pp$4.parseTemplate = function(ref) {
   if ( ref === void 0 ) ref = {};
   var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;
 
@@ -19999,32 +18949,32 @@
   var curElt = this.parseTemplateElement({isTagged: isTagged});
   node.quasis = [curElt];
   while (!curElt.tail) {
-    if (this.type === types$1.eof) { this.raise(this.pos, "Unterminated template literal"); }
-    this.expect(types$1.dollarBraceL);
+    if (this.type === types.eof) { this.raise(this.pos, "Unterminated template literal"); }
+    this.expect(types.dollarBraceL);
     node.expressions.push(this.parseExpression());
-    this.expect(types$1.braceR);
+    this.expect(types.braceR);
     node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
   }
   this.next();
   return this.finishNode(node, "TemplateLiteral")
 };
 
-pp$5.isAsyncProp = function(prop) {
+pp$4.isAsyncProp = function(prop) {
   return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
-    (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types$1.star)) &&
+    (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&
     !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
 };
 
 // Parse an object literal or binding pattern.
 
-pp$5.parseObj = function(isPattern, refDestructuringErrors) {
+pp$4.parseObj = function(isPattern, refDestructuringErrors) {
   var node = this.startNode(), first = true, propHash = {};
   node.properties = [];
   this.next();
-  while (!this.eat(types$1.braceR)) {
+  while (!this.eat(types.braceR)) {
     if (!first) {
-      this.expect(types$1.comma);
-      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) { break }
+      this.expect(types.comma);
+      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) { break }
     } else { first = false; }
 
     var prop = this.parseProperty(isPattern, refDestructuringErrors);
@@ -20034,20 +18984,29 @@
   return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
 };
 
-pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
+pp$4.parseProperty = function(isPattern, refDestructuringErrors) {
   var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
-  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
+  if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
     if (isPattern) {
       prop.argument = this.parseIdent(false);
-      if (this.type === types$1.comma) {
+      if (this.type === types.comma) {
         this.raise(this.start, "Comma is not permitted after the rest element");
       }
       return this.finishNode(prop, "RestElement")
     }
+    // To disallow parenthesized identifier via `this.toAssignable()`.
+    if (this.type === types.parenL && refDestructuringErrors) {
+      if (refDestructuringErrors.parenthesizedAssign < 0) {
+        refDestructuringErrors.parenthesizedAssign = this.start;
+      }
+      if (refDestructuringErrors.parenthesizedBind < 0) {
+        refDestructuringErrors.parenthesizedBind = this.start;
+      }
+    }
     // Parse argument.
     prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
     // To disallow trailing comma via `this.toAssignable()`.
-    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
+    if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
       refDestructuringErrors.trailingComma = this.start;
     }
     // Finish
@@ -20061,13 +19020,13 @@
       startLoc = this.startLoc;
     }
     if (!isPattern)
-      { isGenerator = this.eat(types$1.star); }
+      { isGenerator = this.eat(types.star); }
   }
   var containsEsc = this.containsEsc;
   this.parsePropertyName(prop);
   if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
     isAsync = true;
-    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
+    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
     this.parsePropertyName(prop, refDestructuringErrors);
   } else {
     isAsync = false;
@@ -20076,14 +19035,14 @@
   return this.finishNode(prop, "Property")
 };
 
-pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
-  if ((isGenerator || isAsync) && this.type === types$1.colon)
+pp$4.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
+  if ((isGenerator || isAsync) && this.type === types.colon)
     { this.unexpected(); }
 
-  if (this.eat(types$1.colon)) {
+  if (this.eat(types.colon)) {
     prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
     prop.kind = "init";
-  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
+  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
     if (isPattern) { this.unexpected(); }
     prop.kind = "init";
     prop.method = true;
@@ -20091,7 +19050,7 @@
   } else if (!isPattern && !containsEsc &&
              this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
              (prop.key.name === "get" || prop.key.name === "set") &&
-             (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
+             (this.type !== types.comma && this.type !== types.braceR && this.type !== types.eq)) {
     if (isGenerator || isAsync) { this.unexpected(); }
     prop.kind = prop.key.name;
     this.parsePropertyName(prop);
@@ -20115,7 +19074,7 @@
     prop.kind = "init";
     if (isPattern) {
       prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
-    } else if (this.type === types$1.eq && refDestructuringErrors) {
+    } else if (this.type === types.eq && refDestructuringErrors) {
       if (refDestructuringErrors.shorthandAssign < 0)
         { refDestructuringErrors.shorthandAssign = this.start; }
       prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
@@ -20126,23 +19085,23 @@
   } else { this.unexpected(); }
 };
 
-pp$5.parsePropertyName = function(prop) {
+pp$4.parsePropertyName = function(prop) {
   if (this.options.ecmaVersion >= 6) {
-    if (this.eat(types$1.bracketL)) {
+    if (this.eat(types.bracketL)) {
       prop.computed = true;
       prop.key = this.parseMaybeAssign();
-      this.expect(types$1.bracketR);
+      this.expect(types.bracketR);
       return prop.key
     } else {
       prop.computed = false;
     }
   }
-  return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
+  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
 };
 
 // Initialize empty function node.
 
-pp$5.initFunction = function(node) {
+pp$4.initFunction = function(node) {
   node.id = null;
   if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
   if (this.options.ecmaVersion >= 8) { node.async = false; }
@@ -20150,7 +19109,7 @@
 
 // Parse object or class method.
 
-pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
+pp$4.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
   var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
 
   this.initFunction(node);
@@ -20164,8 +19123,8 @@
   this.awaitIdentPos = 0;
   this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
 
-  this.expect(types$1.parenL);
-  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
+  this.expect(types.parenL);
+  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
   this.checkYieldAwaitInDefaultParams();
   this.parseFunctionBody(node, false, true, false);
 
@@ -20177,7 +19136,7 @@
 
 // Parse arrow function expression with given parameters.
 
-pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
+pp$4.parseArrowExpression = function(node, params, isAsync, forInit) {
   var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
 
   this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
@@ -20199,8 +19158,8 @@
 
 // Parse function body and check parameters.
 
-pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
-  var isExpression = isArrowFunction && this.type !== types$1.braceL;
+pp$4.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
+  var isExpression = isArrowFunction && this.type !== types.braceL;
   var oldStrict = this.strict, useStrict = false;
 
   if (isExpression) {
@@ -20236,7 +19195,7 @@
   this.exitScope();
 };
 
-pp$5.isSimpleParamList = function(params) {
+pp$4.isSimpleParamList = function(params) {
   for (var i = 0, list = params; i < list.length; i += 1)
     {
     var param = list[i];
@@ -20249,7 +19208,7 @@
 // Checks function params for various disallowed patterns such as using "eval"
 // or "arguments" and duplicate parameters.
 
-pp$5.checkParams = function(node, allowDuplicates) {
+pp$4.checkParams = function(node, allowDuplicates) {
   var nameHash = Object.create(null);
   for (var i = 0, list = node.params; i < list.length; i += 1)
     {
@@ -20265,20 +19224,20 @@
 // nothing in between them to be parsed as `null` (which is needed
 // for array literals).
 
-pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
+pp$4.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
   var elts = [], first = true;
   while (!this.eat(close)) {
     if (!first) {
-      this.expect(types$1.comma);
+      this.expect(types.comma);
       if (allowTrailingComma && this.afterTrailingComma(close)) { break }
     } else { first = false; }
 
     var elt = (void 0);
-    if (allowEmpty && this.type === types$1.comma)
+    if (allowEmpty && this.type === types.comma)
       { elt = null; }
-    else if (this.type === types$1.ellipsis) {
+    else if (this.type === types.ellipsis) {
       elt = this.parseSpread(refDestructuringErrors);
-      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0)
+      if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)
         { refDestructuringErrors.trailingComma = this.start; }
     } else {
       elt = this.parseMaybeAssign(false, refDestructuringErrors);
@@ -20288,7 +19247,7 @@
   return elts
 };
 
-pp$5.checkUnreserved = function(ref) {
+pp$4.checkUnreserved = function(ref) {
   var start = ref.start;
   var end = ref.end;
   var name = ref.name;
@@ -20317,9 +19276,9 @@
 // when parsing properties), it will also convert keywords into
 // identifiers.
 
-pp$5.parseIdent = function(liberal, isBinding) {
+pp$4.parseIdent = function(liberal, isBinding) {
   var node = this.startNode();
-  if (this.type === types$1.name) {
+  if (this.type === types.name) {
     node.name = this.value;
   } else if (this.type.keyword) {
     node.name = this.type.keyword;
@@ -20345,9 +19304,9 @@
   return node
 };
 
-pp$5.parsePrivateIdent = function() {
+pp$4.parsePrivateIdent = function() {
   var node = this.startNode();
-  if (this.type === types$1.privateId) {
+  if (this.type === types.privateId) {
     node.name = this.value;
   } else {
     this.unexpected();
@@ -20367,22 +19326,22 @@
 
 // Parses yield expression inside generator.
 
-pp$5.parseYield = function(forInit) {
+pp$4.parseYield = function(forInit) {
   if (!this.yieldPos) { this.yieldPos = this.start; }
 
   var node = this.startNode();
   this.next();
-  if (this.type === types$1.semi || this.canInsertSemicolon() || (this.type !== types$1.star && !this.type.startsExpr)) {
+  if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {
     node.delegate = false;
     node.argument = null;
   } else {
-    node.delegate = this.eat(types$1.star);
+    node.delegate = this.eat(types.star);
     node.argument = this.parseMaybeAssign(forInit);
   }
   return this.finishNode(node, "YieldExpression")
 };
 
-pp$5.parseAwait = function(forInit) {
+pp$4.parseAwait = function(forInit) {
   if (!this.awaitPos) { this.awaitPos = this.start; }
 
   var node = this.startNode();
@@ -20391,7 +19350,7 @@
   return this.finishNode(node, "AwaitExpression")
 };
 
-var pp$4 = Parser.prototype;
+var pp$5 = Parser.prototype;
 
 // This function is used to raise exceptions on parse errors. It
 // takes an offset integer (into the current `input`) to indicate
@@ -20399,7 +19358,7 @@
 // of the error message, and then raises a `SyntaxError` with that
 // message.
 
-pp$4.raise = function(pos, message) {
+pp$5.raise = function(pos, message) {
   var loc = getLineInfo(this.input, pos);
   message += " (" + loc.line + ":" + loc.column + ")";
   var err = new SyntaxError(message);
@@ -20407,15 +19366,15 @@
   throw err
 };
 
-pp$4.raiseRecoverable = pp$4.raise;
+pp$5.raiseRecoverable = pp$5.raise;
 
-pp$4.curPosition = function() {
+pp$5.curPosition = function() {
   if (this.options.locations) {
     return new Position(this.curLine, this.pos - this.lineStart)
   }
 };
 
-var pp$3 = Parser.prototype;
+var pp$6 = Parser.prototype;
 
 var Scope = function Scope(flags) {
   this.flags = flags;
@@ -20431,22 +19390,22 @@
 
 // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.
 
-pp$3.enterScope = function(flags) {
+pp$6.enterScope = function(flags) {
   this.scopeStack.push(new Scope(flags));
 };
 
-pp$3.exitScope = function() {
+pp$6.exitScope = function() {
   this.scopeStack.pop();
 };
 
 // The spec says:
 // > At the top level of a function, or script, function declarations are
 // > treated like var declarations rather than like lexical declarations.
-pp$3.treatFunctionsAsVarInScope = function(scope) {
+pp$6.treatFunctionsAsVarInScope = function(scope) {
   return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
 };
 
-pp$3.declareName = function(name, bindingType, pos) {
+pp$6.declareName = function(name, bindingType, pos) {
   var redeclared = false;
   if (bindingType === BIND_LEXICAL) {
     var scope = this.currentScope();
@@ -20481,7 +19440,7 @@
   if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
 };
 
-pp$3.checkLocalExport = function(id) {
+pp$6.checkLocalExport = function(id) {
   // scope.functions must be empty as Module code is always strict.
   if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
       this.scopeStack[0].var.indexOf(id.name) === -1) {
@@ -20489,11 +19448,11 @@
   }
 };
 
-pp$3.currentScope = function() {
+pp$6.currentScope = function() {
   return this.scopeStack[this.scopeStack.length - 1]
 };
 
-pp$3.currentVarScope = function() {
+pp$6.currentVarScope = function() {
   for (var i = this.scopeStack.length - 1;; i--) {
     var scope = this.scopeStack[i];
     if (scope.flags & SCOPE_VAR) { return scope }
@@ -20501,7 +19460,7 @@
 };
 
 // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
-pp$3.currentThisScope = function() {
+pp$6.currentThisScope = function() {
   for (var i = this.scopeStack.length - 1;; i--) {
     var scope = this.scopeStack[i];
     if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
@@ -20522,13 +19481,13 @@
 
 // Start an AST node, attaching a start offset.
 
-var pp$2 = Parser.prototype;
+var pp$7 = Parser.prototype;
 
-pp$2.startNode = function() {
+pp$7.startNode = function() {
   return new Node(this, this.start, this.startLoc)
 };
 
-pp$2.startNodeAt = function(pos, loc) {
+pp$7.startNodeAt = function(pos, loc) {
   return new Node(this, pos, loc)
 };
 
@@ -20544,17 +19503,17 @@
   return node
 }
 
-pp$2.finishNode = function(node, type) {
+pp$7.finishNode = function(node, type) {
   return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
 };
 
 // Finish node at given position
 
-pp$2.finishNodeAt = function(node, type, pos, loc) {
+pp$7.finishNodeAt = function(node, type, pos, loc) {
   return finishNodeAt.call(this, node, type, pos, loc)
 };
 
-pp$2.copyNode = function(node) {
+pp$7.copyNode = function(node) {
   var newNode = new Node(this, node.start, this.startLoc);
   for (var prop in node) { newNode[prop] = node[prop]; }
   return newNode
@@ -20569,30 +19528,26 @@
 var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
 var ecma11BinaryProperties = ecma10BinaryProperties;
 var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
-var ecma13BinaryProperties = ecma12BinaryProperties;
 var unicodeBinaryProperties = {
   9: ecma9BinaryProperties,
   10: ecma10BinaryProperties,
   11: ecma11BinaryProperties,
-  12: ecma12BinaryProperties,
-  13: ecma13BinaryProperties
+  12: ecma12BinaryProperties
 };
 
 // #table-unicode-general-category-values
 var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
 
 // #table-unicode-script-values
-var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
+var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
 var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
 var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
 var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
-var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
 var unicodeScriptValues = {
   9: ecma9ScriptValues,
   10: ecma10ScriptValues,
   11: ecma11ScriptValues,
-  12: ecma12ScriptValues,
-  13: ecma13ScriptValues
+  12: ecma12ScriptValues
 };
 
 var data = {};
@@ -20610,19 +19565,17 @@
   d.nonBinary.sc = d.nonBinary.Script;
   d.nonBinary.scx = d.nonBinary.Script_Extensions;
 }
+buildUnicodeData(9);
+buildUnicodeData(10);
+buildUnicodeData(11);
+buildUnicodeData(12);
 
-for (var i = 0, list = [9, 10, 11, 12, 13]; i < list.length; i += 1) {
-  var ecmaVersion = list[i];
-
-  buildUnicodeData(ecmaVersion);
-}
-
-var pp$1 = Parser.prototype;
+var pp$8 = Parser.prototype;
 
 var RegExpValidationState = function RegExpValidationState(parser) {
   this.parser = parser;
   this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "");
-  this.unicodeProperties = data[parser.options.ecmaVersion >= 13 ? 13 : parser.options.ecmaVersion];
+  this.unicodeProperties = data[parser.options.ecmaVersion >= 12 ? 12 : parser.options.ecmaVersion];
   this.source = "";
   this.flags = "";
   this.start = 0;
@@ -20713,13 +19666,19 @@
   return false
 };
 
+function codePointToString(ch) {
+  if (ch <= 0xFFFF) { return String.fromCharCode(ch) }
+  ch -= 0x10000;
+  return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)
+}
+
 /**
  * Validate the flags part of a given RegExpLiteral.
  *
  * @param {RegExpValidationState} state The state to validate RegExp.
  * @returns {void}
  */
-pp$1.validateRegExpFlags = function(state) {
+pp$8.validateRegExpFlags = function(state) {
   var validFlags = state.validFlags;
   var flags = state.flags;
 
@@ -20740,7 +19699,7 @@
  * @param {RegExpValidationState} state The state to validate RegExp.
  * @returns {void}
  */
-pp$1.validateRegExpPattern = function(state) {
+pp$8.validateRegExpPattern = function(state) {
   this.regexp_pattern(state);
 
   // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
@@ -20755,7 +19714,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
-pp$1.regexp_pattern = function(state) {
+pp$8.regexp_pattern = function(state) {
   state.pos = 0;
   state.lastIntValue = 0;
   state.lastStringValue = "";
@@ -20789,7 +19748,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
-pp$1.regexp_disjunction = function(state) {
+pp$8.regexp_disjunction = function(state) {
   this.regexp_alternative(state);
   while (state.eat(0x7C /* | */)) {
     this.regexp_alternative(state);
@@ -20805,13 +19764,13 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
-pp$1.regexp_alternative = function(state) {
+pp$8.regexp_alternative = function(state) {
   while (state.pos < state.source.length && this.regexp_eatTerm(state))
     { }
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
-pp$1.regexp_eatTerm = function(state) {
+pp$8.regexp_eatTerm = function(state) {
   if (this.regexp_eatAssertion(state)) {
     // Handle `QuantifiableAssertion Quantifier` alternative.
     // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
@@ -20834,7 +19793,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
-pp$1.regexp_eatAssertion = function(state) {
+pp$8.regexp_eatAssertion = function(state) {
   var start = state.pos;
   state.lastAssertionIsQuantifiable = false;
 
@@ -20872,7 +19831,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
-pp$1.regexp_eatQuantifier = function(state, noError) {
+pp$8.regexp_eatQuantifier = function(state, noError) {
   if ( noError === void 0 ) noError = false;
 
   if (this.regexp_eatQuantifierPrefix(state, noError)) {
@@ -20883,7 +19842,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
-pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
+pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
   return (
     state.eat(0x2A /* * */) ||
     state.eat(0x2B /* + */) ||
@@ -20891,7 +19850,7 @@
     this.regexp_eatBracedQuantifier(state, noError)
   )
 };
-pp$1.regexp_eatBracedQuantifier = function(state, noError) {
+pp$8.regexp_eatBracedQuantifier = function(state, noError) {
   var start = state.pos;
   if (state.eat(0x7B /* { */)) {
     var min = 0, max = -1;
@@ -20917,7 +19876,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
-pp$1.regexp_eatAtom = function(state) {
+pp$8.regexp_eatAtom = function(state) {
   return (
     this.regexp_eatPatternCharacters(state) ||
     state.eat(0x2E /* . */) ||
@@ -20927,7 +19886,7 @@
     this.regexp_eatCapturingGroup(state)
   )
 };
-pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
+pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
   var start = state.pos;
   if (state.eat(0x5C /* \ */)) {
     if (this.regexp_eatAtomEscape(state)) {
@@ -20937,7 +19896,7 @@
   }
   return false
 };
-pp$1.regexp_eatUncapturingGroup = function(state) {
+pp$8.regexp_eatUncapturingGroup = function(state) {
   var start = state.pos;
   if (state.eat(0x28 /* ( */)) {
     if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {
@@ -20951,7 +19910,7 @@
   }
   return false
 };
-pp$1.regexp_eatCapturingGroup = function(state) {
+pp$8.regexp_eatCapturingGroup = function(state) {
   if (state.eat(0x28 /* ( */)) {
     if (this.options.ecmaVersion >= 9) {
       this.regexp_groupSpecifier(state);
@@ -20969,7 +19928,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
-pp$1.regexp_eatExtendedAtom = function(state) {
+pp$8.regexp_eatExtendedAtom = function(state) {
   return (
     state.eat(0x2E /* . */) ||
     this.regexp_eatReverseSolidusAtomEscape(state) ||
@@ -20982,7 +19941,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
-pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
+pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
   if (this.regexp_eatBracedQuantifier(state, true)) {
     state.raise("Nothing to repeat");
   }
@@ -20990,7 +19949,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
-pp$1.regexp_eatSyntaxCharacter = function(state) {
+pp$8.regexp_eatSyntaxCharacter = function(state) {
   var ch = state.current();
   if (isSyntaxCharacter(ch)) {
     state.lastIntValue = ch;
@@ -21012,7 +19971,7 @@
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
 // But eat eager.
-pp$1.regexp_eatPatternCharacters = function(state) {
+pp$8.regexp_eatPatternCharacters = function(state) {
   var start = state.pos;
   var ch = 0;
   while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
@@ -21022,7 +19981,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
-pp$1.regexp_eatExtendedPatternCharacter = function(state) {
+pp$8.regexp_eatExtendedPatternCharacter = function(state) {
   var ch = state.current();
   if (
     ch !== -1 &&
@@ -21043,7 +20002,7 @@
 // GroupSpecifier ::
 //   [empty]
 //   `?` GroupName
-pp$1.regexp_groupSpecifier = function(state) {
+pp$8.regexp_groupSpecifier = function(state) {
   if (state.eat(0x3F /* ? */)) {
     if (this.regexp_eatGroupName(state)) {
       if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
@@ -21059,7 +20018,7 @@
 // GroupName ::
 //   `<` RegExpIdentifierName `>`
 // Note: this updates `state.lastStringValue` property with the eaten name.
-pp$1.regexp_eatGroupName = function(state) {
+pp$8.regexp_eatGroupName = function(state) {
   state.lastStringValue = "";
   if (state.eat(0x3C /* < */)) {
     if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
@@ -21074,7 +20033,7 @@
 //   RegExpIdentifierStart
 //   RegExpIdentifierName RegExpIdentifierPart
 // Note: this updates `state.lastStringValue` property with the eaten name.
-pp$1.regexp_eatRegExpIdentifierName = function(state) {
+pp$8.regexp_eatRegExpIdentifierName = function(state) {
   state.lastStringValue = "";
   if (this.regexp_eatRegExpIdentifierStart(state)) {
     state.lastStringValue += codePointToString(state.lastIntValue);
@@ -21091,7 +20050,7 @@
 //   `$`
 //   `_`
 //   `\` RegExpUnicodeEscapeSequence[+U]
-pp$1.regexp_eatRegExpIdentifierStart = function(state) {
+pp$8.regexp_eatRegExpIdentifierStart = function(state) {
   var start = state.pos;
   var forceU = this.options.ecmaVersion >= 11;
   var ch = state.current(forceU);
@@ -21119,7 +20078,7 @@
 //   `\` RegExpUnicodeEscapeSequence[+U]
 //   <ZWNJ>
 //   <ZWJ>
-pp$1.regexp_eatRegExpIdentifierPart = function(state) {
+pp$8.regexp_eatRegExpIdentifierPart = function(state) {
   var start = state.pos;
   var forceU = this.options.ecmaVersion >= 11;
   var ch = state.current(forceU);
@@ -21141,7 +20100,7 @@
 }
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
-pp$1.regexp_eatAtomEscape = function(state) {
+pp$8.regexp_eatAtomEscape = function(state) {
   if (
     this.regexp_eatBackReference(state) ||
     this.regexp_eatCharacterClassEscape(state) ||
@@ -21159,7 +20118,7 @@
   }
   return false
 };
-pp$1.regexp_eatBackReference = function(state) {
+pp$8.regexp_eatBackReference = function(state) {
   var start = state.pos;
   if (this.regexp_eatDecimalEscape(state)) {
     var n = state.lastIntValue;
@@ -21177,7 +20136,7 @@
   }
   return false
 };
-pp$1.regexp_eatKGroupName = function(state) {
+pp$8.regexp_eatKGroupName = function(state) {
   if (state.eat(0x6B /* k */)) {
     if (this.regexp_eatGroupName(state)) {
       state.backReferenceNames.push(state.lastStringValue);
@@ -21189,7 +20148,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
-pp$1.regexp_eatCharacterEscape = function(state) {
+pp$8.regexp_eatCharacterEscape = function(state) {
   return (
     this.regexp_eatControlEscape(state) ||
     this.regexp_eatCControlLetter(state) ||
@@ -21200,7 +20159,7 @@
     this.regexp_eatIdentityEscape(state)
   )
 };
-pp$1.regexp_eatCControlLetter = function(state) {
+pp$8.regexp_eatCControlLetter = function(state) {
   var start = state.pos;
   if (state.eat(0x63 /* c */)) {
     if (this.regexp_eatControlLetter(state)) {
@@ -21210,7 +20169,7 @@
   }
   return false
 };
-pp$1.regexp_eatZero = function(state) {
+pp$8.regexp_eatZero = function(state) {
   if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
     state.lastIntValue = 0;
     state.advance();
@@ -21220,7 +20179,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
-pp$1.regexp_eatControlEscape = function(state) {
+pp$8.regexp_eatControlEscape = function(state) {
   var ch = state.current();
   if (ch === 0x74 /* t */) {
     state.lastIntValue = 0x09; /* \t */
@@ -21251,7 +20210,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
-pp$1.regexp_eatControlLetter = function(state) {
+pp$8.regexp_eatControlLetter = function(state) {
   var ch = state.current();
   if (isControlLetter(ch)) {
     state.lastIntValue = ch % 0x20;
@@ -21268,7 +20227,7 @@
 }
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
-pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
+pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
   if ( forceU === void 0 ) forceU = false;
 
   var start = state.pos;
@@ -21313,7 +20272,7 @@
 }
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
-pp$1.regexp_eatIdentityEscape = function(state) {
+pp$8.regexp_eatIdentityEscape = function(state) {
   if (state.switchU) {
     if (this.regexp_eatSyntaxCharacter(state)) {
       return true
@@ -21336,7 +20295,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
-pp$1.regexp_eatDecimalEscape = function(state) {
+pp$8.regexp_eatDecimalEscape = function(state) {
   state.lastIntValue = 0;
   var ch = state.current();
   if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
@@ -21350,7 +20309,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
-pp$1.regexp_eatCharacterClassEscape = function(state) {
+pp$8.regexp_eatCharacterClassEscape = function(state) {
   var ch = state.current();
 
   if (isCharacterClassEscape(ch)) {
@@ -21392,7 +20351,7 @@
 // UnicodePropertyValueExpression ::
 //   UnicodePropertyName `=` UnicodePropertyValue
 //   LoneUnicodePropertyNameOrValue
-pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
+pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
   var start = state.pos;
 
   // UnicodePropertyName `=` UnicodePropertyValue
@@ -21414,20 +20373,20 @@
   }
   return false
 };
-pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
-  if (!hasOwn(state.unicodeProperties.nonBinary, name))
+pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
+  if (!has(state.unicodeProperties.nonBinary, name))
     { state.raise("Invalid property name"); }
   if (!state.unicodeProperties.nonBinary[name].test(value))
     { state.raise("Invalid property value"); }
 };
-pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
+pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
   if (!state.unicodeProperties.binary.test(nameOrValue))
     { state.raise("Invalid property name"); }
 };
 
 // UnicodePropertyName ::
 //   UnicodePropertyNameCharacters
-pp$1.regexp_eatUnicodePropertyName = function(state) {
+pp$8.regexp_eatUnicodePropertyName = function(state) {
   var ch = 0;
   state.lastStringValue = "";
   while (isUnicodePropertyNameCharacter(ch = state.current())) {
@@ -21442,7 +20401,7 @@
 
 // UnicodePropertyValue ::
 //   UnicodePropertyValueCharacters
-pp$1.regexp_eatUnicodePropertyValue = function(state) {
+pp$8.regexp_eatUnicodePropertyValue = function(state) {
   var ch = 0;
   state.lastStringValue = "";
   while (isUnicodePropertyValueCharacter(ch = state.current())) {
@@ -21457,12 +20416,12 @@
 
 // LoneUnicodePropertyNameOrValue ::
 //   UnicodePropertyValueCharacters
-pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
+pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
   return this.regexp_eatUnicodePropertyValue(state)
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
-pp$1.regexp_eatCharacterClass = function(state) {
+pp$8.regexp_eatCharacterClass = function(state) {
   if (state.eat(0x5B /* [ */)) {
     state.eat(0x5E /* ^ */);
     this.regexp_classRanges(state);
@@ -21478,7 +20437,7 @@
 // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
 // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
 // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
-pp$1.regexp_classRanges = function(state) {
+pp$8.regexp_classRanges = function(state) {
   while (this.regexp_eatClassAtom(state)) {
     var left = state.lastIntValue;
     if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {
@@ -21495,7 +20454,7 @@
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
 // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
-pp$1.regexp_eatClassAtom = function(state) {
+pp$8.regexp_eatClassAtom = function(state) {
   var start = state.pos;
 
   if (state.eat(0x5C /* \ */)) {
@@ -21524,7 +20483,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
-pp$1.regexp_eatClassEscape = function(state) {
+pp$8.regexp_eatClassEscape = function(state) {
   var start = state.pos;
 
   if (state.eat(0x62 /* b */)) {
@@ -21551,7 +20510,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
-pp$1.regexp_eatClassControlLetter = function(state) {
+pp$8.regexp_eatClassControlLetter = function(state) {
   var ch = state.current();
   if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
     state.lastIntValue = ch % 0x20;
@@ -21562,7 +20521,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
-pp$1.regexp_eatHexEscapeSequence = function(state) {
+pp$8.regexp_eatHexEscapeSequence = function(state) {
   var start = state.pos;
   if (state.eat(0x78 /* x */)) {
     if (this.regexp_eatFixedHexDigits(state, 2)) {
@@ -21577,7 +20536,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
-pp$1.regexp_eatDecimalDigits = function(state) {
+pp$8.regexp_eatDecimalDigits = function(state) {
   var start = state.pos;
   var ch = 0;
   state.lastIntValue = 0;
@@ -21592,7 +20551,7 @@
 }
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
-pp$1.regexp_eatHexDigits = function(state) {
+pp$8.regexp_eatHexDigits = function(state) {
   var start = state.pos;
   var ch = 0;
   state.lastIntValue = 0;
@@ -21621,7 +20580,7 @@
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
 // Allows only 0-377(octal) i.e. 0-255(decimal).
-pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
+pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
   if (this.regexp_eatOctalDigit(state)) {
     var n1 = state.lastIntValue;
     if (this.regexp_eatOctalDigit(state)) {
@@ -21640,7 +20599,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
-pp$1.regexp_eatOctalDigit = function(state) {
+pp$8.regexp_eatOctalDigit = function(state) {
   var ch = state.current();
   if (isOctalDigit(ch)) {
     state.lastIntValue = ch - 0x30; /* 0 */
@@ -21657,7 +20616,7 @@
 // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
 // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
 // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
-pp$1.regexp_eatFixedHexDigits = function(state, length) {
+pp$8.regexp_eatFixedHexDigits = function(state, length) {
   var start = state.pos;
   state.lastIntValue = 0;
   for (var i = 0; i < length; ++i) {
@@ -21689,11 +20648,11 @@
 
 // ## Tokenizer
 
-var pp = Parser.prototype;
+var pp$9 = Parser.prototype;
 
 // Move to the next token
 
-pp.next = function(ignoreEscapeSequenceInKeyword) {
+pp$9.next = function(ignoreEscapeSequenceInKeyword) {
   if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)
     { this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword); }
   if (this.options.onToken)
@@ -21706,21 +20665,21 @@
   this.nextToken();
 };
 
-pp.getToken = function() {
+pp$9.getToken = function() {
   this.next();
   return new Token(this)
 };
 
 // If we're in an ES6 environment, make parsers iterable
 if (typeof Symbol !== "undefined")
-  { pp[Symbol.iterator] = function() {
+  { pp$9[Symbol.iterator] = function() {
     var this$1$1 = this;
 
     return {
       next: function () {
         var token = this$1$1.getToken();
         return {
-          done: token.type === types$1.eof,
+          done: token.type === types.eof,
           value: token
         }
       }
@@ -21733,19 +20692,19 @@
 // Read a single token, updating the parser object's token-related
 // properties.
 
-pp.nextToken = function() {
+pp$9.nextToken = function() {
   var curContext = this.curContext();
   if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }
 
   this.start = this.pos;
   if (this.options.locations) { this.startLoc = this.curPosition(); }
-  if (this.pos >= this.input.length) { return this.finishToken(types$1.eof) }
+  if (this.pos >= this.input.length) { return this.finishToken(types.eof) }
 
   if (curContext.override) { return curContext.override(this) }
   else { this.readToken(this.fullCharCodeAtPos()); }
 };
 
-pp.readToken = function(code) {
+pp$9.readToken = function(code) {
   // Identifier or keyword. '\uXXXX' sequences are allowed in
   // identifiers, so '\' also dispatches to that.
   if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
@@ -21754,22 +20713,24 @@
   return this.getTokenFromCode(code)
 };
 
-pp.fullCharCodeAtPos = function() {
+pp$9.fullCharCodeAtPos = function() {
   var code = this.input.charCodeAt(this.pos);
   if (code <= 0xd7ff || code >= 0xdc00) { return code }
   var next = this.input.charCodeAt(this.pos + 1);
   return next <= 0xdbff || next >= 0xe000 ? code : (code << 10) + next - 0x35fdc00
 };
 
-pp.skipBlockComment = function() {
+pp$9.skipBlockComment = function() {
   var startLoc = this.options.onComment && this.curPosition();
   var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
   if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
   this.pos = end + 2;
   if (this.options.locations) {
-    for (var nextBreak = (void 0), pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;) {
+    lineBreakG.lastIndex = start;
+    var match;
+    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
       ++this.curLine;
-      pos = this.lineStart = nextBreak;
+      this.lineStart = match.index + match[0].length;
     }
   }
   if (this.options.onComment)
@@ -21777,7 +20738,7 @@
                            startLoc, this.curPosition()); }
 };
 
-pp.skipLineComment = function(startSkip) {
+pp$9.skipLineComment = function(startSkip) {
   var start = this.pos;
   var startLoc = this.options.onComment && this.curPosition();
   var ch = this.input.charCodeAt(this.pos += startSkip);
@@ -21792,7 +20753,7 @@
 // Called at the start of the parse and after every token. Skips
 // whitespace and comments, and.
 
-pp.skipSpace = function() {
+pp$9.skipSpace = function() {
   loop: while (this.pos < this.input.length) {
     var ch = this.input.charCodeAt(this.pos);
     switch (ch) {
@@ -21837,7 +20798,7 @@
 // the token, so that the next one's `start` will point at the
 // right position.
 
-pp.finishToken = function(type, val) {
+pp$9.finishToken = function(type, val) {
   this.end = this.pos;
   if (this.options.locations) { this.endLoc = this.curPosition(); }
   var prevType = this.type;
@@ -21856,62 +20817,62 @@
 //
 // All in the name of speed.
 //
-pp.readToken_dot = function() {
+pp$9.readToken_dot = function() {
   var next = this.input.charCodeAt(this.pos + 1);
   if (next >= 48 && next <= 57) { return this.readNumber(true) }
   var next2 = this.input.charCodeAt(this.pos + 2);
   if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
     this.pos += 3;
-    return this.finishToken(types$1.ellipsis)
+    return this.finishToken(types.ellipsis)
   } else {
     ++this.pos;
-    return this.finishToken(types$1.dot)
+    return this.finishToken(types.dot)
   }
 };
 
-pp.readToken_slash = function() { // '/'
+pp$9.readToken_slash = function() { // '/'
   var next = this.input.charCodeAt(this.pos + 1);
   if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
-  if (next === 61) { return this.finishOp(types$1.assign, 2) }
-  return this.finishOp(types$1.slash, 1)
+  if (next === 61) { return this.finishOp(types.assign, 2) }
+  return this.finishOp(types.slash, 1)
 };
 
-pp.readToken_mult_modulo_exp = function(code) { // '%*'
+pp$9.readToken_mult_modulo_exp = function(code) { // '%*'
   var next = this.input.charCodeAt(this.pos + 1);
   var size = 1;
-  var tokentype = code === 42 ? types$1.star : types$1.modulo;
+  var tokentype = code === 42 ? types.star : types.modulo;
 
   // exponentiation operator ** and **=
   if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
     ++size;
-    tokentype = types$1.starstar;
+    tokentype = types.starstar;
     next = this.input.charCodeAt(this.pos + 2);
   }
 
-  if (next === 61) { return this.finishOp(types$1.assign, size + 1) }
+  if (next === 61) { return this.finishOp(types.assign, size + 1) }
   return this.finishOp(tokentype, size)
 };
 
-pp.readToken_pipe_amp = function(code) { // '|&'
+pp$9.readToken_pipe_amp = function(code) { // '|&'
   var next = this.input.charCodeAt(this.pos + 1);
   if (next === code) {
     if (this.options.ecmaVersion >= 12) {
       var next2 = this.input.charCodeAt(this.pos + 2);
-      if (next2 === 61) { return this.finishOp(types$1.assign, 3) }
+      if (next2 === 61) { return this.finishOp(types.assign, 3) }
     }
-    return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2)
+    return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2)
   }
-  if (next === 61) { return this.finishOp(types$1.assign, 2) }
-  return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1)
+  if (next === 61) { return this.finishOp(types.assign, 2) }
+  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
 };
 
-pp.readToken_caret = function() { // '^'
+pp$9.readToken_caret = function() { // '^'
   var next = this.input.charCodeAt(this.pos + 1);
-  if (next === 61) { return this.finishOp(types$1.assign, 2) }
-  return this.finishOp(types$1.bitwiseXOR, 1)
+  if (next === 61) { return this.finishOp(types.assign, 2) }
+  return this.finishOp(types.bitwiseXOR, 1)
 };
 
-pp.readToken_plus_min = function(code) { // '+-'
+pp$9.readToken_plus_min = function(code) { // '+-'
   var next = this.input.charCodeAt(this.pos + 1);
   if (next === code) {
     if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
@@ -21921,19 +20882,19 @@
       this.skipSpace();
       return this.nextToken()
     }
-    return this.finishOp(types$1.incDec, 2)
+    return this.finishOp(types.incDec, 2)
   }
-  if (next === 61) { return this.finishOp(types$1.assign, 2) }
-  return this.finishOp(types$1.plusMin, 1)
+  if (next === 61) { return this.finishOp(types.assign, 2) }
+  return this.finishOp(types.plusMin, 1)
 };
 
-pp.readToken_lt_gt = function(code) { // '<>'
+pp$9.readToken_lt_gt = function(code) { // '<>'
   var next = this.input.charCodeAt(this.pos + 1);
   var size = 1;
   if (next === code) {
     size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
-    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types$1.assign, size + 1) }
-    return this.finishOp(types$1.bitShift, size)
+    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
+    return this.finishOp(types.bitShift, size)
   }
   if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
       this.input.charCodeAt(this.pos + 3) === 45) {
@@ -21943,53 +20904,53 @@
     return this.nextToken()
   }
   if (next === 61) { size = 2; }
-  return this.finishOp(types$1.relational, size)
+  return this.finishOp(types.relational, size)
 };
 
-pp.readToken_eq_excl = function(code) { // '=!'
+pp$9.readToken_eq_excl = function(code) { // '=!'
   var next = this.input.charCodeAt(this.pos + 1);
-  if (next === 61) { return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
+  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
   if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
     this.pos += 2;
-    return this.finishToken(types$1.arrow)
+    return this.finishToken(types.arrow)
   }
-  return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1)
+  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
 };
 
-pp.readToken_question = function() { // '?'
+pp$9.readToken_question = function() { // '?'
   var ecmaVersion = this.options.ecmaVersion;
   if (ecmaVersion >= 11) {
     var next = this.input.charCodeAt(this.pos + 1);
     if (next === 46) {
       var next2 = this.input.charCodeAt(this.pos + 2);
-      if (next2 < 48 || next2 > 57) { return this.finishOp(types$1.questionDot, 2) }
+      if (next2 < 48 || next2 > 57) { return this.finishOp(types.questionDot, 2) }
     }
     if (next === 63) {
       if (ecmaVersion >= 12) {
         var next2$1 = this.input.charCodeAt(this.pos + 2);
-        if (next2$1 === 61) { return this.finishOp(types$1.assign, 3) }
+        if (next2$1 === 61) { return this.finishOp(types.assign, 3) }
       }
-      return this.finishOp(types$1.coalesce, 2)
+      return this.finishOp(types.coalesce, 2)
     }
   }
-  return this.finishOp(types$1.question, 1)
+  return this.finishOp(types.question, 1)
 };
 
-pp.readToken_numberSign = function() { // '#'
+pp$9.readToken_numberSign = function() { // '#'
   var ecmaVersion = this.options.ecmaVersion;
   var code = 35; // '#'
   if (ecmaVersion >= 13) {
     ++this.pos;
     code = this.fullCharCodeAtPos();
     if (isIdentifierStart(code, true) || code === 92 /* '\' */) {
-      return this.finishToken(types$1.privateId, this.readWord1())
+      return this.finishToken(types.privateId, this.readWord1())
     }
   }
 
-  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
+  this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
 };
 
-pp.getTokenFromCode = function(code) {
+pp$9.getTokenFromCode = function(code) {
   switch (code) {
   // The interpretation of a dot depends on whether it is followed
   // by a digit or another two dots.
@@ -21997,20 +20958,20 @@
     return this.readToken_dot()
 
   // Punctuation tokens.
-  case 40: ++this.pos; return this.finishToken(types$1.parenL)
-  case 41: ++this.pos; return this.finishToken(types$1.parenR)
-  case 59: ++this.pos; return this.finishToken(types$1.semi)
-  case 44: ++this.pos; return this.finishToken(types$1.comma)
-  case 91: ++this.pos; return this.finishToken(types$1.bracketL)
-  case 93: ++this.pos; return this.finishToken(types$1.bracketR)
-  case 123: ++this.pos; return this.finishToken(types$1.braceL)
-  case 125: ++this.pos; return this.finishToken(types$1.braceR)
-  case 58: ++this.pos; return this.finishToken(types$1.colon)
+  case 40: ++this.pos; return this.finishToken(types.parenL)
+  case 41: ++this.pos; return this.finishToken(types.parenR)
+  case 59: ++this.pos; return this.finishToken(types.semi)
+  case 44: ++this.pos; return this.finishToken(types.comma)
+  case 91: ++this.pos; return this.finishToken(types.bracketL)
+  case 93: ++this.pos; return this.finishToken(types.bracketR)
+  case 123: ++this.pos; return this.finishToken(types.braceL)
+  case 125: ++this.pos; return this.finishToken(types.braceR)
+  case 58: ++this.pos; return this.finishToken(types.colon)
 
   case 96: // '`'
     if (this.options.ecmaVersion < 6) { break }
     ++this.pos;
-    return this.finishToken(types$1.backQuote)
+    return this.finishToken(types.backQuote)
 
   case 48: // '0'
     var next = this.input.charCodeAt(this.pos + 1);
@@ -22033,6 +20994,7 @@
   // often referred to. `finishOp` simply skips the amount of
   // characters it is given as second argument, and returns a token
   // of the type given by its first argument.
+
   case 47: // '/'
     return this.readToken_slash()
 
@@ -22058,22 +21020,22 @@
     return this.readToken_question()
 
   case 126: // '~'
-    return this.finishOp(types$1.prefix, 1)
+    return this.finishOp(types.prefix, 1)
 
   case 35: // '#'
     return this.readToken_numberSign()
   }
 
-  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
+  this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
 };
 
-pp.finishOp = function(type, size) {
+pp$9.finishOp = function(type, size) {
   var str = this.input.slice(this.pos, this.pos + size);
   this.pos += size;
   return this.finishToken(type, str)
 };
 
-pp.readRegexp = function() {
+pp$9.readRegexp = function() {
   var escaped, inClass, start = this.pos;
   for (;;) {
     if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
@@ -22108,14 +21070,14 @@
     // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
   }
 
-  return this.finishToken(types$1.regexp, {pattern: pattern, flags: flags, value: value})
+  return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})
 };
 
 // Read an integer in the given radix. Return null if zero digits
 // were read, the integer value otherwise. When `len` is given, this
 // will return `null` unless the integer has exactly `len` digits.
 
-pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
+pp$9.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
   // `len` is used for character escape sequences. In that case, disallow separators.
   var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;
 
@@ -22169,7 +21131,7 @@
   return BigInt(str.replace(/_/g, ""))
 }
 
-pp.readRadixNumber = function(radix) {
+pp$9.readRadixNumber = function(radix) {
   var start = this.pos;
   this.pos += 2; // 0x
   var val = this.readInt(radix);
@@ -22178,12 +21140,12 @@
     val = stringToBigInt(this.input.slice(start, this.pos));
     ++this.pos;
   } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
-  return this.finishToken(types$1.num, val)
+  return this.finishToken(types.num, val)
 };
 
 // Read an integer, octal integer, or floating-point number.
 
-pp.readNumber = function(startsWithDot) {
+pp$9.readNumber = function(startsWithDot) {
   var start = this.pos;
   if (!startsWithDot && this.readInt(10, undefined, true) === null) { this.raise(start, "Invalid number"); }
   var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
@@ -22193,7 +21155,7 @@
     var val$1 = stringToBigInt(this.input.slice(start, this.pos));
     ++this.pos;
     if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
-    return this.finishToken(types$1.num, val$1)
+    return this.finishToken(types.num, val$1)
   }
   if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
   if (next === 46 && !octal) { // '.'
@@ -22209,12 +21171,12 @@
   if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
 
   var val = stringToNumber(this.input.slice(start, this.pos), octal);
-  return this.finishToken(types$1.num, val)
+  return this.finishToken(types.num, val)
 };
 
 // Read a string value, interpreting backslash-escapes.
 
-pp.readCodePoint = function() {
+pp$9.readCodePoint = function() {
   var ch = this.input.charCodeAt(this.pos), code;
 
   if (ch === 123) { // '{'
@@ -22229,7 +21191,14 @@
   return code
 };
 
-pp.readString = function(quote) {
+function codePointToString$1(code) {
+  // UTF-16 Decoding
+  if (code <= 0xFFFF) { return String.fromCharCode(code) }
+  code -= 0x10000;
+  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
+}
+
+pp$9.readString = function(quote) {
   var out = "", chunkStart = ++this.pos;
   for (;;) {
     if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
@@ -22252,14 +21221,14 @@
     }
   }
   out += this.input.slice(chunkStart, this.pos++);
-  return this.finishToken(types$1.string, out)
+  return this.finishToken(types.string, out)
 };
 
 // Reads template string tokens.
 
 var INVALID_TEMPLATE_ESCAPE_ERROR = {};
 
-pp.tryReadTemplateToken = function() {
+pp$9.tryReadTemplateToken = function() {
   this.inTemplateElement = true;
   try {
     this.readTmplToken();
@@ -22274,7 +21243,7 @@
   this.inTemplateElement = false;
 };
 
-pp.invalidStringToken = function(position, message) {
+pp$9.invalidStringToken = function(position, message) {
   if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
     throw INVALID_TEMPLATE_ESCAPE_ERROR
   } else {
@@ -22282,23 +21251,23 @@
   }
 };
 
-pp.readTmplToken = function() {
+pp$9.readTmplToken = function() {
   var out = "", chunkStart = this.pos;
   for (;;) {
     if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
     var ch = this.input.charCodeAt(this.pos);
     if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'
-      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
+      if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
         if (ch === 36) {
           this.pos += 2;
-          return this.finishToken(types$1.dollarBraceL)
+          return this.finishToken(types.dollarBraceL)
         } else {
           ++this.pos;
-          return this.finishToken(types$1.backQuote)
+          return this.finishToken(types.backQuote)
         }
       }
       out += this.input.slice(chunkStart, this.pos);
-      return this.finishToken(types$1.template, out)
+      return this.finishToken(types.template, out)
     }
     if (ch === 92) { // '\'
       out += this.input.slice(chunkStart, this.pos);
@@ -22329,7 +21298,7 @@
 };
 
 // Reads a template token to search for the end, without validating any escape sequences
-pp.readInvalidTemplateToken = function() {
+pp$9.readInvalidTemplateToken = function() {
   for (; this.pos < this.input.length; this.pos++) {
     switch (this.input[this.pos]) {
     case "\\":
@@ -22340,10 +21309,10 @@
       if (this.input[this.pos + 1] !== "{") {
         break
       }
-
     // falls through
+
     case "`":
-      return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos))
+      return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))
 
     // no default
     }
@@ -22353,14 +21322,14 @@
 
 // Used to read escaped characters
 
-pp.readEscapedChar = function(inTemplate) {
+pp$9.readEscapedChar = function(inTemplate) {
   var ch = this.input.charCodeAt(++this.pos);
   ++this.pos;
   switch (ch) {
   case 110: return "\n" // 'n' -> '\n'
   case 114: return "\r" // 'r' -> '\r'
   case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
-  case 117: return codePointToString(this.readCodePoint()) // 'u'
+  case 117: return codePointToString$1(this.readCodePoint()) // 'u'
   case 116: return "\t" // 't' -> '\t'
   case 98: return "\b" // 'b' -> '\b'
   case 118: return "\u000b" // 'v' -> '\u000b'
@@ -22418,7 +21387,7 @@
 
 // Used to read character escape sequences ('\x', '\u', '\U').
 
-pp.readHexChar = function(len) {
+pp$9.readHexChar = function(len) {
   var codePos = this.pos;
   var n = this.readInt(16, len);
   if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
@@ -22431,7 +21400,7 @@
 // Incrementally adds only escaped chars, adding other chunks as-is
 // as a micro-optimization.
 
-pp.readWord1 = function() {
+pp$9.readWord1 = function() {
   this.containsEsc = false;
   var word = "", first = true, chunkStart = this.pos;
   var astral = this.options.ecmaVersion >= 6;
@@ -22449,7 +21418,7 @@
       var esc = this.readCodePoint();
       if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
         { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
-      word += codePointToString(esc);
+      word += codePointToString$1(esc);
       chunkStart = this.pos;
     } else {
       break
@@ -22462,18 +21431,18 @@
 // Read an identifier or keyword token. Will check for reserved
 // words when necessary.
 
-pp.readWord = function() {
+pp$9.readWord = function() {
   var word = this.readWord1();
-  var type = types$1.name;
+  var type = types.name;
   if (this.keywords.test(word)) {
-    type = keywords[word];
+    type = keywords$1[word];
   }
   return this.finishToken(type, word)
 };
 
 // Acorn is a tiny, fast JavaScript parser written in JavaScript.
 
-var version = "8.8.1";
+var version = "8.5.0";
 
 Parser.acorn = {
   Parser: Parser,
@@ -22484,10 +21453,10 @@
   getLineInfo: getLineInfo,
   Node: Node,
   TokenType: TokenType,
-  tokTypes: types$1,
-  keywordTypes: keywords,
+  tokTypes: types,
+  keywordTypes: keywords$1,
   TokContext: TokContext,
-  tokContexts: types,
+  tokContexts: types$1,
   isIdentifierChar: isIdentifierChar,
   isIdentifierStart: isIdentifierStart,
   Token: Token,
@@ -22497,103 +21466,70 @@
   nonASCIIwhitespace: nonASCIIwhitespace
 };
 
-// The main exported interface (under `self.acorn` when in the
-// browser) is a `parse` function that takes a code string and
-// returns an abstract syntax tree as specified by [Mozilla parser
-// API][api].
-//
-// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
-
-function parse(input, options) {
-  return Parser.parse(input, options)
-}
-
-// This function tries to parse a single expression at a given
-// offset in a string. Useful for parsing mixed-language formats
-// that embed JavaScript expressions.
-
-function parseExpressionAt(input, pos, options) {
-  return Parser.parseExpressionAt(input, pos, options)
+const readFile = (file) => new Promise((fulfil, reject) => fs.readFile(file, 'utf-8', (err, contents) => (err ? reject(err) : fulfil(contents))));
+function mkdirpath(path) {
+    const dir = dirname(path);
+    try {
+        fs.readdirSync(dir);
+    }
+    catch (_a) {
+        mkdirpath(dir);
+        try {
+            fs.mkdirSync(dir);
+        }
+        catch (err) {
+            if (err.code !== 'EEXIST') {
+                throw err;
+            }
+        }
+    }
 }
-
-// Acorn is organized as a tokenizer and a recursive-descent parser.
-// The `tokenizer` export provides an interface to the tokenizer.
-
-function tokenizer(input, options) {
-  return Parser.tokenizer(input, options)
+function writeFile(dest, data) {
+    return new Promise((fulfil, reject) => {
+        mkdirpath(dest);
+        fs.writeFile(dest, data, err => {
+            if (err) {
+                reject(err);
+            }
+            else {
+                fulfil();
+            }
+        });
+    });
 }
 
-const _acorn = /*#__PURE__*/Object.defineProperty({
-  __proto__: null,
-  Node,
-  Parser,
-  Position,
-  SourceLocation,
-  TokContext,
-  Token,
-  TokenType,
-  defaultOptions,
-  getLineInfo,
-  isIdentifierChar,
-  isIdentifierStart,
-  isNewLine,
-  keywordTypes: keywords,
-  lineBreak,
-  lineBreakG,
-  nonASCIIwhitespace,
-  parse,
-  parseExpressionAt,
-  tokContexts: types,
-  tokTypes: types$1,
-  tokenizer,
-  version
-}, Symbol.toStringTag, { value: 'Module' });
-
-function flru (max) {
-	var num, curr, prev;
-	var limit = max || 1;
-
-	function keep(key, value) {
-		if (++num > limit) {
-			prev = curr;
-			reset(1);
-			++num;
-		}
-		curr[key] = value;
-	}
-
-	function reset(isPartial) {
-		num = 0;
-		curr = Object.create(null);
-		isPartial || (prev=Object.create(null));
-	}
-
-	reset();
-
-	return {
-		clear: reset,
-		has: function (key) {
-			return curr[key] !== void 0 || prev[key] !== void 0;
-		},
-		get: function (key) {
-			var val = curr[key];
-			if (val !== void 0) return val;
-			if ((val=prev[key]) !== void 0) {
-				keep(key, val);
-				return val;
-			}
-		},
-		set: function (key, value) {
-			if (curr[key] !== void 0) {
-				curr[key] = value;
-			} else {
-				keep(key, value);
-			}
-		}
-	};
+class Queue {
+    constructor(maxParallel = 1) {
+        this.maxParallel = maxParallel;
+        this.queue = new Array();
+        this.workerCount = 0;
+    }
+    run(task) {
+        return new Promise((resolve, reject) => {
+            this.queue.push({ reject, resolve, task });
+            this.work();
+        });
+    }
+    async work() {
+        if (this.workerCount >= this.maxParallel)
+            return;
+        this.workerCount++;
+        let entry;
+        while ((entry = this.queue.shift())) {
+            const { reject, resolve, task } = entry;
+            try {
+                const result = await task();
+                resolve(result);
+            }
+            catch (err) {
+                reject(err);
+            }
+        }
+        this.workerCount--;
+    }
 }
 
-function resolveIdViaPlugins(source, importer, pluginDriver, moduleLoaderResolveId, skip, customOptions, isEntry, assertions) {
+function resolveIdViaPlugins(source, importer, pluginDriver, moduleLoaderResolveId, skip, customOptions, isEntry) {
     let skipped = null;
     let replaceContext = null;
     if (skip) {
@@ -22605,30 +21541,18 @@
         }
         replaceContext = (pluginContext, plugin) => ({
             ...pluginContext,
-            resolve: (source, importer, { assertions, custom, isEntry, skipSelf } = BLANK) => moduleLoaderResolveId(source, importer, custom, isEntry, assertions || EMPTY_OBJECT, skipSelf ? [...skip, { importer, plugin, source }] : skip)
+            resolve: (source, importer, { custom, isEntry, skipSelf } = BLANK) => {
+                return moduleLoaderResolveId(source, importer, custom, isEntry, skipSelf ? [...skip, { importer, plugin, source }] : skip);
+            }
         });
     }
-    return pluginDriver.hookFirstAndGetPlugin('resolveId', [source, importer, { assertions, custom: customOptions, isEntry }], replaceContext, skipped);
+    return pluginDriver.hookFirst('resolveId', [source, importer, { custom: customOptions, isEntry }], replaceContext, skipped);
 }
 
-async function resolveId(source, importer, preserveSymlinks, pluginDriver, moduleLoaderResolveId, skip, customOptions, isEntry, assertions) {
-    const pluginResult = await resolveIdViaPlugins(source, importer, pluginDriver, moduleLoaderResolveId, skip, customOptions, isEntry, assertions);
-    if (pluginResult != null) {
-        const [resolveIdResult, plugin] = pluginResult;
-        if (typeof resolveIdResult === 'object' && !resolveIdResult.resolvedBy) {
-            return {
-                ...resolveIdResult,
-                resolvedBy: plugin.name
-            };
-        }
-        if (typeof resolveIdResult === 'string') {
-            return {
-                id: resolveIdResult,
-                resolvedBy: plugin.name
-            };
-        }
-        return resolveIdResult;
-    }
+async function resolveId(source, importer, preserveSymlinks, pluginDriver, moduleLoaderResolveId, skip, customOptions, isEntry) {
+    const pluginResult = await resolveIdViaPlugins(source, importer, pluginDriver, moduleLoaderResolveId, skip, customOptions, isEntry);
+    if (pluginResult != null)
+        return pluginResult;
     // external modules (non-entry modules that start with neither '.' or '/')
     // are skipped at this stage.
     if (importer !== undefined && !isAbsolute(source) && source[0] !== '.')
@@ -22639,31 +21563,67 @@
     // See https://nodejs.org/api/path.html#path_path_resolve_paths
     return addJsExtensionIfNecessary(importer ? resolve(dirname(importer), source) : resolve(source), preserveSymlinks);
 }
-async function addJsExtensionIfNecessary(file, preserveSymlinks) {
-    return ((await findFile(file, preserveSymlinks)) ??
-        (await findFile(file + '.mjs', preserveSymlinks)) ??
-        (await findFile(file + '.js', preserveSymlinks)));
+function addJsExtensionIfNecessary(file, preserveSymlinks) {
+    let found = findFile(file, preserveSymlinks);
+    if (found)
+        return found;
+    found = findFile(file + '.mjs', preserveSymlinks);
+    if (found)
+        return found;
+    found = findFile(file + '.js', preserveSymlinks);
+    return found;
 }
-async function findFile(file, preserveSymlinks) {
+function findFile(file, preserveSymlinks) {
     try {
-        const stats = await lstat(file);
+        const stats = lstatSync(file);
         if (!preserveSymlinks && stats.isSymbolicLink())
-            return await findFile(await realpath(file), preserveSymlinks);
+            return findFile(realpathSync(file), preserveSymlinks);
         if ((preserveSymlinks && stats.isSymbolicLink()) || stats.isFile()) {
             // check case
             const name = basename(file);
-            const files = await readdir(dirname(file));
-            if (files.includes(name))
+            const files = readdirSync(dirname(file));
+            if (files.indexOf(name) !== -1)
                 return file;
         }
     }
-    catch {
+    catch (_a) {
         // suppress
     }
 }
 
 const ANONYMOUS_PLUGIN_PREFIX = 'at position ';
 const ANONYMOUS_OUTPUT_PLUGIN_PREFIX = 'at output position ';
+function throwPluginError(err, plugin, { hook, id } = {}) {
+    if (typeof err === 'string')
+        err = { message: err };
+    if (err.code && err.code !== Errors.PLUGIN_ERROR) {
+        err.pluginCode = err.code;
+    }
+    err.code = Errors.PLUGIN_ERROR;
+    err.plugin = plugin;
+    if (hook) {
+        err.hook = hook;
+    }
+    if (id) {
+        err.id = id;
+    }
+    return error(err);
+}
+const deprecatedHooks = [
+    { active: true, deprecated: 'resolveAssetUrl', replacement: 'resolveFileUrl' }
+];
+function warnDeprecatedHooks(plugins, options) {
+    for (const { active, deprecated, replacement } of deprecatedHooks) {
+        for (const plugin of plugins) {
+            if (deprecated in plugin) {
+                warnDeprecation({
+                    message: `The "${deprecated}" hook used by plugin ${plugin.name} is deprecated. The "${replacement}" hook should be used instead.`,
+                    plugin: plugin.name
+                }, active, options);
+            }
+        }
+    }
+}
 
 function createPluginCache(cache) {
     return {
@@ -22673,7 +21633,7 @@
         get(id) {
             const item = cache[id];
             if (!item)
-                return;
+                return undefined;
             item[0] = 0;
             return item[1];
         },
@@ -22724,9 +21684,15 @@
 function uncacheablePluginError(pluginName) {
     if (pluginName.startsWith(ANONYMOUS_PLUGIN_PREFIX) ||
         pluginName.startsWith(ANONYMOUS_OUTPUT_PLUGIN_PREFIX)) {
-        return error(errorAnonymousPluginCache());
+        return error({
+            code: 'ANONYMOUS_PLUGIN_CACHE',
+            message: 'A plugin is trying to use the Rollup cache but is not declaring a plugin name or cacheKey.'
+        });
     }
-    return error(errorDuplicatePluginName(pluginName));
+    return error({
+        code: 'DUPLICATE_PLUGIN_NAME',
+        message: `The plugin name ${pluginName} is being used twice in the same build. Plugin names must be distinct or provide a cacheKey (please post an issue to the plugin if you are a plugin user).`
+    });
 }
 function getCacheForUncacheablePlugin(pluginName) {
     return {
@@ -22745,7 +21711,7 @@
     };
 }
 
-async function transform(source, module, pluginDriver, warn) {
+function transform(source, module, pluginDriver, warn) {
     const id = module.id;
     const sourcemapChain = [];
     let originalSourcemap = source.map === null ? null : decodedSourcemap(source.map);
@@ -22755,8 +21721,8 @@
     const emittedFiles = [];
     let customTransformCache = false;
     const useCustomTransformCache = () => (customTransformCache = true);
-    let pluginName = '';
-    const currentSource = source.code;
+    let curPlugin;
+    const curSource = source.code;
     function transformReducer(previousCode, result, plugin) {
         let code;
         let map;
@@ -22767,7 +21733,7 @@
             module.updateOptions(result);
             if (result.code == null) {
                 if (result.map || result.ast) {
-                    warn(errorNoTransformMapOrAstWithoutCode(plugin.name));
+                    warn(errNoTransformMapOrAstWithoutCode(plugin.name));
                 }
                 return previousCode;
             }
@@ -22786,81 +21752,92 @@
         }
         return code;
     }
-    let code;
-    try {
-        code = await pluginDriver.hookReduceArg0('transform', [currentSource, id], transformReducer, (pluginContext, plugin) => {
-            pluginName = plugin.name;
-            return {
-                ...pluginContext,
-                addWatchFile(id) {
-                    transformDependencies.push(id);
-                    pluginContext.addWatchFile(id);
-                },
-                cache: customTransformCache
-                    ? pluginContext.cache
-                    : getTrackedPluginCache(pluginContext.cache, useCustomTransformCache),
-                emitFile(emittedFile) {
-                    emittedFiles.push(emittedFile);
-                    return pluginDriver.emitFile(emittedFile);
-                },
-                error(error_, pos) {
-                    if (typeof error_ === 'string')
-                        error_ = { message: error_ };
-                    if (pos)
-                        augmentCodeLocation(error_, pos, currentSource, id);
-                    error_.id = id;
-                    error_.hook = 'transform';
-                    return pluginContext.error(error_);
-                },
-                getCombinedSourcemap() {
-                    const combinedMap = collapseSourcemap(id, originalCode, originalSourcemap, sourcemapChain, warn);
-                    if (!combinedMap) {
-                        const magicString = new MagicString(originalCode);
-                        return magicString.generateMap({ hires: true, includeContent: true, source: id });
-                    }
-                    if (originalSourcemap !== combinedMap) {
-                        originalSourcemap = combinedMap;
-                        sourcemapChain.length = 0;
-                    }
-                    return new SourceMap({
-                        ...combinedMap,
-                        file: null,
-                        sourcesContent: combinedMap.sourcesContent
-                    });
-                },
-                setAssetSource() {
-                    return this.error(errorInvalidSetAssetSourceCall());
-                },
-                warn(warning, pos) {
-                    if (typeof warning === 'string')
-                        warning = { message: warning };
-                    if (pos)
-                        augmentCodeLocation(warning, pos, currentSource, id);
-                    warning.id = id;
-                    warning.hook = 'transform';
-                    pluginContext.warn(warning);
-                }
-            };
-        });
-    }
-    catch (error_) {
-        return error(errorPluginError(error_, pluginName, { hook: 'transform', id }));
-    }
-    if (!customTransformCache && // files emitted by a transform hook need to be emitted again if the hook is skipped
-        emittedFiles.length > 0)
-        module.transformFiles = emittedFiles;
-    return {
-        ast,
-        code,
-        customTransformCache,
-        originalCode,
-        originalSourcemap,
-        sourcemapChain,
-        transformDependencies
-    };
+    return pluginDriver
+        .hookReduceArg0('transform', [curSource, id], transformReducer, (pluginContext, plugin) => {
+        curPlugin = plugin;
+        return {
+            ...pluginContext,
+            addWatchFile(id) {
+                transformDependencies.push(id);
+                pluginContext.addWatchFile(id);
+            },
+            cache: customTransformCache
+                ? pluginContext.cache
+                : getTrackedPluginCache(pluginContext.cache, useCustomTransformCache),
+            emitAsset(name, source) {
+                emittedFiles.push({ name, source, type: 'asset' });
+                return pluginContext.emitAsset(name, source);
+            },
+            emitChunk(id, options) {
+                emittedFiles.push({ id, name: options && options.name, type: 'chunk' });
+                return pluginContext.emitChunk(id, options);
+            },
+            emitFile(emittedFile) {
+                emittedFiles.push(emittedFile);
+                return pluginDriver.emitFile(emittedFile);
+            },
+            error(err, pos) {
+                if (typeof err === 'string')
+                    err = { message: err };
+                if (pos)
+                    augmentCodeLocation(err, pos, curSource, id);
+                err.id = id;
+                err.hook = 'transform';
+                return pluginContext.error(err);
+            },
+            getCombinedSourcemap() {
+                const combinedMap = collapseSourcemap(id, originalCode, originalSourcemap, sourcemapChain, warn);
+                if (!combinedMap) {
+                    const magicString = new MagicString$1(originalCode);
+                    return magicString.generateMap({ hires: true, includeContent: true, source: id });
+                }
+                if (originalSourcemap !== combinedMap) {
+                    originalSourcemap = combinedMap;
+                    sourcemapChain.length = 0;
+                }
+                return new SourceMap({
+                    ...combinedMap,
+                    file: null,
+                    sourcesContent: combinedMap.sourcesContent
+                });
+            },
+            setAssetSource() {
+                return this.error({
+                    code: 'INVALID_SETASSETSOURCE',
+                    message: `setAssetSource cannot be called in transform for caching reasons. Use emitFile with a source, or call setAssetSource in another hook.`
+                });
+            },
+            warn(warning, pos) {
+                if (typeof warning === 'string')
+                    warning = { message: warning };
+                if (pos)
+                    augmentCodeLocation(warning, pos, curSource, id);
+                warning.id = id;
+                warning.hook = 'transform';
+                pluginContext.warn(warning);
+            }
+        };
+    })
+        .catch(err => throwPluginError(err, curPlugin.name, { hook: 'transform', id }))
+        .then(code => {
+        if (!customTransformCache) {
+            // files emitted by a transform hook need to be emitted again if the hook is skipped
+            if (emittedFiles.length)
+                module.transformFiles = emittedFiles;
+        }
+        return {
+            ast,
+            code,
+            customTransformCache,
+            meta: module.info.meta,
+            originalCode,
+            originalSourcemap,
+            sourcemapChain,
+            transformDependencies
+        };
+    });
 }
 
-const RESOLVE_DEPENDENCIES = 'resolveDependencies';
 class ModuleLoader {
     constructor(graph, modulesById, options, pluginDriver) {
         this.graph = graph;
@@ -22870,16 +21847,17 @@
         this.implicitEntryModules = new Set();
         this.indexedEntryModules = [];
         this.latestLoadModulesPromise = Promise.resolve();
-        this.moduleLoadPromises = new Map();
-        this.modulesWithLoadedDependencies = new Set();
-        this.nextChunkNamePriority = 0;
         this.nextEntryModuleIndex = 0;
-        this.resolveId = async (source, importer, customOptions, isEntry, assertions, skip = null) => this.getResolvedIdWithDefaults(this.getNormalizedResolvedIdWithoutDefaults(this.options.external(source, importer, false)
-            ? false
-            : await resolveId(source, importer, this.options.preserveSymlinks, this.pluginDriver, this.resolveId, skip, customOptions, typeof isEntry === 'boolean' ? isEntry : !importer, assertions), importer, source), assertions);
+        this.readQueue = new Queue();
+        this.resolveId = async (source, importer, customOptions, isEntry, skip = null) => {
+            return this.addDefaultsToResolvedId(this.getNormalizedResolvedIdWithoutDefaults(this.options.external(source, importer, false)
+                ? false
+                : await resolveId(source, importer, this.options.preserveSymlinks, this.pluginDriver, this.resolveId, skip, customOptions, typeof isEntry === 'boolean' ? isEntry : !importer), importer, source));
+        };
         this.hasModuleSideEffects = options.treeshake
             ? options.treeshake.moduleSideEffects
             : () => true;
+        this.readQueue.maxParallel = options.maxParallelFileReads;
     }
     async addAdditionalModules(unresolvedModules) {
         const result = this.extendLoadModulesPromise(Promise.all(unresolvedModules.map(id => this.loadEntryModule(id, false, undefined, null))));
@@ -22889,23 +21867,21 @@
     async addEntryModules(unresolvedEntryModules, isUserDefined) {
         const firstEntryModuleIndex = this.nextEntryModuleIndex;
         this.nextEntryModuleIndex += unresolvedEntryModules.length;
-        const firstChunkNamePriority = this.nextChunkNamePriority;
-        this.nextChunkNamePriority += unresolvedEntryModules.length;
         const newEntryModules = await this.extendLoadModulesPromise(Promise.all(unresolvedEntryModules.map(({ id, importer }) => this.loadEntryModule(id, true, importer, null))).then(entryModules => {
-            for (const [index, entryModule] of entryModules.entries()) {
+            let moduleIndex = firstEntryModuleIndex;
+            for (let index = 0; index < entryModules.length; index++) {
+                const entryModule = entryModules[index];
                 entryModule.isUserDefinedEntryPoint =
                     entryModule.isUserDefinedEntryPoint || isUserDefined;
-                addChunkNamesToModule(entryModule, unresolvedEntryModules[index], isUserDefined, firstChunkNamePriority + index);
+                addChunkNamesToModule(entryModule, unresolvedEntryModules[index], isUserDefined);
                 const existingIndexedModule = this.indexedEntryModules.find(indexedModule => indexedModule.module === entryModule);
-                if (existingIndexedModule) {
-                    existingIndexedModule.index = Math.min(existingIndexedModule.index, firstEntryModuleIndex + index);
+                if (!existingIndexedModule) {
+                    this.indexedEntryModules.push({ index: moduleIndex, module: entryModule });
                 }
                 else {
-                    this.indexedEntryModules.push({
-                        index: firstEntryModuleIndex + index,
-                        module: entryModule
-                    });
+                    existingIndexedModule.index = Math.min(existingIndexedModule.index, moduleIndex);
                 }
+                moduleIndex++;
             }
             this.indexedEntryModules.sort(({ index: indexA }, { index: indexB }) => indexA > indexB ? 1 : -1);
             return entryModules;
@@ -22932,14 +21908,23 @@
         }
         return module;
     }
-    async preloadModule(resolvedId) {
-        const module = await this.fetchModule(this.getResolvedIdWithDefaults(resolvedId, EMPTY_OBJECT), undefined, false, resolvedId.resolveDependencies ? RESOLVE_DEPENDENCIES : true);
-        return module.info;
+    addDefaultsToResolvedId(resolvedId) {
+        var _a, _b;
+        if (!resolvedId) {
+            return null;
+        }
+        const external = resolvedId.external || false;
+        return {
+            external,
+            id: resolvedId.id,
+            meta: resolvedId.meta || EMPTY_OBJECT,
+            moduleSideEffects: (_a = resolvedId.moduleSideEffects) !== null && _a !== void 0 ? _a : this.hasModuleSideEffects(resolvedId.id, !!external),
+            syntheticNamedExports: (_b = resolvedId.syntheticNamedExports) !== null && _b !== void 0 ? _b : false
+        };
     }
     addEntryWithImplicitDependants(unresolvedModule, implicitlyLoadedAfter) {
-        const chunkNamePriority = this.nextChunkNamePriority++;
         return this.extendLoadModulesPromise(this.loadEntryModule(unresolvedModule.id, false, unresolvedModule.importer, null).then(async (entryModule) => {
-            addChunkNamesToModule(entryModule, unresolvedModule, false, chunkNamePriority);
+            addChunkNamesToModule(entryModule, unresolvedModule, false);
             if (!entryModule.info.isEntry) {
                 this.implicitEntryModules.add(entryModule);
                 const implicitlyLoadedAfterModules = await Promise.all(implicitlyLoadedAfter.map(id => this.loadEntryModule(id, false, unresolvedModule.importer, entryModule.id)));
@@ -22954,38 +21939,30 @@
         }));
     }
     async addModuleSource(id, importer, module) {
+        timeStart('load modules', 3);
         let source;
         try {
-            source = await this.graph.fileOperationQueue.run(async () => (await this.pluginDriver.hookFirst('load', [id])) ?? (await readFile(id, 'utf8')));
+            source = await this.readQueue.run(async () => { var _a; return (_a = (await this.pluginDriver.hookFirst('load', [id]))) !== null && _a !== void 0 ? _a : (await readFile(id)); });
         }
-        catch (error_) {
-            let message = `Could not load ${id}`;
+        catch (err) {
+            timeEnd('load modules', 3);
+            let msg = `Could not load ${id}`;
             if (importer)
-                message += ` (imported by ${relativeId(importer)})`;
-            message += `: ${error_.message}`;
-            error_.message = message;
-            throw error_;
+                msg += ` (imported by ${relativeId(importer)})`;
+            msg += `: ${err.message}`;
+            err.message = msg;
+            throw err;
         }
+        timeEnd('load modules', 3);
         const sourceDescription = typeof source === 'string'
             ? { code: source }
-            : source != null && typeof source === 'object' && typeof source.code === 'string'
+            : typeof source === 'object' && typeof source.code === 'string'
                 ? source
-                : error(errorBadLoader(id));
+                : error(errBadLoader(id));
         const cachedModule = this.graph.cachedModules.get(id);
         if (cachedModule &&
             !cachedModule.customTransformCache &&
-            cachedModule.originalCode === sourceDescription.code &&
-            !(await this.pluginDriver.hookFirst('shouldTransformCachedModule', [
-                {
-                    ast: cachedModule.ast,
-                    code: cachedModule.code,
-                    id: cachedModule.id,
-                    meta: cachedModule.meta,
-                    moduleSideEffects: cachedModule.moduleSideEffects,
-                    resolvedSources: cachedModule.resolvedIds,
-                    syntheticNamedExports: cachedModule.syntheticNamedExports
-                }
-            ]))) {
+            cachedModule.originalCode === sourceDescription.code) {
             if (cachedModule.transformFiles) {
                 for (const emittedFile of cachedModule.transformFiles)
                     this.pluginDriver.emitFile(emittedFile);
@@ -23031,79 +22008,62 @@
             }
         }
     }
-    // If this is a preload, then this method always waits for the dependencies of
-    // the module to be resolved.
-    // Otherwise, if the module does not exist, it waits for the module and all
-    // its dependencies to be loaded.
-    // Otherwise, it returns immediately.
-    async fetchModule({ assertions, id, meta, moduleSideEffects, syntheticNamedExports }, importer, isEntry, isPreload) {
+    async fetchModule({ id, meta, moduleSideEffects, syntheticNamedExports }, importer, isEntry) {
         const existingModule = this.modulesById.get(id);
         if (existingModule instanceof Module) {
-            if (importer && doAssertionsDiffer(assertions, existingModule.info.assertions)) {
-                this.options.onwarn(errorInconsistentImportAssertions(existingModule.info.assertions, assertions, id, importer));
+            if (isEntry) {
+                existingModule.info.isEntry = true;
+                this.implicitEntryModules.delete(existingModule);
+                for (const dependant of existingModule.implicitlyLoadedAfter) {
+                    dependant.implicitlyLoadedBefore.delete(existingModule);
+                }
+                existingModule.implicitlyLoadedAfter.clear();
             }
-            await this.handleExistingModule(existingModule, isEntry, isPreload);
             return existingModule;
         }
-        const module = new Module(this.graph, id, this.options, isEntry, moduleSideEffects, syntheticNamedExports, meta, assertions);
+        const module = new Module(this.graph, id, this.options, isEntry, moduleSideEffects, syntheticNamedExports, meta);
         this.modulesById.set(id, module);
         this.graph.watchFiles[id] = true;
-        const loadPromise = this.addModuleSource(id, importer, module).then(() => [
-            this.getResolveStaticDependencyPromises(module),
-            this.getResolveDynamicImportPromises(module),
-            loadAndResolveDependenciesPromise
-        ]);
-        const loadAndResolveDependenciesPromise = waitForDependencyResolution(loadPromise).then(() => this.pluginDriver.hookParallel('moduleParsed', [module.info]));
-        loadAndResolveDependenciesPromise.catch(() => {
-            /* avoid unhandled promise rejections */
+        await this.addModuleSource(id, importer, module);
+        const resolveStaticDependencyPromises = this.getResolveStaticDependencyPromises(module);
+        const resolveDynamicImportPromises = this.getResolveDynamicImportPromises(module);
+        Promise.all([
+            ...resolveStaticDependencyPromises,
+            ...resolveDynamicImportPromises
+        ])
+            .then(() => this.pluginDriver.hookParallel('moduleParsed', [module.info]))
+            .catch(() => {
+            /* rejections thrown here are also handled within PluginDriver - they are safe to ignore */
         });
-        this.moduleLoadPromises.set(module, loadPromise);
-        const resolveDependencyPromises = await loadPromise;
-        if (!isPreload) {
-            await this.fetchModuleDependencies(module, ...resolveDependencyPromises);
-        }
-        else if (isPreload === RESOLVE_DEPENDENCIES) {
-            await loadAndResolveDependenciesPromise;
-        }
-        return module;
-    }
-    async fetchModuleDependencies(module, resolveStaticDependencyPromises, resolveDynamicDependencyPromises, loadAndResolveDependenciesPromise) {
-        if (this.modulesWithLoadedDependencies.has(module)) {
-            return;
-        }
-        this.modulesWithLoadedDependencies.add(module);
         await Promise.all([
             this.fetchStaticDependencies(module, resolveStaticDependencyPromises),
-            this.fetchDynamicDependencies(module, resolveDynamicDependencyPromises)
+            this.fetchDynamicDependencies(module, resolveDynamicImportPromises)
         ]);
         module.linkImports();
-        // To handle errors when resolving dependencies or in moduleParsed
-        await loadAndResolveDependenciesPromise;
+        return module;
     }
     fetchResolvedDependency(source, importer, resolvedId) {
         if (resolvedId.external) {
-            const { assertions, external, id, moduleSideEffects, meta } = resolvedId;
-            let externalModule = this.modulesById.get(id);
-            if (!externalModule) {
-                externalModule = new ExternalModule(this.options, id, moduleSideEffects, meta, external !== 'absolute' && isAbsolute(id), assertions);
-                this.modulesById.set(id, externalModule);
-            }
-            else if (!(externalModule instanceof ExternalModule)) {
-                return error(errorInternalIdCannotBeExternal(source, importer));
-            }
-            else if (doAssertionsDiffer(externalModule.info.assertions, assertions)) {
-                this.options.onwarn(errorInconsistentImportAssertions(externalModule.info.assertions, assertions, source, importer));
+            const { external, id, moduleSideEffects, meta } = resolvedId;
+            if (!this.modulesById.has(id)) {
+                this.modulesById.set(id, new ExternalModule(this.options, id, moduleSideEffects, meta, external !== 'absolute' && isAbsolute(id)));
+            }
+            const externalModule = this.modulesById.get(id);
+            if (!(externalModule instanceof ExternalModule)) {
+                return error(errInternalIdCannotBeExternal(source, importer));
             }
             return Promise.resolve(externalModule);
         }
-        return this.fetchModule(resolvedId, importer, false, false);
+        else {
+            return this.fetchModule(resolvedId, importer, false);
+        }
     }
     async fetchStaticDependencies(module, resolveStaticDependencyPromises) {
         for (const dependency of await Promise.all(resolveStaticDependencyPromises.map(resolveStaticDependencyPromise => resolveStaticDependencyPromise.then(([source, resolvedId]) => this.fetchResolvedDependency(source, module.id, resolvedId))))) {
             module.dependencies.add(dependency);
             dependency.importers.push(module.id);
         }
-        if (!this.options.treeshake || module.info.moduleSideEffects === 'no-treeshake') {
+        if (!this.options.treeshake || module.info.hasModuleSideEffects === 'no-treeshake') {
             for (const dependency of module.dependencies) {
                 if (dependency instanceof Module) {
                     dependency.importedFromNotTreeshaken = true;
@@ -23151,7 +22111,7 @@
         return module.dynamicImports.map(async (dynamicImport) => {
             const resolvedId = await this.resolveDynamicImport(module, typeof dynamicImport.argument === 'string'
                 ? dynamicImport.argument
-                : dynamicImport.argument.esTreeNode, module.id, getAssertionsFromImportExpression(dynamicImport.node));
+                : dynamicImport.argument.esTreeNode, module.id);
             if (resolvedId && typeof resolvedId === 'object') {
                 dynamicImport.id = resolvedId.id;
             }
@@ -23159,89 +22119,55 @@
         });
     }
     getResolveStaticDependencyPromises(module) {
-        // eslint-disable-next-line unicorn/prefer-spread
-        return Array.from(module.sourcesWithAssertions, async ([source, assertions]) => [
+        return Array.from(module.sources, async (source) => [
             source,
             (module.resolvedIds[source] =
                 module.resolvedIds[source] ||
-                    this.handleInvalidResolvedId(await this.resolveId(source, module.id, EMPTY_OBJECT, false, assertions), source, module.id, assertions))
+                    this.handleResolveId(await this.resolveId(source, module.id, EMPTY_OBJECT, false), source, module.id))
         ]);
     }
-    getResolvedIdWithDefaults(resolvedId, assertions) {
-        if (!resolvedId) {
-            return null;
-        }
-        const external = resolvedId.external || false;
-        return {
-            assertions: resolvedId.assertions || assertions,
-            external,
-            id: resolvedId.id,
-            meta: resolvedId.meta || {},
-            moduleSideEffects: resolvedId.moduleSideEffects ?? this.hasModuleSideEffects(resolvedId.id, !!external),
-            resolvedBy: resolvedId.resolvedBy ?? 'rollup',
-            syntheticNamedExports: resolvedId.syntheticNamedExports ?? false
-        };
-    }
-    async handleExistingModule(module, isEntry, isPreload) {
-        const loadPromise = this.moduleLoadPromises.get(module);
-        if (isPreload) {
-            return isPreload === RESOLVE_DEPENDENCIES
-                ? waitForDependencyResolution(loadPromise)
-                : loadPromise;
-        }
-        if (isEntry) {
-            module.info.isEntry = true;
-            this.implicitEntryModules.delete(module);
-            for (const dependant of module.implicitlyLoadedAfter) {
-                dependant.implicitlyLoadedBefore.delete(module);
-            }
-            module.implicitlyLoadedAfter.clear();
-        }
-        return this.fetchModuleDependencies(module, ...(await loadPromise));
-    }
-    handleInvalidResolvedId(resolvedId, source, importer, assertions) {
+    handleResolveId(resolvedId, source, importer) {
         if (resolvedId === null) {
             if (isRelative(source)) {
-                return error(errorUnresolvedImport(source, importer));
+                return error(errUnresolvedImport(source, importer));
             }
-            this.options.onwarn(errorUnresolvedImportTreatedAsExternal(source, importer));
+            this.options.onwarn(errUnresolvedImportTreatedAsExternal(source, importer));
             return {
-                assertions,
                 external: true,
                 id: source,
-                meta: {},
+                meta: EMPTY_OBJECT,
                 moduleSideEffects: this.hasModuleSideEffects(source, true),
-                resolvedBy: 'rollup',
                 syntheticNamedExports: false
             };
         }
-        else if (resolvedId.external && resolvedId.syntheticNamedExports) {
-            this.options.onwarn(errorExternalSyntheticExports(source, importer));
+        else {
+            if (resolvedId.external && resolvedId.syntheticNamedExports) {
+                this.options.onwarn(errExternalSyntheticExports(source, importer));
+            }
         }
         return resolvedId;
     }
     async loadEntryModule(unresolvedId, isEntry, importer, implicitlyLoadedBefore) {
-        const resolveIdResult = await resolveId(unresolvedId, importer, this.options.preserveSymlinks, this.pluginDriver, this.resolveId, null, EMPTY_OBJECT, true, EMPTY_OBJECT);
+        const resolveIdResult = await resolveId(unresolvedId, importer, this.options.preserveSymlinks, this.pluginDriver, this.resolveId, null, EMPTY_OBJECT, true);
         if (resolveIdResult == null) {
             return error(implicitlyLoadedBefore === null
-                ? errorUnresolvedEntry(unresolvedId)
-                : errorUnresolvedImplicitDependant(unresolvedId, implicitlyLoadedBefore));
+                ? errUnresolvedEntry(unresolvedId)
+                : errUnresolvedImplicitDependant(unresolvedId, implicitlyLoadedBefore));
         }
         if (resolveIdResult === false ||
             (typeof resolveIdResult === 'object' && resolveIdResult.external)) {
             return error(implicitlyLoadedBefore === null
-                ? errorEntryCannotBeExternal(unresolvedId)
-                : errorImplicitDependantCannotBeExternal(unresolvedId, implicitlyLoadedBefore));
+                ? errEntryCannotBeExternal(unresolvedId)
+                : errImplicitDependantCannotBeExternal(unresolvedId, implicitlyLoadedBefore));
         }
-        return this.fetchModule(this.getResolvedIdWithDefaults(typeof resolveIdResult === 'object'
+        return this.fetchModule(this.addDefaultsToResolvedId(typeof resolveIdResult === 'object'
             ? resolveIdResult
-            : { id: resolveIdResult }, EMPTY_OBJECT), undefined, isEntry, false);
+            : { id: resolveIdResult }), undefined, isEntry);
     }
-    async resolveDynamicImport(module, specifier, importer, assertions) {
+    async resolveDynamicImport(module, specifier, importer) {
         const resolution = await this.pluginDriver.hookFirst('resolveDynamicImport', [
             specifier,
-            importer,
-            { assertions }
+            importer
         ]);
         if (typeof specifier !== 'string') {
             if (typeof resolution === 'string') {
@@ -23250,19 +22176,18 @@
             if (!resolution) {
                 return null;
             }
-            return this.getResolvedIdWithDefaults(resolution, assertions);
+            return {
+                external: false,
+                moduleSideEffects: true,
+                ...resolution
+            };
         }
         if (resolution == null) {
-            const existingResolution = module.resolvedIds[specifier];
-            if (existingResolution) {
-                if (doAssertionsDiffer(existingResolution.assertions, assertions)) {
-                    this.options.onwarn(errorInconsistentImportAssertions(existingResolution.assertions, assertions, specifier, importer));
-                }
-                return existingResolution;
-            }
-            return (module.resolvedIds[specifier] = this.handleInvalidResolvedId(await this.resolveId(specifier, module.id, EMPTY_OBJECT, false, assertions), specifier, module.id, assertions));
+            return (module.resolvedIds[specifier] =
+                module.resolvedIds[specifier] ||
+                    this.handleResolveId(await this.resolveId(specifier, module.id, EMPTY_OBJECT, false), specifier, module.id));
         }
-        return this.handleInvalidResolvedId(this.getResolvedIdWithDefaults(this.getNormalizedResolvedIdWithoutDefaults(resolution, importer, specifier), assertions), specifier, importer, assertions);
+        return this.handleResolveId(this.addDefaultsToResolvedId(this.getNormalizedResolvedIdWithoutDefaults(resolution, importer, specifier)), specifier, importer);
     }
 }
 function normalizeRelativeExternalId(source, importer) {
@@ -23272,16 +22197,17 @@
             : resolve(source)
         : source;
 }
-function addChunkNamesToModule(module, { fileName, name }, isUserDefined, priority) {
+function addChunkNamesToModule(module, { fileName, name }, isUserDefined) {
     if (fileName !== null) {
         module.chunkFileNames.add(fileName);
     }
     else if (name !== null) {
-        // Always keep chunkNames sorted by priority
-        let namePosition = 0;
-        while (module.chunkNames[namePosition]?.priority < priority)
-            namePosition++;
-        module.chunkNames.splice(namePosition, 0, { isUserDefined, name, priority });
+        if (module.chunkName === null) {
+            module.chunkName = name;
+        }
+        if (isUserDefined) {
+            module.userChunkNames.add(name);
+        }
     }
 }
 function isNotAbsoluteExternal(id, source, makeAbsoluteExternalsRelative) {
@@ -23289,10 +22215,6 @@
         (makeAbsoluteExternalsRelative === 'ifRelativeSource' && isRelative(source)) ||
         !isAbsolute(id));
 }
-async function waitForDependencyResolution(loadPromise) {
-    const [resolveStaticDependencyPromises, resolveDynamicImportPromises] = await loadPromise;
-    return Promise.all([...resolveStaticDependencyPromises, ...resolveDynamicImportPromises]);
-}
 
 class GlobalScope extends Scope$1 {
     constructor() {
@@ -23310,232 +22232,20 @@
     }
 }
 
-function getSourceHash(source) {
-    return createHash().update(source).digest('hex');
-}
-function generateAssetFileName(name, source, sourceHash, outputOptions, bundle) {
-    const emittedName = outputOptions.sanitizeFileName(name || 'asset');
-    return makeUnique(renderNamePattern(typeof outputOptions.assetFileNames === 'function'
-        ? outputOptions.assetFileNames({ name, source, type: 'asset' })
-        : outputOptions.assetFileNames, 'output.assetFileNames', {
-        ext: () => extname(emittedName).slice(1),
-        extname: () => extname(emittedName),
-        hash: size => sourceHash.slice(0, Math.max(0, size || defaultHashSize)),
-        name: () => emittedName.slice(0, Math.max(0, emittedName.length - extname(emittedName).length))
-    }), bundle);
-}
-function reserveFileNameInBundle(fileName, { bundle }, warn) {
-    if (bundle[lowercaseBundleKeys].has(fileName.toLowerCase())) {
-        warn(errorFileNameConflict(fileName));
-    }
-    else {
-        bundle[fileName] = FILE_PLACEHOLDER;
-    }
-}
-function hasValidType(emittedFile) {
-    return Boolean(emittedFile &&
-        (emittedFile.type === 'asset' ||
-            emittedFile.type === 'chunk'));
-}
-function hasValidName(emittedFile) {
-    const validatedName = emittedFile.fileName || emittedFile.name;
-    return !validatedName || (typeof validatedName === 'string' && !isPathFragment(validatedName));
-}
-function getValidSource(source, emittedFile, fileReferenceId) {
-    if (!(typeof source === 'string' || source instanceof Uint8Array)) {
-        const assetName = emittedFile.fileName || emittedFile.name || fileReferenceId;
-        return error(errorFailedValidation(`Could not set source for ${typeof assetName === 'string' ? `asset "${assetName}"` : 'unnamed asset'}, asset source needs to be a string, Uint8Array or Buffer.`));
-    }
-    return source;
-}
-function getAssetFileName(file, referenceId) {
-    if (typeof file.fileName !== 'string') {
-        return error(errorAssetNotFinalisedForFileName(file.name || referenceId));
-    }
-    return file.fileName;
-}
-function getChunkFileName(file, facadeChunkByModule) {
-    if (file.fileName) {
-        return file.fileName;
-    }
-    if (facadeChunkByModule) {
-        return facadeChunkByModule.get(file.module).getFileName();
-    }
-    return error(errorChunkNotGeneratedForFileName(file.fileName || file.name));
-}
-class FileEmitter {
-    constructor(graph, options, baseFileEmitter) {
-        this.graph = graph;
-        this.options = options;
-        this.facadeChunkByModule = null;
-        this.nextIdBase = 1;
-        this.output = null;
-        this.outputFileEmitters = [];
-        this.emitFile = (emittedFile) => {
-            if (!hasValidType(emittedFile)) {
-                return error(errorFailedValidation(`Emitted files must be of type "asset" or "chunk", received "${emittedFile && emittedFile.type}".`));
-            }
-            if (!hasValidName(emittedFile)) {
-                return error(errorFailedValidation(`The "fileName" or "name" properties of emitted files must be strings that are neither absolute nor relative paths, received "${emittedFile.fileName || emittedFile.name}".`));
-            }
-            if (emittedFile.type === 'chunk') {
-                return this.emitChunk(emittedFile);
-            }
-            return this.emitAsset(emittedFile);
-        };
-        this.finaliseAssets = () => {
-            for (const [referenceId, emittedFile] of this.filesByReferenceId) {
-                if (emittedFile.type === 'asset' && typeof emittedFile.fileName !== 'string')
-                    return error(errorNoAssetSourceSet(emittedFile.name || referenceId));
-            }
-        };
-        this.getFileName = (fileReferenceId) => {
-            const emittedFile = this.filesByReferenceId.get(fileReferenceId);
-            if (!emittedFile)
-                return error(errorFileReferenceIdNotFoundForFilename(fileReferenceId));
-            if (emittedFile.type === 'chunk') {
-                return getChunkFileName(emittedFile, this.facadeChunkByModule);
-            }
-            return getAssetFileName(emittedFile, fileReferenceId);
-        };
-        this.setAssetSource = (referenceId, requestedSource) => {
-            const consumedFile = this.filesByReferenceId.get(referenceId);
-            if (!consumedFile)
-                return error(errorAssetReferenceIdNotFoundForSetSource(referenceId));
-            if (consumedFile.type !== 'asset') {
-                return error(errorFailedValidation(`Asset sources can only be set for emitted assets but "${referenceId}" is an emitted chunk.`));
-            }
-            if (consumedFile.source !== undefined) {
-                return error(errorAssetSourceAlreadySet(consumedFile.name || referenceId));
-            }
-            const source = getValidSource(requestedSource, consumedFile, referenceId);
-            if (this.output) {
-                this.finalizeAsset(consumedFile, source, referenceId, this.output);
-            }
-            else {
-                consumedFile.source = source;
-                for (const emitter of this.outputFileEmitters) {
-                    emitter.finalizeAsset(consumedFile, source, referenceId, emitter.output);
-                }
-            }
-        };
-        this.setChunkInformation = (facadeChunkByModule) => {
-            this.facadeChunkByModule = facadeChunkByModule;
-        };
-        this.setOutputBundle = (bundle, outputOptions) => {
-            const output = (this.output = {
-                bundle,
-                fileNamesBySource: new Map(),
-                outputOptions
-            });
-            for (const emittedFile of this.filesByReferenceId.values()) {
-                if (emittedFile.fileName) {
-                    reserveFileNameInBundle(emittedFile.fileName, output, this.options.onwarn);
-                }
-            }
-            for (const [referenceId, consumedFile] of this.filesByReferenceId) {
-                if (consumedFile.type === 'asset' && consumedFile.source !== undefined) {
-                    this.finalizeAsset(consumedFile, consumedFile.source, referenceId, output);
-                }
-            }
-        };
-        this.filesByReferenceId = baseFileEmitter
-            ? new Map(baseFileEmitter.filesByReferenceId)
-            : new Map();
-        baseFileEmitter?.addOutputFileEmitter(this);
-    }
-    addOutputFileEmitter(outputFileEmitter) {
-        this.outputFileEmitters.push(outputFileEmitter);
-    }
-    assignReferenceId(file, idBase) {
-        let referenceId = idBase;
-        do {
-            referenceId = createHash().update(referenceId).digest('hex').slice(0, 8);
-        } while (this.filesByReferenceId.has(referenceId) ||
-            this.outputFileEmitters.some(({ filesByReferenceId }) => filesByReferenceId.has(referenceId)));
-        this.filesByReferenceId.set(referenceId, file);
-        for (const { filesByReferenceId } of this.outputFileEmitters) {
-            filesByReferenceId.set(referenceId, file);
+// eslint-disable-next-line @typescript-eslint/ban-types
+function getDeprecatedContextHandler(handler, handlerName, newHandlerName, pluginName, activeDeprecation, options) {
+    let deprecationWarningShown = false;
+    return ((...args) => {
+        if (!deprecationWarningShown) {
+            deprecationWarningShown = true;
+            warnDeprecation({
+                message: `The "this.${handlerName}" plugin context function used by plugin ${pluginName} is deprecated. The "this.${newHandlerName}" plugin context function should be used instead.`,
+                plugin: pluginName
+            }, activeDeprecation, options);
         }
-        return referenceId;
-    }
-    emitAsset(emittedAsset) {
-        const source = emittedAsset.source === undefined
-            ? undefined
-            : getValidSource(emittedAsset.source, emittedAsset, null);
-        const consumedAsset = {
-            fileName: emittedAsset.fileName,
-            name: emittedAsset.name,
-            needsCodeReference: !!emittedAsset.needsCodeReference,
-            source,
-            type: 'asset'
-        };
-        const referenceId = this.assignReferenceId(consumedAsset, emittedAsset.fileName || emittedAsset.name || String(this.nextIdBase++));
-        if (this.output) {
-            this.emitAssetWithReferenceId(consumedAsset, referenceId, this.output);
-        }
-        else {
-            for (const fileEmitter of this.outputFileEmitters) {
-                fileEmitter.emitAssetWithReferenceId(consumedAsset, referenceId, fileEmitter.output);
-            }
-        }
-        return referenceId;
-    }
-    emitAssetWithReferenceId(consumedAsset, referenceId, output) {
-        const { fileName, source } = consumedAsset;
-        if (fileName) {
-            reserveFileNameInBundle(fileName, output, this.options.onwarn);
-        }
-        if (source !== undefined) {
-            this.finalizeAsset(consumedAsset, source, referenceId, output);
-        }
-    }
-    emitChunk(emittedChunk) {
-        if (this.graph.phase > BuildPhase.LOAD_AND_PARSE) {
-            return error(errorInvalidRollupPhaseForChunkEmission());
-        }
-        if (typeof emittedChunk.id !== 'string') {
-            return error(errorFailedValidation(`Emitted chunks need to have a valid string id, received "${emittedChunk.id}"`));
-        }
-        const consumedChunk = {
-            fileName: emittedChunk.fileName,
-            module: null,
-            name: emittedChunk.name || emittedChunk.id,
-            type: 'chunk'
-        };
-        this.graph.moduleLoader
-            .emitChunk(emittedChunk)
-            .then(module => (consumedChunk.module = module))
-            .catch(() => {
-            // Avoid unhandled Promise rejection as the error will be thrown later
-            // once module loading has finished
-        });
-        return this.assignReferenceId(consumedChunk, emittedChunk.id);
-    }
-    finalizeAsset(consumedFile, source, referenceId, { bundle, fileNamesBySource, outputOptions }) {
-        let fileName = consumedFile.fileName;
-        // Deduplicate assets if an explicit fileName is not provided
-        if (!fileName) {
-            const sourceHash = getSourceHash(source);
-            fileName = fileNamesBySource.get(sourceHash);
-            if (!fileName) {
-                fileName = generateAssetFileName(consumedFile.name, source, sourceHash, outputOptions, bundle);
-                fileNamesBySource.set(sourceHash, fileName);
-            }
-        }
-        // We must not modify the original assets to avoid interaction between outputs
-        const assetWithFileName = { ...consumedFile, fileName, source };
-        this.filesByReferenceId.set(referenceId, assetWithFileName);
-        bundle[fileName] = {
-            fileName,
-            name: consumedFile.name,
-            needsCodeReference: consumedFile.needsCodeReference,
-            source,
-            type: 'asset'
-        };
-    }
+        return handler(...args);
+    });
 }
-
 function getPluginContext(plugin, pluginCache, graph, options, fileEmitter, existingPluginNames) {
     let cacheable = true;
     if (typeof plugin.cacheKey !== 'string') {
@@ -23559,42 +22269,49 @@
     else {
         cacheInstance = getCacheForUncacheablePlugin(plugin.name);
     }
-    return {
+    const context = {
         addWatchFile(id) {
             if (graph.phase >= BuildPhase.GENERATE) {
-                return this.error(errorInvalidRollupPhaseForAddWatchFile());
+                return this.error(errInvalidRollupPhaseForAddWatchFile());
             }
             graph.watchFiles[id] = true;
         },
         cache: cacheInstance,
+        emitAsset: getDeprecatedContextHandler((name, source) => fileEmitter.emitFile({ name, source, type: 'asset' }), 'emitAsset', 'emitFile', plugin.name, true, options),
+        emitChunk: getDeprecatedContextHandler((id, options) => fileEmitter.emitFile({ id, name: options && options.name, type: 'chunk' }), 'emitChunk', 'emitFile', plugin.name, true, options),
         emitFile: fileEmitter.emitFile.bind(fileEmitter),
-        error(error_) {
-            return error(errorPluginError(error_, plugin.name));
+        error(err) {
+            return throwPluginError(err, plugin.name);
         },
+        getAssetFileName: getDeprecatedContextHandler(fileEmitter.getFileName, 'getAssetFileName', 'getFileName', plugin.name, true, options),
+        getChunkFileName: getDeprecatedContextHandler(fileEmitter.getFileName, 'getChunkFileName', 'getFileName', plugin.name, true, options),
         getFileName: fileEmitter.getFileName,
         getModuleIds: () => graph.modulesById.keys(),
         getModuleInfo: graph.getModuleInfo,
         getWatchFiles: () => Object.keys(graph.watchFiles),
-        load(resolvedId) {
-            return graph.moduleLoader.preloadModule(resolvedId);
-        },
+        isExternal: getDeprecatedContextHandler((id, parentId, isResolved = false) => options.external(id, parentId, isResolved), 'isExternal', 'resolve', plugin.name, true, options),
         meta: {
             rollupVersion: version$1,
             watchMode: graph.watchMode
         },
         get moduleIds() {
             function* wrappedModuleIds() {
-                // We are wrapping this in a generator to only show the message once we are actually iterating
-                warnDeprecation(`Accessing "this.moduleIds" on the plugin context by plugin ${plugin.name} is deprecated. The "this.getModuleIds" plugin context function should be used instead.`, URL_THIS_GETMODULEIDS, true, options, plugin.name);
+                warnDeprecation({
+                    message: `Accessing "this.moduleIds" on the plugin context by plugin ${plugin.name} is deprecated. The "this.getModuleIds" plugin context function should be used instead.`,
+                    plugin: plugin.name
+                }, false, options);
                 yield* moduleIds;
             }
             const moduleIds = graph.modulesById.keys();
             return wrappedModuleIds();
         },
         parse: graph.contextParse.bind(graph),
-        resolve(source, importer, { assertions, custom, isEntry, skipSelf } = BLANK) {
-            return graph.moduleLoader.resolveId(source, importer, custom, isEntry, assertions || EMPTY_OBJECT, skipSelf ? [{ importer, plugin, source }] : null);
+        resolve(source, importer, { custom, isEntry, skipSelf } = BLANK) {
+            return graph.moduleLoader.resolveId(source, importer, custom, isEntry, skipSelf ? [{ importer, plugin, source }] : null);
         },
+        resolveId: getDeprecatedContextHandler((source, importer) => graph.moduleLoader
+            .resolveId(source, importer, BLANK, undefined)
+            .then(resolveId => resolveId && resolveId.id), 'resolveId', 'resolve', plugin.name, true, options),
         setAssetSource: fileEmitter.setAssetSource,
         warn(warning) {
             if (typeof warning === 'string')
@@ -23606,9 +22323,9 @@
             options.onwarn(warning);
         }
     };
+    return context;
 }
 
-// This will make sure no input hook is omitted
 const inputHookNames = {
     buildEnd: 1,
     buildStart: 1,
@@ -23619,35 +22336,38 @@
     options: 1,
     resolveDynamicImport: 1,
     resolveId: 1,
-    shouldTransformCachedModule: 1,
     transform: 1,
     watchChange: 1
 };
 const inputHooks = Object.keys(inputHookNames);
+function throwInvalidHookError(hookName, pluginName) {
+    return error({
+        code: 'INVALID_PLUGIN_HOOK',
+        message: `Error running plugin hook ${hookName} for ${pluginName}, expected a function hook.`
+    });
+}
 class PluginDriver {
     constructor(graph, options, userPlugins, pluginCache, basePluginDriver) {
         this.graph = graph;
         this.options = options;
+        this.pluginContexts = new Map();
+        warnDeprecatedHooks(userPlugins, options);
         this.pluginCache = pluginCache;
-        this.sortedPlugins = new Map();
-        this.unfulfilledActions = new Set();
         this.fileEmitter = new FileEmitter(graph, options, basePluginDriver && basePluginDriver.fileEmitter);
         this.emitFile = this.fileEmitter.emitFile.bind(this.fileEmitter);
         this.getFileName = this.fileEmitter.getFileName.bind(this.fileEmitter);
-        this.finaliseAssets = this.fileEmitter.finaliseAssets.bind(this.fileEmitter);
-        this.setChunkInformation = this.fileEmitter.setChunkInformation.bind(this.fileEmitter);
+        this.finaliseAssets = this.fileEmitter.assertAssetsFinalized.bind(this.fileEmitter);
         this.setOutputBundle = this.fileEmitter.setOutputBundle.bind(this.fileEmitter);
-        this.plugins = [...(basePluginDriver ? basePluginDriver.plugins : []), ...userPlugins];
+        this.plugins = userPlugins.concat(basePluginDriver ? basePluginDriver.plugins : []);
         const existingPluginNames = new Set();
-        this.pluginContexts = new Map(this.plugins.map(plugin => [
-            plugin,
-            getPluginContext(plugin, pluginCache, graph, options, this.fileEmitter, existingPluginNames)
-        ]));
+        for (const plugin of this.plugins) {
+            this.pluginContexts.set(plugin, getPluginContext(plugin, pluginCache, graph, options, this.fileEmitter, existingPluginNames));
+        }
         if (basePluginDriver) {
             for (const plugin of userPlugins) {
                 for (const hook of inputHooks) {
                     if (hook in plugin) {
-                        options.onwarn(errorInputHookInOutputPlugin(plugin.name, hook));
+                        options.onwarn(errInputHookInOutputPlugin(plugin.name, hook));
                     }
                 }
             }
@@ -23656,238 +22376,148 @@
     createOutputPluginDriver(plugins) {
         return new PluginDriver(this.graph, this.options, plugins, this.pluginCache, this);
     }
-    getUnfulfilledHookActions() {
-        return this.unfulfilledActions;
-    }
     // chains, first non-null result stops and returns
-    hookFirst(hookName, parameters, replaceContext, skipped) {
-        return this.hookFirstAndGetPlugin(hookName, parameters, replaceContext, skipped).then(result => result && result[0]);
-    }
-    // chains, first non-null result stops and returns result and last plugin
-    async hookFirstAndGetPlugin(hookName, parameters, replaceContext, skipped) {
-        for (const plugin of this.getSortedPlugins(hookName)) {
-            if (skipped?.has(plugin))
+    hookFirst(hookName, args, replaceContext, skipped) {
+        let promise = Promise.resolve(undefined);
+        for (const plugin of this.plugins) {
+            if (skipped && skipped.has(plugin))
                 continue;
-            const result = await this.runHook(hookName, parameters, plugin, replaceContext);
-            if (result != null)
-                return [result, plugin];
+            promise = promise.then(result => {
+                if (result != null)
+                    return result;
+                return this.runHook(hookName, args, plugin, false, replaceContext);
+            });
         }
-        return null;
+        return promise;
     }
     // chains synchronously, first non-null result stops and returns
-    hookFirstSync(hookName, parameters, replaceContext) {
-        for (const plugin of this.getSortedPlugins(hookName)) {
-            const result = this.runHookSync(hookName, parameters, plugin, replaceContext);
+    hookFirstSync(hookName, args, replaceContext) {
+        for (const plugin of this.plugins) {
+            const result = this.runHookSync(hookName, args, plugin, replaceContext);
             if (result != null)
                 return result;
         }
         return null;
     }
     // parallel, ignores returns
-    async hookParallel(hookName, parameters, replaceContext) {
-        const parallelPromises = [];
-        for (const plugin of this.getSortedPlugins(hookName)) {
-            if (plugin[hookName].sequential) {
-                await Promise.all(parallelPromises);
-                parallelPromises.length = 0;
-                await this.runHook(hookName, parameters, plugin, replaceContext);
-            }
-            else {
-                parallelPromises.push(this.runHook(hookName, parameters, plugin, replaceContext));
-            }
+    hookParallel(hookName, args, replaceContext) {
+        const promises = [];
+        for (const plugin of this.plugins) {
+            const hookPromise = this.runHook(hookName, args, plugin, false, replaceContext);
+            if (!hookPromise)
+                continue;
+            promises.push(hookPromise);
         }
-        await Promise.all(parallelPromises);
+        return Promise.all(promises).then(() => { });
     }
     // chains, reduces returned value, handling the reduced value as the first hook argument
-    hookReduceArg0(hookName, [argument0, ...rest], reduce, replaceContext) {
-        let promise = Promise.resolve(argument0);
-        for (const plugin of this.getSortedPlugins(hookName)) {
-            promise = promise.then(argument0 => this.runHook(hookName, [argument0, ...rest], plugin, replaceContext).then(result => reduce.call(this.pluginContexts.get(plugin), argument0, result, plugin)));
+    hookReduceArg0(hookName, [arg0, ...rest], reduce, replaceContext) {
+        let promise = Promise.resolve(arg0);
+        for (const plugin of this.plugins) {
+            promise = promise.then(arg0 => {
+                const args = [arg0, ...rest];
+                const hookPromise = this.runHook(hookName, args, plugin, false, replaceContext);
+                if (!hookPromise)
+                    return arg0;
+                return hookPromise.then(result => reduce.call(this.pluginContexts.get(plugin), arg0, result, plugin));
+            });
         }
         return promise;
     }
     // chains synchronously, reduces returned value, handling the reduced value as the first hook argument
-    hookReduceArg0Sync(hookName, [argument0, ...rest], reduce, replaceContext) {
-        for (const plugin of this.getSortedPlugins(hookName)) {
-            const parameters = [argument0, ...rest];
-            const result = this.runHookSync(hookName, parameters, plugin, replaceContext);
-            argument0 = reduce.call(this.pluginContexts.get(plugin), argument0, result, plugin);
-        }
-        return argument0;
-    }
-    // chains, reduces returned value to type string, handling the reduced value separately. permits hooks as values.
-    async hookReduceValue(hookName, initialValue, parameters, reducer) {
-        const results = [];
-        const parallelResults = [];
-        for (const plugin of this.getSortedPlugins(hookName, validateAddonPluginHandler)) {
-            if (plugin[hookName].sequential) {
-                results.push(...(await Promise.all(parallelResults)));
-                parallelResults.length = 0;
-                results.push(await this.runHook(hookName, parameters, plugin));
-            }
-            else {
-                parallelResults.push(this.runHook(hookName, parameters, plugin));
-            }
+    hookReduceArg0Sync(hookName, [arg0, ...rest], reduce, replaceContext) {
+        for (const plugin of this.plugins) {
+            const args = [arg0, ...rest];
+            const result = this.runHookSync(hookName, args, plugin, replaceContext);
+            arg0 = reduce.call(this.pluginContexts.get(plugin), arg0, result, plugin);
+        }
+        return arg0;
+    }
+    // chains, reduces returned value to type T, handling the reduced value separately. permits hooks as values.
+    hookReduceValue(hookName, initialValue, args, reduce, replaceContext) {
+        let promise = Promise.resolve(initialValue);
+        for (const plugin of this.plugins) {
+            promise = promise.then(value => {
+                const hookPromise = this.runHook(hookName, args, plugin, true, replaceContext);
+                if (!hookPromise)
+                    return value;
+                return hookPromise.then(result => reduce.call(this.pluginContexts.get(plugin), value, result, plugin));
+            });
         }
-        results.push(...(await Promise.all(parallelResults)));
-        return results.reduce(reducer, await initialValue);
+        return promise;
     }
     // chains synchronously, reduces returned value to type T, handling the reduced value separately. permits hooks as values.
-    hookReduceValueSync(hookName, initialValue, parameters, reduce, replaceContext) {
-        let accumulator = initialValue;
-        for (const plugin of this.getSortedPlugins(hookName)) {
-            const result = this.runHookSync(hookName, parameters, plugin, replaceContext);
-            accumulator = reduce.call(this.pluginContexts.get(plugin), accumulator, result, plugin);
+    hookReduceValueSync(hookName, initialValue, args, reduce, replaceContext) {
+        let acc = initialValue;
+        for (const plugin of this.plugins) {
+            const result = this.runHookSync(hookName, args, plugin, replaceContext);
+            acc = reduce.call(this.pluginContexts.get(plugin), acc, result, plugin);
         }
-        return accumulator;
+        return acc;
     }
     // chains, ignores returns
-    hookSeq(hookName, parameters, replaceContext) {
+    hookSeq(hookName, args, replaceContext) {
         let promise = Promise.resolve();
-        for (const plugin of this.getSortedPlugins(hookName)) {
-            promise = promise.then(() => this.runHook(hookName, parameters, plugin, replaceContext));
+        for (const plugin of this.plugins) {
+            promise = promise.then(() => this.runHook(hookName, args, plugin, false, replaceContext));
         }
-        return promise.then(noReturn);
+        return promise;
     }
-    getSortedPlugins(hookName, validateHandler) {
-        return getOrCreate(this.sortedPlugins, hookName, () => getSortedValidatedPlugins(hookName, this.plugins, validateHandler));
+    // chains synchronously, ignores returns
+    hookSeqSync(hookName, args, replaceContext) {
+        for (const plugin of this.plugins) {
+            this.runHookSync(hookName, args, plugin, replaceContext);
+        }
     }
-    // Implementation signature
-    runHook(hookName, parameters, plugin, replaceContext) {
-        // We always filter for plugins that support the hook before running it
+    runHook(hookName, args, plugin, permitValues, hookContext) {
         const hook = plugin[hookName];
-        const handler = typeof hook === 'object' ? hook.handler : hook;
+        if (!hook)
+            return undefined;
         let context = this.pluginContexts.get(plugin);
-        if (replaceContext) {
-            context = replaceContext(context, plugin);
+        if (hookContext) {
+            context = hookContext(context, plugin);
         }
-        let action = null;
         return Promise.resolve()
             .then(() => {
-            if (typeof handler !== 'function') {
-                return handler;
+            // permit values allows values to be returned instead of a functional hook
+            if (typeof hook !== 'function') {
+                if (permitValues)
+                    return hook;
+                return throwInvalidHookError(hookName, plugin.name);
             }
             // eslint-disable-next-line @typescript-eslint/ban-types
-            const hookResult = handler.apply(context, parameters);
-            if (!hookResult?.then) {
-                // short circuit for non-thenables and non-Promises
-                return hookResult;
-            }
-            // Track pending hook actions to properly error out when
-            // unfulfilled promises cause rollup to abruptly and confusingly
-            // exit with a successful 0 return code but without producing any
-            // output, errors or warnings.
-            action = [plugin.name, hookName, parameters];
-            this.unfulfilledActions.add(action);
-            // Although it would be more elegant to just return hookResult here
-            // and put the .then() handler just above the .catch() handler below,
-            // doing so would subtly change the defacto async event dispatch order
-            // which at least one test and some plugins in the wild may depend on.
-            return Promise.resolve(hookResult).then(result => {
-                // action was fulfilled
-                this.unfulfilledActions.delete(action);
-                return result;
-            });
+            return hook.apply(context, args);
         })
-            .catch(error_ => {
-            if (action !== null) {
-                // action considered to be fulfilled since error being handled
-                this.unfulfilledActions.delete(action);
-            }
-            return error(errorPluginError(error_, plugin.name, { hook: hookName }));
-        });
+            .catch(err => throwPluginError(err, plugin.name, { hook: hookName }));
     }
     /**
      * Run a sync plugin hook and return the result.
      * @param hookName Name of the plugin hook. Must be in `PluginHooks`.
      * @param args Arguments passed to the plugin hook.
      * @param plugin The acutal plugin
-     * @param replaceContext When passed, the plugin context can be overridden.
+     * @param hookContext When passed, the plugin context can be overridden.
      */
-    runHookSync(hookName, parameters, plugin, replaceContext) {
+    runHookSync(hookName, args, plugin, hookContext) {
         const hook = plugin[hookName];
-        const handler = typeof hook === 'object' ? hook.handler : hook;
+        if (!hook)
+            return undefined;
         let context = this.pluginContexts.get(plugin);
-        if (replaceContext) {
-            context = replaceContext(context, plugin);
+        if (hookContext) {
+            context = hookContext(context, plugin);
         }
         try {
+            // permit values allows values to be returned instead of a functional hook
+            if (typeof hook !== 'function') {
+                return throwInvalidHookError(hookName, plugin.name);
+            }
             // eslint-disable-next-line @typescript-eslint/ban-types
-            return handler.apply(context, parameters);
+            return hook.apply(context, args);
         }
-        catch (error_) {
-            return error(errorPluginError(error_, plugin.name, { hook: hookName }));
+        catch (err) {
+            return throwPluginError(err, plugin.name, { hook: hookName });
         }
     }
 }
-function getSortedValidatedPlugins(hookName, plugins, validateHandler = validateFunctionPluginHandler) {
-    const pre = [];
-    const normal = [];
-    const post = [];
-    for (const plugin of plugins) {
-        const hook = plugin[hookName];
-        if (hook) {
-            if (typeof hook === 'object') {
-                validateHandler(hook.handler, hookName, plugin);
-                if (hook.order === 'pre') {
-                    pre.push(plugin);
-                    continue;
-                }
-                if (hook.order === 'post') {
-                    post.push(plugin);
-                    continue;
-                }
-            }
-            else {
-                validateHandler(hook, hookName, plugin);
-            }
-            normal.push(plugin);
-        }
-    }
-    return [...pre, ...normal, ...post];
-}
-function validateFunctionPluginHandler(handler, hookName, plugin) {
-    if (typeof handler !== 'function') {
-        error(errorInvalidFunctionPluginHook(hookName, plugin.name));
-    }
-}
-function validateAddonPluginHandler(handler, hookName, plugin) {
-    if (typeof handler !== 'string' && typeof handler !== 'function') {
-        return error(errorInvalidAddonPluginHook(hookName, plugin.name));
-    }
-}
-function noReturn() { }
-
-class Queue {
-    constructor(maxParallel) {
-        this.maxParallel = maxParallel;
-        this.queue = [];
-        this.workerCount = 0;
-    }
-    run(task) {
-        return new Promise((resolve, reject) => {
-            this.queue.push({ reject, resolve, task });
-            this.work();
-        });
-    }
-    async work() {
-        if (this.workerCount >= this.maxParallel)
-            return;
-        this.workerCount++;
-        let entry;
-        while ((entry = this.queue.shift())) {
-            const { reject, resolve, task } = entry;
-            try {
-                const result = await task();
-                resolve(result);
-            }
-            catch (error) {
-                reject(error);
-            }
-        }
-        this.workerCount--;
-    }
-}
 
 function normalizeEntryModules(entryModules) {
     if (Array.isArray(entryModules)) {
@@ -23909,8 +22539,8 @@
 }
 class Graph {
     constructor(options, watcher) {
+        var _a, _b;
         this.options = options;
-        this.astLru = flru(5);
         this.cachedModules = new Map();
         this.deoptimizationTracker = new PathTracker();
         this.entryModules = [];
@@ -23930,11 +22560,11 @@
             return foundModule.info;
         };
         if (options.cache !== false) {
-            if (options.cache?.modules) {
+            if ((_a = options.cache) === null || _a === void 0 ? void 0 : _a.modules) {
                 for (const module of options.cache.modules)
                     this.cachedModules.set(module.id, module);
             }
-            this.pluginCache = options.cache?.plugins || Object.create(null);
+            this.pluginCache = ((_b = options.cache) === null || _b === void 0 ? void 0 : _b.plugins) || Object.create(null);
             // increment access counter
             for (const name in this.pluginCache) {
                 const cache = this.pluginCache[name];
@@ -23944,25 +22574,27 @@
         }
         if (watcher) {
             this.watchMode = true;
-            const handleChange = (...parameters) => this.pluginDriver.hookParallel('watchChange', parameters);
-            const handleClose = () => this.pluginDriver.hookParallel('closeWatcher', []);
-            watcher.onCurrentRun('change', handleChange);
-            watcher.onCurrentRun('close', handleClose);
+            const handleChange = (...args) => this.pluginDriver.hookSeqSync('watchChange', args);
+            const handleClose = () => this.pluginDriver.hookSeqSync('closeWatcher', []);
+            watcher.on('change', handleChange);
+            watcher.on('close', handleClose);
+            watcher.once('restart', () => {
+                watcher.removeListener('change', handleChange);
+                watcher.removeListener('close', handleClose);
+            });
         }
         this.pluginDriver = new PluginDriver(this, options, options.plugins, this.pluginCache);
         this.acornParser = Parser.extend(...options.acornInjectPlugins);
         this.moduleLoader = new ModuleLoader(this, this.modulesById, this.options, this.pluginDriver);
-        this.fileOperationQueue = new Queue(options.maxParallelFileOps);
-        this.pureFunctions = getPureFunctions(options);
     }
     async build() {
         timeStart('generate module graph', 2);
         await this.generateModuleGraph();
         timeEnd('generate module graph', 2);
-        timeStart('sort and bind modules', 2);
+        timeStart('sort modules', 2);
         this.phase = BuildPhase.ANALYSE;
         this.sortModules();
-        timeEnd('sort and bind modules', 2);
+        timeEnd('sort modules', 2);
         timeStart('mark included statements', 2);
         this.includeStatements();
         timeEnd('mark included statements', 2);
@@ -23971,13 +22603,15 @@
     contextParse(code, options = {}) {
         const onCommentOrig = options.onComment;
         const comments = [];
-        options.onComment =
-            onCommentOrig && typeof onCommentOrig == 'function'
-                ? (block, text, start, end, ...parameters) => {
-                    comments.push({ end, start, type: block ? 'Block' : 'Line', value: text });
-                    return onCommentOrig.call(options, block, text, start, end, ...parameters);
-                }
-                : comments;
+        if (onCommentOrig && typeof onCommentOrig == 'function') {
+            options.onComment = (block, text, start, end, ...args) => {
+                comments.push({ end, start, type: block ? 'Block' : 'Line', value: text });
+                return onCommentOrig.call(options, block, text, start, end, ...args);
+            };
+        }
+        else {
+            options.onComment = comments;
+        }
         const ast = this.acornParser.parse(code, {
             ...this.options.acorn,
             ...options
@@ -24034,7 +22668,7 @@
                 this.needsTreeshakingPass = false;
                 for (const module of this.modules) {
                     if (module.isExecuted) {
-                        if (module.info.moduleSideEffects === 'no-treeshake') {
+                        if (module.info.hasModuleSideEffects === 'no-treeshake') {
                             module.includeAllInBundle();
                         }
                         else {
@@ -24064,7 +22698,7 @@
         for (const module of this.implicitEntryModules) {
             for (const dependant of module.implicitlyLoadedAfter) {
                 if (!(dependant.info.isEntry || dependant.isIncluded())) {
-                    error(errorImplicitDependantIsNotIncluded(dependant));
+                    error(errImplicitDependantIsNotIncluded(dependant));
                 }
             }
         }
@@ -24072,7 +22706,12 @@
     sortModules() {
         const { orderedModules, cyclePaths } = analyseModuleExecution(this.entryModules);
         for (const cyclePath of cyclePaths) {
-            this.options.onwarn(errorCircularDependency(cyclePath));
+            this.options.onwarn({
+                code: 'CIRCULAR_DEPENDENCY',
+                cycle: cyclePath,
+                importer: cyclePath[0],
+                message: `Circular dependency: ${cyclePath.join(' -> ')}`
+            });
         }
         this.modules = orderedModules;
         for (const module of this.modules) {
@@ -24082,300 +22721,21 @@
     }
     warnForMissingExports() {
         for (const module of this.modules) {
-            for (const importDescription of module.importDescriptions.values()) {
+            for (const importDescription of Object.values(module.importDescriptions)) {
                 if (importDescription.name !== '*' &&
-                    !importDescription.module.getVariableForExportName(importDescription.name)[0]) {
-                    module.warn(errorMissingExport(importDescription.name, module.id, importDescription.module.id), importDescription.start);
+                    !importDescription.module.getVariableForExportName(importDescription.name)) {
+                    module.warn({
+                        code: 'NON_EXISTENT_EXPORT',
+                        message: `Non-existent export '${importDescription.name}' is imported from ${relativeId(importDescription.module.id)}`,
+                        name: importDescription.name,
+                        source: importDescription.module.id
+                    }, importDescription.start);
                 }
             }
         }
     }
 }
 
-function formatAction([pluginName, hookName, parameters]) {
-    const action = `(${pluginName}) ${hookName}`;
-    const s = JSON.stringify;
-    switch (hookName) {
-        case 'resolveId': {
-            return `${action} ${s(parameters[0])} ${s(parameters[1])}`;
-        }
-        case 'load': {
-            return `${action} ${s(parameters[0])}`;
-        }
-        case 'transform': {
-            return `${action} ${s(parameters[1])}`;
-        }
-        case 'shouldTransformCachedModule': {
-            return `${action} ${s(parameters[0].id)}`;
-        }
-        case 'moduleParsed': {
-            return `${action} ${s(parameters[0].id)}`;
-        }
-    }
-    return action;
-}
-// We do not directly listen on process to avoid max listeners warnings for
-// complicated build processes
-const beforeExitEvent = 'beforeExit';
-const beforeExitEmitter = new EventEmitter();
-beforeExitEmitter.setMaxListeners(0);
-process$1.on(beforeExitEvent, () => beforeExitEmitter.emit(beforeExitEvent));
-async function catchUnfinishedHookActions(pluginDriver, callback) {
-    let handleEmptyEventLoop;
-    const emptyEventLoopPromise = new Promise((_, reject) => {
-        handleEmptyEventLoop = () => {
-            const unfulfilledActions = pluginDriver.getUnfulfilledHookActions();
-            reject(new Error(`Unexpected early exit. This happens when Promises returned by plugins cannot resolve. Unfinished hook action(s) on exit:\n` +
-                [...unfulfilledActions].map(formatAction).join('\n')));
-        };
-        beforeExitEmitter.once(beforeExitEvent, handleEmptyEventLoop);
-    });
-    const result = await Promise.race([callback(), emptyEventLoopPromise]);
-    beforeExitEmitter.off(beforeExitEvent, handleEmptyEventLoop);
-    return result;
-}
-
-const leftCurlyBrace = "{".charCodeAt(0);
-const space = " ".charCodeAt(0);
-
-const keyword = "assert";
-const FUNC_STATEMENT = 1, FUNC_NULLABLE_ID = 4;
-
-function importAssertions(Parser) {
-  // Use supplied version acorn version if present, to avoid
-  // reference mismatches due to different acorn versions. This
-  // allows this plugin to be used with Rollup which supplies
-  // its own internal version of acorn and thereby sidesteps
-  // the package manager.
-  const acorn = Parser.acorn || _acorn;
-  const { tokTypes: tt, TokenType } = acorn;
-
-  return class extends Parser {
-    constructor(...args) {
-      super(...args);
-      this.assertToken = new TokenType(keyword);
-    }
-
-    _codeAt(i) {
-      return this.input.charCodeAt(i);
-    }
-
-    _eat(t) {
-      if (this.type !== t) {
-        this.unexpected();
-      }
-      this.next();
-    }
-
-    readToken(code) {
-      let i = 0;
-      for (; i < keyword.length; i++) {
-        if (this._codeAt(this.pos + i) !== keyword.charCodeAt(i)) {
-          return super.readToken(code);
-        }
-      }
-
-      // ensure that the keyword is at the correct location
-      // ie `assert{...` or `assert {...`
-      for (;; i++) {
-        if (this._codeAt(this.pos + i) === leftCurlyBrace) {
-          // Found '{'
-          break;
-        } else if (this._codeAt(this.pos + i) === space) {
-          // white space is allowed between `assert` and `{`, so continue.
-          continue;
-        } else {
-          return super.readToken(code);
-        }
-      }
-
-      // If we're inside a dynamic import expression we'll parse
-      // the `assert` keyword as a standard object property name
-      // ie `import(""./foo.json", { assert: { type: "json" } })`
-      if (this.type.label === "{") {
-        return super.readToken(code);
-      }
-
-      this.pos += keyword.length;
-      return this.finishToken(this.assertToken);
-    }
-
-    parseDynamicImport(node) {
-      this.next(); // skip `(`
-
-      // Parse node.source.
-      node.source = this.parseMaybeAssign();
-
-      if (this.eat(tt.comma)) {
-        const obj = this.parseObj(false);
-        node.arguments = [obj];
-      }
-      this._eat(tt.parenR);
-      return this.finishNode(node, "ImportExpression");
-    }
-
-    // ported from acorn/src/statement.js pp.parseExport
-    parseExport(node, exports) {
-      this.next();
-      // export * from '...'
-      if (this.eat(tt.star)) {
-        if (this.options.ecmaVersion >= 11) {
-          if (this.eatContextual("as")) {
-            node.exported = this.parseIdent(true);
-            this.checkExport(exports, node.exported.name, this.lastTokStart);
-          } else {
-            node.exported = null;
-          }
-        }
-        this.expectContextual("from");
-        if (this.type !== tt.string) { this.unexpected(); }
-        node.source = this.parseExprAtom();
-
-        if (this.type === this.assertToken) {
-          this.next();
-          const assertions = this.parseImportAssertions();
-          if (assertions) {
-            node.assertions = assertions;
-          }
-        }
-
-        this.semicolon();
-        return this.finishNode(node, "ExportAllDeclaration")
-      }
-      if (this.eat(tt._default)) { // export default ...
-        this.checkExport(exports, "default", this.lastTokStart);
-        var isAsync;
-        if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {
-          var fNode = this.startNode();
-          this.next();
-          if (isAsync) { this.next(); }
-          node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
-        } else if (this.type === tt._class) {
-          var cNode = this.startNode();
-          node.declaration = this.parseClass(cNode, "nullableID");
-        } else {
-          node.declaration = this.parseMaybeAssign();
-          this.semicolon();
-        }
-        return this.finishNode(node, "ExportDefaultDeclaration")
-      }
-      // export var|const|let|function|class ...
-      if (this.shouldParseExportStatement()) {
-        node.declaration = this.parseStatement(null);
-        if (node.declaration.type === "VariableDeclaration")
-          { this.checkVariableExport(exports, node.declaration.declarations); }
-        else
-          { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
-        node.specifiers = [];
-        node.source = null;
-      } else { // export { x, y as z } [from '...']
-        node.declaration = null;
-        node.specifiers = this.parseExportSpecifiers(exports);
-        if (this.eatContextual("from")) {
-          if (this.type !== tt.string) { this.unexpected(); }
-          node.source = this.parseExprAtom();
-
-          if (this.type === this.assertToken) {
-            this.next();
-            const assertions = this.parseImportAssertions();
-            if (assertions) {
-              node.assertions = assertions;
-            }
-          }
-        } else {
-          for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
-            // check for keywords used as local names
-            var spec = list[i];
-
-            this.checkUnreserved(spec.local);
-            // check if export is defined
-            this.checkLocalExport(spec.local);
-          }
-
-          node.source = null;
-        }
-        this.semicolon();
-      }
-      return this.finishNode(node, "ExportNamedDeclaration")
-    }
-
-    parseImport(node) {
-      this.next();
-      // import '...'
-      if (this.type === tt.string) {
-        node.specifiers = [];
-        node.source = this.parseExprAtom();
-      } else {
-        node.specifiers = this.parseImportSpecifiers();
-        this.expectContextual("from");
-        node.source =
-          this.type === tt.string ? this.parseExprAtom() : this.unexpected();
-      }
-
-      if (this.type === this.assertToken) {
-        this.next();
-        const assertions = this.parseImportAssertions();
-        if (assertions) {
-          node.assertions = assertions;
-        }
-      }
-      this.semicolon();
-      return this.finishNode(node, "ImportDeclaration");
-    }
-
-    parseImportAssertions() {
-      this._eat(tt.braceL);
-      const attrs = this.parseAssertEntries();
-      this._eat(tt.braceR);
-      return attrs;
-    }
-
-    parseAssertEntries() {
-      const attrs = [];
-      const attrNames = new Set();
-
-      do {
-        if (this.type === tt.braceR) {
-          break;
-        }
-
-        const node = this.startNode();
-
-        // parse AssertionKey : IdentifierName, StringLiteral
-        let assertionKeyNode;
-        if (this.type === tt.string) {
-          assertionKeyNode = this.parseLiteral(this.value);
-        } else {
-          assertionKeyNode = this.parseIdent(true);
-        }
-        this.next();
-        node.key = assertionKeyNode;
-
-        // check if we already have an entry for an attribute
-        // if a duplicate entry is found, throw an error
-        // for now this logic will come into play only when someone declares `type` twice
-        if (attrNames.has(node.key.name)) {
-          this.raise(this.pos, "Duplicated key in assertions");
-        }
-        attrNames.add(node.key.name);
-
-        if (this.type !== tt.string) {
-          this.raise(
-            this.pos,
-            "Only string is supported as an assertion value"
-          );
-        }
-
-        node.value = this.parseLiteral(this.value);
-
-        attrs.push(this.finishNode(node, "ImportAttribute"));
-      } while (this.eat(tt.comma));
-
-      return attrs;
-    }
-  };
-}
-
 function ensureArray(items) {
     if (Array.isArray(items)) {
         return items.filter(Boolean);
@@ -24386,26 +22746,25 @@
     return [];
 }
 
-async function asyncFlatten(array) {
-    do {
-        array = (await Promise.all(array)).flat(Infinity);
-    } while (array.some((v) => v?.then));
-    return array;
-}
-
 const defaultOnWarn = warning => console.warn(warning.message || warning);
 function warnUnknownOptions(passedOptions, validOptions, optionType, warn, ignoredKeys = /$./) {
     const validOptionSet = new Set(validOptions);
     const unknownOptions = Object.keys(passedOptions).filter(key => !(validOptionSet.has(key) || ignoredKeys.test(key)));
     if (unknownOptions.length > 0) {
-        warn(errorUnknownOption(optionType, unknownOptions, [...validOptionSet].sort()));
+        warn({
+            code: 'UNKNOWN_OPTION',
+            message: `Unknown ${optionType}: ${unknownOptions.join(', ')}. Allowed options: ${[
+                ...validOptionSet
+            ]
+                .sort()
+                .join(', ')}`
+        });
     }
 }
 const treeshakePresets = {
     recommended: {
         annotations: true,
         correctVarValueBeforeDeclaration: false,
-        manualPureFunctions: EMPTY_ARRAY,
         moduleSideEffects: () => true,
         propertyReadSideEffects: true,
         tryCatchDeoptimization: true,
@@ -24414,7 +22773,6 @@
     safest: {
         annotations: true,
         correctVarValueBeforeDeclaration: true,
-        manualPureFunctions: EMPTY_ARRAY,
         moduleSideEffects: () => true,
         propertyReadSideEffects: true,
         tryCatchDeoptimization: true,
@@ -24423,7 +22781,6 @@
     smallest: {
         annotations: true,
         correctVarValueBeforeDeclaration: false,
-        manualPureFunctions: EMPTY_ARRAY,
         moduleSideEffects: () => false,
         propertyReadSideEffects: false,
         tryCatchDeoptimization: false,
@@ -24435,74 +22792,71 @@
         arrowFunctions: true,
         constBindings: true,
         objectShorthand: true,
-        reservedNamesAsProps: true,
-        symbols: true
+        reservedNamesAsProps: true
     },
     es5: {
         arrowFunctions: false,
         constBindings: false,
         objectShorthand: false,
-        reservedNamesAsProps: true,
-        symbols: false
+        reservedNamesAsProps: true
     }
 };
-const objectifyOption = (value) => value && typeof value === 'object' ? value : {};
-const objectifyOptionWithPresets = (presets, optionName, urlSnippet, additionalValues) => (value) => {
+const objectifyOptionWithPresets = (presets, optionName, additionalValues) => (value) => {
     if (typeof value === 'string') {
         const preset = presets[value];
         if (preset) {
             return preset;
         }
-        error(errorInvalidOption(optionName, urlSnippet, `valid values are ${additionalValues}${printQuotedStringList(Object.keys(presets))}. You can also supply an object for more fine-grained control`, value));
+        error(errInvalidOption(optionName, getHashFromObjectOption(optionName), `valid values are ${additionalValues}${printQuotedStringList(Object.keys(presets))}. You can also supply an object for more fine-grained control`, value));
     }
-    return objectifyOption(value);
+    return value && typeof value === 'object' ? value : {};
 };
-const getOptionWithPreset = (value, presets, optionName, urlSnippet, additionalValues) => {
-    const presetName = value?.preset;
+const getOptionWithPreset = (value, presets, optionName, additionalValues) => {
+    var _a;
+    const presetName = (_a = value) === null || _a === void 0 ? void 0 : _a.preset;
     if (presetName) {
         const preset = presets[presetName];
         if (preset) {
             return { ...preset, ...value };
         }
         else {
-            error(errorInvalidOption(`${optionName}.preset`, urlSnippet, `valid values are ${printQuotedStringList(Object.keys(presets))}`, presetName));
+            error(errInvalidOption(`${optionName}.preset`, getHashFromObjectOption(optionName), `valid values are ${printQuotedStringList(Object.keys(presets))}`, presetName));
         }
     }
-    return objectifyOptionWithPresets(presets, optionName, urlSnippet, additionalValues)(value);
+    return objectifyOptionWithPresets(presets, optionName, additionalValues)(value);
 };
-const normalizePluginOption = async (plugins) => (await asyncFlatten([plugins])).filter(Boolean);
+const getHashFromObjectOption = (optionName) => optionName.split('.').join('').toLowerCase();
 
-async function normalizeInputOptions(config) {
+function normalizeInputOptions(config) {
+    var _a, _b, _c;
     // These are options that may trigger special warnings or behaviour later
     // if the user did not select an explicit value
     const unsetOptions = new Set();
-    const context = config.context ?? 'undefined';
+    const context = (_a = config.context) !== null && _a !== void 0 ? _a : 'undefined';
     const onwarn = getOnwarn(config);
     const strictDeprecations = config.strictDeprecations || false;
-    const maxParallelFileOps = getmaxParallelFileOps(config, onwarn, strictDeprecations);
     const options = {
         acorn: getAcorn(config),
         acornInjectPlugins: getAcornInjectPlugins(config),
         cache: getCache(config),
         context,
-        experimentalCacheExpiry: config.experimentalCacheExpiry ?? 10,
+        experimentalCacheExpiry: (_b = config.experimentalCacheExpiry) !== null && _b !== void 0 ? _b : 10,
         external: getIdMatcher(config.external),
         inlineDynamicImports: getInlineDynamicImports$1(config, onwarn, strictDeprecations),
         input: getInput(config),
-        makeAbsoluteExternalsRelative: config.makeAbsoluteExternalsRelative ?? 'ifRelativeSource',
+        makeAbsoluteExternalsRelative: (_c = config.makeAbsoluteExternalsRelative) !== null && _c !== void 0 ? _c : true,
         manualChunks: getManualChunks$1(config, onwarn, strictDeprecations),
-        maxParallelFileOps,
-        maxParallelFileReads: maxParallelFileOps,
+        maxParallelFileReads: getMaxParallelFileReads(config),
         moduleContext: getModuleContext(config, context),
         onwarn,
         perf: config.perf || false,
-        plugins: await normalizePluginOption(config.plugins),
-        preserveEntrySignatures: config.preserveEntrySignatures ?? 'exports-only',
+        plugins: ensureArray(config.plugins),
+        preserveEntrySignatures: getPreserveEntrySignatures(config, unsetOptions),
         preserveModules: getPreserveModules$1(config, onwarn, strictDeprecations),
         preserveSymlinks: config.preserveSymlinks || false,
         shimMissingExports: config.shimMissingExports || false,
         strictDeprecations,
-        treeshake: getTreeshake(config)
+        treeshake: getTreeshake(config, onwarn, strictDeprecations)
     };
     warnUnknownOptions(config, [...Object.keys(options), 'watch'], 'input options', options.onwarn, /^(output)$/);
     return { options, unsetOptions };
@@ -24512,34 +22866,33 @@
     return onwarn
         ? warning => {
             warning.toString = () => {
-                let warningString = '';
+                let str = '';
                 if (warning.plugin)
-                    warningString += `(${warning.plugin} plugin) `;
+                    str += `(${warning.plugin} plugin) `;
                 if (warning.loc)
-                    warningString += `${relativeId(warning.loc.file)} (${warning.loc.line}:${warning.loc.column}) `;
-                warningString += warning.message;
-                return warningString;
+                    str += `${relativeId(warning.loc.file)} (${warning.loc.line}:${warning.loc.column}) `;
+                str += warning.message;
+                return str;
             };
             onwarn(warning, defaultOnWarn);
         }
         : defaultOnWarn;
 };
 const getAcorn = (config) => ({
+    allowAwaitOutsideFunction: true,
     ecmaVersion: 'latest',
+    preserveParens: false,
     sourceType: 'module',
     ...config.acorn
 });
-const getAcornInjectPlugins = (config) => [
-    importAssertions,
-    ...ensureArray(config.acornInjectPlugins)
-];
-const getCache = (config) => config.cache?.cache || config.cache;
+const getAcornInjectPlugins = (config) => ensureArray(config.acornInjectPlugins);
+const getCache = (config) => { var _a; return ((_a = config.cache) === null || _a === void 0 ? void 0 : _a.cache) || config.cache; };
 const getIdMatcher = (option) => {
     if (option === true) {
         return () => true;
     }
     if (typeof option === 'function') {
-        return (id, ...parameters) => (!id.startsWith('\0') && option(id, ...parameters)) || false;
+        return (id, ...args) => (!id.startsWith('\0') && option(id, ...args)) || false;
     }
     if (option) {
         const ids = new Set();
@@ -24552,14 +22905,14 @@
                 ids.add(value);
             }
         }
-        return (id, ..._arguments) => ids.has(id) || matchers.some(matcher => matcher.test(id));
+        return (id, ..._args) => ids.has(id) || matchers.some(matcher => matcher.test(id));
     }
     return () => false;
 };
 const getInlineDynamicImports$1 = (config, warn, strictDeprecations) => {
     const configInlineDynamicImports = config.inlineDynamicImports;
     if (configInlineDynamicImports) {
-        warnDeprecationWithOptions('The "inlineDynamicImports" option is deprecated. Use the "output.inlineDynamicImports" option instead.', URL_OUTPUT_INLINEDYNAMICIMPORTS, true, warn, strictDeprecations);
+        warnDeprecationWithOptions('The "inlineDynamicImports" option is deprecated. Use the "output.inlineDynamicImports" option instead.', false, warn, strictDeprecations);
     }
     return configInlineDynamicImports;
 };
@@ -24570,55 +22923,62 @@
 const getManualChunks$1 = (config, warn, strictDeprecations) => {
     const configManualChunks = config.manualChunks;
     if (configManualChunks) {
-        warnDeprecationWithOptions('The "manualChunks" option is deprecated. Use the "output.manualChunks" option instead.', URL_OUTPUT_MANUALCHUNKS, true, warn, strictDeprecations);
+        warnDeprecationWithOptions('The "manualChunks" option is deprecated. Use the "output.manualChunks" option instead.', false, warn, strictDeprecations);
     }
     return configManualChunks;
 };
-const getmaxParallelFileOps = (config, warn, strictDeprecations) => {
+const getMaxParallelFileReads = (config) => {
     const maxParallelFileReads = config.maxParallelFileReads;
     if (typeof maxParallelFileReads === 'number') {
-        warnDeprecationWithOptions('The "maxParallelFileReads" option is deprecated. Use the "maxParallelFileOps" option instead.', URL_MAXPARALLELFILEOPS, true, warn, strictDeprecations);
-    }
-    const maxParallelFileOps = config.maxParallelFileOps ?? maxParallelFileReads;
-    if (typeof maxParallelFileOps === 'number') {
-        if (maxParallelFileOps <= 0)
+        if (maxParallelFileReads <= 0)
             return Infinity;
-        return maxParallelFileOps;
+        return maxParallelFileReads;
     }
     return 20;
 };
 const getModuleContext = (config, context) => {
     const configModuleContext = config.moduleContext;
     if (typeof configModuleContext === 'function') {
-        return id => configModuleContext(id) ?? context;
+        return id => { var _a; return (_a = configModuleContext(id)) !== null && _a !== void 0 ? _a : context; };
     }
     if (configModuleContext) {
         const contextByModuleId = Object.create(null);
         for (const [key, moduleContext] of Object.entries(configModuleContext)) {
             contextByModuleId[resolve(key)] = moduleContext;
         }
-        return id => contextByModuleId[id] ?? context;
+        return id => contextByModuleId[id] || context;
     }
     return () => context;
 };
+const getPreserveEntrySignatures = (config, unsetOptions) => {
+    const configPreserveEntrySignatures = config.preserveEntrySignatures;
+    if (configPreserveEntrySignatures == null) {
+        unsetOptions.add('preserveEntrySignatures');
+    }
+    return configPreserveEntrySignatures !== null && configPreserveEntrySignatures !== void 0 ? configPreserveEntrySignatures : 'strict';
+};
 const getPreserveModules$1 = (config, warn, strictDeprecations) => {
     const configPreserveModules = config.preserveModules;
     if (configPreserveModules) {
-        warnDeprecationWithOptions('The "preserveModules" option is deprecated. Use the "output.preserveModules" option instead.', URL_OUTPUT_PRESERVEMODULES, true, warn, strictDeprecations);
+        warnDeprecationWithOptions('The "preserveModules" option is deprecated. Use the "output.preserveModules" option instead.', false, warn, strictDeprecations);
     }
     return configPreserveModules;
 };
-const getTreeshake = (config) => {
+const getTreeshake = (config, warn, strictDeprecations) => {
     const configTreeshake = config.treeshake;
     if (configTreeshake === false) {
         return false;
     }
-    const configWithPreset = getOptionWithPreset(config.treeshake, treeshakePresets, 'treeshake', URL_TREESHAKE, 'false, true, ');
+    const configWithPreset = getOptionWithPreset(config.treeshake, treeshakePresets, 'treeshake', 'false, true, ');
+    if (typeof configWithPreset.pureExternalModules !== 'undefined') {
+        warnDeprecationWithOptions(`The "treeshake.pureExternalModules" option is deprecated. The "treeshake.moduleSideEffects" option should be used instead. "treeshake.pureExternalModules: true" is equivalent to "treeshake.moduleSideEffects: 'no-external'"`, true, warn, strictDeprecations);
+    }
     return {
         annotations: configWithPreset.annotations !== false,
         correctVarValueBeforeDeclaration: configWithPreset.correctVarValueBeforeDeclaration === true,
-        manualPureFunctions: configWithPreset.manualPureFunctions ?? EMPTY_ARRAY,
-        moduleSideEffects: getHasModuleSideEffects(configWithPreset.moduleSideEffects),
+        moduleSideEffects: typeof configTreeshake === 'object' && configTreeshake.pureExternalModules
+            ? getHasModuleSideEffects(configTreeshake.moduleSideEffects, configTreeshake.pureExternalModules)
+            : getHasModuleSideEffects(configWithPreset.moduleSideEffects, undefined),
         propertyReadSideEffects: configWithPreset.propertyReadSideEffects === 'always'
             ? 'always'
             : configWithPreset.propertyReadSideEffects !== false,
@@ -24626,7 +22986,7 @@
         unknownGlobalSideEffects: configWithPreset.unknownGlobalSideEffects !== false
     };
 };
-const getHasModuleSideEffects = (moduleSideEffectsOption) => {
+const getHasModuleSideEffects = (moduleSideEffectsOption, pureExternalModules) => {
     if (typeof moduleSideEffectsOption === 'boolean') {
         return () => moduleSideEffectsOption;
     }
@@ -24634,31 +22994,29 @@
         return (_id, external) => !external;
     }
     if (typeof moduleSideEffectsOption === 'function') {
-        return (id, external) => id.startsWith('\0') ? true : moduleSideEffectsOption(id, external) !== false;
+        return (id, external) => !id.startsWith('\0') ? moduleSideEffectsOption(id, external) !== false : true;
     }
     if (Array.isArray(moduleSideEffectsOption)) {
         const ids = new Set(moduleSideEffectsOption);
         return id => ids.has(id);
     }
     if (moduleSideEffectsOption) {
-        error(errorInvalidOption('treeshake.moduleSideEffects', URL_TREESHAKE_MODULESIDEEFFECTS, 'please use one of false, "no-external", a function or an array'));
+        error(errInvalidOption('treeshake.moduleSideEffects', 'treeshake', 'please use one of false, "no-external", a function or an array'));
     }
-    return () => true;
+    const isPureExternalModule = getIdMatcher(pureExternalModules);
+    return (id, external) => !(external && isPureExternalModule(id));
 };
 
-// https://datatracker.ietf.org/doc/html/rfc2396
-// eslint-disable-next-line no-control-regex
-const INVALID_CHAR_REGEX = /[\u0000-\u001F"#$&*+,:;<=>?[\]^`{|}\u007F]/g;
-const DRIVE_LETTER_REGEX = /^[a-z]:/i;
 function sanitizeFileName(name) {
-    const match = DRIVE_LETTER_REGEX.exec(name);
+    const match = /^[a-z]:/i.exec(name);
     const driveLetter = match ? match[0] : '';
     // A `:` is only allowed as part of a windows drive letter (ex: C:\foo)
     // Otherwise, avoid them because they can refer to NTFS alternate data streams.
-    return driveLetter + name.slice(driveLetter.length).replace(INVALID_CHAR_REGEX, '_');
+    return driveLetter + name.substr(driveLetter.length).replace(/[\0?*:]/g, '_');
 }
 
-async function normalizeOutputOptions(config, inputOptions, unsetInputOptions) {
+function normalizeOutputOptions(config, inputOptions, unsetInputOptions) {
+    var _a, _b, _c, _d, _e, _f, _g;
     // These are options that may trigger special warnings or behaviour later
     // if the user did not select an explicit value
     const unsetOptions = new Set(unsetInputOptions);
@@ -24668,42 +23026,38 @@
     const preserveModules = getPreserveModules(config, inlineDynamicImports, inputOptions);
     const file = getFile(config, preserveModules, inputOptions);
     const preferConst = getPreferConst(config, inputOptions);
-    const generatedCode = getGeneratedCode(config, preferConst);
     const outputOptions = {
         amd: getAmd(config),
-        assetFileNames: config.assetFileNames ?? 'assets/[name]-[hash][extname]',
+        assetFileNames: (_a = config.assetFileNames) !== null && _a !== void 0 ? _a : 'assets/[name]-[hash][extname]',
         banner: getAddon(config, 'banner'),
-        chunkFileNames: config.chunkFileNames ?? '[name]-[hash].js',
+        chunkFileNames: (_b = config.chunkFileNames) !== null && _b !== void 0 ? _b : '[name]-[hash].js',
         compact,
         dir: getDir(config, file),
-        dynamicImportFunction: getDynamicImportFunction(config, inputOptions, format),
-        dynamicImportInCjs: config.dynamicImportInCjs ?? true,
+        dynamicImportFunction: getDynamicImportFunction(config, inputOptions),
         entryFileNames: getEntryFileNames(config, unsetOptions),
-        esModule: config.esModule ?? 'if-default-prop',
-        experimentalMinChunkSize: config.experimentalMinChunkSize || 0,
+        esModule: (_c = config.esModule) !== null && _c !== void 0 ? _c : true,
         exports: getExports(config, unsetOptions),
         extend: config.extend || false,
-        externalImportAssertions: config.externalImportAssertions ?? true,
-        externalLiveBindings: config.externalLiveBindings ?? true,
+        externalLiveBindings: (_d = config.externalLiveBindings) !== null && _d !== void 0 ? _d : true,
         file,
         footer: getAddon(config, 'footer'),
         format,
-        freeze: config.freeze ?? true,
-        generatedCode,
+        freeze: (_e = config.freeze) !== null && _e !== void 0 ? _e : true,
+        generatedCode: getGeneratedCode(config, preferConst),
         globals: config.globals || {},
-        hoistTransitiveImports: config.hoistTransitiveImports ?? true,
+        hoistTransitiveImports: (_f = config.hoistTransitiveImports) !== null && _f !== void 0 ? _f : true,
         indent: getIndent(config, compact),
         inlineDynamicImports,
-        interop: getInterop(config),
+        interop: getInterop(config, inputOptions),
         intro: getAddon(config, 'intro'),
         manualChunks: getManualChunks(config, inlineDynamicImports, preserveModules, inputOptions),
         minifyInternalExports: getMinifyInternalExports(config, format, compact),
         name: config.name,
-        namespaceToStringTag: getNamespaceToStringTag(config, generatedCode, inputOptions),
+        namespaceToStringTag: config.namespaceToStringTag || false,
         noConflict: config.noConflict || false,
         outro: getAddon(config, 'outro'),
         paths: config.paths || {},
-        plugins: await normalizePluginOption(config.plugins),
+        plugins: ensureArray(config.plugins),
         preferConst,
         preserveModules,
         preserveModulesRoot: getPreserveModulesRoot(config),
@@ -24713,12 +23067,11 @@
                 ? id => id
                 : sanitizeFileName,
         sourcemap: config.sourcemap || false,
-        sourcemapBaseUrl: getSourcemapBaseUrl(config),
         sourcemapExcludeSources: config.sourcemapExcludeSources || false,
         sourcemapFile: config.sourcemapFile,
         sourcemapPathTransform: config.sourcemapPathTransform,
-        strict: config.strict ?? true,
-        systemNullSetters: config.systemNullSetters ?? true,
+        strict: (_g = config.strict) !== null && _g !== void 0 ? _g : true,
+        systemNullSetters: config.systemNullSetters || false,
         validate: config.validate || false
     };
     warnUnknownOptions(config, Object.keys(outputOptions), 'output options', inputOptions.onwarn);
@@ -24728,10 +23081,10 @@
     const { file } = config;
     if (typeof file === 'string') {
         if (preserveModules) {
-            return error(errorInvalidOption('output.file', URL_OUTPUT_DIR, 'you must set "output.dir" instead of "output.file" when using the "output.preserveModules" option'));
+            return error(errInvalidOption('output.file', 'outputdir', 'you must set "output.dir" instead of "output.file" when using the "output.preserveModules" option'));
         }
         if (!Array.isArray(inputOptions.input))
-            return error(errorInvalidOption('output.file', URL_OUTPUT_DIR, 'you must set "output.dir" instead of "output.file" when providing named inputs'));
+            return error(errInvalidOption('output.file', 'outputdir', 'you must set "output.dir" instead of "output.file" when providing named inputs'));
     }
     return file;
 };
@@ -24741,43 +23094,43 @@
         case undefined:
         case 'es':
         case 'esm':
-        case 'module': {
+        case 'module':
             return 'es';
-        }
         case 'cjs':
-        case 'commonjs': {
+        case 'commonjs':
             return 'cjs';
-        }
         case 'system':
-        case 'systemjs': {
+        case 'systemjs':
             return 'system';
-        }
         case 'amd':
         case 'iife':
-        case 'umd': {
+        case 'umd':
             return configFormat;
-        }
-        default: {
-            return error(errorInvalidOption('output.format', URL_OUTPUT_FORMAT, `Valid values are "amd", "cjs", "system", "es", "iife" or "umd"`, configFormat));
-        }
+        default:
+            return error({
+                message: `You must specify "output.format", which can be one of "amd", "cjs", "system", "es", "iife" or "umd".`,
+                url: `https://rollupjs.org/guide/en/#outputformat`
+            });
     }
 };
 const getInlineDynamicImports = (config, inputOptions) => {
-    const inlineDynamicImports = (config.inlineDynamicImports ?? inputOptions.inlineDynamicImports) || false;
+    var _a;
+    const inlineDynamicImports = ((_a = config.inlineDynamicImports) !== null && _a !== void 0 ? _a : inputOptions.inlineDynamicImports) || false;
     const { input } = inputOptions;
     if (inlineDynamicImports && (Array.isArray(input) ? input : Object.keys(input)).length > 1) {
-        return error(errorInvalidOption('output.inlineDynamicImports', URL_OUTPUT_INLINEDYNAMICIMPORTS, 'multiple inputs are not supported when "output.inlineDynamicImports" is true'));
+        return error(errInvalidOption('output.inlineDynamicImports', 'outputinlinedynamicimports', 'multiple inputs are not supported when "output.inlineDynamicImports" is true'));
     }
     return inlineDynamicImports;
 };
 const getPreserveModules = (config, inlineDynamicImports, inputOptions) => {
-    const preserveModules = (config.preserveModules ?? inputOptions.preserveModules) || false;
+    var _a;
+    const preserveModules = ((_a = config.preserveModules) !== null && _a !== void 0 ? _a : inputOptions.preserveModules) || false;
     if (preserveModules) {
         if (inlineDynamicImports) {
-            return error(errorInvalidOption('output.inlineDynamicImports', URL_OUTPUT_INLINEDYNAMICIMPORTS, `this option is not supported for "output.preserveModules"`));
+            return error(errInvalidOption('output.inlineDynamicImports', 'outputinlinedynamicimports', `this option is not supported for "output.preserveModules"`));
         }
         if (inputOptions.preserveEntrySignatures === false) {
-            return error(errorInvalidOption('preserveEntrySignatures', URL_PRESERVEENTRYSIGNATURES, 'setting this option to false is not supported for "output.preserveModules"'));
+            return error(errInvalidOption('preserveEntrySignatures', 'preserveentrysignatures', 'setting this option to false is not supported for "output.preserveModules"'));
         }
     }
     return preserveModules;
@@ -24785,7 +23138,7 @@
 const getPreferConst = (config, inputOptions) => {
     const configPreferConst = config.preferConst;
     if (configPreferConst != null) {
-        warnDeprecation(`The "output.preferConst" option is deprecated. Use the "output.generatedCode.constBindings" option instead.`, URL_OUTPUT_GENERATEDCODE_CONSTBINDINGS, true, inputOptions);
+        warnDeprecation(`The "output.preferConst" option is deprecated. Use the "output.generatedCode.constBindings" option instead.`, false, inputOptions);
     }
     return !!configPreferConst;
 };
@@ -24801,28 +23154,30 @@
         autoId: false,
         basePath: '',
         define: 'define',
-        forceJsExtensionForImports: false,
         ...config.amd
     };
     if ((mergedOption.autoId || mergedOption.basePath) && mergedOption.id) {
-        return error(errorInvalidOption('output.amd.id', URL_OUTPUT_AMD_ID, 'this option cannot be used together with "output.amd.autoId"/"output.amd.basePath"'));
+        return error(errInvalidOption('output.amd.id', 'outputamd', 'this option cannot be used together with "output.amd.autoId"/"output.amd.basePath"'));
     }
     if (mergedOption.basePath && !mergedOption.autoId) {
-        return error(errorInvalidOption('output.amd.basePath', URL_OUTPUT_AMD_BASEPATH, 'this option only works with "output.amd.autoId"'));
+        return error(errInvalidOption('output.amd.basePath', 'outputamd', 'this option only works with "output.amd.autoId"'));
     }
-    return mergedOption.autoId
-        ? {
+    let normalized;
+    if (mergedOption.autoId) {
+        normalized = {
             autoId: true,
             basePath: mergedOption.basePath,
-            define: mergedOption.define,
-            forceJsExtensionForImports: mergedOption.forceJsExtensionForImports
-        }
-        : {
+            define: mergedOption.define
+        };
+    }
+    else {
+        normalized = {
             autoId: false,
             define: mergedOption.define,
-            forceJsExtensionForImports: mergedOption.forceJsExtensionForImports,
             id: mergedOption.id
         };
+    }
+    return normalized;
 };
 const getAddon = (config, name) => {
     const configAddon = config[name];
@@ -24831,21 +23186,17 @@
     }
     return () => configAddon || '';
 };
-// eslint-disable-next-line unicorn/prevent-abbreviations
 const getDir = (config, file) => {
     const { dir } = config;
     if (typeof dir === 'string' && typeof file === 'string') {
-        return error(errorInvalidOption('output.dir', URL_OUTPUT_DIR, 'you must set either "output.file" for a single-file build or "output.dir" when generating multiple chunks'));
+        return error(errInvalidOption('output.dir', 'outputdir', 'you must set either "output.file" for a single-file build or "output.dir" when generating multiple chunks'));
     }
     return dir;
 };
-const getDynamicImportFunction = (config, inputOptions, format) => {
+const getDynamicImportFunction = (config, inputOptions) => {
     const configDynamicImportFunction = config.dynamicImportFunction;
     if (configDynamicImportFunction) {
-        warnDeprecation(`The "output.dynamicImportFunction" option is deprecated. Use the "renderDynamicImport" plugin hook instead.`, URL_RENDERDYNAMICIMPORT, true, inputOptions);
-        if (format !== 'es') {
-            inputOptions.onwarn(errorInvalidOption('output.dynamicImportFunction', URL_OUTPUT_DYNAMICIMPORTFUNCTION, 'this option is ignored for formats other than "es"'));
-        }
+        warnDeprecation(`The "output.dynamicImportFunction" option is deprecated. Use the "renderDynamicImport" plugin hook instead.`, false, inputOptions);
     }
     return configDynamicImportFunction;
 };
@@ -24854,7 +23205,7 @@
     if (configEntryFileNames == null) {
         unsetOptions.add('entryFileNames');
     }
-    return configEntryFileNames ?? '[name].js';
+    return configEntryFileNames !== null && configEntryFileNames !== void 0 ? configEntryFileNames : '[name].js';
 };
 function getExports(config, unsetOptions) {
     const configExports = config.exports;
@@ -24862,18 +23213,17 @@
         unsetOptions.add('exports');
     }
     else if (!['default', 'named', 'none', 'auto'].includes(configExports)) {
-        return error(errorInvalidExportOptionValue(configExports));
+        return error(errInvalidExportOptionValue(configExports));
     }
     return configExports || 'auto';
 }
 const getGeneratedCode = (config, preferConst) => {
-    const configWithPreset = getOptionWithPreset(config.generatedCode, generatedCodePresets, 'output.generatedCode', URL_OUTPUT_GENERATEDCODE, '');
+    const configWithPreset = getOptionWithPreset(config.generatedCode, generatedCodePresets, 'output.generatedCode', '');
     return {
         arrowFunctions: configWithPreset.arrowFunctions === true,
         constBindings: configWithPreset.constBindings === true || preferConst,
         objectShorthand: configWithPreset.objectShorthand === true,
-        reservedNamesAsProps: configWithPreset.reservedNamesAsProps !== false,
-        symbols: configWithPreset.symbols === true
+        reservedNamesAsProps: configWithPreset.reservedNamesAsProps === true
     };
 };
 const getIndent = (config, compact) => {
@@ -24881,17 +23231,27 @@
         return '';
     }
     const configIndent = config.indent;
-    return configIndent === false ? '' : configIndent ?? true;
+    return configIndent === false ? '' : configIndent !== null && configIndent !== void 0 ? configIndent : true;
 };
-const ALLOWED_INTEROP_TYPES = new Set([
-    'compat',
-    'auto',
-    'esModule',
-    'default',
-    'defaultOnly'
-]);
-const getInterop = (config) => {
+const ALLOWED_INTEROP_TYPES = new Set(['auto', 'esModule', 'default', 'defaultOnly', true, false]);
+const getInterop = (config, inputOptions) => {
     const configInterop = config.interop;
+    const validatedInteropTypes = new Set();
+    const validateInterop = (interop) => {
+        if (!validatedInteropTypes.has(interop)) {
+            validatedInteropTypes.add(interop);
+            if (!ALLOWED_INTEROP_TYPES.has(interop)) {
+                return error(errInvalidOption('output.interop', 'outputinterop', `use one of ${Array.from(ALLOWED_INTEROP_TYPES.values(), value => JSON.stringify(value)).join(', ')}`, interop));
+            }
+            if (typeof interop === 'boolean') {
+                warnDeprecation({
+                    message: `The boolean value "${interop}" for the "output.interop" option is deprecated. Use ${interop ? '"auto"' : '"esModule", "default" or "defaultOnly"'} instead.`,
+                    url: 'https://rollupjs.org/guide/en/#outputinterop'
+                }, false, inputOptions);
+            }
+        }
+        return interop;
+    };
     if (typeof configInterop === 'function') {
         const interopPerId = Object.create(null);
         let defaultInterop = null;
@@ -24901,46 +23261,21 @@
                 ? interopPerId[id]
                 : validateInterop((interopPerId[id] = configInterop(id)));
     }
-    return configInterop === undefined ? () => 'default' : () => validateInterop(configInterop);
-};
-const validateInterop = (interop) => {
-    if (!ALLOWED_INTEROP_TYPES.has(interop)) {
-        return error(errorInvalidOption('output.interop', URL_OUTPUT_INTEROP, 
-        // eslint-disable-next-line unicorn/prefer-spread
-        `use one of ${Array.from(ALLOWED_INTEROP_TYPES, value => JSON.stringify(value)).join(', ')}`, interop));
-    }
-    return interop;
+    return configInterop === undefined ? () => true : () => validateInterop(configInterop);
 };
 const getManualChunks = (config, inlineDynamicImports, preserveModules, inputOptions) => {
     const configManualChunks = config.manualChunks || inputOptions.manualChunks;
     if (configManualChunks) {
         if (inlineDynamicImports) {
-            return error(errorInvalidOption('output.manualChunks', URL_OUTPUT_MANUALCHUNKS, 'this option is not supported for "output.inlineDynamicImports"'));
+            return error(errInvalidOption('output.manualChunks', 'outputmanualchunks', 'this option is not supported for "output.inlineDynamicImports"'));
         }
         if (preserveModules) {
-            return error(errorInvalidOption('output.manualChunks', URL_OUTPUT_MANUALCHUNKS, 'this option is not supported for "output.preserveModules"'));
+            return error(errInvalidOption('output.manualChunks', 'outputmanualchunks', 'this option is not supported for "output.preserveModules"'));
         }
     }
     return configManualChunks || {};
 };
-const getMinifyInternalExports = (config, format, compact) => config.minifyInternalExports ?? (compact || format === 'es' || format === 'system');
-const getNamespaceToStringTag = (config, generatedCode, inputOptions) => {
-    const configNamespaceToStringTag = config.namespaceToStringTag;
-    if (configNamespaceToStringTag != null) {
-        warnDeprecation(`The "output.namespaceToStringTag" option is deprecated. Use the "output.generatedCode.symbols" option instead.`, URL_OUTPUT_GENERATEDCODE_SYMBOLS, true, inputOptions);
-        return configNamespaceToStringTag;
-    }
-    return generatedCode.symbols || false;
-};
-const getSourcemapBaseUrl = (config) => {
-    const { sourcemapBaseUrl } = config;
-    if (sourcemapBaseUrl) {
-        if (isValidUrl(sourcemapBaseUrl)) {
-            return sourcemapBaseUrl;
-        }
-        return error(errorInvalidOption('output.sourcemapBaseUrl', URL_OUTPUT_SOURCEMAPBASEURL, `must be a valid URL, received ${JSON.stringify(sourcemapBaseUrl)}`));
-    }
-};
+const getMinifyInternalExports = (config, format, compact) => { var _a; return (_a = config.minifyInternalExports) !== null && _a !== void 0 ? _a : (compact || format === 'es' || format === 'system'); };
 
 function rollup(rawInputOptions) {
     return rollupInternal(rawInputOptions, null);
@@ -24949,31 +23284,25 @@
     const { options: inputOptions, unsetOptions: unsetInputOptions } = await getInputOptions(rawInputOptions, watcher !== null);
     initialiseTimers(inputOptions);
     const graph = new Graph(inputOptions, watcher);
-    // remove the cache object from the memory after graph creation (cache is not used anymore)
+    // remove the cache option from the memory after graph creation (cache is not used anymore)
     const useCache = rawInputOptions.cache !== false;
-    if (rawInputOptions.cache) {
-        inputOptions.cache = undefined;
-        rawInputOptions.cache = undefined;
-    }
+    delete inputOptions.cache;
+    delete rawInputOptions.cache;
     timeStart('BUILD', 1);
-    await catchUnfinishedHookActions(graph.pluginDriver, async () => {
-        try {
-            timeStart('initialize', 2);
-            await graph.pluginDriver.hookParallel('buildStart', [inputOptions]);
-            timeEnd('initialize', 2);
-            await graph.build();
-        }
-        catch (error_) {
-            const watchFiles = Object.keys(graph.watchFiles);
-            if (watchFiles.length > 0) {
-                error_.watchFiles = watchFiles;
-            }
-            await graph.pluginDriver.hookParallel('buildEnd', [error_]);
-            await graph.pluginDriver.hookParallel('closeBundle', []);
-            throw error_;
-        }
-        await graph.pluginDriver.hookParallel('buildEnd', []);
-    });
+    try {
+        await graph.pluginDriver.hookParallel('buildStart', [inputOptions]);
+        await graph.build();
+    }
+    catch (err) {
+        const watchFiles = Object.keys(graph.watchFiles);
+        if (watchFiles.length > 0) {
+            err.watchFiles = watchFiles;
+        }
+        await graph.pluginDriver.hookParallel('buildEnd', [err]);
+        await graph.pluginDriver.hookParallel('closeBundle', []);
+        throw err;
+    }
+    await graph.pluginDriver.hookParallel('buildEnd', []);
     timeEnd('BUILD', 1);
     const result = {
         cache: useCache ? graph.getCache() : undefined,
@@ -24986,13 +23315,13 @@
         closed: false,
         async generate(rawOutputOptions) {
             if (result.closed)
-                return error(errorAlreadyClosed());
+                return error(errAlreadyClosed());
             return handleGenerateWrite(false, inputOptions, unsetInputOptions, rawOutputOptions, graph);
         },
         watchFiles: Object.keys(graph.watchFiles),
         async write(rawOutputOptions) {
             if (result.closed)
-                return error(errorAlreadyClosed());
+                return error(errAlreadyClosed());
             return handleGenerateWrite(true, inputOptions, unsetInputOptions, rawOutputOptions, graph);
         }
     };
@@ -25004,57 +23333,58 @@
     if (!rawInputOptions) {
         throw new Error('You must supply an options object to rollup');
     }
-    const rawPlugins = getSortedValidatedPlugins('options', await normalizePluginOption(rawInputOptions.plugins));
-    const { options, unsetOptions } = await normalizeInputOptions(await rawPlugins.reduce(applyOptionHook(watchMode), Promise.resolve(rawInputOptions)));
+    const rawPlugins = ensureArray(rawInputOptions.plugins);
+    const { options, unsetOptions } = normalizeInputOptions(await rawPlugins.reduce(applyOptionHook(watchMode), Promise.resolve(rawInputOptions)));
     normalizePlugins(options.plugins, ANONYMOUS_PLUGIN_PREFIX);
     return { options, unsetOptions };
 }
 function applyOptionHook(watchMode) {
     return async (inputOptions, plugin) => {
-        const handler = 'handler' in plugin.options ? plugin.options.handler : plugin.options;
-        return ((await handler.call({ meta: { rollupVersion: version$1, watchMode } }, await inputOptions)) ||
-            inputOptions);
+        if (plugin.options) {
+            return ((await plugin.options.call({ meta: { rollupVersion: version$1, watchMode } }, await inputOptions)) || inputOptions);
+        }
+        return inputOptions;
     };
 }
 function normalizePlugins(plugins, anonymousPrefix) {
-    for (const [index, plugin] of plugins.entries()) {
+    for (let pluginIndex = 0; pluginIndex < plugins.length; pluginIndex++) {
+        const plugin = plugins[pluginIndex];
         if (!plugin.name) {
-            plugin.name = `${anonymousPrefix}${index + 1}`;
+            plugin.name = `${anonymousPrefix}${pluginIndex + 1}`;
         }
     }
 }
 async function handleGenerateWrite(isWrite, inputOptions, unsetInputOptions, rawOutputOptions, graph) {
-    const { options: outputOptions, outputPluginDriver, unsetOptions } = await getOutputOptionsAndPluginDriver(rawOutputOptions, graph.pluginDriver, inputOptions, unsetInputOptions);
-    return catchUnfinishedHookActions(outputPluginDriver, async () => {
-        const bundle = new Bundle(outputOptions, unsetOptions, inputOptions, outputPluginDriver, graph);
-        const generated = await bundle.generate(isWrite);
-        if (isWrite) {
-            timeStart('WRITE', 1);
-            if (!outputOptions.dir && !outputOptions.file) {
-                return error(errorMissingFileOrDirOption());
-            }
-            await Promise.all(Object.values(generated).map(chunk => graph.fileOperationQueue.run(() => writeOutputFile(chunk, outputOptions))));
-            await outputPluginDriver.hookParallel('writeBundle', [outputOptions, generated]);
-            timeEnd('WRITE', 1);
+    const { options: outputOptions, outputPluginDriver, unsetOptions } = getOutputOptionsAndPluginDriver(rawOutputOptions, graph.pluginDriver, inputOptions, unsetInputOptions);
+    const bundle = new Bundle(outputOptions, unsetOptions, inputOptions, outputPluginDriver, graph);
+    const generated = await bundle.generate(isWrite);
+    if (isWrite) {
+        if (!outputOptions.dir && !outputOptions.file) {
+            return error({
+                code: 'MISSING_OPTION',
+                message: 'You must specify "output.file" or "output.dir" for the build.'
+            });
         }
-        return createOutput(generated);
-    });
+        await Promise.all(Object.values(generated).map(chunk => writeOutputFile(chunk, outputOptions)));
+        await outputPluginDriver.hookParallel('writeBundle', [outputOptions, generated]);
+    }
+    return createOutput(generated);
 }
-async function getOutputOptionsAndPluginDriver(rawOutputOptions, inputPluginDriver, inputOptions, unsetInputOptions) {
+function getOutputOptionsAndPluginDriver(rawOutputOptions, inputPluginDriver, inputOptions, unsetInputOptions) {
     if (!rawOutputOptions) {
         throw new Error('You must supply an options object');
     }
-    const rawPlugins = await normalizePluginOption(rawOutputOptions.plugins);
+    const rawPlugins = ensureArray(rawOutputOptions.plugins);
     normalizePlugins(rawPlugins, ANONYMOUS_OUTPUT_PLUGIN_PREFIX);
     const outputPluginDriver = inputPluginDriver.createOutputPluginDriver(rawPlugins);
     return {
-        ...(await getOutputOptions(inputOptions, unsetInputOptions, rawOutputOptions, outputPluginDriver)),
+        ...getOutputOptions(inputOptions, unsetInputOptions, rawOutputOptions, outputPluginDriver),
         outputPluginDriver
     };
 }
 function getOutputOptions(inputOptions, unsetInputOptions, rawOutputOptions, outputPluginDriver) {
-    return normalizeOutputOptions(outputPluginDriver.hookReduceArg0Sync('outputOptions', [rawOutputOptions], (outputOptions, result) => result || outputOptions, pluginContext => {
-        const emitError = () => pluginContext.error(errorCannotEmitFromOptionsHook());
+    return normalizeOutputOptions(outputPluginDriver.hookReduceArg0Sync('outputOptions', [rawOutputOptions.output || rawOutputOptions], (outputOptions, result) => result || outputOptions, pluginContext => {
+        const emitError = () => pluginContext.error(errCannotEmitFromOptionsHook());
         return {
             ...pluginContext,
             emitFile: emitError,
@@ -25064,7 +23394,13 @@
 }
 function createOutput(outputBundle) {
     return {
-        output: Object.values(outputBundle).filter(outputFile => Object.keys(outputFile).length > 0).sort((outputFileA, outputFileB) => getSortingFileType(outputFileA) - getSortingFileType(outputFileB))
+        output: Object.values(outputBundle).filter(outputFile => Object.keys(outputFile).length > 0).sort((outputFileA, outputFileB) => {
+            const fileTypeA = getSortingFileType(outputFileA);
+            const fileTypeB = getSortingFileType(outputFileB);
+            if (fileTypeA === fileTypeB)
+                return 0;
+            return fileTypeA < fileTypeB ? -1 : 1;
+        })
     };
 }
 var SortingFileType;
@@ -25082,11 +23418,30 @@
     }
     return SortingFileType.SECONDARY_CHUNK;
 }
-async function writeOutputFile(outputFile, outputOptions) {
+function writeOutputFile(outputFile, outputOptions) {
     const fileName = resolve(outputOptions.dir || dirname(outputOptions.file), outputFile.fileName);
-    // 'recursive: true' does not throw if the folder structure, or parts of it, already exist
-    await mkdir(dirname(fileName), { recursive: true });
-    return writeFile(fileName, outputFile.type === 'asset' ? outputFile.source : outputFile.code);
+    let writeSourceMapPromise;
+    let source;
+    if (outputFile.type === 'asset') {
+        source = outputFile.source;
+    }
+    else {
+        source = outputFile.code;
+        if (outputOptions.sourcemap && outputFile.map) {
+            let url;
+            if (outputOptions.sourcemap === 'inline') {
+                url = outputFile.map.toUrl();
+            }
+            else {
+                url = `${basename(outputFile.fileName)}.map`;
+                writeSourceMapPromise = writeFile(`${fileName}.map`, outputFile.map.toString());
+            }
+            if (outputOptions.sourcemap !== 'hidden') {
+                source += `//# ${SOURCEMAPPING_URL}=${url}\n`;
+            }
+        }
+    }
+    return Promise.all([writeFile(fileName, source), writeSourceMapPromise]);
 }
 /**
  * Auxiliary function for defining rollup configuration
@@ -25097,383 +23452,17 @@
     return options;
 }
 
-const {
-  env = {},
-  argv = [],
-  platform = "",
-} = typeof process === "undefined" ? {} : process;
-
-const isDisabled = "NO_COLOR" in env || argv.includes("--no-color");
-const isForced = "FORCE_COLOR" in env || argv.includes("--color");
-const isWindows = platform === "win32";
-const isDumbTerminal = env.TERM === "dumb";
-
-const isCompatibleTerminal =
-  tty && tty.isatty && tty.isatty(1) && env.TERM && !isDumbTerminal;
-
-const isCI =
-  "CI" in env &&
-  ("GITHUB_ACTIONS" in env || "GITLAB_CI" in env || "CIRCLECI" in env);
-
-const isColorSupported =
-  !isDisabled &&
-  (isForced || (isWindows && !isDumbTerminal) || isCompatibleTerminal || isCI);
-
-const replaceClose = (
-  index,
-  string,
-  close,
-  replace,
-  head = string.substring(0, index) + replace,
-  tail = string.substring(index + close.length),
-  next = tail.indexOf(close)
-) => head + (next < 0 ? tail : replaceClose(next, tail, close, replace));
-
-const clearBleed = (index, string, open, close, replace) =>
-  index < 0
-    ? open + string + close
-    : open + replaceClose(index, string, close, replace) + close;
-
-const filterEmpty =
-  (open, close, replace = open, at = open.length + 1) =>
-  (string) =>
-    string || !(string === "" || string === undefined)
-      ? clearBleed(
-          ("" + string).indexOf(close, at),
-          string,
-          open,
-          close,
-          replace
-        )
-      : "";
-
-const init = (open, close, replace) =>
-  filterEmpty(`\x1b[${open}m`, `\x1b[${close}m`, replace);
-
-const colors = {
-  reset: init(0, 0),
-  bold: init(1, 22, "\x1b[22m\x1b[1m"),
-  dim: init(2, 22, "\x1b[22m\x1b[2m"),
-  italic: init(3, 23),
-  underline: init(4, 24),
-  inverse: init(7, 27),
-  hidden: init(8, 28),
-  strikethrough: init(9, 29),
-  black: init(30, 39),
-  red: init(31, 39),
-  green: init(32, 39),
-  yellow: init(33, 39),
-  blue: init(34, 39),
-  magenta: init(35, 39),
-  cyan: init(36, 39),
-  white: init(37, 39),
-  gray: init(90, 39),
-  bgBlack: init(40, 49),
-  bgRed: init(41, 49),
-  bgGreen: init(42, 49),
-  bgYellow: init(43, 49),
-  bgBlue: init(44, 49),
-  bgMagenta: init(45, 49),
-  bgCyan: init(46, 49),
-  bgWhite: init(47, 49),
-  blackBright: init(90, 39),
-  redBright: init(91, 39),
-  greenBright: init(92, 39),
-  yellowBright: init(93, 39),
-  blueBright: init(94, 39),
-  magentaBright: init(95, 39),
-  cyanBright: init(96, 39),
-  whiteBright: init(97, 39),
-  bgBlackBright: init(100, 49),
-  bgRedBright: init(101, 49),
-  bgGreenBright: init(102, 49),
-  bgYellowBright: init(103, 49),
-  bgBlueBright: init(104, 49),
-  bgMagentaBright: init(105, 49),
-  bgCyanBright: init(106, 49),
-  bgWhiteBright: init(107, 49),
-};
-
-const createColors = ({ useColor = isColorSupported } = {}) =>
-  useColor
-    ? colors
-    : Object.keys(colors).reduce(
-        (colors, key) => ({ ...colors, [key]: String }),
-        {}
-      );
-
-createColors();
-
-// @see https://no-color.org
-// @see https://www.npmjs.com/package/chalk
-const { bold, cyan, dim, gray, green, red, underline, yellow } = createColors({
-    useColor: env$1.FORCE_COLOR !== '0' && !env$1.NO_COLOR
-});
-
-// log to stderr to keep `rollup main.js > bundle.js` from breaking
-const stderr = (...parameters) => process$1.stderr.write(`${parameters.join('')}\n`);
-function handleError(error, recover = false) {
-    const name = error.name || error.cause?.name;
-    const nameSection = name ? `${name}: ` : '';
-    const pluginSection = error.plugin ? `(plugin ${error.plugin}) ` : '';
-    const message = `${pluginSection}${nameSection}${error.message}`;
-    const outputLines = [bold(red(`[!] ${bold(message.toString())}`))];
-    if (error.url) {
-        outputLines.push(cyan(error.url));
-    }
-    if (error.loc) {
-        outputLines.push(`${relativeId((error.loc.file || error.id))} (${error.loc.line}:${error.loc.column})`);
-    }
-    else if (error.id) {
-        outputLines.push(relativeId(error.id));
-    }
-    if (error.frame) {
-        outputLines.push(dim(error.frame));
-    }
-    if (error.stack) {
-        outputLines.push(dim(error.stack?.replace(`${nameSection}${error.message}\n`, '')));
-    }
-    outputLines.push('', '');
-    stderr(outputLines.join('\n'));
-    // eslint-disable-next-line unicorn/no-process-exit
-    if (!recover)
-        process$1.exit(1);
-}
-
-const commandAliases = {
-    c: 'config',
-    d: 'dir',
-    e: 'external',
-    f: 'format',
-    g: 'globals',
-    h: 'help',
-    i: 'input',
-    m: 'sourcemap',
-    n: 'name',
-    o: 'file',
-    p: 'plugin',
-    v: 'version',
-    w: 'watch'
-};
-const EMPTY_COMMAND_OPTIONS = { external: [], globals: undefined };
-async function mergeOptions(config, rawCommandOptions = EMPTY_COMMAND_OPTIONS, defaultOnWarnHandler = defaultOnWarn) {
-    const command = getCommandOptions(rawCommandOptions);
-    const inputOptions = await mergeInputOptions(config, command, defaultOnWarnHandler);
-    const warn = inputOptions.onwarn;
-    if (command.output) {
-        Object.assign(command, command.output);
-    }
-    const outputOptionsArray = ensureArray(config.output);
-    if (outputOptionsArray.length === 0)
-        outputOptionsArray.push({});
-    const outputOptions = await Promise.all(outputOptionsArray.map(singleOutputOptions => mergeOutputOptions(singleOutputOptions, command, warn)));
-    warnUnknownOptions(command, [
-        ...Object.keys(inputOptions),
-        ...Object.keys(outputOptions[0]).filter(option => option !== 'sourcemapPathTransform'),
-        ...Object.keys(commandAliases),
-        'bundleConfigAsCjs',
-        'config',
-        'environment',
-        'plugin',
-        'silent',
-        'failAfterWarnings',
-        'stdin',
-        'waitForBundleInput',
-        'configPlugin'
-    ], 'CLI flags', warn, /^_$|output$|config/);
-    inputOptions.output = outputOptions;
-    return inputOptions;
-}
-function getCommandOptions(rawCommandOptions) {
-    const external = rawCommandOptions.external && typeof rawCommandOptions.external === 'string'
-        ? rawCommandOptions.external.split(',')
-        : [];
-    return {
-        ...rawCommandOptions,
-        external,
-        globals: typeof rawCommandOptions.globals === 'string'
-            ? rawCommandOptions.globals.split(',').reduce((globals, globalDefinition) => {
-                const [id, variableName] = globalDefinition.split(':');
-                globals[id] = variableName;
-                if (!external.includes(id)) {
-                    external.push(id);
-                }
-                return globals;
-            }, Object.create(null))
-            : undefined
-    };
-}
-async function mergeInputOptions(config, overrides, defaultOnWarnHandler) {
-    const getOption = (name) => overrides[name] ?? config[name];
-    const inputOptions = {
-        acorn: getOption('acorn'),
-        acornInjectPlugins: config.acornInjectPlugins,
-        cache: config.cache,
-        context: getOption('context'),
-        experimentalCacheExpiry: getOption('experimentalCacheExpiry'),
-        external: getExternal(config, overrides),
-        inlineDynamicImports: getOption('inlineDynamicImports'),
-        input: getOption('input') || [],
-        makeAbsoluteExternalsRelative: getOption('makeAbsoluteExternalsRelative'),
-        manualChunks: getOption('manualChunks'),
-        maxParallelFileOps: getOption('maxParallelFileOps'),
-        maxParallelFileReads: getOption('maxParallelFileReads'),
-        moduleContext: getOption('moduleContext'),
-        onwarn: getOnWarn(config, defaultOnWarnHandler),
-        perf: getOption('perf'),
-        plugins: await normalizePluginOption(config.plugins),
-        preserveEntrySignatures: getOption('preserveEntrySignatures'),
-        preserveModules: getOption('preserveModules'),
-        preserveSymlinks: getOption('preserveSymlinks'),
-        shimMissingExports: getOption('shimMissingExports'),
-        strictDeprecations: getOption('strictDeprecations'),
-        treeshake: getObjectOption(config, overrides, 'treeshake', objectifyOptionWithPresets(treeshakePresets, 'treeshake', URL_TREESHAKE, 'false, true, ')),
-        watch: getWatch(config, overrides)
-    };
-    warnUnknownOptions(config, Object.keys(inputOptions), 'input options', inputOptions.onwarn, /^output$/);
-    return inputOptions;
-}
-const getExternal = (config, overrides) => {
-    const configExternal = config.external;
-    return typeof configExternal === 'function'
-        ? (source, importer, isResolved) => configExternal(source, importer, isResolved) || overrides.external.includes(source)
-        : [...ensureArray(configExternal), ...overrides.external];
-};
-const getOnWarn = (config, defaultOnWarnHandler) => config.onwarn ? warning => config.onwarn(warning, defaultOnWarnHandler) : defaultOnWarnHandler;
-const getObjectOption = (config, overrides, name, objectifyValue = objectifyOption) => {
-    const commandOption = normalizeObjectOptionValue(overrides[name], objectifyValue);
-    const configOption = normalizeObjectOptionValue(config[name], objectifyValue);
-    if (commandOption !== undefined) {
-        return commandOption && { ...configOption, ...commandOption };
-    }
-    return configOption;
-};
-const getWatch = (config, overrides) => config.watch !== false && getObjectOption(config, overrides, 'watch');
-const normalizeObjectOptionValue = (optionValue, objectifyValue) => {
-    if (!optionValue) {
-        return optionValue;
-    }
-    if (Array.isArray(optionValue)) {
-        return optionValue.reduce((result, value) => value && result && { ...result, ...objectifyValue(value) }, {});
-    }
-    return objectifyValue(optionValue);
-};
-async function mergeOutputOptions(config, overrides, warn) {
-    const getOption = (name) => overrides[name] ?? config[name];
-    const outputOptions = {
-        amd: getObjectOption(config, overrides, 'amd'),
-        assetFileNames: getOption('assetFileNames'),
-        banner: getOption('banner'),
-        chunkFileNames: getOption('chunkFileNames'),
-        compact: getOption('compact'),
-        dir: getOption('dir'),
-        dynamicImportFunction: getOption('dynamicImportFunction'),
-        dynamicImportInCjs: getOption('dynamicImportInCjs'),
-        entryFileNames: getOption('entryFileNames'),
-        esModule: getOption('esModule'),
-        experimentalMinChunkSize: getOption('experimentalMinChunkSize'),
-        exports: getOption('exports'),
-        extend: getOption('extend'),
-        externalImportAssertions: getOption('externalImportAssertions'),
-        externalLiveBindings: getOption('externalLiveBindings'),
-        file: getOption('file'),
-        footer: getOption('footer'),
-        format: getOption('format'),
-        freeze: getOption('freeze'),
-        generatedCode: getObjectOption(config, overrides, 'generatedCode', objectifyOptionWithPresets(generatedCodePresets, 'output.generatedCode', URL_OUTPUT_GENERATEDCODE, '')),
-        globals: getOption('globals'),
-        hoistTransitiveImports: getOption('hoistTransitiveImports'),
-        indent: getOption('indent'),
-        inlineDynamicImports: getOption('inlineDynamicImports'),
-        interop: getOption('interop'),
-        intro: getOption('intro'),
-        manualChunks: getOption('manualChunks'),
-        minifyInternalExports: getOption('minifyInternalExports'),
-        name: getOption('name'),
-        namespaceToStringTag: getOption('namespaceToStringTag'),
-        noConflict: getOption('noConflict'),
-        outro: getOption('outro'),
-        paths: getOption('paths'),
-        plugins: await normalizePluginOption(config.plugins),
-        preferConst: getOption('preferConst'),
-        preserveModules: getOption('preserveModules'),
-        preserveModulesRoot: getOption('preserveModulesRoot'),
-        sanitizeFileName: getOption('sanitizeFileName'),
-        sourcemap: getOption('sourcemap'),
-        sourcemapBaseUrl: getOption('sourcemapBaseUrl'),
-        sourcemapExcludeSources: getOption('sourcemapExcludeSources'),
-        sourcemapFile: getOption('sourcemapFile'),
-        sourcemapPathTransform: getOption('sourcemapPathTransform'),
-        strict: getOption('strict'),
-        systemNullSetters: getOption('systemNullSetters'),
-        validate: getOption('validate')
-    };
-    warnUnknownOptions(config, Object.keys(outputOptions), 'output options', warn);
-    return outputOptions;
-}
-
-class WatchEmitter {
-    constructor() {
-        this.currentHandlers = Object.create(null);
-        this.persistentHandlers = Object.create(null);
-    }
-    // Will be overwritten by Rollup
-    async close() { }
-    emit(event, ...parameters) {
-        return Promise.all([...this.getCurrentHandlers(event), ...this.getPersistentHandlers(event)].map(handler => handler(...parameters)));
-    }
-    off(event, listener) {
-        const listeners = this.persistentHandlers[event];
-        if (listeners) {
-            // A hack stolen from "mitt": ">>> 0" does not change numbers >= 0, but -1
-            // (which would remove the last array element if used unchanged) is turned
-            // into max_int, which is outside the array and does not change anything.
-            listeners.splice(listeners.indexOf(listener) >>> 0, 1);
-        }
-        return this;
-    }
-    on(event, listener) {
-        this.getPersistentHandlers(event).push(listener);
-        return this;
-    }
-    onCurrentRun(event, listener) {
-        this.getCurrentHandlers(event).push(listener);
-        return this;
-    }
-    once(event, listener) {
-        const selfRemovingListener = (...parameters) => {
-            this.off(event, selfRemovingListener);
-            return listener(...parameters);
-        };
-        this.on(event, selfRemovingListener);
-        return this;
-    }
-    removeAllListeners() {
-        this.removeListenersForCurrentRun();
-        this.persistentHandlers = Object.create(null);
-        return this;
-    }
-    removeListenersForCurrentRun() {
-        this.currentHandlers = Object.create(null);
-        return this;
-    }
-    getCurrentHandlers(event) {
-        return this.currentHandlers[event] || (this.currentHandlers[event] = []);
-    }
-    getPersistentHandlers(event) {
-        return this.persistentHandlers[event] || (this.persistentHandlers[event] = []);
-    }
-}
-
 let fsEvents;
 let fsEventsImportError;
-async function loadFsEvents() {
-    try {
-        ({ default: fsEvents } = await import('fsevents'));
-    }
-    catch (error) {
-        fsEventsImportError = error;
-    }
+function loadFsEvents() {
+    const moduleName = 'fsevents';
+    return import(moduleName)
+        .then(namespace => {
+        fsEvents = namespace.default;
+    })
+        .catch(err => {
+        fsEventsImportError = err;
+    });
 }
 // A call to this function will be injected into the chokidar code
 function getFsEvents() {
@@ -25482,28 +23471,32 @@
     return fsEvents;
 }
 
-const fseventsImporter = /*#__PURE__*/Object.defineProperty({
+const fseventsImporter = {
   __proto__: null,
-  getFsEvents,
-  loadFsEvents
-}, Symbol.toStringTag, { value: 'Module' });
+  loadFsEvents,
+  getFsEvents
+};
 
+class WatchEmitter extends EventEmitter {
+    constructor() {
+        super();
+        // Allows more than 10 bundles to be watched without
+        // showing the `MaxListenersExceededWarning` to the user.
+        this.setMaxListeners(Infinity);
+    }
+    close() { }
+}
 function watch(configs) {
     const emitter = new WatchEmitter();
-    watchInternal(configs, emitter).catch(error => {
-        handleError(error);
-    });
+    const configArray = ensureArray(configs);
+    const watchConfigs = configArray.filter(config => config.watch !== false);
+    if (watchConfigs.length === 0) {
+        return error(errInvalidOption('watch', 'watch', 'there must be at least one config where "watch" is not set to "false"'));
+    }
+    loadFsEvents()
+        .then(() => import('./watch.js'))
+        .then(({ Watcher }) => new Watcher(watchConfigs, emitter));
     return emitter;
 }
-async function watchInternal(configs, emitter) {
-    const optionsList = await Promise.all(ensureArray(configs).map(config => mergeOptions(config)));
-    const watchOptionsList = optionsList.filter(config => config.watch !== false);
-    if (watchOptionsList.length === 0) {
-        return error(errorInvalidOption('watch', URL_WATCH, 'there must be at least one config where "watch" is not set to "false"'));
-    }
-    await loadFsEvents();
-    const { Watcher } = await import('./watch.js');
-    new Watcher(watchOptionsList, emitter);
-}
 
-export { createFilter, defineConfig, fseventsImporter, getAugmentedNamespace, picomatchExports, rollup, rollupInternal, version$1 as version, watch };
+export { createFilter, defaultOnWarn, defineConfig, ensureArray, fseventsImporter, generatedCodePresets, getAugmentedNamespace, objectifyOptionWithPresets, picomatch, rollup, rollupInternal, treeshakePresets, version$1 as version, warnUnknownOptions, watch };
diff -urN /chromium-112.0.5615.49/third_party/node/node_modules/rollup/dist/es/shared/watch.js /chromium-111.0.5563.110/third_party/node/node_modules/rollup/dist/es/shared/watch.js
--- a/third_party/node/node_modules/rollup/dist/es/shared/watch.js	2023-02-03 20:05:52.000000000 +0000
+++ b/third_party/node/node_modules/rollup/dist/es/shared/watch.js	2023-01-12 22:12:55.000000000 +0000
@@ -1,35 +1,185 @@
 /*
   @license
-	Rollup.js v3.12.0
-	Sat, 28 Jan 2023 05:55:49 GMT - commit 01ddea09dfdf1c396c1c24ba3d97743698fe1508
+	Rollup.js v2.58.0
+	Fri, 01 Oct 2021 06:54:03 GMT - commit 3a404a07f41a10d10b7af536f05b90ea46d8ad3d
+
 
 	https://github.com/rollup/rollup
 
 	Released under the MIT License.
 */
-import { resolve } from 'node:path';
-import process$1 from 'node:process';
-import { picomatchExports, getAugmentedNamespace, fseventsImporter, createFilter, rollupInternal } from './rollup.js';
-import { platform } from 'node:os';
-import require$$0$1 from 'fs';
+import * as require$$0$1 from 'path';
+import require$$0__default from 'path';
+import { defaultOnWarn, ensureArray, warnUnknownOptions, objectifyOptionWithPresets, treeshakePresets, generatedCodePresets, picomatch as picomatch$2, getAugmentedNamespace, fseventsImporter, createFilter, rollupInternal } from './rollup.js';
+import require$$2$1, { platform } from 'os';
+import require$$0$2 from 'events';
+import fs$4 from 'fs';
 import require$$2 from 'util';
 import require$$1 from 'stream';
-import require$$0$2 from 'path';
-import require$$2$1 from 'os';
-import require$$0$3 from 'events';
-import 'node:perf_hooks';
-import 'node:crypto';
-import 'node:fs/promises';
-import 'node:events';
-import 'tty';
+import 'crypto';
+
+const commandAliases = {
+    c: 'config',
+    d: 'dir',
+    e: 'external',
+    f: 'format',
+    g: 'globals',
+    h: 'help',
+    i: 'input',
+    m: 'sourcemap',
+    n: 'name',
+    o: 'file',
+    p: 'plugin',
+    v: 'version',
+    w: 'watch'
+};
+function mergeOptions(config, rawCommandOptions = { external: [], globals: undefined }, defaultOnWarnHandler = defaultOnWarn) {
+    const command = getCommandOptions(rawCommandOptions);
+    const inputOptions = mergeInputOptions(config, command, defaultOnWarnHandler);
+    const warn = inputOptions.onwarn;
+    if (command.output) {
+        Object.assign(command, command.output);
+    }
+    const outputOptionsArray = ensureArray(config.output);
+    if (outputOptionsArray.length === 0)
+        outputOptionsArray.push({});
+    const outputOptions = outputOptionsArray.map(singleOutputOptions => mergeOutputOptions(singleOutputOptions, command, warn));
+    warnUnknownOptions(command, Object.keys(inputOptions).concat(Object.keys(outputOptions[0]).filter(option => option !== 'sourcemapPathTransform'), Object.keys(commandAliases), 'config', 'environment', 'plugin', 'silent', 'failAfterWarnings', 'stdin', 'waitForBundleInput', 'configPlugin'), 'CLI flags', warn, /^_$|output$|config/);
+    inputOptions.output = outputOptions;
+    return inputOptions;
+}
+function getCommandOptions(rawCommandOptions) {
+    const external = rawCommandOptions.external && typeof rawCommandOptions.external === 'string'
+        ? rawCommandOptions.external.split(',')
+        : [];
+    return {
+        ...rawCommandOptions,
+        external,
+        globals: typeof rawCommandOptions.globals === 'string'
+            ? rawCommandOptions.globals.split(',').reduce((globals, globalDefinition) => {
+                const [id, variableName] = globalDefinition.split(':');
+                globals[id] = variableName;
+                if (external.indexOf(id) === -1) {
+                    external.push(id);
+                }
+                return globals;
+            }, Object.create(null))
+            : undefined
+    };
+}
+function mergeInputOptions(config, overrides, defaultOnWarnHandler) {
+    const getOption = (name) => { var _a; return (_a = overrides[name]) !== null && _a !== void 0 ? _a : config[name]; };
+    const inputOptions = {
+        acorn: getOption('acorn'),
+        acornInjectPlugins: config.acornInjectPlugins,
+        cache: config.cache,
+        context: getOption('context'),
+        experimentalCacheExpiry: getOption('experimentalCacheExpiry'),
+        external: getExternal(config, overrides),
+        inlineDynamicImports: getOption('inlineDynamicImports'),
+        input: getOption('input') || [],
+        makeAbsoluteExternalsRelative: getOption('makeAbsoluteExternalsRelative'),
+        manualChunks: getOption('manualChunks'),
+        maxParallelFileReads: getOption('maxParallelFileReads'),
+        moduleContext: getOption('moduleContext'),
+        onwarn: getOnWarn(config, defaultOnWarnHandler),
+        perf: getOption('perf'),
+        plugins: ensureArray(config.plugins),
+        preserveEntrySignatures: getOption('preserveEntrySignatures'),
+        preserveModules: getOption('preserveModules'),
+        preserveSymlinks: getOption('preserveSymlinks'),
+        shimMissingExports: getOption('shimMissingExports'),
+        strictDeprecations: getOption('strictDeprecations'),
+        treeshake: getObjectOption(config, overrides, 'treeshake', objectifyOptionWithPresets(treeshakePresets, 'treeshake', 'false, true, ')),
+        watch: getWatch(config, overrides, 'watch')
+    };
+    warnUnknownOptions(config, Object.keys(inputOptions), 'input options', inputOptions.onwarn, /^output$/);
+    return inputOptions;
+}
+const getExternal = (config, overrides) => {
+    const configExternal = config.external;
+    return typeof configExternal === 'function'
+        ? (source, importer, isResolved) => configExternal(source, importer, isResolved) || overrides.external.indexOf(source) !== -1
+        : ensureArray(configExternal).concat(overrides.external);
+};
+const getOnWarn = (config, defaultOnWarnHandler) => config.onwarn
+    ? warning => config.onwarn(warning, defaultOnWarnHandler)
+    : defaultOnWarnHandler;
+const getObjectOption = (config, overrides, name, objectifyValue = value => (typeof value === 'object' ? value : {})) => {
+    const commandOption = normalizeObjectOptionValue(overrides[name], objectifyValue);
+    const configOption = normalizeObjectOptionValue(config[name], objectifyValue);
+    if (commandOption !== undefined) {
+        return commandOption && { ...configOption, ...commandOption };
+    }
+    return configOption;
+};
+const getWatch = (config, overrides, name) => config.watch !== false && getObjectOption(config, overrides, name);
+const normalizeObjectOptionValue = (optionValue, objectifyValue) => {
+    if (!optionValue) {
+        return optionValue;
+    }
+    if (Array.isArray(optionValue)) {
+        return optionValue.reduce((result, value) => value && result && { ...result, ...objectifyValue(value) }, {});
+    }
+    return objectifyValue(optionValue);
+};
+function mergeOutputOptions(config, overrides, warn) {
+    const getOption = (name) => { var _a; return (_a = overrides[name]) !== null && _a !== void 0 ? _a : config[name]; };
+    const outputOptions = {
+        amd: getObjectOption(config, overrides, 'amd'),
+        assetFileNames: getOption('assetFileNames'),
+        banner: getOption('banner'),
+        chunkFileNames: getOption('chunkFileNames'),
+        compact: getOption('compact'),
+        dir: getOption('dir'),
+        dynamicImportFunction: getOption('dynamicImportFunction'),
+        entryFileNames: getOption('entryFileNames'),
+        esModule: getOption('esModule'),
+        exports: getOption('exports'),
+        extend: getOption('extend'),
+        externalLiveBindings: getOption('externalLiveBindings'),
+        file: getOption('file'),
+        footer: getOption('footer'),
+        format: getOption('format'),
+        freeze: getOption('freeze'),
+        generatedCode: getObjectOption(config, overrides, 'generatedCode', objectifyOptionWithPresets(generatedCodePresets, 'output.generatedCode', '')),
+        globals: getOption('globals'),
+        hoistTransitiveImports: getOption('hoistTransitiveImports'),
+        indent: getOption('indent'),
+        inlineDynamicImports: getOption('inlineDynamicImports'),
+        interop: getOption('interop'),
+        intro: getOption('intro'),
+        manualChunks: getOption('manualChunks'),
+        minifyInternalExports: getOption('minifyInternalExports'),
+        name: getOption('name'),
+        namespaceToStringTag: getOption('namespaceToStringTag'),
+        noConflict: getOption('noConflict'),
+        outro: getOption('outro'),
+        paths: getOption('paths'),
+        plugins: ensureArray(config.plugins),
+        preferConst: getOption('preferConst'),
+        preserveModules: getOption('preserveModules'),
+        preserveModulesRoot: getOption('preserveModulesRoot'),
+        sanitizeFileName: getOption('sanitizeFileName'),
+        sourcemap: getOption('sourcemap'),
+        sourcemapExcludeSources: getOption('sourcemapExcludeSources'),
+        sourcemapFile: getOption('sourcemapFile'),
+        sourcemapPathTransform: getOption('sourcemapPathTransform'),
+        strict: getOption('strict'),
+        systemNullSetters: getOption('systemNullSetters'),
+        validate: getOption('validate')
+    };
+    warnUnknownOptions(config, Object.keys(outputOptions), 'output options', warn);
+    return outputOptions;
+}
 
-var chokidar = {};
+var chokidar$1 = {};
 
-const fs$3 = require$$0$1;
+const fs$3 = fs$4;
 const { Readable } = require$$1;
-const sysPath$3 = require$$0$2;
+const sysPath$3 = require$$0__default;
 const { promisify: promisify$3 } = require$$2;
-const picomatch$1 = picomatchExports;
+const picomatch$1 = picomatch$2;
 
 const readdir$1 = promisify$3(fs$3.readdir);
 const stat$3 = promisify$3(fs$3.stat);
@@ -311,11 +461,7 @@
 
 var readdirp_1 = readdirp$1;
 
-var anymatchExports = {};
-var anymatch$2 = {
-  get exports(){ return anymatchExports; },
-  set exports(v){ anymatchExports = v; },
-};
+var anymatch$2 = {exports: {}};
 
 /*!
  * normalize-path <https://github.com/jonschlinkert/normalize-path>
@@ -353,9 +499,9 @@
   return prefix + segs.join('/');
 };
 
-Object.defineProperty(anymatchExports, "__esModule", { value: true });
+Object.defineProperty(anymatch$2.exports, "__esModule", { value: true });
 
-const picomatch = picomatchExports;
+const picomatch = picomatch$2;
 const normalizePath$1 = normalizePath$2;
 
 /**
@@ -400,7 +546,7 @@
     throw new TypeError('anymatch: second argument must be a string: got ' +
       Object.prototype.toString.call(_path))
   }
-  const path = normalizePath$1(_path, false);
+  const path = normalizePath$1(_path);
 
   for (let index = 0; index < negPatterns.length; index++) {
     const nglob = negPatterns[index];
@@ -629,7 +775,7 @@
 };
 
 var isGlob$1 = isGlob$2;
-var pathPosixDirname = require$$0$2.posix.dirname;
+var pathPosixDirname = require$$0__default.posix.dirname;
 var isWin32 = require$$2$1.platform() === 'win32';
 
 var slash = '/';
@@ -673,117 +819,117 @@
 
 (function (exports) {
 
-	exports.isInteger = num => {
-	  if (typeof num === 'number') {
-	    return Number.isInteger(num);
-	  }
-	  if (typeof num === 'string' && num.trim() !== '') {
-	    return Number.isInteger(Number(num));
-	  }
-	  return false;
-	};
-
-	/**
-	 * Find a node of the given type
-	 */
-
-	exports.find = (node, type) => node.nodes.find(node => node.type === type);
-
-	/**
-	 * Find a node of the given type
-	 */
-
-	exports.exceedsLimit = (min, max, step = 1, limit) => {
-	  if (limit === false) return false;
-	  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;
-	  return ((Number(max) - Number(min)) / Number(step)) >= limit;
-	};
-
-	/**
-	 * Escape the given node with '\\' before node.value
-	 */
-
-	exports.escapeNode = (block, n = 0, type) => {
-	  let node = block.nodes[n];
-	  if (!node) return;
-
-	  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {
-	    if (node.escaped !== true) {
-	      node.value = '\\' + node.value;
-	      node.escaped = true;
-	    }
-	  }
-	};
-
-	/**
-	 * Returns true if the given brace node should be enclosed in literal braces
-	 */
-
-	exports.encloseBrace = node => {
-	  if (node.type !== 'brace') return false;
-	  if ((node.commas >> 0 + node.ranges >> 0) === 0) {
-	    node.invalid = true;
-	    return true;
-	  }
-	  return false;
-	};
-
-	/**
-	 * Returns true if a brace node is invalid.
-	 */
-
-	exports.isInvalidBrace = block => {
-	  if (block.type !== 'brace') return false;
-	  if (block.invalid === true || block.dollar) return true;
-	  if ((block.commas >> 0 + block.ranges >> 0) === 0) {
-	    block.invalid = true;
-	    return true;
-	  }
-	  if (block.open !== true || block.close !== true) {
-	    block.invalid = true;
-	    return true;
-	  }
-	  return false;
-	};
-
-	/**
-	 * Returns true if a node is an open or close node
-	 */
-
-	exports.isOpenOrClose = node => {
-	  if (node.type === 'open' || node.type === 'close') {
-	    return true;
-	  }
-	  return node.open === true || node.close === true;
-	};
-
-	/**
-	 * Reduce an array of text nodes.
-	 */
-
-	exports.reduce = nodes => nodes.reduce((acc, node) => {
-	  if (node.type === 'text') acc.push(node.value);
-	  if (node.type === 'range') node.type = 'text';
-	  return acc;
-	}, []);
-
-	/**
-	 * Flatten an array
-	 */
-
-	exports.flatten = (...args) => {
-	  const result = [];
-	  const flat = arr => {
-	    for (let i = 0; i < arr.length; i++) {
-	      let ele = arr[i];
-	      Array.isArray(ele) ? flat(ele) : ele !== void 0 && result.push(ele);
-	    }
-	    return result;
-	  };
-	  flat(args);
-	  return result;
-	};
-} (utils$3));
+exports.isInteger = num => {
+  if (typeof num === 'number') {
+    return Number.isInteger(num);
+  }
+  if (typeof num === 'string' && num.trim() !== '') {
+    return Number.isInteger(Number(num));
+  }
+  return false;
+};
+
+/**
+ * Find a node of the given type
+ */
+
+exports.find = (node, type) => node.nodes.find(node => node.type === type);
+
+/**
+ * Find a node of the given type
+ */
+
+exports.exceedsLimit = (min, max, step = 1, limit) => {
+  if (limit === false) return false;
+  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;
+  return ((Number(max) - Number(min)) / Number(step)) >= limit;
+};
+
+/**
+ * Escape the given node with '\\' before node.value
+ */
+
+exports.escapeNode = (block, n = 0, type) => {
+  let node = block.nodes[n];
+  if (!node) return;
+
+  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {
+    if (node.escaped !== true) {
+      node.value = '\\' + node.value;
+      node.escaped = true;
+    }
+  }
+};
+
+/**
+ * Returns true if the given brace node should be enclosed in literal braces
+ */
+
+exports.encloseBrace = node => {
+  if (node.type !== 'brace') return false;
+  if ((node.commas >> 0 + node.ranges >> 0) === 0) {
+    node.invalid = true;
+    return true;
+  }
+  return false;
+};
+
+/**
+ * Returns true if a brace node is invalid.
+ */
+
+exports.isInvalidBrace = block => {
+  if (block.type !== 'brace') return false;
+  if (block.invalid === true || block.dollar) return true;
+  if ((block.commas >> 0 + block.ranges >> 0) === 0) {
+    block.invalid = true;
+    return true;
+  }
+  if (block.open !== true || block.close !== true) {
+    block.invalid = true;
+    return true;
+  }
+  return false;
+};
+
+/**
+ * Returns true if a node is an open or close node
+ */
+
+exports.isOpenOrClose = node => {
+  if (node.type === 'open' || node.type === 'close') {
+    return true;
+  }
+  return node.open === true || node.close === true;
+};
+
+/**
+ * Reduce an array of text nodes.
+ */
+
+exports.reduce = nodes => nodes.reduce((acc, node) => {
+  if (node.type === 'text') acc.push(node.value);
+  if (node.type === 'range') node.type = 'text';
+  return acc;
+}, []);
+
+/**
+ * Flatten an array
+ */
+
+exports.flatten = (...args) => {
+  const result = [];
+  const flat = arr => {
+    for (let i = 0; i < arr.length; i++) {
+      let ele = arr[i];
+      Array.isArray(ele) ? flat(ele) : ele !== void 0 && result.push(ele);
+    }
+    return result;
+  };
+  flat(args);
+  return result;
+};
+}(utils$3));
 
 const utils$2 = utils$3;
 
@@ -2089,12 +2235,6 @@
 
 var braces_1 = braces$1;
 
-var binaryExtensionsExports = {};
-var binaryExtensions$1 = {
-  get exports(){ return binaryExtensionsExports; },
-  set exports(v){ binaryExtensionsExports = v; },
-};
-
 const require$$0 = [
 	"3dm",
 	"3ds",
@@ -2356,12 +2496,10 @@
 	"zipx"
 ];
 
-(function (module) {
-	module.exports = require$$0;
-} (binaryExtensions$1));
+var binaryExtensions$1 = require$$0;
 
-const path = require$$0$2;
-const binaryExtensions = binaryExtensionsExports;
+const path = require$$0__default;
+const binaryExtensions = binaryExtensions$1;
 
 const extensions = new Set(binaryExtensions);
 
@@ -2371,73 +2509,73 @@
 
 (function (exports) {
 
-	const {sep} = require$$0$2;
-	const {platform} = process;
-	const os = require$$2$1;
-
-	exports.EV_ALL = 'all';
-	exports.EV_READY = 'ready';
-	exports.EV_ADD = 'add';
-	exports.EV_CHANGE = 'change';
-	exports.EV_ADD_DIR = 'addDir';
-	exports.EV_UNLINK = 'unlink';
-	exports.EV_UNLINK_DIR = 'unlinkDir';
-	exports.EV_RAW = 'raw';
-	exports.EV_ERROR = 'error';
-
-	exports.STR_DATA = 'data';
-	exports.STR_END = 'end';
-	exports.STR_CLOSE = 'close';
-
-	exports.FSEVENT_CREATED = 'created';
-	exports.FSEVENT_MODIFIED = 'modified';
-	exports.FSEVENT_DELETED = 'deleted';
-	exports.FSEVENT_MOVED = 'moved';
-	exports.FSEVENT_CLONED = 'cloned';
-	exports.FSEVENT_UNKNOWN = 'unknown';
-	exports.FSEVENT_TYPE_FILE = 'file';
-	exports.FSEVENT_TYPE_DIRECTORY = 'directory';
-	exports.FSEVENT_TYPE_SYMLINK = 'symlink';
-
-	exports.KEY_LISTENERS = 'listeners';
-	exports.KEY_ERR = 'errHandlers';
-	exports.KEY_RAW = 'rawEmitters';
-	exports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];
-
-	exports.DOT_SLASH = `.${sep}`;
-
-	exports.BACK_SLASH_RE = /\\/g;
-	exports.DOUBLE_SLASH_RE = /\/\//;
-	exports.SLASH_OR_BACK_SLASH_RE = /[/\\]/;
-	exports.DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
-	exports.REPLACER_RE = /^\.[/\\]/;
-
-	exports.SLASH = '/';
-	exports.SLASH_SLASH = '//';
-	exports.BRACE_START = '{';
-	exports.BANG = '!';
-	exports.ONE_DOT = '.';
-	exports.TWO_DOTS = '..';
-	exports.STAR = '*';
-	exports.GLOBSTAR = '**';
-	exports.ROOT_GLOBSTAR = '/**/*';
-	exports.SLASH_GLOBSTAR = '/**';
-	exports.DIR_SUFFIX = 'Dir';
-	exports.ANYMATCH_OPTS = {dot: true};
-	exports.STRING_TYPE = 'string';
-	exports.FUNCTION_TYPE = 'function';
-	exports.EMPTY_STR = '';
-	exports.EMPTY_FN = () => {};
-	exports.IDENTITY_FN = val => val;
-
-	exports.isWindows = platform === 'win32';
-	exports.isMacos = platform === 'darwin';
-	exports.isLinux = platform === 'linux';
-	exports.isIBMi = os.type() === 'OS400';
-} (constants));
+const {sep} = require$$0__default;
+const {platform} = process;
+const os = require$$2$1;
+
+exports.EV_ALL = 'all';
+exports.EV_READY = 'ready';
+exports.EV_ADD = 'add';
+exports.EV_CHANGE = 'change';
+exports.EV_ADD_DIR = 'addDir';
+exports.EV_UNLINK = 'unlink';
+exports.EV_UNLINK_DIR = 'unlinkDir';
+exports.EV_RAW = 'raw';
+exports.EV_ERROR = 'error';
+
+exports.STR_DATA = 'data';
+exports.STR_END = 'end';
+exports.STR_CLOSE = 'close';
+
+exports.FSEVENT_CREATED = 'created';
+exports.FSEVENT_MODIFIED = 'modified';
+exports.FSEVENT_DELETED = 'deleted';
+exports.FSEVENT_MOVED = 'moved';
+exports.FSEVENT_CLONED = 'cloned';
+exports.FSEVENT_UNKNOWN = 'unknown';
+exports.FSEVENT_TYPE_FILE = 'file';
+exports.FSEVENT_TYPE_DIRECTORY = 'directory';
+exports.FSEVENT_TYPE_SYMLINK = 'symlink';
+
+exports.KEY_LISTENERS = 'listeners';
+exports.KEY_ERR = 'errHandlers';
+exports.KEY_RAW = 'rawEmitters';
+exports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];
+
+exports.DOT_SLASH = `.${sep}`;
+
+exports.BACK_SLASH_RE = /\\/g;
+exports.DOUBLE_SLASH_RE = /\/\//;
+exports.SLASH_OR_BACK_SLASH_RE = /[/\\]/;
+exports.DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
+exports.REPLACER_RE = /^\.[/\\]/;
+
+exports.SLASH = '/';
+exports.SLASH_SLASH = '//';
+exports.BRACE_START = '{';
+exports.BANG = '!';
+exports.ONE_DOT = '.';
+exports.TWO_DOTS = '..';
+exports.STAR = '*';
+exports.GLOBSTAR = '**';
+exports.ROOT_GLOBSTAR = '/**/*';
+exports.SLASH_GLOBSTAR = '/**';
+exports.DIR_SUFFIX = 'Dir';
+exports.ANYMATCH_OPTS = {dot: true};
+exports.STRING_TYPE = 'string';
+exports.FUNCTION_TYPE = 'function';
+exports.EMPTY_STR = '';
+exports.EMPTY_FN = () => {};
+exports.IDENTITY_FN = val => val;
+
+exports.isWindows = platform === 'win32';
+exports.isMacos = platform === 'darwin';
+exports.isLinux = platform === 'linux';
+exports.isIBMi = os.type() === 'OS400';
+}(constants));
 
-const fs$2 = require$$0$1;
-const sysPath$2 = require$$0$2;
+const fs$2 = fs$4;
+const sysPath$2 = require$$0__default;
 const { promisify: promisify$2 } = require$$2;
 const isBinaryPath = isBinaryPath$1;
 const {
@@ -2719,7 +2857,7 @@
 /**
  * @mixin
  */
-let NodeFsHandler$1 = class NodeFsHandler {
+class NodeFsHandler$1 {
 
 /**
  * @param {import("../index").FSWatcher} fsW
@@ -2847,15 +2985,7 @@
   if (!this.fsw.options.followSymlinks) {
     // watch symlink directly (don't follow) and detect changes
     this.fsw._incrReadyCount();
-
-    let linkPath;
-    try {
-      linkPath = await fsrealpath(path);
-    } catch (e) {
-      this.fsw._emitReady();
-      return true;
-    }
-
+    const linkPath = await fsrealpath(path);
     if (this.fsw.closed) return;
     if (dir.has(item)) {
       if (this.fsw._symlinkPaths.get(full) !== linkPath) {
@@ -3075,20 +3205,16 @@
   }
 }
 
-};
+}
 
 var nodefsHandler = NodeFsHandler$1;
 
-var fseventsHandlerExports = {};
-var fseventsHandler = {
-  get exports(){ return fseventsHandlerExports; },
-  set exports(v){ fseventsHandlerExports = v; },
-};
+var fseventsHandler = {exports: {}};
 
 const require$$3 = /*@__PURE__*/getAugmentedNamespace(fseventsImporter);
 
-const fs$1 = require$$0$1;
-const sysPath$1 = require$$0$2;
+const fs$1 = fs$4;
+const sysPath$1 = require$$0__default;
 const { promisify: promisify$1 } = require$$2;
 
 let fsevents;
@@ -3299,7 +3425,7 @@
 /**
  * @mixin
  */
-let FsEventsHandler$1 = class FsEventsHandler {
+class FsEventsHandler$1 {
 
 /**
  * @param {import('../index').FSWatcher} fsw
@@ -3605,24 +3731,24 @@
   }
 }
 
-};
+}
 
 fseventsHandler.exports = FsEventsHandler$1;
-fseventsHandlerExports.canUse = canUse;
+fseventsHandler.exports.canUse = canUse;
 
-const { EventEmitter } = require$$0$3;
-const fs = require$$0$1;
-const sysPath = require$$0$2;
+const { EventEmitter } = require$$0$2;
+const fs = fs$4;
+const sysPath = require$$0__default;
 const { promisify } = require$$2;
 const readdirp = readdirp_1;
-const anymatch = anymatchExports.default;
+const anymatch = anymatch$2.exports.default;
 const globParent = globParent$1;
 const isGlob = isGlob$2;
 const braces = braces_1;
 const normalizePath = normalizePath$2;
 
 const NodeFsHandler = nodefsHandler;
-const FsEventsHandler = fseventsHandlerExports;
+const FsEventsHandler = fseventsHandler.exports;
 const {
   EV_ALL,
   EV_READY,
@@ -4566,7 +4692,7 @@
 }
 
 // Export FSWatcher class
-chokidar.FSWatcher = FSWatcher;
+chokidar$1.FSWatcher = FSWatcher;
 
 /**
  * Instantiates watcher with paths to be tracked.
@@ -4580,7 +4706,9 @@
   return watcher;
 };
 
-chokidar.watch = watch;
+chokidar$1.watch = watch;
+
+const chokidar = chokidar$1;
 
 class FileWatcher {
     constructor(task, chokidarOptions) {
@@ -4605,7 +4733,7 @@
     }
     watch(id, isTransformDependency) {
         if (isTransformDependency) {
-            const watcher = this.transformWatchers.get(id) ?? this.createWatcher(id);
+            const watcher = this.transformWatchers.get(id) || this.createWatcher(id);
             watcher.add(id);
             this.transformWatchers.set(id, watcher);
         }
@@ -4655,39 +4783,33 @@
     }
 };
 class Watcher {
-    constructor(optionsList, emitter) {
+    constructor(configs, emitter) {
         this.buildDelay = 0;
         this.buildTimeout = null;
-        this.closed = false;
         this.invalidatedIds = new Map();
         this.rerun = false;
         this.running = true;
         this.emitter = emitter;
         emitter.close = this.close.bind(this);
-        this.tasks = optionsList.map(options => new Task(this, options));
-        for (const { watch } of optionsList) {
-            if (watch && typeof watch.buildDelay === 'number') {
-                this.buildDelay = Math.max(this.buildDelay, watch.buildDelay);
-            }
-        }
-        process$1.nextTick(() => this.run());
+        this.tasks = configs.map(config => new Task(this, config));
+        this.buildDelay = configs.reduce((buildDelay, { watch }) => watch && typeof watch.buildDelay === 'number'
+            ? Math.max(buildDelay, watch.buildDelay)
+            : buildDelay, this.buildDelay);
+        process.nextTick(() => this.run());
     }
-    async close() {
-        if (this.closed)
-            return;
-        this.closed = true;
+    close() {
         if (this.buildTimeout)
             clearTimeout(this.buildTimeout);
         for (const task of this.tasks) {
             task.close();
         }
-        await this.emitter.emit('close');
+        this.emitter.emit('close');
         this.emitter.removeAllListeners();
     }
     invalidate(file) {
         if (file) {
-            const previousEvent = this.invalidatedIds.get(file.id);
-            const event = previousEvent ? eventsRewrites[previousEvent][file.event] : file.event;
+            const prevEvent = this.invalidatedIds.get(file.id);
+            const event = prevEvent ? eventsRewrites[prevEvent][file.event] : file.event;
             if (event === 'buggy') {
                 //TODO: throws or warn? Currently just ignore, uses new event
                 this.invalidatedIds.set(file.id, file.event);
@@ -4705,38 +4827,26 @@
         }
         if (this.buildTimeout)
             clearTimeout(this.buildTimeout);
-        this.buildTimeout = setTimeout(async () => {
+        this.buildTimeout = setTimeout(() => {
             this.buildTimeout = null;
-            try {
-                await Promise.all([...this.invalidatedIds].map(([id, event]) => this.emitter.emit('change', id, { event })));
-                this.invalidatedIds.clear();
-                await this.emitter.emit('restart');
-                this.emitter.removeListenersForCurrentRun();
-                this.run();
-            }
-            catch (error) {
-                this.invalidatedIds.clear();
-                await this.emitter.emit('event', {
-                    code: 'ERROR',
-                    error,
-                    result: null
-                });
-                await this.emitter.emit('event', {
-                    code: 'END'
-                });
+            for (const [id, event] of this.invalidatedIds.entries()) {
+                this.emitter.emit('change', id, { event });
             }
+            this.invalidatedIds.clear();
+            this.emitter.emit('restart');
+            this.run();
         }, this.buildDelay);
     }
     async run() {
         this.running = true;
-        await this.emitter.emit('event', {
+        this.emitter.emit('event', {
             code: 'START'
         });
         for (const task of this.tasks) {
             await task.run();
         }
         this.running = false;
-        await this.emitter.emit('event', {
+        this.emitter.emit('event', {
             code: 'END'
         });
         if (this.rerun) {
@@ -4746,19 +4856,19 @@
     }
 }
 class Task {
-    constructor(watcher, options) {
+    constructor(watcher, config) {
         this.cache = { modules: [] };
         this.watchFiles = [];
         this.closed = false;
         this.invalidated = true;
         this.watched = new Set();
         this.watcher = watcher;
-        this.options = options;
-        this.skipWrite = Boolean(options.watch && options.watch.skipWrite);
+        this.skipWrite = Boolean(config.watch && config.watch.skipWrite);
+        this.options = mergeOptions(config);
         this.outputs = this.options.output;
         this.outputFiles = this.outputs.map(output => {
             if (output.file || output.dir)
-                return resolve(output.file || output.dir);
+                return require$$0$1.resolve(output.file || output.dir);
             return undefined;
         });
         const watchOptions = this.options.watch || {};
@@ -4777,7 +4887,7 @@
         this.invalidated = true;
         if (details.isTransformDependency) {
             for (const module of this.cache.modules) {
-                if (!module.transformDependencies.includes(id))
+                if (module.transformDependencies.indexOf(id) === -1)
                     continue;
                 // effective invalidation
                 module.originalCode = null;
@@ -4794,7 +4904,7 @@
             cache: this.cache
         };
         const start = Date.now();
-        await this.watcher.emitter.emit('event', {
+        this.watcher.emitter.emit('event', {
             code: 'BUNDLE_START',
             input: this.options.input,
             output: this.outputFiles
@@ -4807,7 +4917,7 @@
             }
             this.updateWatchedFiles(result);
             this.skipWrite || (await Promise.all(this.outputs.map(output => result.write(output))));
-            await this.watcher.emitter.emit('event', {
+            this.watcher.emitter.emit('event', {
                 code: 'BUNDLE_END',
                 duration: Date.now() - start,
                 input: this.options.input,
@@ -4826,7 +4936,7 @@
                     this.cache.modules = this.cache.modules.filter(module => module.id !== error.id);
                 }
             }
-            await this.watcher.emitter.emit('event', {
+            this.watcher.emitter.emit('event', {
                 code: 'ERROR',
                 error,
                 result
@@ -4856,7 +4966,7 @@
         if (!this.filter(id))
             return;
         this.watched.add(id);
-        if (this.outputFiles.includes(id)) {
+        if (this.outputFiles.some(file => file === id)) {
             throw new Error('Cannot import the generated bundle');
         }
         // this is necessary to ensure that any 'renamed' files
diff -urN /chromium-112.0.5615.49/third_party/node/node_modules/rollup/dist/loadConfigFile.js /chromium-111.0.5563.110/third_party/node/node_modules/rollup/dist/loadConfigFile.js
--- a/third_party/node/node_modules/rollup/dist/loadConfigFile.js	2023-02-03 20:05:52.000000000 +0000
+++ b/third_party/node/node_modules/rollup/dist/loadConfigFile.js	2023-01-12 22:12:55.000000000 +0000
@@ -1,7 +1,8 @@
 /*
   @license
-	Rollup.js v3.12.0
-	Sat, 28 Jan 2023 05:55:49 GMT - commit 01ddea09dfdf1c396c1c24ba3d97743698fe1508
+	Rollup.js v2.58.0
+	Fri, 01 Oct 2021 06:54:03 GMT - commit 3a404a07f41a10d10b7af536f05b90ea46d8ad3d
+
 
 	https://github.com/rollup/rollup
 
@@ -9,21 +10,17 @@
 */
 'use strict';
 
-Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
-
-require('node:fs/promises');
-require('node:path');
-require('node:process');
-require('node:url');
-require('./shared/rollup.js');
-const loadConfigFile_js = require('./shared/loadConfigFile.js');
+require('fs');
 require('path');
-require('node:perf_hooks');
-require('node:crypto');
-require('node:events');
+require('url');
+const loadConfigFile_js = require('./shared/loadConfigFile.js');
+require('./shared/rollup.js');
+require('./shared/mergeOptions.js');
 require('tty');
+require('crypto');
+require('events');
 
 
 
-exports.loadConfigFile = loadConfigFile_js.loadConfigFile;
+module.exports = loadConfigFile_js.loadAndParseConfigFile;
 //# sourceMappingURL=loadConfigFile.js.map
diff -urN /chromium-112.0.5615.49/third_party/node/node_modules/rollup/dist/rollup.browser.js /chromium-111.0.5563.110/third_party/node/node_modules/rollup/dist/rollup.browser.js
--- a/third_party/node/node_modules/rollup/dist/rollup.browser.js	1970-01-01 00:00:00.000000000 +0000
+++ b/third_party/node/node_modules/rollup/dist/rollup.browser.js	2023-01-12 22:12:55.000000000 +0000
@@ -0,0 +1,12 @@
+/*
+  @license
+	Rollup.js v2.58.0
+	Fri, 01 Oct 2021 06:54:03 GMT - commit 3a404a07f41a10d10b7af536f05b90ea46d8ad3d
+
+
+	https://github.com/rollup/rollup
+
+	Released under the MIT License.
+*/
+var e,t;e=this,t=function(e){for(var t="2.58.0",s={},i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",n=0;n<i.length;n++)s[i.charCodeAt(n)]=n;function r(e,t,s){4===s?e.push([t[0],t[1],t[2],t[3]]):5===s?e.push([t[0],t[1],t[2],t[3],t[4]]):1===s&&e.push([t[0]])}function a(e){var t="";e=e<0?-e<<1|1:e<<1;do{var s=31&e;(e>>>=5)>0&&(s|=32),t+=i[s]}while(e>0);return t}var o=function e(t){this.bits=t instanceof e?t.bits.slice():[]};o.prototype.add=function(e){this.bits[e>>5]|=1<<(31&e)},o.prototype.has=function(e){return!!(this.bits[e>>5]&1<<(31&e))};var h=function(e,t,s){this.start=e,this.end=t,this.original=s,this.intro="",this.outro="",this.content=s,this.storeName=!1,this.edited=!1,Object.defineProperties(this,{previous:{writable:!0,value:null},next:{writable:!0,value:null}})};h.prototype.appendLeft=function(e){this.outro+=e},h.prototype.appendRight=function(e){this.intro=this.intro+e},h.prototype.clone=function(){var e=new h(this.start,this.end,this.original);return e.intro=this.intro,e.outro=this.outro,e.content=this.content,e.storeName=this.storeName,e.edited=this.edited,e},h.prototype.contains=function(e){return this.start<e&&e<this.end},h.prototype.eachNext=function(e){for(var t=this;t;)e(t),t=t.next},h.prototype.eachPrevious=function(e){for(var t=this;t;)e(t),t=t.previous},h.prototype.edit=function(e,t,s){return this.content=e,s||(this.intro="",this.outro=""),this.storeName=t,this.edited=!0,this},h.prototype.prependLeft=function(e){this.outro=e+this.outro},h.prototype.prependRight=function(e){this.intro=e+this.intro},h.prototype.split=function(e){var t=e-this.start,s=this.original.slice(0,t),i=this.original.slice(t);this.original=s;var n=new h(e,this.end,i);return n.outro=this.outro,this.outro="",this.end=e,this.edited?(n.edit("",!1),this.content=""):this.content=s,n.next=this.next,n.next&&(n.next.previous=n),n.previous=this,this.next=n,n},h.prototype.toString=function(){return this.intro+this.content+this.outro},h.prototype.trimEnd=function(e){if(this.outro=this.outro.replace(e,""),this.outro.length)return!0;var t=this.content.replace(e,"");return t.length?(t!==this.content&&this.split(this.start+t.length).edit("",void 0,!0),!0):(this.edit("",void 0,!0),this.intro=this.intro.replace(e,""),!!this.intro.length||void 0)},h.prototype.trimStart=function(e){if(this.intro=this.intro.replace(e,""),this.intro.length)return!0;var t=this.content.replace(e,"");return t.length?(t!==this.content&&(this.split(this.end-t.length),this.edit("",void 0,!0)),!0):(this.edit("",void 0,!0),this.outro=this.outro.replace(e,""),!!this.outro.length||void 0)};var l=function(){throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.")};"undefined"!=typeof window&&"function"==typeof window.btoa?l=function(e){return window.btoa(unescape(encodeURIComponent(e)))}:"function"==typeof Buffer&&(l=function(e){return Buffer.from(e,"utf-8").toString("base64")});var c=function(e){this.version=3,this.file=e.file,this.sources=e.sources,this.sourcesContent=e.sourcesContent,this.names=e.names,this.mappings=function(e){for(var t=0,s=0,i=0,n=0,r="",o=0;o<e.length;o++){var h=e[o];if(o>0&&(r+=";"),0!==h.length){for(var l=0,c=[],u=0,d=h;u<d.length;u++){var p=d[u],f=a(p[0]-l);l=p[0],p.length>1&&(f+=a(p[1]-t)+a(p[2]-s)+a(p[3]-i),t=p[1],s=p[2],i=p[3]),5===p.length&&(f+=a(p[4]-n),n=p[4]),c.push(f)}r+=c.join(",")}}return r}(e.mappings)};function u(e){var t=e.split("\n"),s=t.filter((function(e){return/^\t+/.test(e)})),i=t.filter((function(e){return/^ {2,}/.test(e)}));if(0===s.length&&0===i.length)return null;if(s.length>=i.length)return"\t";var n=i.reduce((function(e,t){var s=/^ +/.exec(t)[0].length;return Math.min(s,e)}),1/0);return new Array(n+1).join(" ")}function d(e,t){var s=e.split(/[/\\]/),i=t.split(/[/\\]/);for(s.pop();s[0]===i[0];)s.shift(),i.shift();if(s.length)for(var n=s.length;n--;)s[n]="..";return s.concat(i).join("/")}c.prototype.toString=function(){return JSON.stringify(this)},c.prototype.toUrl=function(){return"data:application/json;charset=utf-8;base64,"+l(this.toString())};var p=Object.prototype.toString;function f(e){return"[object Object]"===p.call(e)}function m(e){for(var t=e.split("\n"),s=[],i=0,n=0;i<t.length;i++)s.push(n),n+=t[i].length+1;return function(e){for(var t=0,i=s.length;t<i;){var n=t+i>>1;e<s[n]?i=n:t=n+1}var r=t-1;return{line:r,column:e-s[r]}}}var g=function(e){this.hires=e,this.generatedCodeLine=0,this.generatedCodeColumn=0,this.raw=[],this.rawSegments=this.raw[this.generatedCodeLine]=[],this.pending=null};g.prototype.addEdit=function(e,t,s,i){if(t.length){var n=[this.generatedCodeColumn,e,s.line,s.column];i>=0&&n.push(i),this.rawSegments.push(n)}else this.pending&&this.rawSegments.push(this.pending);this.advance(t),this.pending=null},g.prototype.addUneditedChunk=function(e,t,s,i,n){for(var r=t.start,a=!0;r<t.end;)(this.hires||a||n.has(r))&&this.rawSegments.push([this.generatedCodeColumn,e,i.line,i.column]),"\n"===s[r]?(i.line+=1,i.column=0,this.generatedCodeLine+=1,this.raw[this.generatedCodeLine]=this.rawSegments=[],this.generatedCodeColumn=0,a=!0):(i.column+=1,this.generatedCodeColumn+=1,a=!1),r+=1;this.pending=null},g.prototype.advance=function(e){if(e){var t=e.split("\n");if(t.length>1){for(var s=0;s<t.length-1;s++)this.generatedCodeLine++,this.raw[this.generatedCodeLine]=this.rawSegments=[];this.generatedCodeColumn=0}this.generatedCodeColumn+=t[t.length-1].length}};var y="\n",E={insertLeft:!1,insertRight:!1,storeName:!1},x=function(e,t){void 0===t&&(t={});var s=new h(0,e.length,e);Object.defineProperties(this,{original:{writable:!0,value:e},outro:{writable:!0,value:""},intro:{writable:!0,value:""},firstChunk:{writable:!0,value:s},lastChunk:{writable:!0,value:s},lastSearchedChunk:{writable:!0,value:s},byStart:{writable:!0,value:{}},byEnd:{writable:!0,value:{}},filename:{writable:!0,value:t.filename},indentExclusionRanges:{writable:!0,value:t.indentExclusionRanges},sourcemapLocations:{writable:!0,value:new o},storedNames:{writable:!0,value:{}},indentStr:{writable:!0,value:u(e)}}),this.byStart[0]=s,this.byEnd[e.length]=s};x.prototype.addSourcemapLocation=function(e){this.sourcemapLocations.add(e)},x.prototype.append=function(e){if("string"!=typeof e)throw new TypeError("outro content must be a string");return this.outro+=e,this},x.prototype.appendLeft=function(e,t){if("string"!=typeof t)throw new TypeError("inserted content must be a string");this._split(e);var s=this.byEnd[e];return s?s.appendLeft(t):this.intro+=t,this},x.prototype.appendRight=function(e,t){if("string"!=typeof t)throw new TypeError("inserted content must be a string");this._split(e);var s=this.byStart[e];return s?s.appendRight(t):this.outro+=t,this},x.prototype.clone=function(){for(var e=new x(this.original,{filename:this.filename}),t=this.firstChunk,s=e.firstChunk=e.lastSearchedChunk=t.clone();t;){e.byStart[s.start]=s,e.byEnd[s.end]=s;var i=t.next,n=i&&i.clone();n&&(s.next=n,n.previous=s,s=n),t=i}return e.lastChunk=s,this.indentExclusionRanges&&(e.indentExclusionRanges=this.indentExclusionRanges.slice()),e.sourcemapLocations=new o(this.sourcemapLocations),e.intro=this.intro,e.outro=this.outro,e},x.prototype.generateDecodedMap=function(e){var t=this;e=e||{};var s=Object.keys(this.storedNames),i=new g(e.hires),n=m(this.original);return this.intro&&i.advance(this.intro),this.firstChunk.eachNext((function(e){var r=n(e.start);e.intro.length&&i.advance(e.intro),e.edited?i.addEdit(0,e.content,r,e.storeName?s.indexOf(e.original):-1):i.addUneditedChunk(0,e,t.original,r,t.sourcemapLocations),e.outro.length&&i.advance(e.outro)})),{file:e.file?e.file.split(/[/\\]/).pop():null,sources:[e.source?d(e.file||"",e.source):null],sourcesContent:e.includeContent?[this.original]:[null],names:s,mappings:i.raw}},x.prototype.generateMap=function(e){return new c(this.generateDecodedMap(e))},x.prototype.getIndentString=function(){return null===this.indentStr?"\t":this.indentStr},x.prototype.indent=function(e,t){var s=/^[^\r\n]/gm;if(f(e)&&(t=e,e=void 0),""===(e=void 0!==e?e:this.indentStr||"\t"))return this;var i={};(t=t||{}).exclude&&("number"==typeof t.exclude[0]?[t.exclude]:t.exclude).forEach((function(e){for(var t=e[0];t<e[1];t+=1)i[t]=!0}));var n=!1!==t.indentStart,r=function(t){return n?""+e+t:(n=!0,t)};this.intro=this.intro.replace(s,r);for(var a=0,o=this.firstChunk;o;){var h=o.end;if(o.edited)i[a]||(o.content=o.content.replace(s,r),o.content.length&&(n="\n"===o.content[o.content.length-1]));else for(a=o.start;a<h;){if(!i[a]){var l=this.original[a];"\n"===l?n=!0:"\r"!==l&&n&&(n=!1,a===o.start?o.prependRight(e):(this._splitChunk(o,a),(o=o.next).prependRight(e)))}a+=1}a=o.end,o=o.next}return this.outro=this.outro.replace(s,r),this},x.prototype.insert=function(){throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)")},x.prototype.insertLeft=function(e,t){return E.insertLeft||(console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"),E.insertLeft=!0),this.appendLeft(e,t)},x.prototype.insertRight=function(e,t){return E.insertRight||(console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"),E.insertRight=!0),this.prependRight(e,t)},x.prototype.move=function(e,t,s){if(s>=e&&s<=t)throw new Error("Cannot move a selection inside itself");this._split(e),this._split(t),this._split(s);var i=this.byStart[e],n=this.byEnd[t],r=i.previous,a=n.next,o=this.byStart[s];if(!o&&n===this.lastChunk)return this;var h=o?o.previous:this.lastChunk;return r&&(r.next=a),a&&(a.previous=r),h&&(h.next=i),o&&(o.previous=n),i.previous||(this.firstChunk=n.next),n.next||(this.lastChunk=i.previous,this.lastChunk.next=null),i.previous=h,n.next=o||null,h||(this.firstChunk=i),o||(this.lastChunk=n),this},x.prototype.overwrite=function(e,t,s,i){if("string"!=typeof s)throw new TypeError("replacement content must be a string");for(;e<0;)e+=this.original.length;for(;t<0;)t+=this.original.length;if(t>this.original.length)throw new Error("end is out of bounds");if(e===t)throw new Error("Cannot overwrite a zero-length range – use appendLeft or prependRight instead");this._split(e),this._split(t),!0===i&&(E.storeName||(console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"),E.storeName=!0),i={storeName:!0});var n=void 0!==i&&i.storeName,r=void 0!==i&&i.contentOnly;if(n){var a=this.original.slice(e,t);this.storedNames[a]=!0}var o=this.byStart[e],l=this.byEnd[t];if(o){if(t>o.end&&o.next!==this.byStart[o.end])throw new Error("Cannot overwrite across a split point");if(o.edit(s,n,r),o!==l){for(var c=o.next;c!==l;)c.edit("",!1),c=c.next;c.edit("",!1)}}else{var u=new h(e,t,"").edit(s,n);l.next=u,u.previous=l}return this},x.prototype.prepend=function(e){if("string"!=typeof e)throw new TypeError("outro content must be a string");return this.intro=e+this.intro,this},x.prototype.prependLeft=function(e,t){if("string"!=typeof t)throw new TypeError("inserted content must be a string");this._split(e);var s=this.byEnd[e];return s?s.prependLeft(t):this.intro=t+this.intro,this},x.prototype.prependRight=function(e,t){if("string"!=typeof t)throw new TypeError("inserted content must be a string");this._split(e);var s=this.byStart[e];return s?s.prependRight(t):this.outro=t+this.outro,this},x.prototype.remove=function(e,t){for(;e<0;)e+=this.original.length;for(;t<0;)t+=this.original.length;if(e===t)return this;if(e<0||t>this.original.length)throw new Error("Character is out of bounds");if(e>t)throw new Error("end must be greater than start");this._split(e),this._split(t);for(var s=this.byStart[e];s;)s.intro="",s.outro="",s.edit(""),s=t>s.end?this.byStart[s.end]:null;return this},x.prototype.lastChar=function(){if(this.outro.length)return this.outro[this.outro.length-1];var e=this.lastChunk;do{if(e.outro.length)return e.outro[e.outro.length-1];if(e.content.length)return e.content[e.content.length-1];if(e.intro.length)return e.intro[e.intro.length-1]}while(e=e.previous);return this.intro.length?this.intro[this.intro.length-1]:""},x.prototype.lastLine=function(){var e=this.outro.lastIndexOf(y);if(-1!==e)return this.outro.substr(e+1);var t=this.outro,s=this.lastChunk;do{if(s.outro.length>0){if(-1!==(e=s.outro.lastIndexOf(y)))return s.outro.substr(e+1)+t;t=s.outro+t}if(s.content.length>0){if(-1!==(e=s.content.lastIndexOf(y)))return s.content.substr(e+1)+t;t=s.content+t}if(s.intro.length>0){if(-1!==(e=s.intro.lastIndexOf(y)))return s.intro.substr(e+1)+t;t=s.intro+t}}while(s=s.previous);return-1!==(e=this.intro.lastIndexOf(y))?this.intro.substr(e+1)+t:this.intro+t},x.prototype.slice=function(e,t){for(void 0===e&&(e=0),void 0===t&&(t=this.original.length);e<0;)e+=this.original.length;for(;t<0;)t+=this.original.length;for(var s="",i=this.firstChunk;i&&(i.start>e||i.end<=e);){if(i.start<t&&i.end>=t)return s;i=i.next}if(i&&i.edited&&i.start!==e)throw new Error("Cannot use replaced character "+e+" as slice start anchor.");for(var n=i;i;){!i.intro||n===i&&i.start!==e||(s+=i.intro);var r=i.start<t&&i.end>=t;if(r&&i.edited&&i.end!==t)throw new Error("Cannot use replaced character "+t+" as slice end anchor.");var a=n===i?e-i.start:0,o=r?i.content.length+t-i.end:i.content.length;if(s+=i.content.slice(a,o),!i.outro||r&&i.end!==t||(s+=i.outro),r)break;i=i.next}return s},x.prototype.snip=function(e,t){var s=this.clone();return s.remove(0,e),s.remove(t,s.original.length),s},x.prototype._split=function(e){if(!this.byStart[e]&&!this.byEnd[e])for(var t=this.lastSearchedChunk,s=e>t.end;t;){if(t.contains(e))return this._splitChunk(t,e);t=s?this.byStart[t.end]:this.byEnd[t.start]}},x.prototype._splitChunk=function(e,t){if(e.edited&&e.content.length){var s=m(this.original)(t);throw new Error("Cannot split a chunk that has already been edited ("+s.line+":"+s.column+' – "'+e.original+'")')}var i=e.split(t);return this.byEnd[t]=e,this.byStart[t]=i,this.byEnd[i.end]=i,e===this.lastChunk&&(this.lastChunk=i),this.lastSearchedChunk=e,!0},x.prototype.toString=function(){for(var e=this.intro,t=this.firstChunk;t;)e+=t.toString(),t=t.next;return e+this.outro},x.prototype.isEmpty=function(){var e=this.firstChunk;do{if(e.intro.length&&e.intro.trim()||e.content.length&&e.content.trim()||e.outro.length&&e.outro.trim())return!1}while(e=e.next);return!0},x.prototype.length=function(){var e=this.firstChunk,t=0;do{t+=e.intro.length+e.content.length+e.outro.length}while(e=e.next);return t},x.prototype.trimLines=function(){return this.trim("[\\r\\n]")},x.prototype.trim=function(e){return this.trimStart(e).trimEnd(e)},x.prototype.trimEndAborted=function(e){var t=new RegExp((e||"\\s")+"+$");if(this.outro=this.outro.replace(t,""),this.outro.length)return!0;var s=this.lastChunk;do{var i=s.end,n=s.trimEnd(t);if(s.end!==i&&(this.lastChunk===s&&(this.lastChunk=s.next),this.byEnd[s.end]=s,this.byStart[s.next.start]=s.next,this.byEnd[s.next.end]=s.next),n)return!0;s=s.previous}while(s);return!1},x.prototype.trimEnd=function(e){return this.trimEndAborted(e),this},x.prototype.trimStartAborted=function(e){var t=new RegExp("^"+(e||"\\s")+"+");if(this.intro=this.intro.replace(t,""),this.intro.length)return!0;var s=this.firstChunk;do{var i=s.end,n=s.trimStart(t);if(s.end!==i&&(s===this.lastChunk&&(this.lastChunk=s.next),this.byEnd[s.end]=s,this.byStart[s.next.start]=s.next,this.byEnd[s.next.end]=s.next),n)return!0;s=s.next}while(s);return!1},x.prototype.trimStart=function(e){return this.trimStartAborted(e),this};var v=Object.prototype.hasOwnProperty,b=function(e){void 0===e&&(e={}),this.intro=e.intro||"",this.separator=void 0!==e.separator?e.separator:"\n",this.sources=[],this.uniqueSources=[],this.uniqueSourceIndexByFilename={}};b.prototype.addSource=function(e){if(e instanceof x)return this.addSource({content:e,filename:e.filename,separator:this.separator});if(!f(e)||!e.content)throw new Error("bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`");if(["filename","indentExclusionRanges","separator"].forEach((function(t){v.call(e,t)||(e[t]=e.content[t])})),void 0===e.separator&&(e.separator=this.separator),e.filename)if(v.call(this.uniqueSourceIndexByFilename,e.filename)){var t=this.uniqueSources[this.uniqueSourceIndexByFilename[e.filename]];if(e.content.original!==t.content)throw new Error("Illegal source: same filename ("+e.filename+"), different contents")}else this.uniqueSourceIndexByFilename[e.filename]=this.uniqueSources.length,this.uniqueSources.push({filename:e.filename,content:e.content.original});return this.sources.push(e),this},b.prototype.append=function(e,t){return this.addSource({content:new x(e),separator:t&&t.separator||""}),this},b.prototype.clone=function(){var e=new b({intro:this.intro,separator:this.separator});return this.sources.forEach((function(t){e.addSource({filename:t.filename,content:t.content.clone(),separator:t.separator})})),e},b.prototype.generateDecodedMap=function(e){var t=this;void 0===e&&(e={});var s=[];this.sources.forEach((function(e){Object.keys(e.content.storedNames).forEach((function(e){~s.indexOf(e)||s.push(e)}))}));var i=new g(e.hires);return this.intro&&i.advance(this.intro),this.sources.forEach((function(e,n){n>0&&i.advance(t.separator);var r=e.filename?t.uniqueSourceIndexByFilename[e.filename]:-1,a=e.content,o=m(a.original);a.intro&&i.advance(a.intro),a.firstChunk.eachNext((function(t){var n=o(t.start);t.intro.length&&i.advance(t.intro),e.filename?t.edited?i.addEdit(r,t.content,n,t.storeName?s.indexOf(t.original):-1):i.addUneditedChunk(r,t,a.original,n,a.sourcemapLocations):i.advance(t.content),t.outro.length&&i.advance(t.outro)})),a.outro&&i.advance(a.outro)})),{file:e.file?e.file.split(/[/\\]/).pop():null,sources:this.uniqueSources.map((function(t){return e.file?d(e.file,t.filename):t.filename})),sourcesContent:this.uniqueSources.map((function(t){return e.includeContent?t.content:null})),names:s,mappings:i.raw}},b.prototype.generateMap=function(e){return new c(this.generateDecodedMap(e))},b.prototype.getIndentString=function(){var e={};return this.sources.forEach((function(t){var s=t.content.indentStr;null!==s&&(e[s]||(e[s]=0),e[s]+=1)})),Object.keys(e).sort((function(t,s){return e[t]-e[s]}))[0]||"\t"},b.prototype.indent=function(e){var t=this;if(arguments.length||(e=this.getIndentString()),""===e)return this;var s=!this.intro||"\n"===this.intro.slice(-1);return this.sources.forEach((function(i,n){var r=void 0!==i.separator?i.separator:t.separator,a=s||n>0&&/\r?\n$/.test(r);i.content.indent(e,{exclude:i.indentExclusionRanges,indentStart:a}),s="\n"===i.content.lastChar()})),this.intro&&(this.intro=e+this.intro.replace(/^[^\n]/gm,(function(t,s){return s>0?e+t:t}))),this},b.prototype.prepend=function(e){return this.intro=e+this.intro,this},b.prototype.toString=function(){var e=this,t=this.sources.map((function(t,s){var i=void 0!==t.separator?t.separator:e.separator;return(s>0?i:"")+t.content.toString()})).join("");return this.intro+t},b.prototype.isEmpty=function(){return!(this.intro.length&&this.intro.trim()||this.sources.some((function(e){return!e.content.isEmpty()})))},b.prototype.length=function(){return this.sources.reduce((function(e,t){return e+t.content.length()}),this.intro.length)},b.prototype.trimLines=function(){return this.trim("[\\r\\n]")},b.prototype.trim=function(e){return this.trimStart(e).trimEnd(e)},b.prototype.trimStart=function(e){var t=new RegExp("^"+(e||"\\s")+"+");if(this.intro=this.intro.replace(t,""),!this.intro){var s,i=0;do{if(!(s=this.sources[i++]))break}while(!s.content.trimStartAborted(e))}return this},b.prototype.trimEnd=function(e){var t,s=new RegExp((e||"\\s")+"+$"),i=this.sources.length-1;do{if(!(t=this.sources[i--])){this.intro=this.intro.replace(s,"");break}}while(!t.content.trimEndAborted(e));return this};var A=x;const S=/^(?:\/|(?:[A-Za-z]:)?[\\|/])/,P=/^\.?\.\//;function k(e){return S.test(e)}function w(e){return P.test(e)}function C(e){return e.replace(/\\/g,"/")}function I(e){return e.split(/[/\\]/).pop()||""}function N(e){const t=/[/\\][^/\\]*$/.exec(e);if(!t)return".";const s=e.slice(0,-t[0].length);return s||"/"}function _(e){const t=/\.[^.]+$/.exec(I(e));return t?t[0]:""}function $(e,t){const s=e.split(/[/\\]/).filter(Boolean),i=t.split(/[/\\]/).filter(Boolean);for("."===s[0]&&s.shift(),"."===i[0]&&i.shift();s[0]&&i[0]&&s[0]===i[0];)s.shift(),i.shift();for(;".."===i[0]&&s.length>0;)i.shift(),s.pop();for(;s.pop();)i.unshift("..");return i.join("/")}function T(...e){const t=e.shift();if(!t)return"/";let s=t.split(/[/\\]/);for(const t of e)if(k(t))s=t.split(/[/\\]/);else{const e=t.split(/[/\\]/);for(;"."===e[0]||".."===e[0];)".."===e.shift()&&s.pop();s.push(...e)}return s.join("/")}function R(e,t,s){const i=e.get(t);if(i)return i;const n=s();return e.set(t,n),n}const M=Symbol("Unknown Key"),D=Symbol("Unknown Integer"),O=[],L=[M],V=[D],B=Symbol("Entities");class F{constructor(){this.entityPaths=Object.create(null,{[B]:{value:new Set}})}trackEntityAtPathAndGetIfTracked(e,t){const s=this.getEntities(e);return!!s.has(t)||(s.add(t),!1)}withTrackedEntityAtPath(e,t,s,i){const n=this.getEntities(e);if(n.has(t))return i;n.add(t);const r=s();return n.delete(t),r}getEntities(e){let t=this.entityPaths;for(const s of e)t=t[s]=t[s]||Object.create(null,{[B]:{value:new Set}});return t[B]}}const z=new F;class W{constructor(){this.entityPaths=Object.create(null,{[B]:{value:new Map}})}trackEntityAtPathAndGetIfTracked(e,t,s){let i=this.entityPaths;for(const t of e)i=i[t]=i[t]||Object.create(null,{[B]:{value:new Map}});const n=R(i[B],t,(()=>new Set));return!!n.has(s)||(n.add(s),!1)}}const j=Symbol("Unknown Value");class U{constructor(){this.included=!1}deoptimizePath(e){}deoptimizeThisOnEventAtPath(e,t,s,i){s.deoptimizePath(L)}getLiteralValueAtPath(e,t,s){return j}getReturnExpressionWhenCalledAtPath(e,t,s,i){return G}hasEffectsWhenAccessedAtPath(e,t){return!0}hasEffectsWhenAssignedAtPath(e,t){return!0}hasEffectsWhenCalledAtPath(e,t,s){return!0}include(e,t){this.included=!0}includeCallArguments(e,t){for(const s of t)s.include(e,!1)}}const G=new class extends U{};class H extends U{constructor(e){super(),this.name=e,this.alwaysRendered=!1,this.initReached=!1,this.isId=!1,this.isReassigned=!1,this.kind=null,this.renderBaseName=null,this.renderName=null}addReference(e){}getBaseVariableName(){return this.renderBaseName||this.renderName||this.name}getName(e){const t=this.renderName||this.name;return this.renderBaseName?`${this.renderBaseName}${e(t)}`:t}hasEffectsWhenAccessedAtPath(e,t){return e.length>0}include(){this.included=!0}markCalledFromTryStatement(){}setRenderNames(e,t){this.renderBaseName=e,this.renderName=t}}class q extends H{constructor(e,t){super(t),this.referenced=!1,this.module=e,this.isNamespace="*"===t}addReference(e){this.referenced=!0,"default"!==this.name&&"*"!==this.name||this.module.suggestName(e.name)}hasEffectsWhenAccessedAtPath(e){return e.length>(this.isNamespace?1:0)}include(){this.included||(this.included=!0,this.module.used=!0)}}const K=Object.freeze(Object.create(null)),X=Object.freeze({}),Y=Object.freeze([]),Q="break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public".split(" "),Z="Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl".split(" "),J=new Set(Q.concat(Z)),ee=/[^$_a-zA-Z0-9]/g,te=e=>/\d/.test(e[0]);function se(e){return e=e.replace(/-(\w)/g,((e,t)=>t.toUpperCase())).replace(ee,"_"),(te(e)||J.has(e))&&(e=`_${e}`),e||"_"}function ie(e,t){const s=e.length<=1,i=e.map((e=>`"${e}"`));let n=s?i[0]:`${i.slice(0,-1).join(", ")} and ${i.slice(-1)[0]}`;return t&&(n+=` ${s?t[0]:t[1]}`),n}function ne(e){const t=I(e);return t.substr(0,t.length-_(e).length)}function re(e){return k(e)?$(T(),e):e}function ae(e){return"/"===e[0]||"."===e[0]&&("/"===e[1]||"."===e[1])||k(e)}class oe{constructor(e,t,s,i,n){this.options=e,this.id=t,this.renormalizeRenderPath=n,this.declarations=Object.create(null),this.defaultVariableName="",this.dynamicImporters=[],this.execIndex=1/0,this.exportedVariables=new Map,this.importers=[],this.mostCommonSuggestion=0,this.nameSuggestions=Object.create(null),this.namespaceVariableName="",this.reexported=!1,this.renderPath=void 0,this.used=!1,this.variableName="",this.suggestedVariableName=se(t.split(/[\\/]/).pop());const{importers:r,dynamicImporters:a}=this;this.info={ast:null,code:null,dynamicallyImportedIds:Y,get dynamicImporters(){return a.sort()},hasModuleSideEffects:s,id:t,implicitlyLoadedAfterOneOf:Y,implicitlyLoadedBefore:Y,importedIds:Y,get importers(){return r.sort()},isEntry:!1,isExternal:!0,meta:i,syntheticNamedExports:!1}}getVariableForExportName(e){let t=this.declarations[e];return t||(this.declarations[e]=t=new q(this,e),this.exportedVariables.set(t,e),t)}setRenderPath(e,t){return this.renderPath="function"==typeof e.paths?e.paths(this.id):e.paths[this.id],this.renderPath||(this.renderPath=this.renormalizeRenderPath?C($(t,this.id)):this.id),this.renderPath}suggestName(e){this.nameSuggestions[e]||(this.nameSuggestions[e]=0),this.nameSuggestions[e]+=1,this.nameSuggestions[e]>this.mostCommonSuggestion&&(this.mostCommonSuggestion=this.nameSuggestions[e],this.suggestedVariableName=e)}warnUnusedImports(){const e=Object.keys(this.declarations).filter((e=>{if("*"===e)return!1;const t=this.declarations[e];return!t.included&&!this.reexported&&!t.referenced}));if(0===e.length)return;const t=new Set;for(const s of e){const{importers:e}=this.declarations[s].module;for(const s of e)t.add(s)}const s=[...t];this.options.onwarn({code:"UNUSED_EXTERNAL_IMPORT",message:`${ie(e,["is","are"])} imported from external module "${this.id}" but never used in ${ie(s.map((e=>re(e))))}.`,names:e,source:this.id,sources:s})}}const he={ArrayPattern(e,t){for(const s of t.elements)s&&he[s.type](e,s)},AssignmentPattern(e,t){he[t.left.type](e,t.left)},Identifier(e,t){e.push(t.name)},MemberExpression(){},ObjectPattern(e,t){for(const s of t.properties)"RestElement"===s.type?he.RestElement(e,s):he[s.value.type](e,s.value)},RestElement(e,t){he[t.argument.type](e,t.argument)}},le=function(e){const t=[];return he[e.type](t,e),t};function ce(e,t,s){if("number"==typeof s)throw new Error("locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument");return function(e,t){void 0===t&&(t={});var s=t.offsetLine||0,i=t.offsetColumn||0,n=e.split("\n"),r=0,a=n.map((function(e,t){var s=r+e.length+1,i={start:r,end:s,line:t};return r=s,i})),o=0;function h(e,t){return e.start<=t&&t<e.end}function l(e,t){return{line:s+e.line,column:i+t-e.start,character:t}}return function(t,s){"string"==typeof t&&(t=e.indexOf(t,s||0));for(var i=a[o],n=t>=i.end?1:-1;i;){if(h(i,t))return l(i,t);i=a[o+=n]}}}(e,s)(t,s&&s.startIndex)}function ue(){return{brokenFlow:0,includedCallArguments:new Set,includedLabels:new Set}}function de(){return{accessed:new F,assigned:new F,brokenFlow:0,called:new W,ignore:{breaks:!1,continues:!1,labels:new Set,returnYield:!1},includedLabels:new Set,instantiated:new W,replacedVariableInits:new Map}}function pe(e,t,s){s(e,t)}function fe(e,t,s){}new Set("break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl".split(" ")).add("");var me={};me.Program=me.BlockStatement=me.StaticBlock=function(e,t,s){for(var i=0,n=e.body;i<n.length;i+=1)s(n[i],t,"Statement")},me.Statement=pe,me.EmptyStatement=fe,me.ExpressionStatement=me.ParenthesizedExpression=me.ChainExpression=function(e,t,s){return s(e.expression,t,"Expression")},me.IfStatement=function(e,t,s){s(e.test,t,"Expression"),s(e.consequent,t,"Statement"),e.alternate&&s(e.alternate,t,"Statement")},me.LabeledStatement=function(e,t,s){return s(e.body,t,"Statement")},me.BreakStatement=me.ContinueStatement=fe,me.WithStatement=function(e,t,s){s(e.object,t,"Expression"),s(e.body,t,"Statement")},me.SwitchStatement=function(e,t,s){s(e.discriminant,t,"Expression");for(var i=0,n=e.cases;i<n.length;i+=1){var r=n[i];r.test&&s(r.test,t,"Expression");for(var a=0,o=r.consequent;a<o.length;a+=1)s(o[a],t,"Statement")}},me.SwitchCase=function(e,t,s){e.test&&s(e.test,t,"Expression");for(var i=0,n=e.consequent;i<n.length;i+=1)s(n[i],t,"Statement")},me.ReturnStatement=me.YieldExpression=me.AwaitExpression=function(e,t,s){e.argument&&s(e.argument,t,"Expression")},me.ThrowStatement=me.SpreadElement=function(e,t,s){return s(e.argument,t,"Expression")},me.TryStatement=function(e,t,s){s(e.block,t,"Statement"),e.handler&&s(e.handler,t),e.finalizer&&s(e.finalizer,t,"Statement")},me.CatchClause=function(e,t,s){e.param&&s(e.param,t,"Pattern"),s(e.body,t,"Statement")},me.WhileStatement=me.DoWhileStatement=function(e,t,s){s(e.test,t,"Expression"),s(e.body,t,"Statement")},me.ForStatement=function(e,t,s){e.init&&s(e.init,t,"ForInit"),e.test&&s(e.test,t,"Expression"),e.update&&s(e.update,t,"Expression"),s(e.body,t,"Statement")},me.ForInStatement=me.ForOfStatement=function(e,t,s){s(e.left,t,"ForInit"),s(e.right,t,"Expression"),s(e.body,t,"Statement")},me.ForInit=function(e,t,s){"VariableDeclaration"===e.type?s(e,t):s(e,t,"Expression")},me.DebuggerStatement=fe,me.FunctionDeclaration=function(e,t,s){return s(e,t,"Function")},me.VariableDeclaration=function(e,t,s){for(var i=0,n=e.declarations;i<n.length;i+=1)s(n[i],t)},me.VariableDeclarator=function(e,t,s){s(e.id,t,"Pattern"),e.init&&s(e.init,t,"Expression")},me.Function=function(e,t,s){e.id&&s(e.id,t,"Pattern");for(var i=0,n=e.params;i<n.length;i+=1)s(n[i],t,"Pattern");s(e.body,t,e.expression?"Expression":"Statement")},me.Pattern=function(e,t,s){"Identifier"===e.type?s(e,t,"VariablePattern"):"MemberExpression"===e.type?s(e,t,"MemberPattern"):s(e,t)},me.VariablePattern=fe,me.MemberPattern=pe,me.RestElement=function(e,t,s){return s(e.argument,t,"Pattern")},me.ArrayPattern=function(e,t,s){for(var i=0,n=e.elements;i<n.length;i+=1){var r=n[i];r&&s(r,t,"Pattern")}},me.ObjectPattern=function(e,t,s){for(var i=0,n=e.properties;i<n.length;i+=1){var r=n[i];"Property"===r.type?(r.computed&&s(r.key,t,"Expression"),s(r.value,t,"Pattern")):"RestElement"===r.type&&s(r.argument,t,"Pattern")}},me.Expression=pe,me.ThisExpression=me.Super=me.MetaProperty=fe,me.ArrayExpression=function(e,t,s){for(var i=0,n=e.elements;i<n.length;i+=1){var r=n[i];r&&s(r,t,"Expression")}},me.ObjectExpression=function(e,t,s){for(var i=0,n=e.properties;i<n.length;i+=1)s(n[i],t)},me.FunctionExpression=me.ArrowFunctionExpression=me.FunctionDeclaration,me.SequenceExpression=function(e,t,s){for(var i=0,n=e.expressions;i<n.length;i+=1)s(n[i],t,"Expression")},me.TemplateLiteral=function(e,t,s){for(var i=0,n=e.quasis;i<n.length;i+=1)s(n[i],t);for(var r=0,a=e.expressions;r<a.length;r+=1)s(a[r],t,"Expression")},me.TemplateElement=fe,me.UnaryExpression=me.UpdateExpression=function(e,t,s){s(e.argument,t,"Expression")},me.BinaryExpression=me.LogicalExpression=function(e,t,s){s(e.left,t,"Expression"),s(e.right,t,"Expression")},me.AssignmentExpression=me.AssignmentPattern=function(e,t,s){s(e.left,t,"Pattern"),s(e.right,t,"Expression")},me.ConditionalExpression=function(e,t,s){s(e.test,t,"Expression"),s(e.consequent,t,"Expression"),s(e.alternate,t,"Expression")},me.NewExpression=me.CallExpression=function(e,t,s){if(s(e.callee,t,"Expression"),e.arguments)for(var i=0,n=e.arguments;i<n.length;i+=1)s(n[i],t,"Expression")},me.MemberExpression=function(e,t,s){s(e.object,t,"Expression"),e.computed&&s(e.property,t,"Expression")},me.ExportNamedDeclaration=me.ExportDefaultDeclaration=function(e,t,s){e.declaration&&s(e.declaration,t,"ExportNamedDeclaration"===e.type||e.declaration.id?"Statement":"Expression"),e.source&&s(e.source,t,"Expression")},me.ExportAllDeclaration=function(e,t,s){e.exported&&s(e.exported,t),s(e.source,t,"Expression")},me.ImportDeclaration=function(e,t,s){for(var i=0,n=e.specifiers;i<n.length;i+=1)s(n[i],t);s(e.source,t,"Expression")},me.ImportExpression=function(e,t,s){s(e.source,t,"Expression")},me.ImportSpecifier=me.ImportDefaultSpecifier=me.ImportNamespaceSpecifier=me.Identifier=me.PrivateIdentifier=me.Literal=fe,me.TaggedTemplateExpression=function(e,t,s){s(e.tag,t,"Expression"),s(e.quasi,t,"Expression")},me.ClassDeclaration=me.ClassExpression=function(e,t,s){return s(e,t,"Class")},me.Class=function(e,t,s){e.id&&s(e.id,t,"Pattern"),e.superClass&&s(e.superClass,t,"Expression"),s(e.body,t)},me.ClassBody=function(e,t,s){for(var i=0,n=e.body;i<n.length;i+=1)s(n[i],t)},me.MethodDefinition=me.PropertyDefinition=me.Property=function(e,t,s){e.computed&&s(e.key,t,"Expression"),e.value&&s(e.value,t,"Expression")};const ge="ArrowFunctionExpression",ye="BlockStatement",Ee="CallExpression",xe="ExpressionStatement",ve="Identifier",be="Program";let Ae="sourceMa";Ae+="ppingURL";const Se=new RegExp("^#[ \\f\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]+sourceMappingURL=.+");me.PropertyDefinition=function(e,t,s){e.computed&&s(e.key,t,"Expression"),e.value&&s(e.value,t,"Expression")};const Pe="_rollupAnnotations",ke="_rollupRemoved";function we(e,t,s=e.type){const{annotations:i}=t;let n=i[t.annotationIndex];for(;n&&e.start>=n.end;)Ne(e,n,t.code),n=i[++t.annotationIndex];if(n&&n.end<=e.end)for(me[s](e,t,we);(n=i[t.annotationIndex])&&n.end<=e.end;)++t.annotationIndex,Te(e,n,!1)}const Ce=/[^\s(]/g,Ie=/\S/g;function Ne(e,t,s){const i=[];let n;if(_e(s.slice(t.end,e.start),Ce)){const t=e.start;for(;;){switch(i.push(e),e.type){case xe:case"ChainExpression":e=e.expression;continue;case"SequenceExpression":if(_e(s.slice(t,e.start),Ie)){e=e.expressions[0];continue}n=!0;break;case"ConditionalExpression":if(_e(s.slice(t,e.start),Ie)){e=e.test;continue}n=!0;break;case"LogicalExpression":case"BinaryExpression":if(_e(s.slice(t,e.start),Ie)){e=e.left;continue}n=!0;break;case Ee:case"NewExpression":break;default:n=!0}break}}else n=!0;if(n)Te(e,t,!1);else for(const e of i)Te(e,t,!0)}function _e(e,t){let s;for(;null!==(s=t.exec(e));){if("/"===s[0]){const s=e.charCodeAt(t.lastIndex);if(42===s){t.lastIndex=e.indexOf("*/",t.lastIndex+1)+2;continue}if(47===s){t.lastIndex=e.indexOf("\n",t.lastIndex+1)+1;continue}}return t.lastIndex=0,!1}return!0}const $e=/[@#]__PURE__/;function Te(e,t,s){const i=s?Pe:ke,n=e[i];n?n.push(t):e[i]=[t]}const Re={Literal:[],Program:["body"]},Me="variables";class De extends U{constructor(e,t,s){super(),this.esTreeNode=e,this.keys=Re[e.type]||function(e){return Re[e.type]=Object.keys(e).filter((t=>"object"==typeof e[t]&&95!==t.charCodeAt(0))),Re[e.type]}(e),this.parent=t,this.context=t.context,this.createScope(s),this.parseNode(e),this.initialise(),this.context.magicString.addSourcemapLocation(this.start),this.context.magicString.addSourcemapLocation(this.end)}addExportedVariables(e,t){}bind(){for(const e of this.keys){const t=this[e];if(null!==t)if(Array.isArray(t))for(const e of t)null!==e&&e.bind();else t.bind()}}createScope(e){this.scope=e}hasEffects(e){!1===this.deoptimized&&this.applyDeoptimizations();for(const t of this.keys){const s=this[t];if(null!==s)if(Array.isArray(s)){for(const t of s)if(null!==t&&t.hasEffects(e))return!0}else if(s.hasEffects(e))return!0}return!1}include(e,t){!1===this.deoptimized&&this.applyDeoptimizations(),this.included=!0;for(const s of this.keys){const i=this[s];if(null!==i)if(Array.isArray(i))for(const s of i)null!==s&&s.include(e,t);else i.include(e,t)}}includeAsSingleStatement(e,t){this.include(e,t)}initialise(){}insertSemicolon(e){";"!==e.original[this.end-1]&&e.appendLeft(this.end,";")}parseNode(e){for(const[t,s]of Object.entries(e))if(!this.hasOwnProperty(t))if(95===t.charCodeAt(0)){if(t===Pe)this.annotations=s;else if(t===ke)for(const{start:e,end:t}of s)this.context.magicString.remove(e,t)}else if("object"!=typeof s||null===s)this[t]=s;else if(Array.isArray(s)){this[t]=[];for(const e of s)this[t].push(null===e?null:new(this.context.nodeConstructors[e.type]||this.context.nodeConstructors.UnknownNode)(e,this,this.scope))}else this[t]=new(this.context.nodeConstructors[s.type]||this.context.nodeConstructors.UnknownNode)(s,this,this.scope)}render(e,t){for(const s of this.keys){const i=this[s];if(null!==i)if(Array.isArray(i))for(const s of i)null!==s&&s.render(e,t);else i.render(e,t)}}shouldBeIncluded(e){return this.included||!e.brokenFlow&&this.hasEffects(de())}applyDeoptimizations(){}}class Oe extends De{hasEffects(){return!1}initialise(){this.context.addExport(this)}render(e,t,s){e.remove(s.start,s.end)}}function Le(e,t,s,i){if(t.remove(s,i),e.annotations)for(const i of e.annotations){if(!(i.start<s))return;t.remove(i.start,i.end)}}function Ve(e,t){if(e.annotations||e.parent.type!==xe||(e=e.parent),e.annotations)for(const s of e.annotations)t.remove(s.start,s.end)}Oe.prototype.needsBoundaries=!0;const Be={isNoStatement:!0};function Fe(e,t,s=0){let i,n;for(i=e.indexOf(t,s);;){if(-1===(s=e.indexOf("/",s))||s>=i)return i;n=e.charCodeAt(++s),++s,(s=47===n?e.indexOf("\n",s)+1:e.indexOf("*/",s)+2)>i&&(i=e.indexOf(t,s))}}const ze=/\S/g;function We(e,t){return ze.lastIndex=t,ze.exec(e).index}function je(e){let t,s,i=0;for(t=e.indexOf("\n",i);;){if(i=e.indexOf("/",i),-1===i||i>t)return[t,t+1];if(s=e.charCodeAt(i+1),47===s)return[i,t+1];i=e.indexOf("*/",i+3)+2,i>t&&(t=e.indexOf("\n",i))}}function Ue(e,t,s,i,n){let r,a,o,h,l=e[0],c=!l.included||l.needsBoundaries;c&&(h=s+je(t.original.slice(s,l.start))[1]);for(let s=1;s<=e.length;s++)r=l,a=h,o=c,l=e[s],c=void 0!==l&&(!l.included||l.needsBoundaries),o||c?(h=r.end+je(t.original.slice(r.end,void 0===l?i:l.start))[1],r.included?o?r.render(t,n,{end:h,start:a}):r.render(t,n):Le(r,t,a,h)):r.render(t,n)}function Ge(e,t,s,i){const n=[];let r,a,o,h,l,c=s-1;for(let i=0;i<e.length;i++){for(a=e[i],void 0!==r&&(c=r.end+Fe(t.original.slice(r.end,a.start),",")),o=h=c+1+je(t.original.slice(c+1,a.start))[1];l=t.original.charCodeAt(o),32===l||9===l||10===l||13===l;)o++;void 0!==r&&n.push({contentEnd:h,end:o,node:r,separator:c,start:s}),r=a,s=o}return n.push({contentEnd:i,end:i,node:r,separator:null,start:s}),n}function He(e,t,s){for(;;){const[i,n]=je(e.original.slice(t,s));if(-1===i)break;e.remove(t+i,t+=n)}}function qe(e,{exportNamesByVariable:t,snippets:{_:s,getObject:i,getPropertyAccess:n}},r=""){if(1===e.length&&1===t.get(e[0]).length){const i=e[0];return`exports('${t.get(i)}',${s}${i.getName(n)}${r})`}{const s=[];for(const i of e)for(const e of t.get(i))s.push([e,i.getName(n)+r]);return`exports(${i(s,{lineBreakIndent:null})})`}}function Ke(e,t,s,i,{exportNamesByVariable:n,snippets:{_:r}}){i.prependRight(t,`exports('${n.get(e)}',${r}`),i.appendLeft(s,")")}function Xe(e,t,s,i,n,r){const{_:a,getPropertyAccess:o}=r.snippets;n.appendLeft(s,`,${a}${qe([e],r)},${a}${e.getName(o)}`),i&&(n.prependRight(t,"("),n.appendLeft(s,")"))}function Ye(e){let t="";do{const s=e%64;e=Math.floor(e/64),t="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$"[s]+t}while(0!==e);return t}const Qe={__proto__:null,await:!0,break:!0,case:!0,catch:!0,class:!0,const:!0,continue:!0,debugger:!0,default:!0,delete:!0,do:!0,else:!0,enum:!0,eval:!0,export:!0,extends:!0,false:!0,finally:!0,for:!0,function:!0,if:!0,implements:!0,import:!0,in:!0,instanceof:!0,interface:!0,let:!0,new:!0,null:!0,package:!0,private:!0,protected:!0,public:!0,return:!0,static:!0,super:!0,switch:!0,this:!0,throw:!0,true:!0,try:!0,typeof:!0,undefined:!0,var:!0,void:!0,while:!0,with:!0,yield:!0};function Ze(e,t){let s=e,i=1;for(;t.has(s)||Qe[s];)s=`${e}$${Ye(i++)}`;return t.add(s),s}const Je=[];function et(e,t=null){return Object.create(t,e)}const tt=new class extends U{getLiteralValueAtPath(){}},st={value:{callsArgs:null,returns:G}},it=new class extends U{getReturnExpressionWhenCalledAtPath(e){return 1===e.length?ft(ct,e[0]):G}hasEffectsWhenAccessedAtPath(e){return e.length>1}hasEffectsWhenCalledAtPath(e,t,s){return 1!==e.length||pt(ct,e[0],t,s)}},nt={value:{callsArgs:null,returns:it}},rt=new class extends U{getReturnExpressionWhenCalledAtPath(e){return 1===e.length?ft(ut,e[0]):G}hasEffectsWhenAccessedAtPath(e){return e.length>1}hasEffectsWhenCalledAtPath(e,t,s){return 1!==e.length||pt(ut,e[0],t,s)}},at={value:{callsArgs:null,returns:rt}},ot=new class extends U{getReturnExpressionWhenCalledAtPath(e){return 1===e.length?ft(dt,e[0]):G}hasEffectsWhenAccessedAtPath(e){return e.length>1}hasEffectsWhenCalledAtPath(e,t,s){return 1!==e.length||pt(dt,e[0],t,s)}},ht={value:{callsArgs:null,returns:ot}},lt=et({hasOwnProperty:nt,isPrototypeOf:nt,propertyIsEnumerable:nt,toLocaleString:ht,toString:ht,valueOf:st}),ct=et({valueOf:nt},lt),ut=et({toExponential:ht,toFixed:ht,toLocaleString:ht,toPrecision:ht,valueOf:at},lt),dt=et({charAt:ht,charCodeAt:at,codePointAt:at,concat:ht,endsWith:nt,includes:nt,indexOf:at,lastIndexOf:at,localeCompare:at,match:nt,normalize:ht,padEnd:ht,padStart:ht,repeat:ht,replace:{value:{callsArgs:[1],returns:ot}},search:at,slice:ht,split:st,startsWith:nt,substr:ht,substring:ht,toLocaleLowerCase:ht,toLocaleUpperCase:ht,toLowerCase:ht,toUpperCase:ht,trim:ht,valueOf:ht},lt);function pt(e,t,s,i){if("string"!=typeof t||!e[t])return!0;if(!e[t].callsArgs)return!1;for(const n of e[t].callsArgs)if(s.args[n]&&s.args[n].hasEffectsWhenCalledAtPath(O,{args:Je,thisParam:null,withNew:!1},i))return!0;return!1}function ft(e,t){return"string"==typeof t&&e[t]?e[t].returns:G}class mt extends H{constructor(e,t,s,i){super(e),this.calledFromTryStatement=!1,this.additionalInitializers=null,this.expressionsToBeDeoptimized=[],this.declarations=t?[t]:[],this.init=s,this.deoptimizationTracker=i.deoptimizationTracker,this.module=i.module}addDeclaration(e,t){this.declarations.push(e);const s=this.markInitializersForDeoptimization();null!==t&&s.push(t)}consolidateInitializers(){if(null!==this.additionalInitializers){for(const e of this.additionalInitializers)e.deoptimizePath(L);this.additionalInitializers=null}}deoptimizePath(e){var t,s;if(!this.isReassigned&&!this.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(e,this))if(0===e.length){if(!this.isReassigned){this.isReassigned=!0;const e=this.expressionsToBeDeoptimized;this.expressionsToBeDeoptimized=[];for(const t of e)t.deoptimizeCache();null===(t=this.init)||void 0===t||t.deoptimizePath(L)}}else null===(s=this.init)||void 0===s||s.deoptimizePath(e)}deoptimizeThisOnEventAtPath(e,t,s,i){if(this.isReassigned||!this.init)return s.deoptimizePath(L);i.withTrackedEntityAtPath(t,this.init,(()=>this.init.deoptimizeThisOnEventAtPath(e,t,s,i)),void 0)}getLiteralValueAtPath(e,t,s){return this.isReassigned||!this.init?j:t.withTrackedEntityAtPath(e,this.init,(()=>(this.expressionsToBeDeoptimized.push(s),this.init.getLiteralValueAtPath(e,t,s))),j)}getReturnExpressionWhenCalledAtPath(e,t,s,i){return this.isReassigned||!this.init?G:s.withTrackedEntityAtPath(e,this.init,(()=>(this.expressionsToBeDeoptimized.push(i),this.init.getReturnExpressionWhenCalledAtPath(e,t,s,i))),G)}hasEffectsWhenAccessedAtPath(e,t){return!!this.isReassigned||this.init&&!t.accessed.trackEntityAtPathAndGetIfTracked(e,this)&&this.init.hasEffectsWhenAccessedAtPath(e,t)}hasEffectsWhenAssignedAtPath(e,t){return!!this.included||0!==e.length&&(!!this.isReassigned||this.init&&!t.accessed.trackEntityAtPathAndGetIfTracked(e,this)&&this.init.hasEffectsWhenAssignedAtPath(e,t))}hasEffectsWhenCalledAtPath(e,t,s){return!!this.isReassigned||this.init&&!(t.withNew?s.instantiated:s.called).trackEntityAtPathAndGetIfTracked(e,t,this)&&this.init.hasEffectsWhenCalledAtPath(e,t,s)}include(){if(!this.included){this.included=!0;for(const e of this.declarations){e.included||e.include(ue(),!1);let t=e.parent;for(;!t.included&&(t.included=!0,t.type!==be);)t=t.parent}}}includeCallArguments(e,t){if(this.isReassigned||this.init&&e.includedCallArguments.has(this.init))for(const s of t)s.include(e,!1);else this.init&&(e.includedCallArguments.add(this.init),this.init.includeCallArguments(e,t),e.includedCallArguments.delete(this.init))}markCalledFromTryStatement(){this.calledFromTryStatement=!0}markInitializersForDeoptimization(){return null===this.additionalInitializers&&(this.additionalInitializers=null===this.init?[]:[this.init],this.init=G,this.isReassigned=!0),this.additionalInitializers}}class gt{constructor(){this.children=[],this.variables=new Map}addDeclaration(e,t,s,i){const n=e.name;let r=this.variables.get(n);return r?r.addDeclaration(e,s):(r=new mt(e.name,e,s||tt,t),this.variables.set(n,r)),r}contains(e){return this.variables.has(e)}findVariable(e){throw new Error("Internal Error: findVariable needs to be implemented by a subclass")}}class yt extends gt{constructor(e){super(),this.accessedOutsideVariables=new Map,this.parent=e,e.children.push(this)}addAccessedDynamicImport(e){(this.accessedDynamicImports||(this.accessedDynamicImports=new Set)).add(e),this.parent instanceof yt&&this.parent.addAccessedDynamicImport(e)}addAccessedGlobals(e,t){const s=t.get(this)||new Set;for(const t of e)s.add(t);t.set(this,s),this.parent instanceof yt&&this.parent.addAccessedGlobals(e,t)}addNamespaceMemberAccess(e,t){this.accessedOutsideVariables.set(e,t),this.parent.addNamespaceMemberAccess(e,t)}addReturnExpression(e){this.parent instanceof yt&&this.parent.addReturnExpression(e)}addUsedOutsideNames(e,t,s,i){for(const i of this.accessedOutsideVariables.values())i.included&&(e.add(i.getBaseVariableName()),"system"===t&&s.has(i)&&e.add("exports"));const n=i.get(this);if(n)for(const t of n)e.add(t)}contains(e){return this.variables.has(e)||this.parent.contains(e)}deconflict(e,t,s){const i=new Set;if(this.addUsedOutsideNames(i,e,t,s),this.accessedDynamicImports)for(const e of this.accessedDynamicImports)e.inlineNamespace&&i.add(e.inlineNamespace.getBaseVariableName());for(const[e,t]of this.variables)(t.included||t.alwaysRendered)&&t.setRenderNames(null,Ze(e,i));for(const i of this.children)i.deconflict(e,t,s)}findLexicalBoundary(){return this.parent.findLexicalBoundary()}findVariable(e){const t=this.variables.get(e)||this.accessedOutsideVariables.get(e);if(t)return t;const s=this.parent.findVariable(e);return this.accessedOutsideVariables.set(e,s),s}}function Et(e,t){if("MemberExpression"===e.type)return!e.computed&&Et(e.object,e);if("Identifier"===e.type){if(!t)return!0;switch(t.type){case"MemberExpression":return t.computed||e===t.object;case"MethodDefinition":return t.computed;case"PropertyDefinition":case"Property":return t.computed||e===t.value;case"ExportSpecifier":case"ImportSpecifier":return e===t.local;case"LabeledStatement":case"BreakStatement":case"ContinueStatement":return!1;default:return!0}}return!1}const xt=Symbol("Value Properties"),vt={pure:!0},bt={pure:!1},At={__proto__:null,[xt]:bt},St={__proto__:null,[xt]:vt},Pt={__proto__:null,[xt]:bt,prototype:At},kt={__proto__:null,[xt]:vt,prototype:At},wt={__proto__:null,[xt]:vt,from:St,of:St,prototype:At},Ct={__proto__:null,[xt]:vt,supportedLocalesOf:kt},It={global:At,globalThis:At,self:At,window:At,__proto__:null,[xt]:bt,Array:{__proto__:null,[xt]:bt,from:At,isArray:St,of:St,prototype:At},ArrayBuffer:{__proto__:null,[xt]:vt,isView:St,prototype:At},Atomics:At,BigInt:Pt,BigInt64Array:Pt,BigUint64Array:Pt,Boolean:kt,constructor:Pt,DataView:kt,Date:{__proto__:null,[xt]:vt,now:St,parse:St,prototype:At,UTC:St},decodeURI:St,decodeURIComponent:St,encodeURI:St,encodeURIComponent:St,Error:kt,escape:St,eval:At,EvalError:kt,Float32Array:wt,Float64Array:wt,Function:Pt,hasOwnProperty:At,Infinity:At,Int16Array:wt,Int32Array:wt,Int8Array:wt,isFinite:St,isNaN:St,isPrototypeOf:At,JSON:At,Map:kt,Math:{__proto__:null,[xt]:bt,abs:St,acos:St,acosh:St,asin:St,asinh:St,atan:St,atan2:St,atanh:St,cbrt:St,ceil:St,clz32:St,cos:St,cosh:St,exp:St,expm1:St,floor:St,fround:St,hypot:St,imul:St,log:St,log10:St,log1p:St,log2:St,max:St,min:St,pow:St,random:St,round:St,sign:St,sin:St,sinh:St,sqrt:St,tan:St,tanh:St,trunc:St},NaN:At,Number:{__proto__:null,[xt]:vt,isFinite:St,isInteger:St,isNaN:St,isSafeInteger:St,parseFloat:St,parseInt:St,prototype:At},Object:{__proto__:null,[xt]:vt,create:St,getNotifier:St,getOwn:St,getOwnPropertyDescriptor:St,getOwnPropertyNames:St,getOwnPropertySymbols:St,getPrototypeOf:St,is:St,isExtensible:St,isFrozen:St,isSealed:St,keys:St,prototype:At},parseFloat:St,parseInt:St,Promise:{__proto__:null,[xt]:bt,all:At,prototype:At,race:At,reject:At,resolve:At},propertyIsEnumerable:At,Proxy:At,RangeError:kt,ReferenceError:kt,Reflect:At,RegExp:kt,Set:kt,SharedArrayBuffer:Pt,String:{__proto__:null,[xt]:vt,fromCharCode:St,fromCodePoint:St,prototype:At,raw:St},Symbol:{__proto__:null,[xt]:vt,for:St,keyFor:St,prototype:At},SyntaxError:kt,toLocaleString:At,toString:At,TypeError:kt,Uint16Array:wt,Uint32Array:wt,Uint8Array:wt,Uint8ClampedArray:wt,unescape:St,URIError:kt,valueOf:At,WeakMap:kt,WeakSet:kt,clearInterval:Pt,clearTimeout:Pt,console:At,Intl:{__proto__:null,[xt]:bt,Collator:Ct,DateTimeFormat:Ct,ListFormat:Ct,NumberFormat:Ct,PluralRules:Ct,RelativeTimeFormat:Ct},setInterval:Pt,setTimeout:Pt,TextDecoder:Pt,TextEncoder:Pt,URL:Pt,URLSearchParams:Pt,AbortController:Pt,AbortSignal:Pt,addEventListener:At,alert:At,AnalyserNode:Pt,Animation:Pt,AnimationEvent:Pt,applicationCache:At,ApplicationCache:Pt,ApplicationCacheErrorEvent:Pt,atob:At,Attr:Pt,Audio:Pt,AudioBuffer:Pt,AudioBufferSourceNode:Pt,AudioContext:Pt,AudioDestinationNode:Pt,AudioListener:Pt,AudioNode:Pt,AudioParam:Pt,AudioProcessingEvent:Pt,AudioScheduledSourceNode:Pt,AudioWorkletNode:Pt,BarProp:Pt,BaseAudioContext:Pt,BatteryManager:Pt,BeforeUnloadEvent:Pt,BiquadFilterNode:Pt,Blob:Pt,BlobEvent:Pt,blur:At,BroadcastChannel:Pt,btoa:At,ByteLengthQueuingStrategy:Pt,Cache:Pt,caches:At,CacheStorage:Pt,cancelAnimationFrame:At,cancelIdleCallback:At,CanvasCaptureMediaStreamTrack:Pt,CanvasGradient:Pt,CanvasPattern:Pt,CanvasRenderingContext2D:Pt,ChannelMergerNode:Pt,ChannelSplitterNode:Pt,CharacterData:Pt,clientInformation:At,ClipboardEvent:Pt,close:At,closed:At,CloseEvent:Pt,Comment:Pt,CompositionEvent:Pt,confirm:At,ConstantSourceNode:Pt,ConvolverNode:Pt,CountQueuingStrategy:Pt,createImageBitmap:At,Credential:Pt,CredentialsContainer:Pt,crypto:At,Crypto:Pt,CryptoKey:Pt,CSS:Pt,CSSConditionRule:Pt,CSSFontFaceRule:Pt,CSSGroupingRule:Pt,CSSImportRule:Pt,CSSKeyframeRule:Pt,CSSKeyframesRule:Pt,CSSMediaRule:Pt,CSSNamespaceRule:Pt,CSSPageRule:Pt,CSSRule:Pt,CSSRuleList:Pt,CSSStyleDeclaration:Pt,CSSStyleRule:Pt,CSSStyleSheet:Pt,CSSSupportsRule:Pt,CustomElementRegistry:Pt,customElements:At,CustomEvent:Pt,DataTransfer:Pt,DataTransferItem:Pt,DataTransferItemList:Pt,defaultstatus:At,defaultStatus:At,DelayNode:Pt,DeviceMotionEvent:Pt,DeviceOrientationEvent:Pt,devicePixelRatio:At,dispatchEvent:At,document:At,Document:Pt,DocumentFragment:Pt,DocumentType:Pt,DOMError:Pt,DOMException:Pt,DOMImplementation:Pt,DOMMatrix:Pt,DOMMatrixReadOnly:Pt,DOMParser:Pt,DOMPoint:Pt,DOMPointReadOnly:Pt,DOMQuad:Pt,DOMRect:Pt,DOMRectReadOnly:Pt,DOMStringList:Pt,DOMStringMap:Pt,DOMTokenList:Pt,DragEvent:Pt,DynamicsCompressorNode:Pt,Element:Pt,ErrorEvent:Pt,Event:Pt,EventSource:Pt,EventTarget:Pt,external:At,fetch:At,File:Pt,FileList:Pt,FileReader:Pt,find:At,focus:At,FocusEvent:Pt,FontFace:Pt,FontFaceSetLoadEvent:Pt,FormData:Pt,frames:At,GainNode:Pt,Gamepad:Pt,GamepadButton:Pt,GamepadEvent:Pt,getComputedStyle:At,getSelection:At,HashChangeEvent:Pt,Headers:Pt,history:At,History:Pt,HTMLAllCollection:Pt,HTMLAnchorElement:Pt,HTMLAreaElement:Pt,HTMLAudioElement:Pt,HTMLBaseElement:Pt,HTMLBodyElement:Pt,HTMLBRElement:Pt,HTMLButtonElement:Pt,HTMLCanvasElement:Pt,HTMLCollection:Pt,HTMLContentElement:Pt,HTMLDataElement:Pt,HTMLDataListElement:Pt,HTMLDetailsElement:Pt,HTMLDialogElement:Pt,HTMLDirectoryElement:Pt,HTMLDivElement:Pt,HTMLDListElement:Pt,HTMLDocument:Pt,HTMLElement:Pt,HTMLEmbedElement:Pt,HTMLFieldSetElement:Pt,HTMLFontElement:Pt,HTMLFormControlsCollection:Pt,HTMLFormElement:Pt,HTMLFrameElement:Pt,HTMLFrameSetElement:Pt,HTMLHeadElement:Pt,HTMLHeadingElement:Pt,HTMLHRElement:Pt,HTMLHtmlElement:Pt,HTMLIFrameElement:Pt,HTMLImageElement:Pt,HTMLInputElement:Pt,HTMLLabelElement:Pt,HTMLLegendElement:Pt,HTMLLIElement:Pt,HTMLLinkElement:Pt,HTMLMapElement:Pt,HTMLMarqueeElement:Pt,HTMLMediaElement:Pt,HTMLMenuElement:Pt,HTMLMetaElement:Pt,HTMLMeterElement:Pt,HTMLModElement:Pt,HTMLObjectElement:Pt,HTMLOListElement:Pt,HTMLOptGroupElement:Pt,HTMLOptionElement:Pt,HTMLOptionsCollection:Pt,HTMLOutputElement:Pt,HTMLParagraphElement:Pt,HTMLParamElement:Pt,HTMLPictureElement:Pt,HTMLPreElement:Pt,HTMLProgressElement:Pt,HTMLQuoteElement:Pt,HTMLScriptElement:Pt,HTMLSelectElement:Pt,HTMLShadowElement:Pt,HTMLSlotElement:Pt,HTMLSourceElement:Pt,HTMLSpanElement:Pt,HTMLStyleElement:Pt,HTMLTableCaptionElement:Pt,HTMLTableCellElement:Pt,HTMLTableColElement:Pt,HTMLTableElement:Pt,HTMLTableRowElement:Pt,HTMLTableSectionElement:Pt,HTMLTemplateElement:Pt,HTMLTextAreaElement:Pt,HTMLTimeElement:Pt,HTMLTitleElement:Pt,HTMLTrackElement:Pt,HTMLUListElement:Pt,HTMLUnknownElement:Pt,HTMLVideoElement:Pt,IDBCursor:Pt,IDBCursorWithValue:Pt,IDBDatabase:Pt,IDBFactory:Pt,IDBIndex:Pt,IDBKeyRange:Pt,IDBObjectStore:Pt,IDBOpenDBRequest:Pt,IDBRequest:Pt,IDBTransaction:Pt,IDBVersionChangeEvent:Pt,IdleDeadline:Pt,IIRFilterNode:Pt,Image:Pt,ImageBitmap:Pt,ImageBitmapRenderingContext:Pt,ImageCapture:Pt,ImageData:Pt,indexedDB:At,innerHeight:At,innerWidth:At,InputEvent:Pt,IntersectionObserver:Pt,IntersectionObserverEntry:Pt,isSecureContext:At,KeyboardEvent:Pt,KeyframeEffect:Pt,length:At,localStorage:At,location:At,Location:Pt,locationbar:At,matchMedia:At,MediaDeviceInfo:Pt,MediaDevices:Pt,MediaElementAudioSourceNode:Pt,MediaEncryptedEvent:Pt,MediaError:Pt,MediaKeyMessageEvent:Pt,MediaKeySession:Pt,MediaKeyStatusMap:Pt,MediaKeySystemAccess:Pt,MediaList:Pt,MediaQueryList:Pt,MediaQueryListEvent:Pt,MediaRecorder:Pt,MediaSettingsRange:Pt,MediaSource:Pt,MediaStream:Pt,MediaStreamAudioDestinationNode:Pt,MediaStreamAudioSourceNode:Pt,MediaStreamEvent:Pt,MediaStreamTrack:Pt,MediaStreamTrackEvent:Pt,menubar:At,MessageChannel:Pt,MessageEvent:Pt,MessagePort:Pt,MIDIAccess:Pt,MIDIConnectionEvent:Pt,MIDIInput:Pt,MIDIInputMap:Pt,MIDIMessageEvent:Pt,MIDIOutput:Pt,MIDIOutputMap:Pt,MIDIPort:Pt,MimeType:Pt,MimeTypeArray:Pt,MouseEvent:Pt,moveBy:At,moveTo:At,MutationEvent:Pt,MutationObserver:Pt,MutationRecord:Pt,name:At,NamedNodeMap:Pt,NavigationPreloadManager:Pt,navigator:At,Navigator:Pt,NetworkInformation:Pt,Node:Pt,NodeFilter:At,NodeIterator:Pt,NodeList:Pt,Notification:Pt,OfflineAudioCompletionEvent:Pt,OfflineAudioContext:Pt,offscreenBuffering:At,OffscreenCanvas:Pt,open:At,openDatabase:At,Option:Pt,origin:At,OscillatorNode:Pt,outerHeight:At,outerWidth:At,PageTransitionEvent:Pt,pageXOffset:At,pageYOffset:At,PannerNode:Pt,parent:At,Path2D:Pt,PaymentAddress:Pt,PaymentRequest:Pt,PaymentRequestUpdateEvent:Pt,PaymentResponse:Pt,performance:At,Performance:Pt,PerformanceEntry:Pt,PerformanceLongTaskTiming:Pt,PerformanceMark:Pt,PerformanceMeasure:Pt,PerformanceNavigation:Pt,PerformanceNavigationTiming:Pt,PerformanceObserver:Pt,PerformanceObserverEntryList:Pt,PerformancePaintTiming:Pt,PerformanceResourceTiming:Pt,PerformanceTiming:Pt,PeriodicWave:Pt,Permissions:Pt,PermissionStatus:Pt,personalbar:At,PhotoCapabilities:Pt,Plugin:Pt,PluginArray:Pt,PointerEvent:Pt,PopStateEvent:Pt,postMessage:At,Presentation:Pt,PresentationAvailability:Pt,PresentationConnection:Pt,PresentationConnectionAvailableEvent:Pt,PresentationConnectionCloseEvent:Pt,PresentationConnectionList:Pt,PresentationReceiver:Pt,PresentationRequest:Pt,print:At,ProcessingInstruction:Pt,ProgressEvent:Pt,PromiseRejectionEvent:Pt,prompt:At,PushManager:Pt,PushSubscription:Pt,PushSubscriptionOptions:Pt,queueMicrotask:At,RadioNodeList:Pt,Range:Pt,ReadableStream:Pt,RemotePlayback:Pt,removeEventListener:At,Request:Pt,requestAnimationFrame:At,requestIdleCallback:At,resizeBy:At,ResizeObserver:Pt,ResizeObserverEntry:Pt,resizeTo:At,Response:Pt,RTCCertificate:Pt,RTCDataChannel:Pt,RTCDataChannelEvent:Pt,RTCDtlsTransport:Pt,RTCIceCandidate:Pt,RTCIceTransport:Pt,RTCPeerConnection:Pt,RTCPeerConnectionIceEvent:Pt,RTCRtpReceiver:Pt,RTCRtpSender:Pt,RTCSctpTransport:Pt,RTCSessionDescription:Pt,RTCStatsReport:Pt,RTCTrackEvent:Pt,screen:At,Screen:Pt,screenLeft:At,ScreenOrientation:Pt,screenTop:At,screenX:At,screenY:At,ScriptProcessorNode:Pt,scroll:At,scrollbars:At,scrollBy:At,scrollTo:At,scrollX:At,scrollY:At,SecurityPolicyViolationEvent:Pt,Selection:Pt,ServiceWorker:Pt,ServiceWorkerContainer:Pt,ServiceWorkerRegistration:Pt,sessionStorage:At,ShadowRoot:Pt,SharedWorker:Pt,SourceBuffer:Pt,SourceBufferList:Pt,speechSynthesis:At,SpeechSynthesisEvent:Pt,SpeechSynthesisUtterance:Pt,StaticRange:Pt,status:At,statusbar:At,StereoPannerNode:Pt,stop:At,Storage:Pt,StorageEvent:Pt,StorageManager:Pt,styleMedia:At,StyleSheet:Pt,StyleSheetList:Pt,SubtleCrypto:Pt,SVGAElement:Pt,SVGAngle:Pt,SVGAnimatedAngle:Pt,SVGAnimatedBoolean:Pt,SVGAnimatedEnumeration:Pt,SVGAnimatedInteger:Pt,SVGAnimatedLength:Pt,SVGAnimatedLengthList:Pt,SVGAnimatedNumber:Pt,SVGAnimatedNumberList:Pt,SVGAnimatedPreserveAspectRatio:Pt,SVGAnimatedRect:Pt,SVGAnimatedString:Pt,SVGAnimatedTransformList:Pt,SVGAnimateElement:Pt,SVGAnimateMotionElement:Pt,SVGAnimateTransformElement:Pt,SVGAnimationElement:Pt,SVGCircleElement:Pt,SVGClipPathElement:Pt,SVGComponentTransferFunctionElement:Pt,SVGDefsElement:Pt,SVGDescElement:Pt,SVGDiscardElement:Pt,SVGElement:Pt,SVGEllipseElement:Pt,SVGFEBlendElement:Pt,SVGFEColorMatrixElement:Pt,SVGFEComponentTransferElement:Pt,SVGFECompositeElement:Pt,SVGFEConvolveMatrixElement:Pt,SVGFEDiffuseLightingElement:Pt,SVGFEDisplacementMapElement:Pt,SVGFEDistantLightElement:Pt,SVGFEDropShadowElement:Pt,SVGFEFloodElement:Pt,SVGFEFuncAElement:Pt,SVGFEFuncBElement:Pt,SVGFEFuncGElement:Pt,SVGFEFuncRElement:Pt,SVGFEGaussianBlurElement:Pt,SVGFEImageElement:Pt,SVGFEMergeElement:Pt,SVGFEMergeNodeElement:Pt,SVGFEMorphologyElement:Pt,SVGFEOffsetElement:Pt,SVGFEPointLightElement:Pt,SVGFESpecularLightingElement:Pt,SVGFESpotLightElement:Pt,SVGFETileElement:Pt,SVGFETurbulenceElement:Pt,SVGFilterElement:Pt,SVGForeignObjectElement:Pt,SVGGElement:Pt,SVGGeometryElement:Pt,SVGGradientElement:Pt,SVGGraphicsElement:Pt,SVGImageElement:Pt,SVGLength:Pt,SVGLengthList:Pt,SVGLinearGradientElement:Pt,SVGLineElement:Pt,SVGMarkerElement:Pt,SVGMaskElement:Pt,SVGMatrix:Pt,SVGMetadataElement:Pt,SVGMPathElement:Pt,SVGNumber:Pt,SVGNumberList:Pt,SVGPathElement:Pt,SVGPatternElement:Pt,SVGPoint:Pt,SVGPointList:Pt,SVGPolygonElement:Pt,SVGPolylineElement:Pt,SVGPreserveAspectRatio:Pt,SVGRadialGradientElement:Pt,SVGRect:Pt,SVGRectElement:Pt,SVGScriptElement:Pt,SVGSetElement:Pt,SVGStopElement:Pt,SVGStringList:Pt,SVGStyleElement:Pt,SVGSVGElement:Pt,SVGSwitchElement:Pt,SVGSymbolElement:Pt,SVGTextContentElement:Pt,SVGTextElement:Pt,SVGTextPathElement:Pt,SVGTextPositioningElement:Pt,SVGTitleElement:Pt,SVGTransform:Pt,SVGTransformList:Pt,SVGTSpanElement:Pt,SVGUnitTypes:Pt,SVGUseElement:Pt,SVGViewElement:Pt,TaskAttributionTiming:Pt,Text:Pt,TextEvent:Pt,TextMetrics:Pt,TextTrack:Pt,TextTrackCue:Pt,TextTrackCueList:Pt,TextTrackList:Pt,TimeRanges:Pt,toolbar:At,top:At,Touch:Pt,TouchEvent:Pt,TouchList:Pt,TrackEvent:Pt,TransitionEvent:Pt,TreeWalker:Pt,UIEvent:Pt,ValidityState:Pt,visualViewport:At,VisualViewport:Pt,VTTCue:Pt,WaveShaperNode:Pt,WebAssembly:At,WebGL2RenderingContext:Pt,WebGLActiveInfo:Pt,WebGLBuffer:Pt,WebGLContextEvent:Pt,WebGLFramebuffer:Pt,WebGLProgram:Pt,WebGLQuery:Pt,WebGLRenderbuffer:Pt,WebGLRenderingContext:Pt,WebGLSampler:Pt,WebGLShader:Pt,WebGLShaderPrecisionFormat:Pt,WebGLSync:Pt,WebGLTexture:Pt,WebGLTransformFeedback:Pt,WebGLUniformLocation:Pt,WebGLVertexArrayObject:Pt,WebSocket:Pt,WheelEvent:Pt,Window:Pt,Worker:Pt,WritableStream:Pt,XMLDocument:Pt,XMLHttpRequest:Pt,XMLHttpRequestEventTarget:Pt,XMLHttpRequestUpload:Pt,XMLSerializer:Pt,XPathEvaluator:Pt,XPathExpression:Pt,XPathResult:Pt,XSLTProcessor:Pt};for(const e of["window","global","self","globalThis"])It[e]=It;function Nt(e){let t=It;for(const s of e){if("string"!=typeof s)return null;if(t=t[s],!t)return null}return t[xt]}class _t extends H{constructor(){super(...arguments),this.isReassigned=!0}hasEffectsWhenAccessedAtPath(e){return!function(e){return 1===e.length?"undefined"===e[0]||null!==Nt(e):null!==Nt(e.slice(0,-1))}([this.name,...e])}hasEffectsWhenCalledAtPath(e){return!function(e){const t=Nt(e);return null!==t&&t.pure}([this.name,...e])}}const $t={__proto__:null,class:!0,const:!0,let:!0,var:!0};class Tt extends De{constructor(){super(...arguments),this.variable=null,this.deoptimized=!1,this.isTDZAccess=null}addExportedVariables(e,t){null!==this.variable&&t.has(this.variable)&&e.push(this.variable)}bind(){null===this.variable&&Et(this,this.parent)&&(this.variable=this.scope.findVariable(this.name),this.variable.addReference(this))}declare(e,t){let s;const{treeshake:i}=this.context.options;switch(e){case"var":s=this.scope.addDeclaration(this,this.context,t,!0),i&&i.correctVarValueBeforeDeclaration&&s.markInitializersForDeoptimization();break;case"function":case"let":case"const":case"class":s=this.scope.addDeclaration(this,this.context,t,!1);break;case"parameter":s=this.scope.addParameterDeclaration(this);break;default:throw new Error(`Internal Error: Unexpected identifier kind ${e}.`)}return s.kind=e,[this.variable=s]}deoptimizePath(e){0!==e.length||this.scope.contains(this.name)||this.disallowImportReassignment(),this.variable.deoptimizePath(e)}deoptimizeThisOnEventAtPath(e,t,s,i){this.variable.deoptimizeThisOnEventAtPath(e,t,s,i)}getLiteralValueAtPath(e,t,s){return this.getVariableRespectingTDZ().getLiteralValueAtPath(e,t,s)}getReturnExpressionWhenCalledAtPath(e,t,s,i){return this.getVariableRespectingTDZ().getReturnExpressionWhenCalledAtPath(e,t,s,i)}hasEffects(){return this.deoptimized||this.applyDeoptimizations(),!(!this.isPossibleTDZ()||"var"===this.variable.kind)||this.context.options.treeshake.unknownGlobalSideEffects&&this.variable instanceof _t&&this.variable.hasEffectsWhenAccessedAtPath(O)}hasEffectsWhenAccessedAtPath(e,t){return null!==this.variable&&this.getVariableRespectingTDZ().hasEffectsWhenAccessedAtPath(e,t)}hasEffectsWhenAssignedAtPath(e,t){return!this.variable||(e.length>0?this.getVariableRespectingTDZ():this.variable).hasEffectsWhenAssignedAtPath(e,t)}hasEffectsWhenCalledAtPath(e,t,s){return!this.variable||this.getVariableRespectingTDZ().hasEffectsWhenCalledAtPath(e,t,s)}include(){this.deoptimized||this.applyDeoptimizations(),this.included||(this.included=!0,null!==this.variable&&this.context.includeVariableInModule(this.variable))}includeCallArguments(e,t){this.getVariableRespectingTDZ().includeCallArguments(e,t)}isPossibleTDZ(){if(null!==this.isTDZAccess)return this.isTDZAccess;if(!(this.variable instanceof mt&&this.variable.kind&&this.variable.kind in $t))return this.isTDZAccess=!1;let e;return this.variable.declarations&&1===this.variable.declarations.length&&(e=this.variable.declarations[0])&&this.start<e.start&&Rt(this)===Rt(e)?this.isTDZAccess=!0:this.variable.initReached?this.isTDZAccess=!1:this.isTDZAccess=!0}markDeclarationReached(){this.variable.initReached=!0}render(e,{snippets:{getPropertyAccess:t}},{renderedParentType:s,isCalleeOfRenderedParent:i,isShorthandProperty:n}=K){if(this.variable){const r=this.variable.getName(t);r!==this.name&&(e.overwrite(this.start,this.end,r,{contentOnly:!0,storeName:!0}),n&&e.prependRight(this.start,`${this.name}: `)),"eval"===r&&s===Ee&&i&&e.appendRight(this.start,"0, ")}}applyDeoptimizations(){this.deoptimized=!0,null!==this.variable&&this.variable instanceof mt&&(this.variable.consolidateInitializers(),this.context.requestTreeshakingPass())}disallowImportReassignment(){return this.context.error({code:"ILLEGAL_REASSIGNMENT",message:`Illegal reassignment to import '${this.name}'`},this.start)}getVariableRespectingTDZ(){return this.isPossibleTDZ()?G:this.variable}}function Rt(e){for(;e&&!/^Program|Function/.test(e.type);)e=e.parent;return e}class Mt extends De{constructor(){super(...arguments),this.accessedValue=null,this.accessorCallOptions={args:Je,thisParam:null,withNew:!1}}deoptimizeCache(){}deoptimizePath(e){this.getAccessedValue().deoptimizePath(e)}deoptimizeThisOnEventAtPath(e,t,s,i){return 0===e&&"get"===this.kind&&0===t.length||1===e&&"set"===this.kind&&0===t.length?this.value.deoptimizeThisOnEventAtPath(2,O,s,i):void this.getAccessedValue().deoptimizeThisOnEventAtPath(e,t,s,i)}getLiteralValueAtPath(e,t,s){return this.getAccessedValue().getLiteralValueAtPath(e,t,s)}getReturnExpressionWhenCalledAtPath(e,t,s,i){return this.getAccessedValue().getReturnExpressionWhenCalledAtPath(e,t,s,i)}hasEffects(e){return this.key.hasEffects(e)}hasEffectsWhenAccessedAtPath(e,t){return"get"===this.kind&&0===e.length?this.value.hasEffectsWhenCalledAtPath(O,this.accessorCallOptions,t):this.getAccessedValue().hasEffectsWhenAccessedAtPath(e,t)}hasEffectsWhenAssignedAtPath(e,t){return"set"===this.kind?this.value.hasEffectsWhenCalledAtPath(O,this.accessorCallOptions,t):this.getAccessedValue().hasEffectsWhenAssignedAtPath(e,t)}hasEffectsWhenCalledAtPath(e,t,s){return this.getAccessedValue().hasEffectsWhenCalledAtPath(e,t,s)}getAccessedValue(){return null===this.accessedValue?"get"===this.kind?(this.accessedValue=G,this.accessedValue=this.value.getReturnExpressionWhenCalledAtPath(O,this.accessorCallOptions,z,this)):this.accessedValue=this.value:this.accessedValue}}class Dt extends Mt{}const Ot=/^\d+$/;class Lt extends U{constructor(e,t,s=!1){if(super(),this.prototypeExpression=t,this.immutable=s,this.allProperties=[],this.deoptimizedPaths=Object.create(null),this.expressionsToBeDeoptimizedByKey=Object.create(null),this.gettersByKey=Object.create(null),this.hasUnknownDeoptimizedInteger=!1,this.hasUnknownDeoptimizedProperty=!1,this.propertiesAndGettersByKey=Object.create(null),this.propertiesAndSettersByKey=Object.create(null),this.settersByKey=Object.create(null),this.thisParametersToBeDeoptimized=new Set,this.unknownIntegerProps=[],this.unmatchableGetters=[],this.unmatchablePropertiesAndGetters=[],this.unmatchableSetters=[],Array.isArray(e))this.buildPropertyMaps(e);else{this.propertiesAndGettersByKey=this.propertiesAndSettersByKey=e;for(const t of Object.values(e))this.allProperties.push(...t)}}deoptimizeAllProperties(){var e;if(!this.hasUnknownDeoptimizedProperty){this.hasUnknownDeoptimizedProperty=!0;for(const e of Object.values(this.propertiesAndGettersByKey).concat(Object.values(this.settersByKey)))for(const t of e)t.deoptimizePath(L);null===(e=this.prototypeExpression)||void 0===e||e.deoptimizePath([M,M]),this.deoptimizeCachedEntities()}}deoptimizeIntegerProperties(){if(!this.hasUnknownDeoptimizedProperty&&!this.hasUnknownDeoptimizedInteger){this.hasUnknownDeoptimizedInteger=!0;for(const[e,t]of Object.entries(this.propertiesAndGettersByKey))if(Ot.test(e))for(const e of t)e.deoptimizePath(L);this.deoptimizeCachedIntegerEntities()}}deoptimizePath(e){var t;if(this.hasUnknownDeoptimizedProperty||this.immutable)return;const s=e[0];if(1===e.length){if("string"!=typeof s)return s===D?this.deoptimizeIntegerProperties():this.deoptimizeAllProperties();if(!this.deoptimizedPaths[s]){this.deoptimizedPaths[s]=!0;const e=this.expressionsToBeDeoptimizedByKey[s];if(e)for(const t of e)t.deoptimizeCache()}}const i=1===e.length?L:e.slice(1);for(const e of"string"==typeof s?(this.propertiesAndGettersByKey[s]||this.unmatchablePropertiesAndGetters).concat(this.settersByKey[s]||this.unmatchableSetters):this.allProperties)e.deoptimizePath(i);null===(t=this.prototypeExpression)||void 0===t||t.deoptimizePath(1===e.length?[M,M]:e)}deoptimizeThisOnEventAtPath(e,t,s,i){var n;const[r,...a]=t;if(this.hasUnknownDeoptimizedProperty||(2===e||t.length>1)&&"string"==typeof r&&this.deoptimizedPaths[r])return void s.deoptimizePath(L);const[o,h,l]=2===e||t.length>1?[this.propertiesAndGettersByKey,this.propertiesAndGettersByKey,this.unmatchablePropertiesAndGetters]:0===e?[this.propertiesAndGettersByKey,this.gettersByKey,this.unmatchableGetters]:[this.propertiesAndSettersByKey,this.settersByKey,this.unmatchableSetters];if("string"==typeof r){if(o[r]){const t=h[r];if(t)for(const n of t)n.deoptimizeThisOnEventAtPath(e,a,s,i);return void(this.immutable||this.thisParametersToBeDeoptimized.add(s))}for(const t of l)t.deoptimizeThisOnEventAtPath(e,a,s,i);if(Ot.test(r))for(const t of this.unknownIntegerProps)t.deoptimizeThisOnEventAtPath(e,a,s,i)}else{for(const t of Object.values(h).concat([l]))for(const n of t)n.deoptimizeThisOnEventAtPath(e,a,s,i);for(const t of this.unknownIntegerProps)t.deoptimizeThisOnEventAtPath(e,a,s,i)}this.immutable||this.thisParametersToBeDeoptimized.add(s),null===(n=this.prototypeExpression)||void 0===n||n.deoptimizeThisOnEventAtPath(e,t,s,i)}getLiteralValueAtPath(e,t,s){if(0===e.length)return j;const i=e[0],n=this.getMemberExpressionAndTrackDeopt(i,s);return n?n.getLiteralValueAtPath(e.slice(1),t,s):this.prototypeExpression?this.prototypeExpression.getLiteralValueAtPath(e,t,s):1!==e.length?j:void 0}getReturnExpressionWhenCalledAtPath(e,t,s,i){if(0===e.length)return G;const n=e[0],r=this.getMemberExpressionAndTrackDeopt(n,i);return r?r.getReturnExpressionWhenCalledAtPath(e.slice(1),t,s,i):this.prototypeExpression?this.prototypeExpression.getReturnExpressionWhenCalledAtPath(e,t,s,i):G}hasEffectsWhenAccessedAtPath(e,t){const[s,...i]=e;if(e.length>1){if("string"!=typeof s)return!0;const n=this.getMemberExpression(s);return n?n.hasEffectsWhenAccessedAtPath(i,t):!this.prototypeExpression||this.prototypeExpression.hasEffectsWhenAccessedAtPath(e,t)}if(this.hasUnknownDeoptimizedProperty)return!0;if("string"==typeof s){if(this.propertiesAndGettersByKey[s]){const e=this.gettersByKey[s];if(e)for(const s of e)if(s.hasEffectsWhenAccessedAtPath(i,t))return!0;return!1}for(const e of this.unmatchableGetters)if(e.hasEffectsWhenAccessedAtPath(i,t))return!0}else for(const e of Object.values(this.gettersByKey).concat([this.unmatchableGetters]))for(const s of e)if(s.hasEffectsWhenAccessedAtPath(i,t))return!0;return!!this.prototypeExpression&&this.prototypeExpression.hasEffectsWhenAccessedAtPath(e,t)}hasEffectsWhenAssignedAtPath(e,t){const[s,...i]=e;if(e.length>1){if("string"!=typeof s)return!0;const n=this.getMemberExpression(s);return n?n.hasEffectsWhenAssignedAtPath(i,t):!this.prototypeExpression||this.prototypeExpression.hasEffectsWhenAssignedAtPath(e,t)}if(this.hasUnknownDeoptimizedProperty)return!0;if("string"==typeof s){if(this.propertiesAndSettersByKey[s]){const e=this.settersByKey[s];if(e)for(const s of e)if(s.hasEffectsWhenAssignedAtPath(i,t))return!0;return!1}for(const e of this.unmatchableSetters)if(e.hasEffectsWhenAssignedAtPath(i,t))return!0}return!!this.prototypeExpression&&this.prototypeExpression.hasEffectsWhenAssignedAtPath(e,t)}hasEffectsWhenCalledAtPath(e,t,s){const i=e[0],n=this.getMemberExpression(i);return n?n.hasEffectsWhenCalledAtPath(e.slice(1),t,s):!this.prototypeExpression||this.prototypeExpression.hasEffectsWhenCalledAtPath(e,t,s)}buildPropertyMaps(e){const{allProperties:t,propertiesAndGettersByKey:s,propertiesAndSettersByKey:i,settersByKey:n,gettersByKey:r,unknownIntegerProps:a,unmatchablePropertiesAndGetters:o,unmatchableGetters:h,unmatchableSetters:l}=this,c=[];for(let u=e.length-1;u>=0;u--){const{key:d,kind:p,property:f}=e[u];if(t.push(f),"string"!=typeof d){if(d===D){a.push(f);continue}"set"===p&&l.push(f),"get"===p&&h.push(f),"get"!==p&&c.push(f),"set"!==p&&o.push(f)}else"set"===p?i[d]||(i[d]=[f,...c],n[d]=[f,...l]):"get"===p?s[d]||(s[d]=[f,...o],r[d]=[f,...h]):(i[d]||(i[d]=[f,...c]),s[d]||(s[d]=[f,...o]))}}deoptimizeCachedEntities(){for(const e of Object.values(this.expressionsToBeDeoptimizedByKey))for(const t of e)t.deoptimizeCache();for(const e of this.thisParametersToBeDeoptimized)e.deoptimizePath(L)}deoptimizeCachedIntegerEntities(){for(const[e,t]of Object.entries(this.expressionsToBeDeoptimizedByKey))if(Ot.test(e))for(const e of t)e.deoptimizeCache();for(const e of this.thisParametersToBeDeoptimized)e.deoptimizePath(V)}getMemberExpression(e){if(this.hasUnknownDeoptimizedProperty||"string"!=typeof e||this.hasUnknownDeoptimizedInteger&&Ot.test(e)||this.deoptimizedPaths[e])return G;const t=this.propertiesAndGettersByKey[e];return 1===(null==t?void 0:t.length)?t[0]:t||this.unmatchablePropertiesAndGetters.length>0||this.unknownIntegerProps.length&&Ot.test(e)?G:null}getMemberExpressionAndTrackDeopt(e,t){if("string"!=typeof e)return G;const s=this.getMemberExpression(e);return s===G||this.immutable||(this.expressionsToBeDeoptimizedByKey[e]=this.expressionsToBeDeoptimizedByKey[e]||[]).push(t),s}}class Vt extends U{constructor(e,t){super(),this.object=e,this.key=t}deoptimizePath(e){this.object.deoptimizePath([this.key,...e])}deoptimizeThisOnEventAtPath(e,t,s,i){this.object.deoptimizeThisOnEventAtPath(e,[this.key,...t],s,i)}getLiteralValueAtPath(e,t,s){return this.object.getLiteralValueAtPath([this.key,...e],t,s)}getReturnExpressionWhenCalledAtPath(e,t,s,i){return this.object.getReturnExpressionWhenCalledAtPath([this.key,...e],t,s,i)}hasEffectsWhenAccessedAtPath(e,t){return 0!==e.length&&this.object.hasEffectsWhenAccessedAtPath([this.key,...e],t)}hasEffectsWhenAssignedAtPath(e,t){return this.object.hasEffectsWhenAssignedAtPath([this.key,...e],t)}hasEffectsWhenCalledAtPath(e,t,s){return this.object.hasEffectsWhenCalledAtPath([this.key,...e],t,s)}}class Bt extends U{constructor(e){super(),this.description=e}deoptimizeThisOnEventAtPath(e,t,s){2===e&&0===t.length&&this.description.mutatesSelfAsArray&&s.deoptimizePath(V)}getReturnExpressionWhenCalledAtPath(e,t){return e.length>0?G:this.description.returnsPrimitive||("self"===this.description.returns?t.thisParam||G:this.description.returns())}hasEffectsWhenAccessedAtPath(e){return e.length>1}hasEffectsWhenAssignedAtPath(e){return e.length>0}hasEffectsWhenCalledAtPath(e,t,s){var i,n;if(e.length>0||!0===this.description.mutatesSelfAsArray&&(null===(i=t.thisParam)||void 0===i?void 0:i.hasEffectsWhenAssignedAtPath(V,s)))return!0;if(!this.description.callsArgs)return!1;for(const e of this.description.callsArgs)if(null===(n=t.args[e])||void 0===n?void 0:n.hasEffectsWhenCalledAtPath(O,{args:Je,thisParam:null,withNew:!1},s))return!0;return!1}includeCallArguments(e,t){for(const s of t)s.include(e,!1)}}const Ft=[new Bt({callsArgs:null,mutatesSelfAsArray:!1,returns:null,returnsPrimitive:it})],zt=[new Bt({callsArgs:null,mutatesSelfAsArray:!1,returns:null,returnsPrimitive:ot})],Wt=[new Bt({callsArgs:null,mutatesSelfAsArray:!1,returns:null,returnsPrimitive:rt})],jt=[new Bt({callsArgs:null,mutatesSelfAsArray:!1,returns:null,returnsPrimitive:G})],Ut=new Lt({__proto__:null,hasOwnProperty:Ft,isPrototypeOf:Ft,propertyIsEnumerable:Ft,toLocaleString:zt,toString:zt,valueOf:jt},null,!0);class Gt extends De{constructor(){super(...arguments),this.objectEntity=null}createScope(e){this.scope=new yt(e)}deoptimizeCache(){this.getObjectEntity().deoptimizeAllProperties()}deoptimizePath(e){this.getObjectEntity().deoptimizePath(e)}deoptimizeThisOnEventAtPath(e,t,s,i){this.getObjectEntity().deoptimizeThisOnEventAtPath(e,t,s,i)}getLiteralValueAtPath(e,t,s){return this.getObjectEntity().getLiteralValueAtPath(e,t,s)}getReturnExpressionWhenCalledAtPath(e,t,s,i){return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(e,t,s,i)}hasEffects(e){var t,s;const i=(null===(t=this.superClass)||void 0===t?void 0:t.hasEffects(e))||this.body.hasEffects(e);return null===(s=this.id)||void 0===s||s.markDeclarationReached(),i||super.hasEffects(e)}hasEffectsWhenAccessedAtPath(e,t){return this.getObjectEntity().hasEffectsWhenAccessedAtPath(e,t)}hasEffectsWhenAssignedAtPath(e,t){return this.getObjectEntity().hasEffectsWhenAssignedAtPath(e,t)}hasEffectsWhenCalledAtPath(e,t,s){return 0===e.length?!t.withNew||(null!==this.classConstructor?this.classConstructor.hasEffectsWhenCalledAtPath(O,t,s):null!==this.superClass&&this.superClass.hasEffectsWhenCalledAtPath(e,t,s)):this.getObjectEntity().hasEffectsWhenCalledAtPath(e,t,s)}include(e,t){var s;this.included=!0,null===(s=this.superClass)||void 0===s||s.include(e,t),this.body.include(e,t),this.id&&(this.id.markDeclarationReached(),this.id.include())}initialise(){var e;null===(e=this.id)||void 0===e||e.declare("class",this);for(const e of this.body.body)if(e instanceof Dt&&"constructor"===e.kind)return void(this.classConstructor=e);this.classConstructor=null}getObjectEntity(){if(null!==this.objectEntity)return this.objectEntity;const e=[],t=[];for(const s of this.body.body){const i=s.static?e:t,n=s.kind;if(i===t&&!n)continue;const r="set"===n||"get"===n?n:"init";let a;if(s.computed){const e=s.key.getLiteralValueAtPath(O,z,this);if(e===j){i.push({key:M,kind:r,property:s});continue}a=String(e)}else a=s.key instanceof Tt?s.key.name:String(s.key.value);i.push({key:a,kind:r,property:s})}return e.unshift({key:"prototype",kind:"init",property:new Lt(t,this.superClass?new Vt(this.superClass,"prototype"):Ut)}),this.objectEntity=new Lt(e,this.superClass||Ut)}}class Ht extends Gt{initialise(){super.initialise(),null!==this.id&&(this.id.variable.isId=!0)}parseNode(e){null!==e.id&&(this.id=new this.context.nodeConstructors.Identifier(e.id,this,this.scope.parent)),super.parseNode(e)}render(e,t){const{exportNamesByVariable:s,format:i,snippets:{_:n}}=t;"system"===i&&this.id&&s.has(this.id.variable)&&e.appendLeft(this.end,`${n}${qe([this.id.variable],t)};`),super.render(e,t)}}class qt extends mt{constructor(e){super("arguments",null,G,e)}hasEffectsWhenAccessedAtPath(e){return e.length>1}hasEffectsWhenAssignedAtPath(){return!0}hasEffectsWhenCalledAtPath(){return!0}}class Kt extends mt{constructor(e){super("this",null,null,e),this.deoptimizedPaths=[],this.entitiesToBeDeoptimized=new Set,this.thisDeoptimizationList=[],this.thisDeoptimizations=new W}addEntityToBeDeoptimized(e){for(const t of this.deoptimizedPaths)e.deoptimizePath(t);for(const t of this.thisDeoptimizationList)this.applyThisDeoptimizationEvent(e,t);this.entitiesToBeDeoptimized.add(e)}deoptimizePath(e){if(0!==e.length&&!this.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(e,this)){this.deoptimizedPaths.push(e);for(const t of this.entitiesToBeDeoptimized)t.deoptimizePath(e)}}deoptimizeThisOnEventAtPath(e,t,s){const i={event:e,path:t,thisParameter:s};if(!this.thisDeoptimizations.trackEntityAtPathAndGetIfTracked(t,e,s)){for(const e of this.entitiesToBeDeoptimized)this.applyThisDeoptimizationEvent(e,i);this.thisDeoptimizationList.push(i)}}hasEffectsWhenAccessedAtPath(e,t){return this.getInit(t).hasEffectsWhenAccessedAtPath(e,t)||super.hasEffectsWhenAccessedAtPath(e,t)}hasEffectsWhenAssignedAtPath(e,t){return this.getInit(t).hasEffectsWhenAssignedAtPath(e,t)||super.hasEffectsWhenAssignedAtPath(e,t)}applyThisDeoptimizationEvent(e,{event:t,path:s,thisParameter:i}){e.deoptimizeThisOnEventAtPath(t,s,i===this?e:i,z)}getInit(e){return e.replacedVariableInits.get(this)||G}}class Xt extends De{constructor(){super(...arguments),this.deoptimized=!1}deoptimizeThisOnEventAtPath(e,t,s,i){t.length>0&&this.argument.deoptimizeThisOnEventAtPath(e,[M,...t],s,i)}hasEffects(e){this.deoptimized||this.applyDeoptimizations();const{propertyReadSideEffects:t}=this.context.options.treeshake;return this.argument.hasEffects(e)||t&&("always"===t||this.argument.hasEffectsWhenAccessedAtPath(L,e))}applyDeoptimizations(){this.deoptimized=!0,this.argument.deoptimizePath([M,M]),this.context.requestTreeshakingPass()}}class Yt extends yt{constructor(e,t){super(e),this.parameters=[],this.hasRest=!1,this.context=t,this.hoistedBodyVarScope=new yt(this)}addParameterDeclaration(e){const t=e.name;let s=this.hoistedBodyVarScope.variables.get(t);return s?s.addDeclaration(e,null):s=new mt(t,e,G,this.context),this.variables.set(t,s),s}addParameterVariables(e,t){this.parameters=e;for(const t of e)for(const e of t)e.alwaysRendered=!0;this.hasRest=t}includeCallArguments(e,t){let s=!1,i=!1;const n=this.hasRest&&this.parameters[this.parameters.length-1];for(const s of t)if(s instanceof Xt){for(const s of t)s.include(e,!1);break}for(let r=t.length-1;r>=0;r--){const a=this.parameters[r]||n,o=t[r];if(a)if(s=!1,0===a.length)i=!0;else for(const e of a)e.included&&(i=!0),e.calledFromTryStatement&&(s=!0);!i&&o.shouldBeIncluded(e)&&(i=!0),i&&o.include(e,s)}}}class Qt extends Yt{constructor(){super(...arguments),this.returnExpression=null,this.returnExpressions=[]}addReturnExpression(e){this.returnExpressions.push(e)}getReturnExpression(){return null===this.returnExpression&&this.updateReturnExpression(),this.returnExpression}updateReturnExpression(){if(1===this.returnExpressions.length)this.returnExpression=this.returnExpressions[0];else{this.returnExpression=G;for(const e of this.returnExpressions)e.deoptimizePath(L)}}}class Zt extends Qt{constructor(e,t){super(e,t),this.variables.set("arguments",this.argumentsVariable=new qt(t)),this.variables.set("this",this.thisVariable=new Kt(t))}findLexicalBoundary(){return this}includeCallArguments(e,t){if(super.includeCallArguments(e,t),this.argumentsVariable.included)for(const s of t)s.included||s.include(e,!1)}}class Jt extends De{constructor(){super(...arguments),this.deoptimized=!1,this.declarationInit=null}addExportedVariables(e,t){this.argument.addExportedVariables(e,t)}declare(e,t){return this.declarationInit=t,this.argument.declare(e,G)}deoptimizePath(e){0===e.length&&this.argument.deoptimizePath(O)}hasEffectsWhenAssignedAtPath(e,t){return e.length>0||this.argument.hasEffectsWhenAssignedAtPath(O,t)}markDeclarationReached(){this.argument.markDeclarationReached()}applyDeoptimizations(){this.deoptimized=!0,null!==this.declarationInit&&(this.declarationInit.deoptimizePath([M,M]),this.context.requestTreeshakingPass())}}class es extends De{constructor(){super(...arguments),this.deoptimizedReturn=!1,this.isPrototypeDeoptimized=!1}createScope(e){this.scope=new Zt(e,this.context)}deoptimizePath(e){1===e.length&&("prototype"===e[0]?this.isPrototypeDeoptimized=!0:e[0]===M&&(this.isPrototypeDeoptimized=!0,this.scope.getReturnExpression().deoptimizePath(L)))}deoptimizeThisOnEventAtPath(e,t,s){2===e&&(t.length>0?s.deoptimizePath(L):this.scope.thisVariable.addEntityToBeDeoptimized(s))}getReturnExpressionWhenCalledAtPath(e){return 0!==e.length?G:this.async?(this.deoptimizedReturn||(this.deoptimizedReturn=!0,this.scope.getReturnExpression().deoptimizePath(L),this.context.requestTreeshakingPass()),G):this.scope.getReturnExpression()}hasEffects(){return null!==this.id&&this.id.hasEffects()}hasEffectsWhenAccessedAtPath(e){return!(e.length<=1)&&(e.length>2||"prototype"!==e[0]||this.isPrototypeDeoptimized)}hasEffectsWhenAssignedAtPath(e){return!(e.length<=1)&&(e.length>2||"prototype"!==e[0]||this.isPrototypeDeoptimized)}hasEffectsWhenCalledAtPath(e,t,s){if(e.length>0)return!0;if(this.async){const{propertyReadSideEffects:e}=this.context.options.treeshake,t=this.scope.getReturnExpression();if(t.hasEffectsWhenCalledAtPath(["then"],{args:Je,thisParam:null,withNew:!1},s)||e&&("always"===e||t.hasEffectsWhenAccessedAtPath(["then"],s)))return!0}for(const e of this.params)if(e.hasEffects(s))return!0;const i=s.replacedVariableInits.get(this.scope.thisVariable);s.replacedVariableInits.set(this.scope.thisVariable,t.withNew?new Lt(Object.create(null),Ut):G);const{brokenFlow:n,ignore:r}=s;return s.ignore={breaks:!1,continues:!1,labels:new Set,returnYield:!0},!!this.body.hasEffects(s)||(s.brokenFlow=n,i?s.replacedVariableInits.set(this.scope.thisVariable,i):s.replacedVariableInits.delete(this.scope.thisVariable),s.ignore=r,!1)}include(e,t){this.included=!0,this.id&&this.id.include();const s=this.scope.argumentsVariable.included;for(const i of this.params)i instanceof Tt&&!s||i.include(e,t);const{brokenFlow:i}=e;e.brokenFlow=0,this.body.include(e,t),e.brokenFlow=i}includeCallArguments(e,t){this.scope.includeCallArguments(e,t)}initialise(){null!==this.id&&this.id.declare("function",this),this.scope.addParameterVariables(this.params.map((e=>e.declare("parameter",G))),this.params[this.params.length-1]instanceof Jt),this.body.addImplicitReturnExpressionToScope()}parseNode(e){this.body=new this.context.nodeConstructors.BlockStatement(e.body,this,this.scope.hoistedBodyVarScope),super.parseNode(e)}}es.prototype.preventChildBlockScope=!0;class ts extends es{initialise(){super.initialise(),null!==this.id&&(this.id.variable.isId=!0)}parseNode(e){null!==e.id&&(this.id=new this.context.nodeConstructors.Identifier(e.id,this,this.scope.parent)),super.parseNode(e)}}class ss extends De{include(e,t){super.include(e,t),t&&this.context.includeVariableInModule(this.variable)}initialise(){const e=this.declaration;this.declarationName=e.id&&e.id.name||this.declaration.name,this.variable=this.scope.addExportDefaultDeclaration(this.declarationName||this.context.getModuleName(),this,this.context),this.context.addExport(this)}render(e,t,s){const{start:i,end:n}=s,r=function(e,t){return We(e,Fe(e,"default",t)+7)}(e.original,this.start);if(this.declaration instanceof ts)this.renderNamedDeclaration(e,r,"function","(",null===this.declaration.id,t);else if(this.declaration instanceof Ht)this.renderNamedDeclaration(e,r,"class","{",null===this.declaration.id,t);else{if(this.variable.getOriginalVariable()!==this.variable)return void Le(this,e,i,n);if(!this.variable.included)return e.remove(this.start,r),this.declaration.render(e,t,{renderedSurroundingElement:xe}),void(";"!==e.original[this.end-1]&&e.appendLeft(this.end,";"));this.renderVariableDeclaration(e,r,t)}this.declaration.render(e,t)}renderNamedDeclaration(e,t,s,i,n,r){const{exportNamesByVariable:a,format:o,snippets:{getPropertyAccess:h}}=r,l=this.variable.getName(h);e.remove(this.start,t),n&&e.appendLeft(function(e,t,s,i){const n=Fe(e,t,i)+t.length;e=e.slice(n,Fe(e,s,n));const r=Fe(e,"*");return-1===r?n:n+r+1}(e.original,s,i,t),` ${l}`),"system"===o&&this.declaration instanceof Ht&&a.has(this.variable)&&e.appendLeft(this.end,` ${qe([this.variable],r)};`)}renderVariableDeclaration(e,t,{format:s,exportNamesByVariable:i,snippets:{cnst:n,getPropertyAccess:r}}){const a=59===e.original.charCodeAt(this.end-1),o="system"===s&&i.get(this.variable);o?(e.overwrite(this.start,t,`${n} ${this.variable.getName(r)} = exports('${o[0]}', `),e.appendRight(a?this.end-1:this.end,")"+(a?"":";"))):(e.overwrite(this.start,t,`${n} ${this.variable.getName(r)} = `),a||e.appendLeft(this.end,";"))}}ss.prototype.needsBoundaries=!0;class is extends De{deoptimizeThisOnEventAtPath(){}getLiteralValueAtPath(e){return e.length>0||null===this.value&&110!==this.context.code.charCodeAt(this.start)||"bigint"==typeof this.value||47===this.context.code.charCodeAt(this.start)?j:this.value}getReturnExpressionWhenCalledAtPath(e){return 1!==e.length?G:ft(this.members,e[0])}hasEffectsWhenAccessedAtPath(e){return null===this.value?e.length>0:e.length>1}hasEffectsWhenAssignedAtPath(e){return e.length>0}hasEffectsWhenCalledAtPath(e,t,s){return 1!==e.length||pt(this.members,e[0],t,s)}initialise(){this.members=function(e){switch(typeof e){case"boolean":return ct;case"number":return ut;case"string":return dt;default:return Object.create(null)}}(this.value)}parseNode(e){this.value=e.value,this.regex=e.regex,super.parseNode(e)}render(e){"string"==typeof this.value&&e.indentExclusionRanges.push([this.start+1,this.end-1])}}class ns extends De{constructor(){super(...arguments),this.hasCachedEffect=!1}hasEffects(e){if(this.hasCachedEffect)return!0;for(const t of this.body)if(t.hasEffects(e))return this.hasCachedEffect=!0;return!1}include(e,t){this.included=!0;for(const s of this.body)(t||s.shouldBeIncluded(e))&&s.include(e,t)}render(e,t){this.body.length?Ue(this.body,e,this.start,this.end,t):super.render(e,t)}}class rs extends De{getLiteralValueAtPath(e){return e.length>0||1!==this.quasis.length?j:this.quasis[0].value.cooked}render(e,t){e.indentExclusionRanges.push([this.start,this.end]),super.render(e,t)}}function as(e,t){return null!==e.renderBaseName&&t.has(e)&&e.isReassigned}class os extends De{deoptimizePath(){for(const e of this.declarations)e.deoptimizePath(O)}hasEffectsWhenAssignedAtPath(){return!1}include(e,t){this.included=!0;for(const s of this.declarations)(t||s.shouldBeIncluded(e))&&s.include(e,t)}includeAsSingleStatement(e,t){this.included=!0;for(const s of this.declarations)(t||s.shouldBeIncluded(e))&&(s.include(e,t),s.id.include(e,t))}initialise(){for(const e of this.declarations)e.declareDeclarator(this.kind)}render(e,t,s=K){if(function(e,t){for(const s of e){if(!s.id.included)return!1;if(s.id.type===ve){if(t.has(s.id.variable))return!1}else{const e=[];if(s.id.addExportedVariables(e,t),e.length>0)return!1}}return!0}(this.declarations,t.exportNamesByVariable)){for(const s of this.declarations)s.render(e,t);s.isNoStatement||59===e.original.charCodeAt(this.end-1)||e.appendLeft(this.end,";")}else this.renderReplacedDeclarations(e,t,s)}renderDeclarationEnd(e,t,s,i,n,r,a,o){59===e.original.charCodeAt(this.end-1)&&e.remove(this.end-1,this.end),o||(t+=";"),null!==s?(10!==e.original.charCodeAt(i-1)||10!==e.original.charCodeAt(this.end)&&13!==e.original.charCodeAt(this.end)||(i--,13===e.original.charCodeAt(i)&&i--),i===s+1?e.overwrite(s,n,t):(e.overwrite(s,s+1,t),e.remove(i,n))):e.appendLeft(n,t),r.length>0&&e.appendLeft(n,` ${qe(r,a)};`)}renderReplacedDeclarations(e,t,{isNoStatement:s}){const i=Ge(this.declarations,e,this.start+this.kind.length,this.end-(59===e.original.charCodeAt(this.end-1)?1:0));let n,r;r=We(e.original,this.start+this.kind.length);let a=r-1;e.remove(this.start,a);let o,h,l=!1,c=!1,u="";const d=[],p=function(e,t,s){var i;let n=null;if("system"===t.format){for(const{node:r}of e)r.id instanceof Tt&&r.init&&0===s.length&&1===(null===(i=t.exportNamesByVariable.get(r.id.variable))||void 0===i?void 0:i.length)?(n=r.id.variable,s.push(n)):r.id.addExportedVariables(s,t.exportNamesByVariable);s.length>1?n=null:n&&(s.length=0)}return n}(i,t,d);for(const{node:s,start:d,separator:f,contentEnd:m,end:g}of i)if(s.included){if(s.render(e,t),o="",h="",!s.id.included||s.id instanceof Tt&&as(s.id.variable,t.exportNamesByVariable))c&&(u+=";"),l=!1;else{if(p&&p===s.id.variable){const i=Fe(e.original,"=",s.id.end);Ke(p,We(e.original,i+1),null===f?m:f,e,t)}l?u+=",":(c&&(u+=";"),o+=`${this.kind} `,l=!0)}r===a+1?e.overwrite(a,r,u+o):(e.overwrite(a,a+1,u),e.appendLeft(r,o)),n=m,r=g,c=!0,a=f,u=""}else e.remove(d,g);this.renderDeclarationEnd(e,u,a,n,r,d,t,s)}}const hs=[{key:D,kind:"init",property:G},{key:"length",kind:"init",property:rt}],ls=[new Bt({callsArgs:[0],mutatesSelfAsArray:"deopt-only",returns:null,returnsPrimitive:it})],cs=[new Bt({callsArgs:[0],mutatesSelfAsArray:"deopt-only",returns:null,returnsPrimitive:rt})],us=[new Bt({callsArgs:null,mutatesSelfAsArray:!0,returns:()=>new Lt(hs,vs),returnsPrimitive:null})],ds=[new Bt({callsArgs:null,mutatesSelfAsArray:"deopt-only",returns:()=>new Lt(hs,vs),returnsPrimitive:null})],ps=[new Bt({callsArgs:[0],mutatesSelfAsArray:"deopt-only",returns:()=>new Lt(hs,vs),returnsPrimitive:null})],fs=[new Bt({callsArgs:null,mutatesSelfAsArray:!0,returns:null,returnsPrimitive:rt})],ms=[new Bt({callsArgs:null,mutatesSelfAsArray:!0,returns:null,returnsPrimitive:G})],gs=[new Bt({callsArgs:null,mutatesSelfAsArray:"deopt-only",returns:null,returnsPrimitive:G})],ys=[new Bt({callsArgs:[0],mutatesSelfAsArray:"deopt-only",returns:null,returnsPrimitive:G})],Es=[new Bt({callsArgs:null,mutatesSelfAsArray:!0,returns:"self",returnsPrimitive:null})],xs=[new Bt({callsArgs:[0],mutatesSelfAsArray:!0,returns:"self",returnsPrimitive:null})],vs=new Lt({__proto__:null,at:gs,concat:ds,copyWithin:Es,entries:ds,every:ls,fill:Es,filter:ps,find:ys,findIndex:cs,forEach:ys,includes:Ft,indexOf:Wt,join:zt,keys:jt,lastIndexOf:Wt,map:ps,pop:ms,push:fs,reduce:ys,reduceRight:ys,reverse:Es,shift:ms,slice:ds,some:ls,sort:xs,splice:us,unshift:fs,values:gs},Ut,!0);class bs extends yt{addDeclaration(e,t,s,i){if(i){const n=this.parent.addDeclaration(e,t,s,i);return n.markInitializersForDeoptimization(),n}return super.addDeclaration(e,t,s,!1)}}class As extends De{initialise(){this.directive&&"use strict"!==this.directive&&this.parent.type===be&&this.context.warn({code:"MODULE_LEVEL_DIRECTIVE",message:`Module level directives cause errors when bundled, '${this.directive}' was ignored.`},this.start)}render(e,t){super.render(e,t),this.included&&this.insertSemicolon(e)}shouldBeIncluded(e){return this.directive&&"use strict"!==this.directive?this.parent.type!==be:super.shouldBeIncluded(e)}}class Ss extends De{constructor(){super(...arguments),this.directlyIncluded=!1}addImplicitReturnExpressionToScope(){const e=this.body[this.body.length-1];e&&"ReturnStatement"===e.type||this.scope.addReturnExpression(G)}createScope(e){this.scope=this.parent.preventChildBlockScope?e:new bs(e)}hasEffects(e){if(this.deoptimizeBody)return!0;for(const t of this.body){if(t.hasEffects(e))return!0;if(e.brokenFlow)break}return!1}include(e,t){if(!this.deoptimizeBody||!this.directlyIncluded){this.included=!0,this.directlyIncluded=!0,this.deoptimizeBody&&(t=!0);for(const s of this.body)(t||s.shouldBeIncluded(e))&&s.include(e,t)}}initialise(){const e=this.body[0];this.deoptimizeBody=e instanceof As&&"use asm"===e.directive}render(e,t){this.body.length?Ue(this.body,e,this.start+1,this.end-1,t):super.render(e,t)}}class Ps extends De{constructor(){super(...arguments),this.deoptimizedReturn=!1}createScope(e){this.scope=new Qt(e,this.context)}deoptimizePath(e){1===e.length&&e[0]===M&&this.scope.getReturnExpression().deoptimizePath(L)}deoptimizeThisOnEventAtPath(){}getReturnExpressionWhenCalledAtPath(e){return 0!==e.length?G:this.async?(this.deoptimizedReturn||(this.deoptimizedReturn=!0,this.scope.getReturnExpression().deoptimizePath(L),this.context.requestTreeshakingPass()),G):this.scope.getReturnExpression()}hasEffects(){return!1}hasEffectsWhenAccessedAtPath(e){return e.length>1}hasEffectsWhenAssignedAtPath(e){return e.length>1}hasEffectsWhenCalledAtPath(e,t,s){if(e.length>0)return!0;if(this.async){const{propertyReadSideEffects:e}=this.context.options.treeshake,t=this.scope.getReturnExpression();if(t.hasEffectsWhenCalledAtPath(["then"],{args:Je,thisParam:null,withNew:!1},s)||e&&("always"===e||t.hasEffectsWhenAccessedAtPath(["then"],s)))return!0}for(const e of this.params)if(e.hasEffects(s))return!0;const{ignore:i,brokenFlow:n}=s;return s.ignore={breaks:!1,continues:!1,labels:new Set,returnYield:!0},!!this.body.hasEffects(s)||(s.ignore=i,s.brokenFlow=n,!1)}include(e,t){this.included=!0;for(const s of this.params)s instanceof Tt||s.include(e,t);const{brokenFlow:s}=e;e.brokenFlow=0,this.body.include(e,t),e.brokenFlow=s}includeCallArguments(e,t){this.scope.includeCallArguments(e,t)}initialise(){this.scope.addParameterVariables(this.params.map((e=>e.declare("parameter",G))),this.params[this.params.length-1]instanceof Jt),this.body instanceof Ss?this.body.addImplicitReturnExpressionToScope():this.scope.addReturnExpression(this.body)}parseNode(e){e.body.type===ye&&(this.body=new this.context.nodeConstructors.BlockStatement(e.body,this,this.scope.hoistedBodyVarScope)),super.parseNode(e)}}Ps.prototype.preventChildBlockScope=!0;class ks extends De{addExportedVariables(e,t){for(const s of this.properties)"Property"===s.type?s.value.addExportedVariables(e,t):s.argument.addExportedVariables(e,t)}declare(e,t){const s=[];for(const i of this.properties)s.push(...i.declare(e,t));return s}deoptimizePath(e){if(0===e.length)for(const t of this.properties)t.deoptimizePath(e)}hasEffectsWhenAssignedAtPath(e,t){if(e.length>0)return!0;for(const e of this.properties)if(e.hasEffectsWhenAssignedAtPath(O,t))return!0;return!1}markDeclarationReached(){for(const e of this.properties)e.markDeclarationReached()}}class ws extends De{constructor(){super(...arguments),this.deoptimized=!1}hasEffects(e){return this.deoptimized||this.applyDeoptimizations(),this.right.hasEffects(e)||this.left.hasEffects(e)||this.left.hasEffectsWhenAssignedAtPath(O,e)}hasEffectsWhenAccessedAtPath(e,t){return e.length>0&&this.right.hasEffectsWhenAccessedAtPath(e,t)}include(e,t){let s;this.deoptimized||this.applyDeoptimizations(),this.included=!0,(t||"="!==this.operator||this.left.included||(s=de(),this.left.hasEffects(s)||this.left.hasEffectsWhenAssignedAtPath(O,s)))&&this.left.include(e,t),this.right.include(e,t)}render(e,t,{preventASI:s,renderedParentType:i,renderedSurroundingElement:n}=K){if(this.left.included)this.left.render(e,t),this.right.render(e,t);else{const r=We(e.original,Fe(e.original,"=",this.left.end)+1);e.remove(this.start,r),s&&He(e,r,this.right.start),this.right.render(e,t,{renderedParentType:i||this.parent.type,renderedSurroundingElement:n||this.parent.type})}if("system"===t.format)if(this.left instanceof Tt){const s=this.left.variable,i=t.exportNamesByVariable.get(s);if(i)return void(1===i.length?Ke(s,this.start,this.end,e,t):Xe(s,this.start,this.end,this.parent.type!==xe,e,t))}else{const s=[];if(this.left.addExportedVariables(s,t.exportNamesByVariable),s.length>0)return void function(e,t,s,i,n,r){const{_:a,getDirectReturnIifeLeft:o}=r.snippets;n.prependRight(t,o(["v"],`${qe(e,r)},${a}v`,{needsArrowReturnParens:!0,needsWrappedFunction:i})),n.appendLeft(s,")")}(s,this.start,this.end,n===xe,e,t)}this.left.included&&this.left instanceof ks&&(n===xe||n===ge)&&(e.appendRight(this.start,"("),e.prependLeft(this.end,")"))}applyDeoptimizations(){this.deoptimized=!0,this.left.deoptimizePath(O),this.right.deoptimizePath(L),this.context.requestTreeshakingPass()}}const Cs={"!=":(e,t)=>e!=t,"!==":(e,t)=>e!==t,"%":(e,t)=>e%t,"&":(e,t)=>e&t,"*":(e,t)=>e*t,"**":(e,t)=>e**t,"+":(e,t)=>e+t,"-":(e,t)=>e-t,"/":(e,t)=>e/t,"<":(e,t)=>e<t,"<<":(e,t)=>e<<t,"<=":(e,t)=>e<=t,"==":(e,t)=>e==t,"===":(e,t)=>e===t,">":(e,t)=>e>t,">=":(e,t)=>e>=t,">>":(e,t)=>e>>t,">>>":(e,t)=>e>>>t,"^":(e,t)=>e^t,in:()=>j,instanceof:()=>j,"|":(e,t)=>e|t};function Is(e){return e.computed?(t=e.property)instanceof is?String(t.value):null:e.property.name;var t}function Ns(e){const t=e.propertyKey,s=e.object;if("string"==typeof t){if(s instanceof Tt)return[{key:s.name,pos:s.start},{key:t,pos:e.property.start}];if(s instanceof _s){const i=Ns(s);return i&&[...i,{key:t,pos:e.property.start}]}}return null}class _s extends De{constructor(){super(...arguments),this.variable=null,this.deoptimized=!1,this.bound=!1,this.expressionsToBeDeoptimized=[],this.replacement=null}bind(){this.bound=!0;const e=Ns(this),t=e&&this.scope.findVariable(e[0].key);if(t&&t.isNamespace){const s=this.resolveNamespaceVariables(t,e.slice(1));s?"string"==typeof s?this.replacement=s:(this.variable=s,this.scope.addNamespaceMemberAccess(function(e){let t=e[0].key;for(let s=1;s<e.length;s++)t+="."+e[s].key;return t}(e),s)):super.bind()}else super.bind()}deoptimizeCache(){const e=this.expressionsToBeDeoptimized;this.expressionsToBeDeoptimized=[],this.propertyKey=M,this.object.deoptimizePath(L);for(const t of e)t.deoptimizeCache()}deoptimizePath(e){0===e.length&&this.disallowNamespaceReassignment(),this.variable?this.variable.deoptimizePath(e):this.replacement||e.length<7&&this.object.deoptimizePath([this.getPropertyKey(),...e])}deoptimizeThisOnEventAtPath(e,t,s,i){this.variable?this.variable.deoptimizeThisOnEventAtPath(e,t,s,i):this.replacement||(t.length<7?this.object.deoptimizeThisOnEventAtPath(e,[this.getPropertyKey(),...t],s,i):s.deoptimizePath(L))}getLiteralValueAtPath(e,t,s){return null!==this.variable?this.variable.getLiteralValueAtPath(e,t,s):this.replacement?j:(this.expressionsToBeDeoptimized.push(s),e.length<7?this.object.getLiteralValueAtPath([this.getPropertyKey(),...e],t,s):j)}getReturnExpressionWhenCalledAtPath(e,t,s,i){return null!==this.variable?this.variable.getReturnExpressionWhenCalledAtPath(e,t,s,i):this.replacement?G:(this.expressionsToBeDeoptimized.push(i),e.length<7?this.object.getReturnExpressionWhenCalledAtPath([this.getPropertyKey(),...e],t,s,i):G)}hasEffects(e){this.deoptimized||this.applyDeoptimizations();const{propertyReadSideEffects:t}=this.context.options.treeshake;return this.property.hasEffects(e)||this.object.hasEffects(e)||!(this.variable||this.replacement||this.parent instanceof ws&&"="===this.parent.operator)&&t&&("always"===t||this.object.hasEffectsWhenAccessedAtPath([this.getPropertyKey()],e))}hasEffectsWhenAccessedAtPath(e,t){return null!==this.variable?this.variable.hasEffectsWhenAccessedAtPath(e,t):!!this.replacement||!(e.length<7)||this.object.hasEffectsWhenAccessedAtPath([this.getPropertyKey(),...e],t)}hasEffectsWhenAssignedAtPath(e,t){return null!==this.variable?this.variable.hasEffectsWhenAssignedAtPath(e,t):!!this.replacement||!(e.length<7)||this.object.hasEffectsWhenAssignedAtPath([this.getPropertyKey(),...e],t)}hasEffectsWhenCalledAtPath(e,t,s){return null!==this.variable?this.variable.hasEffectsWhenCalledAtPath(e,t,s):!!this.replacement||!(e.length<7)||this.object.hasEffectsWhenCalledAtPath([this.getPropertyKey(),...e],t,s)}include(e,t){this.deoptimized||this.applyDeoptimizations(),this.included||(this.included=!0,null!==this.variable&&this.context.includeVariableInModule(this.variable)),this.object.include(e,t),this.property.include(e,t)}includeCallArguments(e,t){this.variable?this.variable.includeCallArguments(e,t):super.includeCallArguments(e,t)}initialise(){this.propertyKey=Is(this)}render(e,t,{renderedParentType:s,isCalleeOfRenderedParent:i,renderedSurroundingElement:n}=K){if(this.variable||this.replacement){const{snippets:{getPropertyAccess:n}}=t;let r=this.variable?this.variable.getName(n):this.replacement;s&&i&&(r="0, "+r),e.overwrite(this.start,this.end,r,{contentOnly:!0,storeName:!0})}else s&&i&&e.appendRight(this.start,"0, "),this.object.render(e,t,{renderedSurroundingElement:n}),this.property.render(e,t)}applyDeoptimizations(){this.deoptimized=!0;const{propertyReadSideEffects:e}=this.context.options.treeshake;this.bound&&e&&!this.variable&&!this.replacement&&(this.parent instanceof ws&&"="===this.parent.operator||this.object.deoptimizeThisOnEventAtPath(0,[this.propertyKey],this.object,z),this.parent instanceof ws&&this.object.deoptimizeThisOnEventAtPath(1,[this.propertyKey],this.object,z),this.context.requestTreeshakingPass())}disallowNamespaceReassignment(){this.object instanceof Tt&&this.scope.findVariable(this.object.name).isNamespace&&(this.variable&&this.context.includeVariableInModule(this.variable),this.context.warn({code:"ILLEGAL_NAMESPACE_REASSIGNMENT",message:`Illegal reassignment to import '${this.object.name}'`},this.start))}getPropertyKey(){if(null===this.propertyKey){this.propertyKey=M;const e=this.property.getLiteralValueAtPath(O,z,this);return this.propertyKey=e===j?M:String(e)}return this.propertyKey}resolveNamespaceVariables(e,t){if(0===t.length)return e;if(!e.isNamespace||e instanceof q)return null;const s=t[0].key,i=e.context.traceExport(s);if(!i){const i=e.context.fileName;return this.context.warn({code:"MISSING_EXPORT",exporter:re(i),importer:re(this.context.fileName),message:`'${s}' is not exported by '${re(i)}'`,missing:s,url:"https://rollupjs.org/guide/en/#error-name-is-not-exported-by-module"},t[0].pos),"undefined"}return this.resolveNamespaceVariables(i,t.slice(1))}}class $s extends Yt{addDeclaration(e,t,s,i){const n=this.variables.get(e.name);return n?(this.parent.addDeclaration(e,t,tt,i),n.addDeclaration(e,s),n):this.parent.addDeclaration(e,t,s,i)}}class Ts extends yt{constructor(e,t,s){super(e),this.variables.set("this",this.thisVariable=new mt("this",null,t,s)),this.instanceScope=new yt(this),this.instanceScope.variables.set("this",new Kt(s))}findLexicalBoundary(){return this}}class Rs extends U{constructor(e){super(),this.expressions=e,this.included=!1}deoptimizePath(e){for(const t of this.expressions)t.deoptimizePath(e)}getReturnExpressionWhenCalledAtPath(e,t,s,i){return new Rs(this.expressions.map((n=>n.getReturnExpressionWhenCalledAtPath(e,t,s,i))))}hasEffectsWhenAccessedAtPath(e,t){for(const s of this.expressions)if(s.hasEffectsWhenAccessedAtPath(e,t))return!0;return!1}hasEffectsWhenAssignedAtPath(e,t){for(const s of this.expressions)if(s.hasEffectsWhenAssignedAtPath(e,t))return!0;return!1}hasEffectsWhenCalledAtPath(e,t,s){for(const i of this.expressions)if(i.hasEffectsWhenCalledAtPath(e,t,s))return!0;return!1}include(e,t){for(const s of this.expressions)s.included||s.include(e,t)}}class Ms extends De{bind(){null!==this.declaration&&this.declaration.bind()}hasEffects(e){return null!==this.declaration&&this.declaration.hasEffects(e)}initialise(){this.context.addExport(this)}render(e,t,s){const{start:i,end:n}=s;null===this.declaration?e.remove(i,n):(e.remove(this.start,this.declaration.start),this.declaration.render(e,t,{end:n,start:i}))}}Ms.prototype.needsBoundaries=!0;class Ds extends bs{constructor(){super(...arguments),this.hoistedDeclarations=[]}addDeclaration(e,t,s,i){return this.hoistedDeclarations.push(e),super.addDeclaration(e,t,s,i)}}const Os=Symbol("unset");class Ls extends De{constructor(){super(...arguments),this.testValue=Os}deoptimizeCache(){this.testValue=j}hasEffects(e){if(this.test.hasEffects(e))return!0;const t=this.getTestValue();if(t===j){const{brokenFlow:t}=e;if(this.consequent.hasEffects(e))return!0;const s=e.brokenFlow;return e.brokenFlow=t,null!==this.alternate&&(!!this.alternate.hasEffects(e)||(e.brokenFlow=e.brokenFlow<s?e.brokenFlow:s,!1))}return t?this.consequent.hasEffects(e):null!==this.alternate&&this.alternate.hasEffects(e)}include(e,t){if(this.included=!0,t)this.includeRecursively(t,e);else{const t=this.getTestValue();t===j?this.includeUnknownTest(e):this.includeKnownTest(e,t)}}parseNode(e){this.consequentScope=new Ds(this.scope),this.consequent=new(this.context.nodeConstructors[e.consequent.type]||this.context.nodeConstructors.UnknownNode)(e.consequent,this,this.consequentScope),e.alternate&&(this.alternateScope=new Ds(this.scope),this.alternate=new(this.context.nodeConstructors[e.alternate.type]||this.context.nodeConstructors.UnknownNode)(e.alternate,this,this.alternateScope)),super.parseNode(e)}render(e,t){const{snippets:{getPropertyAccess:s}}=t,i=this.getTestValue(),n=[],r=this.test.included,a=!this.context.options.treeshake;r?this.test.render(e,t):e.remove(this.start,this.consequent.start),this.consequent.included&&(a||i===j||i)?this.consequent.render(e,t):(e.overwrite(this.consequent.start,this.consequent.end,r?";":""),n.push(...this.consequentScope.hoistedDeclarations)),this.alternate&&(!this.alternate.included||!a&&i!==j&&i?(r&&this.shouldKeepAlternateBranch()?e.overwrite(this.alternate.start,this.end,";"):e.remove(this.consequent.end,this.end),n.push(...this.alternateScope.hoistedDeclarations)):(r?101===e.original.charCodeAt(this.alternate.start-1)&&e.prependLeft(this.alternate.start," "):e.remove(this.consequent.end,this.alternate.start),this.alternate.render(e,t))),this.renderHoistedDeclarations(n,e,s)}getTestValue(){return this.testValue===Os?this.testValue=this.test.getLiteralValueAtPath(O,z,this):this.testValue}includeKnownTest(e,t){this.test.shouldBeIncluded(e)&&this.test.include(e,!1),t&&this.consequent.shouldBeIncluded(e)&&this.consequent.includeAsSingleStatement(e,!1),null!==this.alternate&&!t&&this.alternate.shouldBeIncluded(e)&&this.alternate.includeAsSingleStatement(e,!1)}includeRecursively(e,t){this.test.include(t,e),this.consequent.include(t,e),null!==this.alternate&&this.alternate.include(t,e)}includeUnknownTest(e){this.test.include(e,!1);const{brokenFlow:t}=e;let s=0;this.consequent.shouldBeIncluded(e)&&(this.consequent.includeAsSingleStatement(e,!1),s=e.brokenFlow,e.brokenFlow=t),null!==this.alternate&&this.alternate.shouldBeIncluded(e)&&(this.alternate.includeAsSingleStatement(e,!1),e.brokenFlow=e.brokenFlow<s?e.brokenFlow:s)}renderHoistedDeclarations(e,t,s){const i=[...new Set(e.map((e=>{const t=e.variable;return t.included?t.getName(s):""})))].filter(Boolean).join(", ");if(i){const e=this.parent.type,s=e!==be&&e!==ye;t.prependRight(this.start,`${s?"{ ":""}var ${i}; `),s&&t.appendLeft(this.end," }")}}shouldKeepAlternateBranch(){let e=this.parent;do{if(e instanceof Ls&&e.alternate)return!0;if(e instanceof Ss)return!1;e=e.parent}while(e);return!1}}class Vs extends De{bind(){}hasEffects(){return!1}initialise(){this.context.addImport(this)}render(e,t,s){e.remove(s.start,s.end)}}Vs.prototype.needsBoundaries=!0;const Bs="_interopDefault",Fs="_interopDefaultLegacy",zs="_interopNamespace",Ws="_interopNamespaceDefault",js="_interopNamespaceDefaultOnly",Us="_mergeNamespaces",Gs={auto:Bs,default:null,defaultOnly:null,esModule:null,false:null,true:Fs},Hs=(e,t)=>"esModule"===e||t&&("auto"===e||"true"===e),qs={auto:zs,default:Ws,defaultOnly:js,esModule:null,false:null,true:zs},Ks=(e,t)=>Hs(e,t)&&Gs[e]===Bs,Xs=(e,t,s,i,n,r,a)=>{const o=new Set(e);for(const e of ai)t.has(e)&&o.add(e);return ai.map((e=>o.has(e)?Ys[e](s,i,n,r,a,o):"")).join("")},Ys={[Fs](e,t,s){const{_:i,getDirectReturnFunction:n,n:r}=t,[a,o]=n(["e"],{functionReturn:!0,lineBreakIndent:null,name:Fs});return`${a}e${i}&&${i}typeof e${i}===${i}'object'${i}&&${i}'default'${i}in e${i}?${i}${s?Qs(t):Zs(t)}${o}${r}${r}`},[Bs](e,t,s){const{_:i,getDirectReturnFunction:n,n:r}=t,[a,o]=n(["e"],{functionReturn:!0,lineBreakIndent:null,name:Bs});return`${a}e${i}&&${i}e.__esModule${i}?${i}${s?Qs(t):Zs(t)}${o}${r}${r}`},[js](e,{_:t,getDirectReturnFunction:s,getObject:i,n:n},r,a,o){const[h,l]=s(["e"],{functionReturn:!0,lineBreakIndent:null,name:js});return`${h}${ri(i([["__proto__","null"],...o?[[null,`[Symbol.toStringTag]:${t}'Module'`]]:[],["default","e"]],{lineBreakIndent:null}),a)}${l}${n}${n}`},[Ws](e,t,s,i,n){const{_:r,n:a}=t;return`function _interopNamespaceDefault(e)${r}{${a}`+Js(e,e,t,s,i,n)+`}${a}${a}`},[zs](e,t,s,i,n,r){const{_:a,getDirectReturnFunction:o,n:h}=t;if(r.has(Ws)){const[e,t]=o(["e"],{functionReturn:!0,lineBreakIndent:null,name:zs});return`${e}e${a}&&${a}e.__esModule${a}?${a}e${a}:${a}_interopNamespaceDefault(e)${t}${h}${h}`}return`function _interopNamespace(e)${a}{${h}${e}if${a}(e${a}&&${a}e.__esModule)${a}return e;${h}`+Js(e,e,t,s,i,n)+`}${h}${h}`},[Us](e,t,s,i){const{_:n,n:r}=t;return`function _mergeNamespaces(n, m)${n}{${r}${e}${ti(`{${r}${e}${e}${e}if${n}(k${n}!==${n}'default'${n}&&${n}!(k in n))${n}{${r}`+(s?ii:ni)(e,e+e+e+e,t)+`${e}${e}${e}}${r}`+`${e}${e}}`,!s,e,t)}${r}${e}return ${ri("n",i)};${r}}${r}${r}`}},Qs=({_:e,getObject:t})=>`e${e}:${e}${t([["default","e"]],{lineBreakIndent:null})}`,Zs=({_:e,getPropertyAccess:t})=>`e${t("default")}${e}:${e}e`,Js=(e,t,s,i,n,r)=>{const{_:a,cnst:o,getPropertyAccess:h,n:l,s:c}=s,u=`{${l}`+(i?si:ni)(e,t+e+e,s)+`${t}${e}}`;return`${t}${o} n${a}=${a}${r?`{__proto__:${a}null,${a}[Symbol.toStringTag]:${a}'Module'}`:"Object.create(null)"};${l}${t}if${a}(e)${a}{${l}${t}${e}${ei(u,!i,s)}${l}${t}}${l}${t}n${h("default")}${a}=${a}e;${l}${t}return ${ri("n",n)}${c}${l}`},ei=(e,t,{_:s,cnst:i,getFunctionIntro:n,s:r})=>"var"!==i||t?`for${s}(${i} k in e)${s}${e}`:`Object.keys(e).forEach(${n(["k"],{isAsync:!1,name:null})}${e})${r}`,ti=(e,t,s,{_:i,cnst:n,getDirectReturnFunction:r,getFunctionIntro:a,n:o})=>{if("var"!==n||t)return`for${i}(var i${i}=${i}0;${i}i${i}<${i}m.length;${i}i++)${i}{${o}${s}${s}${n} e${i}=${i}m[i];${o}${s}${s}for${i}(${n} k in e)${i}${e}${o}${s}}`;const[h,l]=r(["e"],{functionReturn:!1,lineBreakIndent:{base:s,t:s},name:null});return`m.forEach(${h}Object.keys(e).forEach(${a(["k"],{isAsync:!1,name:null})}${e})${l});`},si=(e,t,s)=>{const{_:i,n:n}=s;return`${t}if${i}(k${i}!==${i}'default')${i}{${n}`+ii(e,t+e,s)+`${t}}${n}`},ii=(e,t,{_:s,cnst:i,getDirectReturnFunction:n,n:r})=>{const[a,o]=n([],{functionReturn:!0,lineBreakIndent:null,name:null});return`${t}${i} d${s}=${s}Object.getOwnPropertyDescriptor(e,${s}k);${r}${t}Object.defineProperty(n,${s}k,${s}d.get${s}?${s}d${s}:${s}{${r}${t}${e}enumerable:${s}true,${r}${t}${e}get:${s}${a}e[k]${o}${r}${t}});${r}`},ni=(e,t,{_:s,n:i})=>`${t}n[k]${s}=${s}e[k];${i}`,ri=(e,t)=>t?`Object.freeze(${e})`:e,ai=Object.keys(Ys);function oi(e,t,s){return"external"===t?qs[String(s(e instanceof oe?e.id:null))]:"default"===t?js:null}const hi={amd:["require"],cjs:["require"],system:["module"]};function li(e){return e.replace(/^\t+/,(e=>e.split("\t").join("  ")))}function ci(e){throw e instanceof Error||(e=Object.assign(new Error(e.message),e)),e}function ui(e,t,s,i){if("object"==typeof t){const{line:s,column:n}=t;e.loc={column:n,file:i,line:s}}else{e.pos=t;const{line:n,column:r}=ce(s,t,{offsetLine:1});e.loc={column:r,file:i,line:n}}if(void 0===e.frame){const{line:t,column:i}=e.loc;e.frame=function(e,t,s){let i=e.split("\n");const n=Math.max(0,t-3);let r=Math.min(t+2,i.length);for(i=i.slice(n,r);!/\S/.test(i[i.length-1]);)i.pop(),r-=1;const a=String(r).length;return i.map(((e,i)=>{const r=n+i+1===t;let o=String(i+n+1);for(;o.length<a;)o=` ${o}`;if(r){const t=function(e){let t="";for(;e--;)t+=" ";return t}(a+2+li(e.slice(0,s)).length)+"^";return`${o}: ${li(e)}\n${t}`}return`${o}: ${li(e)}`})).join("\n")}(s,t,i)}}var di;function pi({fileName:e,code:t},s){const i={code:di.CHUNK_INVALID,message:`Chunk "${e}" is not valid JavaScript: ${s.message}.`};return ui(i,s.loc,t,e),i}function fi(e,t,s){return{code:"INVALID_EXPORT_OPTION",message:`"${e}" was specified for "output.exports", but entry module "${re(s)}" has the following exports: ${t.join(", ")}`}}function mi(e,t,s,i){return{code:di.INVALID_OPTION,message:`Invalid value ${void 0!==i?`${JSON.stringify(i)} `:""}for option "${e}" - ${s}.`,url:`https://rollupjs.org/guide/en/#${t}`}}function gi(e,t,s){return{code:di.MISSING_EXPORT,message:`'${e}' is not exported by ${re(s)}, imported by ${re(t)}`,url:"https://rollupjs.org/guide/en/#error-name-is-not-exported-by-module"}}function yi(e){const t=Array.from(e.implicitlyLoadedBefore,(e=>re(e.id))).sort();return{code:di.MISSING_IMPLICIT_DEPENDANT,message:`Module "${re(e.id)}" that should be implicitly loaded before ${ie(t)} is not included in the module graph. Either it was not imported by an included module or only via a tree-shaken dynamic import, or no imported bindings were used and it had otherwise no side-effects.`}}function Ei(e,t,s){return{code:di.NAMESPACE_CONFLICT,message:`Conflicting namespaces: "${re(t.id)}" re-exports "${e}" from both "${re(t.exportsAll[e])}" and "${re(s.exportsAll[e])}" (will be ignored)`,name:e,reexporter:t.id,sources:[t.exportsAll[e],s.exportsAll[e]]}}function xi(e,t,s,i){return{code:di.AMBIGUOUS_EXTERNAL_NAMESPACES,message:`Ambiguous external namespace resolution: "${re(t)}" re-exports "${e}" from one of the external modules ${ie(i.map((e=>re(e))))}, guessing "${re(s)}".`,name:e,reexporter:t,sources:i}}function vi(e,t,s){const i=s?"reexport":"import";return{code:di.UNEXPECTED_NAMED_IMPORT,id:e,message:`The named export "${t}" was ${i}ed from the external module ${re(e)} even though its interop type is "defaultOnly". Either remove or change this ${i} or change the value of the "output.interop" option.`,url:"https://rollupjs.org/guide/en/#outputinterop"}}function bi(e){return{code:di.UNEXPECTED_NAMED_IMPORT,id:e,message:`There was a namespace "*" reexport from the external module ${re(e)} even though its interop type is "defaultOnly". This will be ignored as namespace reexports only reexport named exports. If this is not intended, either remove or change this reexport or change the value of the "output.interop" option.`,url:"https://rollupjs.org/guide/en/#outputinterop"}}function Ai(e){return{code:di.VALIDATION_ERROR,message:e}}function Si(){return{code:di.ALREADY_CLOSED,message:'Bundle is already closed, no more calls to "generate" or "write" are allowed.'}}function Pi(e,t,s){ki(e,t,s.onwarn,s.strictDeprecations)}function ki(e,t,s,i){if(t||i){const t=function(e){return{code:di.DEPRECATED_FEATURE,..."string"==typeof e?{message:e}:e}}(e);if(i)return ci(t);s(t)}}!function(e){e.ALREADY_CLOSED="ALREADY_CLOSED",e.ASSET_NOT_FINALISED="ASSET_NOT_FINALISED",e.ASSET_NOT_FOUND="ASSET_NOT_FOUND",e.ASSET_SOURCE_ALREADY_SET="ASSET_SOURCE_ALREADY_SET",e.ASSET_SOURCE_MISSING="ASSET_SOURCE_MISSING",e.BAD_LOADER="BAD_LOADER",e.CANNOT_EMIT_FROM_OPTIONS_HOOK="CANNOT_EMIT_FROM_OPTIONS_HOOK",e.CHUNK_NOT_GENERATED="CHUNK_NOT_GENERATED",e.CHUNK_INVALID="CHUNK_INVALID",e.CIRCULAR_REEXPORT="CIRCULAR_REEXPORT",e.CYCLIC_CROSS_CHUNK_REEXPORT="CYCLIC_CROSS_CHUNK_REEXPORT",e.DEPRECATED_FEATURE="DEPRECATED_FEATURE",e.EXTERNAL_SYNTHETIC_EXPORTS="EXTERNAL_SYNTHETIC_EXPORTS",e.FILE_NAME_CONFLICT="FILE_NAME_CONFLICT",e.FILE_NOT_FOUND="FILE_NOT_FOUND",e.INPUT_HOOK_IN_OUTPUT_PLUGIN="INPUT_HOOK_IN_OUTPUT_PLUGIN",e.INVALID_CHUNK="INVALID_CHUNK",e.INVALID_EXPORT_OPTION="INVALID_EXPORT_OPTION",e.INVALID_EXTERNAL_ID="INVALID_EXTERNAL_ID",e.INVALID_OPTION="INVALID_OPTION",e.INVALID_PLUGIN_HOOK="INVALID_PLUGIN_HOOK",e.INVALID_ROLLUP_PHASE="INVALID_ROLLUP_PHASE",e.MISSING_EXPORT="MISSING_EXPORT",e.MISSING_IMPLICIT_DEPENDANT="MISSING_IMPLICIT_DEPENDANT",e.MIXED_EXPORTS="MIXED_EXPORTS",e.NAMESPACE_CONFLICT="NAMESPACE_CONFLICT",e.AMBIGUOUS_EXTERNAL_NAMESPACES="AMBIGUOUS_EXTERNAL_NAMESPACES",e.NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE="NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE",e.PLUGIN_ERROR="PLUGIN_ERROR",e.PREFER_NAMED_EXPORTS="PREFER_NAMED_EXPORTS",e.SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT="SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT",e.UNEXPECTED_NAMED_IMPORT="UNEXPECTED_NAMED_IMPORT",e.UNRESOLVED_ENTRY="UNRESOLVED_ENTRY",e.UNRESOLVED_IMPORT="UNRESOLVED_IMPORT",e.VALIDATION_ERROR="VALIDATION_ERROR"}(di||(di={}));const wi="ROLLUP_ASSET_URL_",Ci="ROLLUP_CHUNK_URL_",Ii="ROLLUP_FILE_URL_",Ni={amd:["document","module","URL"],cjs:["document","require","URL"],es:[],iife:["document","URL"],system:["module"],umd:["document","require","URL"]},_i={amd:["document","require","URL"],cjs:["document","require","URL"],es:[],iife:["document","URL"],system:["module","URL"],umd:["document","require","URL"]},$i=(e,t="URL")=>`new ${t}(${e}).href`,Ti=(e,t=!1)=>$i(`'${e}', ${t?"typeof document === 'undefined' ? location.href : ":""}document.currentScript && document.currentScript.src || document.baseURI`),Ri=e=>(t,{chunkId:s})=>{const i=e(s);return null===t?`({ url: ${i} })`:"url"===t?i:"undefined"},Mi=(e,t=!1)=>`${t?"typeof document === 'undefined' ? location.href : ":""}(document.currentScript && document.currentScript.src || new URL('${e}', document.baseURI).href)`,Di={amd:e=>("."!==e[0]&&(e="./"+e),$i(`require.toUrl('${e}'), document.baseURI`)),cjs:e=>`(typeof document === 'undefined' ? ${$i(`'file:' + __dirname + '/${e}'`,"(require('u' + 'rl').URL)")} : ${Ti(e)})`,es:e=>$i(`'${e}', import.meta.url`),iife:e=>Ti(e),system:e=>$i(`'${e}', module.meta.url`),umd:e=>`(typeof document === 'undefined' && typeof location === 'undefined' ? ${$i(`'file:' + __dirname + '/${e}'`,"(require('u' + 'rl').URL)")} : ${Ti(e,!0)})`},Oi={amd:Ri((()=>$i("module.uri, document.baseURI"))),cjs:Ri((e=>`(typeof document === 'undefined' ? ${$i("'file:' + __filename","(require('u' + 'rl').URL)")} : ${Mi(e)})`)),iife:Ri((e=>Mi(e))),system:(e,{snippets:{getPropertyAccess:t}})=>null===e?"module.meta":`module.meta${t(e)}`,umd:Ri((e=>`(typeof document === 'undefined' && typeof location === 'undefined' ? ${$i("'file:' + __filename","(require('u' + 'rl').URL)")} : ${Mi(e,!0)})`))};class Li extends De{hasEffects(e){if(this.test&&this.test.hasEffects(e))return!0;for(const t of this.consequent){if(e.brokenFlow)break;if(t.hasEffects(e))return!0}return!1}include(e,t){this.included=!0,this.test&&this.test.include(e,t);for(const s of this.consequent)(t||s.shouldBeIncluded(e))&&s.include(e,t)}render(e,t,s){if(this.consequent.length){this.test&&this.test.render(e,t);const i=this.test?this.test.end:Fe(e.original,"default",this.start)+7,n=Fe(e.original,":",i)+1;Ue(this.consequent,e,n,s.end,t)}else super.render(e,t)}}Li.prototype.needsBoundaries=!0;class Vi extends H{constructor(){super("undefined")}getLiteralValueAtPath(){}}class Bi extends mt{constructor(e,t,s){super(e,t,t.declaration,s),this.hasId=!1,this.originalId=null,this.originalVariable=null;const i=t.declaration;(i instanceof ts||i instanceof Ht)&&i.id?(this.hasId=!0,this.originalId=i.id):i instanceof Tt&&(this.originalId=i)}addReference(e){this.hasId||(this.name=e.name)}getAssignedVariableName(){return this.originalId&&this.originalId.name||null}getBaseVariableName(){const e=this.getOriginalVariable();return e===this?super.getBaseVariableName():e.getBaseVariableName()}getDirectOriginalVariable(){return!this.originalId||!this.hasId&&(this.originalId.isPossibleTDZ()||this.originalId.variable.isReassigned||this.originalId.variable instanceof Vi||"syntheticNamespace"in this.originalId.variable)?null:this.originalId.variable}getName(e){const t=this.getOriginalVariable();return t===this?super.getName(e):t.getName(e)}getOriginalVariable(){if(this.originalVariable)return this.originalVariable;let e,t=this;const s=new Set;do{s.add(t),e=t,t=e.getDirectOriginalVariable()}while(t instanceof Bi&&!s.has(t));return this.originalVariable=t||e}}class Fi extends yt{constructor(e,t){super(e),this.context=t,this.variables.set("this",new mt("this",null,tt,t))}addExportDefaultDeclaration(e,t,s){const i=new Bi(e,t,s);return this.variables.set("default",i),i}addNamespaceMemberAccess(){}deconflict(e,t,s){for(const i of this.children)i.deconflict(e,t,s)}findLexicalBoundary(){return this}findVariable(e){const t=this.variables.get(e)||this.accessedOutsideVariables.get(e);if(t)return t;const s=this.context.traceVariable(e)||this.parent.findVariable(e);return s instanceof _t&&this.accessedOutsideVariables.set(e,s),s}}const zi={"!":e=>!e,"+":e=>+e,"-":e=>-e,delete:()=>j,typeof:e=>typeof e,void:()=>{},"~":e=>~e},Wi={ArrayExpression:class extends De{constructor(){super(...arguments),this.objectEntity=null}deoptimizePath(e){this.getObjectEntity().deoptimizePath(e)}deoptimizeThisOnEventAtPath(e,t,s,i){this.getObjectEntity().deoptimizeThisOnEventAtPath(e,t,s,i)}getLiteralValueAtPath(e,t,s){return this.getObjectEntity().getLiteralValueAtPath(e,t,s)}getReturnExpressionWhenCalledAtPath(e,t,s,i){return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(e,t,s,i)}hasEffectsWhenAccessedAtPath(e,t){return this.getObjectEntity().hasEffectsWhenAccessedAtPath(e,t)}hasEffectsWhenAssignedAtPath(e,t){return this.getObjectEntity().hasEffectsWhenAssignedAtPath(e,t)}hasEffectsWhenCalledAtPath(e,t,s){return this.getObjectEntity().hasEffectsWhenCalledAtPath(e,t,s)}getObjectEntity(){if(null!==this.objectEntity)return this.objectEntity;const e=[{key:"length",kind:"init",property:rt}];let t=!1;for(let s=0;s<this.elements.length;s++){const i=this.elements[s];i instanceof Xt||t?i&&(t=!0,e.unshift({key:D,kind:"init",property:i})):i?e.push({key:String(s),kind:"init",property:i}):e.push({key:String(s),kind:"init",property:tt})}return this.objectEntity=new Lt(e,vs)}},ArrayPattern:class extends De{addExportedVariables(e,t){for(const s of this.elements)null!==s&&s.addExportedVariables(e,t)}declare(e){const t=[];for(const s of this.elements)null!==s&&t.push(...s.declare(e,G));return t}deoptimizePath(e){if(0===e.length)for(const t of this.elements)null!==t&&t.deoptimizePath(e)}hasEffectsWhenAssignedAtPath(e,t){if(e.length>0)return!0;for(const e of this.elements)if(null!==e&&e.hasEffectsWhenAssignedAtPath(O,t))return!0;return!1}markDeclarationReached(){for(const e of this.elements)null!==e&&e.markDeclarationReached()}},ArrowFunctionExpression:Ps,AssignmentExpression:ws,AssignmentPattern:class extends De{constructor(){super(...arguments),this.deoptimized=!1}addExportedVariables(e,t){this.left.addExportedVariables(e,t)}declare(e,t){return this.left.declare(e,t)}deoptimizePath(e){0===e.length&&this.left.deoptimizePath(e)}hasEffectsWhenAssignedAtPath(e,t){return e.length>0||this.left.hasEffectsWhenAssignedAtPath(O,t)}markDeclarationReached(){this.left.markDeclarationReached()}render(e,t,{isShorthandProperty:s}=K){this.left.render(e,t,{isShorthandProperty:s}),this.right.render(e,t)}applyDeoptimizations(){this.deoptimized=!0,this.left.deoptimizePath(O),this.right.deoptimizePath(L),this.context.requestTreeshakingPass()}},AwaitExpression:class extends De{constructor(){super(...arguments),this.deoptimized=!1}hasEffects(){return this.deoptimized||this.applyDeoptimizations(),!0}include(e,t){if(this.deoptimized||this.applyDeoptimizations(),!this.included){this.included=!0;e:if(!this.context.usesTopLevelAwait){let e=this.parent;do{if(e instanceof es||e instanceof Ps)break e}while(e=e.parent);this.context.usesTopLevelAwait=!0}}this.argument.include(e,t)}applyDeoptimizations(){this.deoptimized=!0,this.argument.deoptimizePath(L),this.context.requestTreeshakingPass()}},BinaryExpression:class extends De{deoptimizeCache(){}getLiteralValueAtPath(e,t,s){if(e.length>0)return j;const i=this.left.getLiteralValueAtPath(O,t,s);if(i===j)return j;const n=this.right.getLiteralValueAtPath(O,t,s);if(n===j)return j;const r=Cs[this.operator];return r?r(i,n):j}hasEffects(e){return"+"===this.operator&&this.parent instanceof As&&""===this.left.getLiteralValueAtPath(O,z,this)||super.hasEffects(e)}hasEffectsWhenAccessedAtPath(e){return e.length>1}render(e,t,{renderedSurroundingElement:s}=K){this.left.render(e,t,{renderedSurroundingElement:s}),this.right.render(e,t)}},BlockStatement:Ss,BreakStatement:class extends De{hasEffects(e){if(this.label){if(!e.ignore.labels.has(this.label.name))return!0;e.includedLabels.add(this.label.name),e.brokenFlow=2}else{if(!e.ignore.breaks)return!0;e.brokenFlow=1}return!1}include(e){this.included=!0,this.label&&(this.label.include(),e.includedLabels.add(this.label.name)),e.brokenFlow=this.label?2:1}},CallExpression:class extends De{constructor(){super(...arguments),this.deoptimized=!1,this.deoptimizableDependentExpressions=[],this.expressionsToBeDeoptimized=new Set,this.returnExpression=null}bind(){super.bind(),this.callee instanceof Tt&&(this.scope.findVariable(this.callee.name).isNamespace&&this.context.warn({code:"CANNOT_CALL_NAMESPACE",message:`Cannot call a namespace ('${this.callee.name}')`},this.start),"eval"===this.callee.name&&this.context.warn({code:"EVAL",message:"Use of eval is strongly discouraged, as it poses security risks and may cause issues with minification",url:"https://rollupjs.org/guide/en/#avoiding-eval"},this.start)),this.callOptions={args:this.arguments,thisParam:this.callee instanceof _s&&!this.callee.variable?this.callee.object:null,withNew:!1}}deoptimizeCache(){if(this.returnExpression!==G){this.returnExpression=G;for(const e of this.deoptimizableDependentExpressions)e.deoptimizeCache();for(const e of this.expressionsToBeDeoptimized)e.deoptimizePath(L)}}deoptimizePath(e){if(0===e.length||this.context.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(e,this))return;const t=this.getReturnExpression();t!==G&&t.deoptimizePath(e)}deoptimizeThisOnEventAtPath(e,t,s,i){const n=this.getReturnExpression(i);n===G?s.deoptimizePath(L):i.withTrackedEntityAtPath(t,n,(()=>{this.expressionsToBeDeoptimized.add(s),n.deoptimizeThisOnEventAtPath(e,t,s,i)}),void 0)}getLiteralValueAtPath(e,t,s){const i=this.getReturnExpression(t);return i===G?j:t.withTrackedEntityAtPath(e,i,(()=>(this.deoptimizableDependentExpressions.push(s),i.getLiteralValueAtPath(e,t,s))),j)}getReturnExpressionWhenCalledAtPath(e,t,s,i){const n=this.getReturnExpression(s);return this.returnExpression===G?G:s.withTrackedEntityAtPath(e,n,(()=>(this.deoptimizableDependentExpressions.push(i),n.getReturnExpressionWhenCalledAtPath(e,t,s,i))),G)}hasEffects(e){try{for(const t of this.arguments)if(t.hasEffects(e))return!0;return(!this.context.options.treeshake.annotations||!this.annotations)&&(this.callee.hasEffects(e)||this.callee.hasEffectsWhenCalledAtPath(O,this.callOptions,e))}finally{this.deoptimized||this.applyDeoptimizations()}}hasEffectsWhenAccessedAtPath(e,t){return!t.accessed.trackEntityAtPathAndGetIfTracked(e,this)&&this.getReturnExpression().hasEffectsWhenAccessedAtPath(e,t)}hasEffectsWhenAssignedAtPath(e,t){return!t.assigned.trackEntityAtPathAndGetIfTracked(e,this)&&this.getReturnExpression().hasEffectsWhenAssignedAtPath(e,t)}hasEffectsWhenCalledAtPath(e,t,s){return!(t.withNew?s.instantiated:s.called).trackEntityAtPathAndGetIfTracked(e,t,this)&&this.getReturnExpression().hasEffectsWhenCalledAtPath(e,t,s)}include(e,t){this.deoptimized||this.applyDeoptimizations(),t?(super.include(e,t),t===Me&&this.callee instanceof Tt&&this.callee.variable&&this.callee.variable.markCalledFromTryStatement()):(this.included=!0,this.callee.include(e,!1)),this.callee.includeCallArguments(e,this.arguments);const s=this.getReturnExpression();s.included||s.include(e,!1)}render(e,t,{renderedSurroundingElement:s}=K){if(this.callee.render(e,t,{isCalleeOfRenderedParent:!0,renderedSurroundingElement:s}),this.arguments.length>0)if(this.arguments[this.arguments.length-1].included)for(const s of this.arguments)s.render(e,t);else{let s=this.arguments.length-2;for(;s>=0&&!this.arguments[s].included;)s--;if(s>=0){for(let i=0;i<=s;i++)this.arguments[i].render(e,t);e.remove(Fe(e.original,",",this.arguments[s].end),this.end-1)}else e.remove(Fe(e.original,"(",this.callee.end)+1,this.end-1)}}applyDeoptimizations(){this.deoptimized=!0;const{thisParam:e}=this.callOptions;e&&this.callee.deoptimizeThisOnEventAtPath(2,O,e,z);for(const e of this.arguments)e.deoptimizePath(L);this.context.requestTreeshakingPass()}getReturnExpression(e=z){return null===this.returnExpression?(this.returnExpression=G,this.returnExpression=this.callee.getReturnExpressionWhenCalledAtPath(O,this.callOptions,e,this)):this.returnExpression}},CatchClause:class extends De{createScope(e){this.scope=new $s(e,this.context)}parseNode(e){const{param:t}=e;t&&(this.param=new(this.context.nodeConstructors[t.type]||this.context.nodeConstructors.UnknownNode)(t,this,this.scope),this.param.declare("parameter",G)),super.parseNode(e)}},ChainExpression:class extends De{},ClassBody:class extends De{createScope(e){this.scope=new Ts(e,this.parent,this.context)}include(e,t){this.included=!0,this.context.includeVariableInModule(this.scope.thisVariable);for(const s of this.body)s.include(e,t)}parseNode(e){const t=this.body=[];for(const s of e.body)t.push(new this.context.nodeConstructors[s.type](s,this,s.static?this.scope:this.scope.instanceScope));super.parseNode(e)}},ClassDeclaration:Ht,ClassExpression:class extends Gt{render(e,t,{renderedSurroundingElement:s}=K){super.render(e,t),s===xe&&(e.appendRight(this.start,"("),e.prependLeft(this.end,")"))}},ConditionalExpression:class extends De{constructor(){super(...arguments),this.expressionsToBeDeoptimized=[],this.isBranchResolutionAnalysed=!1,this.usedBranch=null}deoptimizeCache(){if(null!==this.usedBranch){const e=this.usedBranch===this.consequent?this.alternate:this.consequent;this.usedBranch=null,e.deoptimizePath(L);for(const e of this.expressionsToBeDeoptimized)e.deoptimizeCache()}}deoptimizePath(e){const t=this.getUsedBranch();null===t?(this.consequent.deoptimizePath(e),this.alternate.deoptimizePath(e)):t.deoptimizePath(e)}deoptimizeThisOnEventAtPath(e,t,s,i){this.consequent.deoptimizeThisOnEventAtPath(e,t,s,i),this.alternate.deoptimizeThisOnEventAtPath(e,t,s,i)}getLiteralValueAtPath(e,t,s){const i=this.getUsedBranch();return null===i?j:(this.expressionsToBeDeoptimized.push(s),i.getLiteralValueAtPath(e,t,s))}getReturnExpressionWhenCalledAtPath(e,t,s,i){const n=this.getUsedBranch();return null===n?new Rs([this.consequent.getReturnExpressionWhenCalledAtPath(e,t,s,i),this.alternate.getReturnExpressionWhenCalledAtPath(e,t,s,i)]):(this.expressionsToBeDeoptimized.push(i),n.getReturnExpressionWhenCalledAtPath(e,t,s,i))}hasEffects(e){if(this.test.hasEffects(e))return!0;const t=this.getUsedBranch();return null===t?this.consequent.hasEffects(e)||this.alternate.hasEffects(e):t.hasEffects(e)}hasEffectsWhenAccessedAtPath(e,t){const s=this.getUsedBranch();return null===s?this.consequent.hasEffectsWhenAccessedAtPath(e,t)||this.alternate.hasEffectsWhenAccessedAtPath(e,t):s.hasEffectsWhenAccessedAtPath(e,t)}hasEffectsWhenAssignedAtPath(e,t){const s=this.getUsedBranch();return null===s?this.consequent.hasEffectsWhenAssignedAtPath(e,t)||this.alternate.hasEffectsWhenAssignedAtPath(e,t):s.hasEffectsWhenAssignedAtPath(e,t)}hasEffectsWhenCalledAtPath(e,t,s){const i=this.getUsedBranch();return null===i?this.consequent.hasEffectsWhenCalledAtPath(e,t,s)||this.alternate.hasEffectsWhenCalledAtPath(e,t,s):i.hasEffectsWhenCalledAtPath(e,t,s)}include(e,t){this.included=!0;const s=this.getUsedBranch();t||this.test.shouldBeIncluded(e)||null===s?(this.test.include(e,t),this.consequent.include(e,t),this.alternate.include(e,t)):s.include(e,t)}includeCallArguments(e,t){const s=this.getUsedBranch();null===s?(this.consequent.includeCallArguments(e,t),this.alternate.includeCallArguments(e,t)):s.includeCallArguments(e,t)}render(e,t,{isCalleeOfRenderedParent:s,preventASI:i,renderedParentType:n,renderedSurroundingElement:r}=K){const a=this.getUsedBranch();if(this.test.included)this.test.render(e,t,{renderedSurroundingElement:r}),this.consequent.render(e,t),this.alternate.render(e,t);else{const o=Fe(e.original,":",this.consequent.end),h=We(e.original,(this.consequent.included?Fe(e.original,"?",this.test.end):o)+1);i&&He(e,h,a.start),e.remove(this.start,h),this.consequent.included&&e.remove(o,this.end),Ve(this,e),a.render(e,t,{isCalleeOfRenderedParent:s,preventASI:!0,renderedParentType:n||this.parent.type,renderedSurroundingElement:r||this.parent.type})}}getUsedBranch(){if(this.isBranchResolutionAnalysed)return this.usedBranch;this.isBranchResolutionAnalysed=!0;const e=this.test.getLiteralValueAtPath(O,z,this);return e===j?null:this.usedBranch=e?this.consequent:this.alternate}},ContinueStatement:class extends De{hasEffects(e){if(this.label){if(!e.ignore.labels.has(this.label.name))return!0;e.includedLabels.add(this.label.name),e.brokenFlow=2}else{if(!e.ignore.continues)return!0;e.brokenFlow=1}return!1}include(e){this.included=!0,this.label&&(this.label.include(),e.includedLabels.add(this.label.name)),e.brokenFlow=this.label?2:1}},DoWhileStatement:class extends De{hasEffects(e){if(this.test.hasEffects(e))return!0;const{brokenFlow:t,ignore:{breaks:s,continues:i}}=e;return e.ignore.breaks=!0,e.ignore.continues=!0,!!this.body.hasEffects(e)||(e.ignore.breaks=s,e.ignore.continues=i,e.brokenFlow=t,!1)}include(e,t){this.included=!0,this.test.include(e,t);const{brokenFlow:s}=e;this.body.includeAsSingleStatement(e,t),e.brokenFlow=s}},EmptyStatement:class extends De{hasEffects(){return!1}},ExportAllDeclaration:Oe,ExportDefaultDeclaration:ss,ExportNamedDeclaration:Ms,ExportSpecifier:class extends De{},ExpressionStatement:As,ForInStatement:class extends De{constructor(){super(...arguments),this.deoptimized=!1}createScope(e){this.scope=new bs(e)}hasEffects(e){if(this.deoptimized||this.applyDeoptimizations(),this.left&&(this.left.hasEffects(e)||this.left.hasEffectsWhenAssignedAtPath(O,e))||this.right&&this.right.hasEffects(e))return!0;const{brokenFlow:t,ignore:{breaks:s,continues:i}}=e;return e.ignore.breaks=!0,e.ignore.continues=!0,!!this.body.hasEffects(e)||(e.ignore.breaks=s,e.ignore.continues=i,e.brokenFlow=t,!1)}include(e,t){this.deoptimized||this.applyDeoptimizations(),this.included=!0,this.left.include(e,t||!0),this.right.include(e,t);const{brokenFlow:s}=e;this.body.includeAsSingleStatement(e,t),e.brokenFlow=s}render(e,t){this.left.render(e,t,Be),this.right.render(e,t,Be),110===e.original.charCodeAt(this.right.start-1)&&e.prependLeft(this.right.start," "),this.body.render(e,t)}applyDeoptimizations(){this.deoptimized=!0,this.left.deoptimizePath(O),this.context.requestTreeshakingPass()}},ForOfStatement:class extends De{constructor(){super(...arguments),this.deoptimized=!1}createScope(e){this.scope=new bs(e)}hasEffects(){return this.deoptimized||this.applyDeoptimizations(),!0}include(e,t){this.deoptimized||this.applyDeoptimizations(),this.included=!0,this.left.include(e,t||!0),this.right.include(e,t);const{brokenFlow:s}=e;this.body.includeAsSingleStatement(e,t),e.brokenFlow=s}render(e,t){this.left.render(e,t,Be),this.right.render(e,t,Be),102===e.original.charCodeAt(this.right.start-1)&&e.prependLeft(this.right.start," "),this.body.render(e,t)}applyDeoptimizations(){this.deoptimized=!0,this.left.deoptimizePath(O),this.context.requestTreeshakingPass()}},ForStatement:class extends De{createScope(e){this.scope=new bs(e)}hasEffects(e){if(this.init&&this.init.hasEffects(e)||this.test&&this.test.hasEffects(e)||this.update&&this.update.hasEffects(e))return!0;const{brokenFlow:t,ignore:{breaks:s,continues:i}}=e;return e.ignore.breaks=!0,e.ignore.continues=!0,!!this.body.hasEffects(e)||(e.ignore.breaks=s,e.ignore.continues=i,e.brokenFlow=t,!1)}include(e,t){this.included=!0,this.init&&this.init.includeAsSingleStatement(e,t),this.test&&this.test.include(e,t);const{brokenFlow:s}=e;this.update&&this.update.include(e,t),this.body.includeAsSingleStatement(e,t),e.brokenFlow=s}render(e,t){this.init&&this.init.render(e,t,Be),this.test&&this.test.render(e,t,Be),this.update&&this.update.render(e,t,Be),this.body.render(e,t)}},FunctionDeclaration:ts,FunctionExpression:class extends es{render(e,t,{renderedSurroundingElement:s}=K){super.render(e,t),s===xe&&(e.appendRight(this.start,"("),e.prependLeft(this.end,")"))}},Identifier:Tt,IfStatement:Ls,ImportDeclaration:Vs,ImportDefaultSpecifier:class extends De{},ImportExpression:class extends De{constructor(){super(...arguments),this.inlineNamespace=null,this.mechanism=null,this.resolution=null}hasEffects(){return!0}include(e,t){this.included||(this.included=!0,this.context.includeDynamicImport(this),this.scope.addAccessedDynamicImport(this)),this.source.include(e,t)}initialise(){this.context.addDynamicImport(this)}render(e,t){if(this.inlineNamespace){const{snippets:{getDirectReturnFunction:s,getPropertyAccess:i}}=t,[n,r]=s([],{functionReturn:!0,lineBreakIndent:null,name:null});e.overwrite(this.start,this.end,`Promise.resolve().then(${n}${this.inlineNamespace.getName(i)}${r})`,{contentOnly:!0})}else this.mechanism&&(e.overwrite(this.start,Fe(e.original,"(",this.start+6)+1,this.mechanism.left,{contentOnly:!0}),e.overwrite(this.end-1,this.end,this.mechanism.right,{contentOnly:!0})),this.source.render(e,t)}renderFinalResolution(e,t,s,{getDirectReturnFunction:i}){if(e.overwrite(this.source.start,this.source.end,t),s){const[t,n]=i(["n"],{functionReturn:!0,lineBreakIndent:null,name:null});e.prependLeft(this.end,`.then(${t}n.${s}${n})`)}}setExternalResolution(e,t,s,i,n,r){const{format:a}=s;this.resolution=t;const o=[...hi[a]||[]];let h;({helper:h,mechanism:this.mechanism}=this.getDynamicImportMechanismAndHelper(t,e,s,i,n)),h&&o.push(h),o.length>0&&this.scope.addAccessedGlobals(o,r)}setInternalResolution(e){this.inlineNamespace=e}getDynamicImportMechanismAndHelper(e,t,{compact:s,dynamicImportFunction:i,format:n,generatedCode:{arrowFunctions:r},interop:a},{_:o,getDirectReturnFunction:h,getDirectReturnIifeLeft:l},c){const u=c.hookFirstSync("renderDynamicImport",[{customResolution:"string"==typeof this.resolution?this.resolution:null,format:n,moduleId:this.context.module.id,targetModuleId:this.resolution&&"string"!=typeof this.resolution?this.resolution.id:null}]);if(u)return{helper:null,mechanism:u};const d=!this.resolution||"string"==typeof this.resolution;switch(n){case"cjs":{const s=oi(e,t,a);let i="require(",n=")";s&&(i=`/*#__PURE__*/${s}(${i}`,n+=")");const[o,c]=h([],{functionReturn:!0,lineBreakIndent:null,name:null});return i=`Promise.resolve().then(${o}${i}`,n+=`${c})`,!r&&d&&(i=l(["t"],`${i}t${n}`,{needsArrowReturnParens:!1,needsWrappedFunction:!0}),n=")"),{helper:s,mechanism:{left:i,right:n}}}case"amd":{const i=s?"c":"resolve",n=s?"e":"reject",c=oi(e,t,a),[u,p]=h(["m"],{functionReturn:!1,lineBreakIndent:null,name:null}),f=c?`${u}${i}(/*#__PURE__*/${c}(m))${p}`:i,[m,g]=h([i,n],{functionReturn:!1,lineBreakIndent:null,name:null});let y=`new Promise(${m}require([`,E=`],${o}${f},${o}${n})${g})`;return!r&&d&&(y=l(["t"],`${y}t${E}`,{needsArrowReturnParens:!1,needsWrappedFunction:!0}),E=")"),{helper:c,mechanism:{left:y,right:E}}}case"system":return{helper:null,mechanism:{left:"module.import(",right:")"}};case"es":if(i)return{helper:null,mechanism:{left:`${i}(`,right:")"}}}return{helper:null,mechanism:null}}},ImportNamespaceSpecifier:class extends De{},ImportSpecifier:class extends De{},LabeledStatement:class extends De{hasEffects(e){const t=e.brokenFlow;return e.ignore.labels.add(this.label.name),!!this.body.hasEffects(e)||(e.ignore.labels.delete(this.label.name),e.includedLabels.has(this.label.name)&&(e.includedLabels.delete(this.label.name),e.brokenFlow=t),!1)}include(e,t){this.included=!0;const s=e.brokenFlow;this.body.include(e,t),(t||e.includedLabels.has(this.label.name))&&(this.label.include(),e.includedLabels.delete(this.label.name),e.brokenFlow=s)}render(e,t){this.label.included?this.label.render(e,t):e.remove(this.start,We(e.original,Fe(e.original,":",this.label.end)+1)),this.body.render(e,t)}},Literal:is,LogicalExpression:class extends De{constructor(){super(...arguments),this.expressionsToBeDeoptimized=[],this.isBranchResolutionAnalysed=!1,this.usedBranch=null}deoptimizeCache(){if(null!==this.usedBranch){const e=this.usedBranch===this.left?this.right:this.left;this.usedBranch=null,e.deoptimizePath(L);for(const e of this.expressionsToBeDeoptimized)e.deoptimizeCache()}}deoptimizePath(e){const t=this.getUsedBranch();null===t?(this.left.deoptimizePath(e),this.right.deoptimizePath(e)):t.deoptimizePath(e)}deoptimizeThisOnEventAtPath(e,t,s,i){this.left.deoptimizeThisOnEventAtPath(e,t,s,i),this.right.deoptimizeThisOnEventAtPath(e,t,s,i)}getLiteralValueAtPath(e,t,s){const i=this.getUsedBranch();return null===i?j:(this.expressionsToBeDeoptimized.push(s),i.getLiteralValueAtPath(e,t,s))}getReturnExpressionWhenCalledAtPath(e,t,s,i){const n=this.getUsedBranch();return null===n?new Rs([this.left.getReturnExpressionWhenCalledAtPath(e,t,s,i),this.right.getReturnExpressionWhenCalledAtPath(e,t,s,i)]):(this.expressionsToBeDeoptimized.push(i),n.getReturnExpressionWhenCalledAtPath(e,t,s,i))}hasEffects(e){return!!this.left.hasEffects(e)||this.getUsedBranch()!==this.left&&this.right.hasEffects(e)}hasEffectsWhenAccessedAtPath(e,t){const s=this.getUsedBranch();return null===s?this.left.hasEffectsWhenAccessedAtPath(e,t)||this.right.hasEffectsWhenAccessedAtPath(e,t):s.hasEffectsWhenAccessedAtPath(e,t)}hasEffectsWhenAssignedAtPath(e,t){const s=this.getUsedBranch();return null===s?this.left.hasEffectsWhenAssignedAtPath(e,t)||this.right.hasEffectsWhenAssignedAtPath(e,t):s.hasEffectsWhenAssignedAtPath(e,t)}hasEffectsWhenCalledAtPath(e,t,s){const i=this.getUsedBranch();return null===i?this.left.hasEffectsWhenCalledAtPath(e,t,s)||this.right.hasEffectsWhenCalledAtPath(e,t,s):i.hasEffectsWhenCalledAtPath(e,t,s)}include(e,t){this.included=!0;const s=this.getUsedBranch();t||s===this.right&&this.left.shouldBeIncluded(e)||null===s?(this.left.include(e,t),this.right.include(e,t)):s.include(e,t)}render(e,t,{isCalleeOfRenderedParent:s,preventASI:i,renderedParentType:n,renderedSurroundingElement:r}=K){if(this.left.included&&this.right.included)this.left.render(e,t,{preventASI:i,renderedSurroundingElement:r}),this.right.render(e,t);else{const a=Fe(e.original,this.operator,this.left.end);if(this.right.included){const t=We(e.original,a+2);e.remove(this.start,t),i&&He(e,t,this.right.start)}else e.remove(a,this.end);Ve(this,e),this.getUsedBranch().render(e,t,{isCalleeOfRenderedParent:s,preventASI:i,renderedParentType:n||this.parent.type,renderedSurroundingElement:r||this.parent.type})}}getUsedBranch(){if(!this.isBranchResolutionAnalysed){this.isBranchResolutionAnalysed=!0;const e=this.left.getLiteralValueAtPath(O,z,this);if(e===j)return null;this.usedBranch="||"===this.operator&&e||"&&"===this.operator&&!e||"??"===this.operator&&null!=e?this.left:this.right}return this.usedBranch}},MemberExpression:_s,MetaProperty:class extends De{addAccessedGlobals(e,t){const s=this.metaProperty,i=(s&&(s.startsWith(Ii)||s.startsWith(wi)||s.startsWith(Ci))?_i:Ni)[e];i.length>0&&this.scope.addAccessedGlobals(i,t)}getReferencedFileName(e){const t=this.metaProperty;return t&&t.startsWith(Ii)?e.getFileName(t.substr(Ii.length)):null}hasEffects(){return!1}hasEffectsWhenAccessedAtPath(e){return e.length>1}include(){if(!this.included&&(this.included=!0,"import"===this.meta.name)){this.context.addImportMeta(this);const e=this.parent;this.metaProperty=e instanceof _s&&"string"==typeof e.propertyKey?e.propertyKey:null}}renderFinalMechanism(e,t,s,i,n){var r;const a=this.parent,o=this.metaProperty;if(o&&(o.startsWith(Ii)||o.startsWith(wi)||o.startsWith(Ci))){let i,r=null,h=null,l=null;o.startsWith(Ii)?(r=o.substr(Ii.length),i=n.getFileName(r)):o.startsWith(wi)?(Pi(`Using the "${wi}" prefix to reference files is deprecated. Use the "${Ii}" prefix instead.`,!0,this.context.options),h=o.substr(wi.length),i=n.getFileName(h)):(Pi(`Using the "${Ci}" prefix to reference files is deprecated. Use the "${Ii}" prefix instead.`,!0,this.context.options),l=o.substr(Ci.length),i=n.getFileName(l));const c=C($(N(t),i));let u;return null!==h&&(u=n.hookFirstSync("resolveAssetUrl",[{assetFileName:i,chunkId:t,format:s,moduleId:this.context.module.id,relativeAssetPath:c}])),u||(u=n.hookFirstSync("resolveFileUrl",[{assetReferenceId:h,chunkId:t,chunkReferenceId:l,fileName:i,format:s,moduleId:this.context.module.id,referenceId:r||h||l,relativePath:c}])||Di[s](c)),void e.overwrite(a.start,a.end,u,{contentOnly:!0})}const h=n.hookFirstSync("resolveImportMeta",[o,{chunkId:t,format:s,moduleId:this.context.module.id}])||(null===(r=Oi[s])||void 0===r?void 0:r.call(Oi,o,{chunkId:t,snippets:i}));"string"==typeof h&&(a instanceof _s?e.overwrite(a.start,a.end,h,{contentOnly:!0}):e.overwrite(this.start,this.end,h,{contentOnly:!0}))}},MethodDefinition:Dt,NewExpression:class extends De{constructor(){super(...arguments),this.deoptimized=!1}hasEffects(e){this.deoptimized||this.applyDeoptimizations();for(const t of this.arguments)if(t.hasEffects(e))return!0;return(!this.context.options.treeshake.annotations||!this.annotations)&&(this.callee.hasEffects(e)||this.callee.hasEffectsWhenCalledAtPath(O,this.callOptions,e))}hasEffectsWhenAccessedAtPath(e){return e.length>0}initialise(){this.callOptions={args:this.arguments,thisParam:null,withNew:!0}}applyDeoptimizations(){this.deoptimized=!0;for(const e of this.arguments)e.deoptimizePath(L);this.context.requestTreeshakingPass()}},ObjectExpression:class extends De{constructor(){super(...arguments),this.objectEntity=null}deoptimizeCache(){this.getObjectEntity().deoptimizeAllProperties()}deoptimizePath(e){this.getObjectEntity().deoptimizePath(e)}deoptimizeThisOnEventAtPath(e,t,s,i){this.getObjectEntity().deoptimizeThisOnEventAtPath(e,t,s,i)}getLiteralValueAtPath(e,t,s){return this.getObjectEntity().getLiteralValueAtPath(e,t,s)}getReturnExpressionWhenCalledAtPath(e,t,s,i){return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(e,t,s,i)}hasEffectsWhenAccessedAtPath(e,t){return this.getObjectEntity().hasEffectsWhenAccessedAtPath(e,t)}hasEffectsWhenAssignedAtPath(e,t){return this.getObjectEntity().hasEffectsWhenAssignedAtPath(e,t)}hasEffectsWhenCalledAtPath(e,t,s){return this.getObjectEntity().hasEffectsWhenCalledAtPath(e,t,s)}render(e,t,{renderedSurroundingElement:s}=K){super.render(e,t),s!==xe&&s!==ge||(e.appendRight(this.start,"("),e.prependLeft(this.end,")"))}getObjectEntity(){if(null!==this.objectEntity)return this.objectEntity;let e=Ut;const t=[];for(const s of this.properties){if(s instanceof Xt){t.push({key:M,kind:"init",property:s});continue}let i;if(s.computed){const e=s.key.getLiteralValueAtPath(O,z,this);if(e===j){t.push({key:M,kind:s.kind,property:s});continue}i=String(e)}else if(i=s.key instanceof Tt?s.key.name:String(s.key.value),"__proto__"===i&&"init"===s.kind){e=s.value instanceof is&&null===s.value.value?null:s.value;continue}t.push({key:i,kind:s.kind,property:s})}return this.objectEntity=new Lt(t,e)}},ObjectPattern:ks,PrivateIdentifier:class extends De{},Program:ns,Property:class extends Mt{constructor(){super(...arguments),this.deoptimized=!1,this.declarationInit=null}declare(e,t){return this.declarationInit=t,this.value.declare(e,G)}hasEffects(e){this.deoptimized||this.applyDeoptimizations();const t=this.context.options.treeshake.propertyReadSideEffects;return"ObjectPattern"===this.parent.type&&"always"===t||this.key.hasEffects(e)||this.value.hasEffects(e)}markDeclarationReached(){this.value.markDeclarationReached()}render(e,t){this.shorthand||this.key.render(e,t),this.value.render(e,t,{isShorthandProperty:this.shorthand})}applyDeoptimizations(){this.deoptimized=!0,null!==this.declarationInit&&(this.declarationInit.deoptimizePath([M,M]),this.context.requestTreeshakingPass())}},PropertyDefinition:class extends De{deoptimizePath(e){var t;null===(t=this.value)||void 0===t||t.deoptimizePath(e)}deoptimizeThisOnEventAtPath(e,t,s,i){var n;null===(n=this.value)||void 0===n||n.deoptimizeThisOnEventAtPath(e,t,s,i)}getLiteralValueAtPath(e,t,s){return this.value?this.value.getLiteralValueAtPath(e,t,s):j}getReturnExpressionWhenCalledAtPath(e,t,s,i){return this.value?this.value.getReturnExpressionWhenCalledAtPath(e,t,s,i):G}hasEffects(e){return this.key.hasEffects(e)||this.static&&null!==this.value&&this.value.hasEffects(e)}hasEffectsWhenAccessedAtPath(e,t){return!this.value||this.value.hasEffectsWhenAccessedAtPath(e,t)}hasEffectsWhenAssignedAtPath(e,t){return!this.value||this.value.hasEffectsWhenAssignedAtPath(e,t)}hasEffectsWhenCalledAtPath(e,t,s){return!this.value||this.value.hasEffectsWhenCalledAtPath(e,t,s)}},RestElement:Jt,ReturnStatement:class extends De{hasEffects(e){return!(e.ignore.returnYield&&(null===this.argument||!this.argument.hasEffects(e))&&(e.brokenFlow=2,1))}include(e,t){this.included=!0,this.argument&&this.argument.include(e,t),e.brokenFlow=2}initialise(){this.scope.addReturnExpression(this.argument||G)}render(e,t){this.argument&&(this.argument.render(e,t,{preventASI:!0}),this.argument.start===this.start+6&&e.prependLeft(this.start+6," "))}},SequenceExpression:class extends De{deoptimizePath(e){this.expressions[this.expressions.length-1].deoptimizePath(e)}deoptimizeThisOnEventAtPath(e,t,s,i){this.expressions[this.expressions.length-1].deoptimizeThisOnEventAtPath(e,t,s,i)}getLiteralValueAtPath(e,t,s){return this.expressions[this.expressions.length-1].getLiteralValueAtPath(e,t,s)}hasEffects(e){for(const t of this.expressions)if(t.hasEffects(e))return!0;return!1}hasEffectsWhenAccessedAtPath(e,t){return e.length>0&&this.expressions[this.expressions.length-1].hasEffectsWhenAccessedAtPath(e,t)}hasEffectsWhenAssignedAtPath(e,t){return this.expressions[this.expressions.length-1].hasEffectsWhenAssignedAtPath(e,t)}hasEffectsWhenCalledAtPath(e,t,s){return this.expressions[this.expressions.length-1].hasEffectsWhenCalledAtPath(e,t,s)}include(e,t){this.included=!0;const s=this.expressions[this.expressions.length-1];for(const i of this.expressions)(t||i===s&&!(this.parent instanceof As)||i.shouldBeIncluded(e))&&i.include(e,t)}render(e,t,{renderedParentType:s,isCalleeOfRenderedParent:i,preventASI:n}=K){let r=0,a=null;const o=this.expressions[this.expressions.length-1];for(const{node:h,separator:l,start:c,end:u}of Ge(this.expressions,e,this.start,this.end))if(h.included)if(r++,a=l,1===r&&n&&He(e,c,h.start),1===r){const n=s||this.parent.type;h.render(e,t,{isCalleeOfRenderedParent:i&&h===o,renderedParentType:n,renderedSurroundingElement:n})}else h.render(e,t);else Le(h,e,c,u);a&&e.remove(a,this.end)}},SpreadElement:Xt,Super:class extends De{bind(){this.variable=this.scope.findVariable("this")}deoptimizePath(e){this.variable.deoptimizePath(e)}include(){this.included||(this.included=!0,this.context.includeVariableInModule(this.variable))}},SwitchCase:Li,SwitchStatement:class extends De{createScope(e){this.scope=new bs(e)}hasEffects(e){if(this.discriminant.hasEffects(e))return!0;const{brokenFlow:t,ignore:{breaks:s}}=e;let i=1/0;e.ignore.breaks=!0;for(const s of this.cases){if(s.hasEffects(e))return!0;i=e.brokenFlow<i?e.brokenFlow:i,e.brokenFlow=t}return null!==this.defaultCase&&1!==i&&(e.brokenFlow=i),e.ignore.breaks=s,!1}include(e,t){this.included=!0,this.discriminant.include(e,t);const{brokenFlow:s}=e;let i=1/0,n=t||null!==this.defaultCase&&this.defaultCase<this.cases.length-1;for(let r=this.cases.length-1;r>=0;r--){const a=this.cases[r];if(a.included&&(n=!0),!n){const e=de();e.ignore.breaks=!0,n=a.hasEffects(e)}n?(a.include(e,t),i=i<e.brokenFlow?i:e.brokenFlow,e.brokenFlow=s):i=s}n&&null!==this.defaultCase&&1!==i&&(e.brokenFlow=i)}initialise(){for(let e=0;e<this.cases.length;e++)if(null===this.cases[e].test)return void(this.defaultCase=e);this.defaultCase=null}render(e,t){this.discriminant.render(e,t),this.cases.length>0&&Ue(this.cases,e,this.cases[0].start,this.end-1,t)}},TaggedTemplateExpression:class extends De{bind(){if(super.bind(),this.tag.type===ve){const e=this.tag.name;this.scope.findVariable(e).isNamespace&&this.context.warn({code:"CANNOT_CALL_NAMESPACE",message:`Cannot call a namespace ('${e}')`},this.start)}}hasEffects(e){return super.hasEffects(e)||this.tag.hasEffectsWhenCalledAtPath(O,this.callOptions,e)}initialise(){this.callOptions={args:Je,thisParam:null,withNew:!1}}render(e,t){this.tag.render(e,t,{isCalleeOfRenderedParent:!0}),this.quasi.render(e,t)}},TemplateElement:class extends De{bind(){}hasEffects(){return!1}include(){this.included=!0}parseNode(e){this.value=e.value,super.parseNode(e)}render(){}},TemplateLiteral:rs,ThisExpression:class extends De{bind(){this.variable=this.scope.findVariable("this")}deoptimizePath(e){this.variable.deoptimizePath(e)}deoptimizeThisOnEventAtPath(e,t,s,i){this.variable.deoptimizeThisOnEventAtPath(e,t,s===this?this.variable:s,i)}hasEffectsWhenAccessedAtPath(e,t){return e.length>0&&this.variable.hasEffectsWhenAccessedAtPath(e,t)}hasEffectsWhenAssignedAtPath(e,t){return this.variable.hasEffectsWhenAssignedAtPath(e,t)}include(){this.included||(this.included=!0,this.context.includeVariableInModule(this.variable))}initialise(){this.alias=this.scope.findLexicalBoundary()instanceof Fi?this.context.moduleContext:null,"undefined"===this.alias&&this.context.warn({code:"THIS_IS_UNDEFINED",message:"The 'this' keyword is equivalent to 'undefined' at the top level of an ES module, and has been rewritten",url:"https://rollupjs.org/guide/en/#error-this-is-undefined"},this.start)}render(e){null!==this.alias&&e.overwrite(this.start,this.end,this.alias,{contentOnly:!1,storeName:!0})}},ThrowStatement:class extends De{hasEffects(){return!0}include(e,t){this.included=!0,this.argument.include(e,t),e.brokenFlow=2}render(e,t){this.argument.render(e,t,{preventASI:!0}),this.argument.start===this.start+5&&e.prependLeft(this.start+5," ")}},TryStatement:class extends De{constructor(){super(...arguments),this.directlyIncluded=!1,this.includedLabelsAfterBlock=null}hasEffects(e){return(this.context.options.treeshake.tryCatchDeoptimization?this.block.body.length>0:this.block.hasEffects(e))||null!==this.finalizer&&this.finalizer.hasEffects(e)}include(e,t){var s;const i=null===(s=this.context.options.treeshake)||void 0===s?void 0:s.tryCatchDeoptimization,{brokenFlow:n}=e;if(this.directlyIncluded&&i){if(this.includedLabelsAfterBlock)for(const t of this.includedLabelsAfterBlock)e.includedLabels.add(t)}else this.included=!0,this.directlyIncluded=!0,this.block.include(e,i?Me:t),e.includedLabels.size>0&&(this.includedLabelsAfterBlock=[...e.includedLabels]),e.brokenFlow=n;null!==this.handler&&(this.handler.include(e,t),e.brokenFlow=n),null!==this.finalizer&&this.finalizer.include(e,t)}},UnaryExpression:class extends De{constructor(){super(...arguments),this.deoptimized=!1}getLiteralValueAtPath(e,t,s){if(e.length>0)return j;const i=this.argument.getLiteralValueAtPath(O,t,s);return i===j?j:zi[this.operator](i)}hasEffects(e){return this.deoptimized||this.applyDeoptimizations(),!("typeof"===this.operator&&this.argument instanceof Tt)&&(this.argument.hasEffects(e)||"delete"===this.operator&&this.argument.hasEffectsWhenAssignedAtPath(O,e))}hasEffectsWhenAccessedAtPath(e){return"void"===this.operator?e.length>0:e.length>1}applyDeoptimizations(){this.deoptimized=!0,"delete"===this.operator&&(this.argument.deoptimizePath(O),this.context.requestTreeshakingPass())}},UnknownNode:class extends De{hasEffects(){return!0}include(e){super.include(e,!0)}},UpdateExpression:class extends De{constructor(){super(...arguments),this.deoptimized=!1}hasEffects(e){return this.deoptimized||this.applyDeoptimizations(),this.argument.hasEffects(e)||this.argument.hasEffectsWhenAssignedAtPath(O,e)}hasEffectsWhenAccessedAtPath(e){return e.length>1}render(e,t){const{exportNamesByVariable:s,format:i,snippets:{_:n}}=t;if(this.argument.render(e,t),"system"===i){const i=this.argument.variable,r=s.get(i);if(r)if(this.prefix)1===r.length?Ke(i,this.start,this.end,e,t):Xe(i,this.start,this.end,this.parent.type!==xe,e,t);else{const s=this.operator[0];!function(e,t,s,i,n,r,a){const{_:o}=r.snippets;n.prependRight(t,`${qe([e],r,a)},${o}`),i&&(n.prependRight(t,"("),n.appendLeft(s,")"))}(i,this.start,this.end,this.parent.type!==xe,e,t,`${n}${s}${n}1`)}}}applyDeoptimizations(){this.deoptimized=!0,this.argument.deoptimizePath(O),this.argument instanceof Tt&&(this.scope.findVariable(this.argument.name).isReassigned=!0),this.context.requestTreeshakingPass()}},VariableDeclaration:os,VariableDeclarator:class extends De{declareDeclarator(e){this.id.declare(e,this.init||tt)}deoptimizePath(e){this.id.deoptimizePath(e)}hasEffects(e){const t=null!==this.init&&this.init.hasEffects(e);return this.id.markDeclarationReached(),t||this.id.hasEffects(e)}include(e,t){this.included=!0,this.init&&this.init.include(e,t),this.id.markDeclarationReached(),(t||this.id.shouldBeIncluded(e))&&this.id.include(e,t)}render(e,t){const{exportNamesByVariable:s,snippets:{_:i}}=t,n=this.id.included;if(n)this.id.render(e,t);else{const t=Fe(e.original,"=",this.id.end);e.remove(this.start,We(e.original,t+1))}this.init?this.init.render(e,t,n?K:{renderedSurroundingElement:xe}):this.id instanceof Tt&&as(this.id.variable,s)&&e.appendLeft(this.end,`${i}=${i}void 0`)}},WhileStatement:class extends De{hasEffects(e){if(this.test.hasEffects(e))return!0;const{brokenFlow:t,ignore:{breaks:s,continues:i}}=e;return e.ignore.breaks=!0,e.ignore.continues=!0,!!this.body.hasEffects(e)||(e.ignore.breaks=s,e.ignore.continues=i,e.brokenFlow=t,!1)}include(e,t){this.included=!0,this.test.include(e,t);const{brokenFlow:s}=e;this.body.includeAsSingleStatement(e,t),e.brokenFlow=s}},YieldExpression:class extends De{constructor(){super(...arguments),this.deoptimized=!1}hasEffects(e){return this.deoptimized||this.applyDeoptimizations(),!e.ignore.returnYield||null!==this.argument&&this.argument.hasEffects(e)}render(e,t){this.argument&&(this.argument.render(e,t,{preventASI:!0}),this.argument.start===this.start+5&&e.prependLeft(this.start+5," "))}applyDeoptimizations(){this.deoptimized=!0;const{argument:e}=this;e&&(e.deoptimizePath(L),this.context.requestTreeshakingPass())}}},ji="_missingExportShim";class Ui extends H{constructor(e){super(ji),this.module=e}include(){super.include(),this.module.needsExportShim=!0}}class Gi extends H{constructor(e){super(e.getModuleName()),this.memberVariables=null,this.mergedNamespaces=[],this.referencedEarly=!1,this.references=[],this.context=e,this.module=e.module}addReference(e){this.references.push(e),this.name=e.name}getMemberVariables(){if(this.memberVariables)return this.memberVariables;const e=Object.create(null);for(const t of this.context.getExports().concat(this.context.getReexports()))if("*"!==t[0]&&t!==this.module.info.syntheticNamedExports){const s=this.context.traceExport(t);s&&(e[t]=s)}return this.memberVariables=e}include(){this.included=!0,this.context.includeAllExports()}prepare(e){this.mergedNamespaces.length>0&&this.module.scope.addAccessedGlobals([Us],e)}renderBlock(e){const{exportNamesByVariable:t,format:s,freeze:i,indent:n,namespaceToStringTag:r,snippets:{_:a,cnst:o,getObject:h,getPropertyAccess:l,n:c,s:u}}=e,d=this.getMemberVariables(),p=Object.entries(d).map((([e,t])=>this.referencedEarly||t.isReassigned?[null,`get ${e}${a}()${a}{${a}return ${t.getName(l)}${u}${a}}`]:[e,t.getName(l)]));r&&p.unshift([null,`[Symbol.toStringTag]:${a}'Module'`]),p.unshift([null,`__proto__:${a}null`]);let f=h(p,{lineBreakIndent:{base:"",t:n}});return this.mergedNamespaces.length>0&&(f=`/*#__PURE__*/_mergeNamespaces(${f}, [${this.mergedNamespaces.map((e=>e.getName(l))).join(`,${a}`)}])`),i&&(f=`/*#__PURE__*/Object.freeze(${f})`),f=`${o} ${this.getName(l)}${a}=${a}${f};`,"system"===s&&t.has(this)&&(f+=`${c}${qe([this],e)};`),f}renderFirst(){return this.referencedEarly}setMergedNamespaces(e){this.mergedNamespaces=e;const t=this.context.getModuleExecIndex();for(const e of this.references)if(e.context.getModuleExecIndex()<=t){this.referencedEarly=!0;break}}}Gi.prototype.isNamespace=!0;class Hi extends H{constructor(e,t,s){super(t),this.baseVariable=null,this.context=e,this.module=e.module,this.syntheticNamespace=s}getBaseVariable(){if(this.baseVariable)return this.baseVariable;let e=this.syntheticNamespace;for(;e instanceof Bi||e instanceof Hi;){if(e instanceof Bi){const t=e.getOriginalVariable();if(t===e)break;e=t}e instanceof Hi&&(e=e.syntheticNamespace)}return this.baseVariable=e}getBaseVariableName(){return this.syntheticNamespace.getBaseVariableName()}getName(e){return`${this.syntheticNamespace.getName(e)}${e(this.name)}`}include(){this.included=!0,this.context.includeVariableInModule(this.syntheticNamespace)}setRenderNames(e,t){super.setRenderNames(e,t)}}function qi(e){return e.id}const Ki=()=>{};let Xi=()=>[0,0],Yi=()=>0,Qi=()=>0,Zi={};function Ji(e,t){switch(t){case 1:return`# ${e}`;case 2:return`## ${e}`;case 3:return e;default:return`${"  ".repeat(t-4)}- ${e}`}}function en(e,t=3){e=Ji(e,t),Zi.hasOwnProperty(e)||(Zi[e]={memory:0,startMemory:void 0,startTime:void 0,time:0,totalMemory:0});const s=Qi();Zi[e].startTime=Xi(),Zi[e].startMemory=s}function tn(e,t=3){if(e=Ji(e,t),Zi.hasOwnProperty(e)){const t=Qi();Zi[e].time+=Yi(Zi[e].startTime),Zi[e].totalMemory=Math.max(Zi[e].totalMemory,t),Zi[e].memory+=t-Zi[e].startMemory}}function sn(){const e={};for(const[t,{time:s,memory:i,totalMemory:n}]of Object.entries(Zi))e[t]=[s,i,n];return e}let nn=Ki,rn=Ki;const an={load:!0,resolveDynamicImport:!0,resolveId:!0,transform:!0};function on(e,t){const s={};for(const i of Object.keys(e))if(!0===an[i]){let n=`plugin ${t}`;e.name&&(n+=` (${e.name})`),n+=` - ${i}`,s[i]=function(...t){nn(n,4);let r=e[i].apply(this===s?e:this,t);return rn(n,4),r&&"function"==typeof r.then&&(nn(`${n} (async)`,4),r=r.then((e=>(rn(`${n} (async)`,4),e)))),r}}else s[i]=e[i];return s}function hn(e){e.perf?(Zi={},"undefined"!=typeof process&&"function"==typeof process.hrtime?(Xi=process.hrtime.bind(process),Yi=e=>{return 1e3*(t=process.hrtime(e))[0]+t[1]/1e6;var t}):"undefined"!=typeof performance&&"function"==typeof performance.now&&(Xi=()=>[performance.now(),0],Yi=e=>performance.now()-e[0]),"undefined"!=typeof process&&"function"==typeof process.memoryUsage&&(Qi=()=>process.memoryUsage().heapUsed),nn=en,rn=tn,e.plugins=e.plugins.map(on)):(nn=Ki,rn=Ki)}function ln(e){e.isExecuted=!0;const t=[e],s=new Set;for(const e of t)for(const i of[...e.dependencies,...e.implicitlyLoadedBefore])i instanceof oe||i.isExecuted||!i.info.hasModuleSideEffects&&!e.implicitlyLoadedBefore.has(i)||s.has(i.id)||(i.isExecuted=!0,s.add(i.id),t.push(i))}const cn={identifier:null,localName:ji};function un(e,t,s,i,n=new Map,r){const a=n.get(t);if(a){if(a.has(e))return i?null:ci((o=t,h=e.id,{code:di.CIRCULAR_REEXPORT,id:h,message:`"${o}" cannot be exported from ${re(h)} as it is a reexport that references itself.`}));a.add(e)}else n.set(t,new Set([e]));var o,h;return e.getVariableForExportName(t,{importerForSideEffects:s,isExportAllSearch:i,searchedNamesAndModules:n,skipExternalNamespaceReexports:r})}class dn{constructor(e,t,s,i,n,r,a){this.graph=e,this.id=t,this.options=s,this.alternativeReexportModules=new Map,this.ast=null,this.chunkFileNames=new Set,this.chunkName=null,this.cycles=new Set,this.dependencies=new Set,this.dynamicDependencies=new Set,this.dynamicImporters=[],this.dynamicImports=[],this.execIndex=1/0,this.exportAllSources=new Set,this.exports=Object.create(null),this.exportsAll=Object.create(null),this.implicitlyLoadedAfter=new Set,this.implicitlyLoadedBefore=new Set,this.importDescriptions=Object.create(null),this.importMetas=[],this.importedFromNotTreeshaken=!1,this.importers=[],this.imports=new Set,this.includedDynamicImporters=[],this.isExecuted=!1,this.isUserDefinedEntryPoint=!1,this.needsExportShim=!1,this.preserveSignature=this.options.preserveEntrySignatures,this.reexportDescriptions=Object.create(null),this.sideEffectDependenciesByVariable=new Map,this.sources=new Set,this.userChunkNames=new Set,this.usesTopLevelAwait=!1,this.allExportNames=null,this.exportAllModules=[],this.exportNamesByVariable=null,this.exportShimVariable=new Ui(this),this.namespaceReexportsByName=Object.create(null),this.relevantDependencies=null,this.syntheticExports=new Map,this.syntheticNamespace=null,this.transformDependencies=[],this.transitiveReexports=null,this.excludeFromSourcemap=/\0/.test(t),this.context=s.moduleContext(t);const o=this;this.info={ast:null,code:null,get dynamicallyImportedIds(){const e=[];for(const{id:t}of o.dynamicImports)t&&e.push(t);return e},get dynamicImporters(){return o.dynamicImporters.sort()},hasModuleSideEffects:n,id:t,get implicitlyLoadedAfterOneOf(){return Array.from(o.implicitlyLoadedAfter,qi)},get implicitlyLoadedBefore(){return Array.from(o.implicitlyLoadedBefore,qi)},get importedIds(){return Array.from(o.sources,(e=>o.resolvedIds[e].id))},get importers(){return o.importers.sort()},isEntry:i,isExternal:!1,meta:a,syntheticNamedExports:r}}basename(){const e=I(this.id),t=_(this.id);return se(t?e.slice(0,-t.length):e)}bindReferences(){this.ast.bind()}error(e,t){return this.addLocationToLogProps(e,t),ci(e)}getAllExportNames(){if(this.allExportNames)return this.allExportNames;const e=this.allExportNames=new Set;for(const t of Object.keys(this.exports))e.add(t);for(const t of Object.keys(this.reexportDescriptions))e.add(t);for(const t of this.exportAllModules)if(t instanceof oe)e.add(`*${t.id}`);else for(const s of t.getAllExportNames())"default"!==s&&e.add(s);return e}getDependenciesToBeIncluded(){if(this.relevantDependencies)return this.relevantDependencies;const e=new Set,t=new Set,s=new Set;let i=this.imports.keys();if(this.info.isEntry||this.includedDynamicImporters.length>0||this.namespace.included||this.implicitlyLoadedAfter.size>0){i=new Set(i);for(const e of[...this.getReexports(),...this.getExports()]){const t=this.getVariableForExportName(e);t&&i.add(t)}}for(let e of i){const i=this.sideEffectDependenciesByVariable.get(e);if(i)for(const e of i)s.add(e);e instanceof Hi?e=e.getBaseVariable():e instanceof Bi&&(e=e.getOriginalVariable()),t.add(e.module)}if(this.options.treeshake&&"no-treeshake"!==this.info.hasModuleSideEffects)this.addRelevantSideEffectDependencies(e,t,s);else for(const t of this.dependencies)e.add(t);for(const s of t)e.add(s);return this.relevantDependencies=e}getExportNamesByVariable(){if(this.exportNamesByVariable)return this.exportNamesByVariable;const e=new Map;for(const t of this.getAllExportNames()){if(t===this.info.syntheticNamedExports)continue;let s=this.getVariableForExportName(t);if(s instanceof Bi&&(s=s.getOriginalVariable()),!s||!(s.included||s instanceof q))continue;const i=e.get(s);i?i.push(t):e.set(s,[t])}return this.exportNamesByVariable=e}getExports(){return Object.keys(this.exports)}getReexports(){if(this.transitiveReexports)return this.transitiveReexports;this.transitiveReexports=[];const e=new Set;for(const t in this.reexportDescriptions)e.add(t);for(const t of this.exportAllModules)if(t instanceof oe)e.add(`*${t.id}`);else for(const s of[...t.getReexports(),...t.getExports()])"default"!==s&&e.add(s);return this.transitiveReexports=[...e]}getRenderedExports(){const e=[],t=[];for(const s in this.exports){const i=this.getVariableForExportName(s);(i&&i.included?e:t).push(s)}return{removedExports:t,renderedExports:e}}getSyntheticNamespace(){return null===this.syntheticNamespace&&(this.syntheticNamespace=void 0,this.syntheticNamespace=this.getVariableForExportName("string"==typeof this.info.syntheticNamedExports?this.info.syntheticNamedExports:"default")),this.syntheticNamespace?this.syntheticNamespace:ci((e=this.id,t=this.info.syntheticNamedExports,{code:di.SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT,id:e,message:`Module "${re(e)}" that is marked with 'syntheticNamedExports: ${JSON.stringify(t)}' needs ${"string"==typeof t&&"default"!==t?`an export named "${t}"`:"a default export"} that does not reexport an unresolved named export of the same module.`}));var e,t}getVariableForExportName(e,{importerForSideEffects:t,isExportAllSearch:s,searchedNamesAndModules:i,skipExternalNamespaceReexports:n}=X){if("*"===e[0])return 1===e.length?this.namespace:this.graph.modulesById.get(e.slice(1)).getVariableForExportName("*");const r=this.reexportDescriptions[e];if(r){const e=un(r.module,r.localName,t,!1,i,!1);return e?(t&&pn(e,t,this),e):this.error(gi(r.localName,this.id,r.module.id),r.start)}const a=this.exports[e];if(a){if(a===cn)return this.exportShimVariable;const e=a.localName,s=this.traceVariable(e,t);return t&&(R(t.sideEffectDependenciesByVariable,s,(()=>new Set)).add(this),pn(s,t,this)),s}if("default"!==e){const s=e in this.namespaceReexportsByName?this.namespaceReexportsByName[e]:this.getVariableFromNamespaceReexports(e,t,i,n);if(n||(this.namespaceReexportsByName[e]=s),s)return s}if(this.info.syntheticNamedExports){let t=this.syntheticExports.get(e);if(!t){const s=this.getSyntheticNamespace();return t=new Hi(this.astContext,e,s),this.syntheticExports.set(e,t),t}return t}return!s&&this.options.shimMissingExports?(this.shimMissingExport(e),this.exportShimVariable):null}hasEffects(){return"no-treeshake"===this.info.hasModuleSideEffects||this.ast.included&&this.ast.hasEffects(de())}include(){const e=ue();this.ast.shouldBeIncluded(e)&&this.ast.include(e,!1)}includeAllExports(e){this.isExecuted||(ln(this),this.graph.needsTreeshakingPass=!0);for(const t of this.getExports())if(e||t!==this.info.syntheticNamedExports){const e=this.getVariableForExportName(t);e.deoptimizePath(L),e.included||this.includeVariable(e)}for(const e of this.getReexports()){const t=this.getVariableForExportName(e);t&&(t.deoptimizePath(L),t.included||this.includeVariable(t),t instanceof q&&(t.module.reexported=!0))}e&&this.namespace.setMergedNamespaces(this.includeAndGetAdditionalMergedNamespaces())}includeAllInBundle(){this.ast.include(ue(),!0),this.includeAllExports(!1)}isIncluded(){return this.ast.included||this.namespace.included||this.importedFromNotTreeshaken}linkImports(){this.addModulesToImportDescriptions(this.importDescriptions),this.addModulesToImportDescriptions(this.reexportDescriptions);for(const e in this.exports)"default"!==e&&e!==this.info.syntheticNamedExports&&(this.exportsAll[e]=this.id);const e=[];for(const t of this.exportAllSources){const s=this.graph.modulesById.get(this.resolvedIds[t].id);if(s instanceof oe)e.push(s);else{this.exportAllModules.push(s);for(const e in s.exportsAll)e in this.exportsAll?this.options.onwarn(Ei(e,this,s)):this.exportsAll[e]=s.exportsAll[e]}}this.exportAllModules.push(...e)}render(e){const t=this.magicString.clone();return this.ast.render(t,e),this.usesTopLevelAwait=this.astContext.usesTopLevelAwait,t}setSource({ast:e,code:t,customTransformCache:s,originalCode:i,originalSourcemap:n,resolvedIds:r,sourcemapChain:a,transformDependencies:o,transformFiles:h,...l}){this.info.code=t,this.originalCode=i,this.originalSourcemap=n,this.sourcemapChain=a,h&&(this.transformFiles=h),this.transformDependencies=o,this.customTransformCache=s,this.updateOptions(l),nn("generate ast",3),e||(e=this.tryParse()),rn("generate ast",3),this.resolvedIds=r||Object.create(null);const c=this.id;this.magicString=new A(t,{filename:this.excludeFromSourcemap?null:c,indentExclusionRanges:[]}),nn("analyse ast",3),this.astContext={addDynamicImport:this.addDynamicImport.bind(this),addExport:this.addExport.bind(this),addImport:this.addImport.bind(this),addImportMeta:this.addImportMeta.bind(this),code:t,deoptimizationTracker:this.graph.deoptimizationTracker,error:this.error.bind(this),fileName:c,getExports:this.getExports.bind(this),getModuleExecIndex:()=>this.execIndex,getModuleName:this.basename.bind(this),getReexports:this.getReexports.bind(this),importDescriptions:this.importDescriptions,includeAllExports:()=>this.includeAllExports(!0),includeDynamicImport:this.includeDynamicImport.bind(this),includeVariableInModule:this.includeVariableInModule.bind(this),magicString:this.magicString,module:this,moduleContext:this.context,nodeConstructors:Wi,options:this.options,requestTreeshakingPass:()=>this.graph.needsTreeshakingPass=!0,traceExport:this.getVariableForExportName.bind(this),traceVariable:this.traceVariable.bind(this),usesTopLevelAwait:!1,warn:this.warn.bind(this)},this.scope=new Fi(this.graph.scope,this.astContext),this.namespace=new Gi(this.astContext),this.ast=new ns(e,{context:this.astContext,type:"Module"},this.scope),this.info.ast=e,rn("analyse ast",3)}toJSON(){return{ast:this.ast.esTreeNode,code:this.info.code,customTransformCache:this.customTransformCache,dependencies:Array.from(this.dependencies,qi),id:this.id,meta:this.info.meta,moduleSideEffects:this.info.hasModuleSideEffects,originalCode:this.originalCode,originalSourcemap:this.originalSourcemap,resolvedIds:this.resolvedIds,sourcemapChain:this.sourcemapChain,syntheticNamedExports:this.info.syntheticNamedExports,transformDependencies:this.transformDependencies,transformFiles:this.transformFiles}}traceVariable(e,t){const s=this.scope.variables.get(e);if(s)return s;if(e in this.importDescriptions){const s=this.importDescriptions[e],i=s.module;if(i instanceof dn&&"*"===s.name)return i.namespace;const n=i.getVariableForExportName(s.name,{importerForSideEffects:t||this});return n||this.error(gi(s.name,this.id,i.id),s.start)}return null}tryParse(){try{return this.graph.contextParse(this.info.code)}catch(e){let t=e.message.replace(/ \(\d+:\d+\)$/,"");return this.id.endsWith(".json")?t+=" (Note that you need @rollup/plugin-json to import JSON files)":this.id.endsWith(".js")||(t+=" (Note that you need plugins to import files that are not JavaScript)"),this.error({code:"PARSE_ERROR",message:t,parserError:e},e.pos)}}updateOptions({meta:e,moduleSideEffects:t,syntheticNamedExports:s}){null!=t&&(this.info.hasModuleSideEffects=t),null!=s&&(this.info.syntheticNamedExports=s),null!=e&&(this.info.meta={...this.info.meta,...e})}warn(e,t){this.addLocationToLogProps(e,t),this.options.onwarn(e)}addDynamicImport(e){let t=e.source;t instanceof rs?1===t.quasis.length&&t.quasis[0].value.cooked&&(t=t.quasis[0].value.cooked):t instanceof is&&"string"==typeof t.value&&(t=t.value),this.dynamicImports.push({argument:t,id:null,node:e,resolution:null})}addExport(e){if(e instanceof ss)this.exports.default={identifier:e.variable.getAssignedVariableName(),localName:"default"};else if(e instanceof Oe){const t=e.source.value;if(this.sources.add(t),e.exported){const s=e.exported.name;this.reexportDescriptions[s]={localName:"*",module:null,source:t,start:e.start}}else this.exportAllSources.add(t)}else if(e.source instanceof is){const t=e.source.value;this.sources.add(t);for(const s of e.specifiers){const e=s.exported.name;this.reexportDescriptions[e]={localName:s.local.name,module:null,source:t,start:s.start}}}else if(e.declaration){const t=e.declaration;if(t instanceof os)for(const e of t.declarations)for(const t of le(e.id))this.exports[t]={identifier:null,localName:t};else{const e=t.id.name;this.exports[e]={identifier:null,localName:e}}}else for(const t of e.specifiers){const e=t.local.name,s=t.exported.name;this.exports[s]={identifier:null,localName:e}}}addImport(e){const t=e.source.value;this.sources.add(t);for(const s of e.specifiers){const e="ImportDefaultSpecifier"===s.type,i="ImportNamespaceSpecifier"===s.type,n=e?"default":i?"*":s.imported.name;this.importDescriptions[s.local.name]={module:null,name:n,source:t,start:s.start}}}addImportMeta(e){this.importMetas.push(e)}addLocationToLogProps(e,t){e.id=this.id,e.pos=t;let s=this.info.code;const i=ce(s,t,{offsetLine:1});if(i){let{column:n,line:r}=i;try{({column:n,line:r}=function(e,t){const s=e.filter((e=>e.mappings));for(;s.length>0;){const e=s.pop(),i=e.mappings[t.line-1];let n=!1;if(void 0!==i)for(const s of i)if(s[0]>=t.column){if(1===s.length)break;t={column:s[3],line:s[2]+1,name:5===s.length?e.names[s[4]]:void 0,source:e.sources[s[1]]},n=!0;break}if(!n)throw new Error("Can't resolve original location of error.")}return t}(this.sourcemapChain,{column:n,line:r})),s=this.originalCode}catch(e){this.options.onwarn({code:"SOURCEMAP_ERROR",id:this.id,loc:{column:n,file:this.id,line:r},message:`Error when using sourcemap for reporting an error: ${e.message}`,pos:t})}ui(e,{column:n,line:r},s,this.id)}}addModulesToImportDescriptions(e){for(const t of Object.values(e)){const e=this.resolvedIds[t.source].id;t.module=this.graph.modulesById.get(e)}}addRelevantSideEffectDependencies(e,t,s){const i=new Set,n=r=>{for(const a of r)i.has(a)||(i.add(a),t.has(a)?e.add(a):(a.info.hasModuleSideEffects||s.has(a))&&(a instanceof oe||a.hasEffects()?e.add(a):n(a.dependencies)))};n(this.dependencies),n(s)}getVariableFromNamespaceReexports(e,t,s,i=!1){let n=null;const r=[{searchedNamesAndModules:s,skipExternalNamespaces:!0}];if(!i){const e=new Map;for(const[t,i]of s||[])e.set(t,new Set(i));r.push({searchedNamesAndModules:e,skipExternalNamespaces:!1})}for(const{skipExternalNamespaces:s,searchedNamesAndModules:i}of r){const r=new Set;for(const a of this.exportAllModules)if(a instanceof dn||!s){const o=un(a,e,t,!0,i,s);o&&(o instanceof Hi?n||(n=o):r.add(o))}if(1===r.size)return[...r][0];if(r.size>1){if(s)return null;const t=[...r],i=t[0];return this.options.onwarn(xi(e,this.id,i.module.id,t.map((e=>e.module.id)))),i}}return n||null}includeAndGetAdditionalMergedNamespaces(){const e=new Set,t=new Set;for(const s of[this,...this.exportAllModules])if(s instanceof oe){const t=s.getVariableForExportName("*");t.include(),this.imports.add(t),e.add(t)}else if(s.info.syntheticNamedExports){const e=s.getSyntheticNamespace();e.include(),this.imports.add(e),t.add(e)}return[...t,...e]}includeDynamicImport(e){const t=this.dynamicImports.find((t=>t.node===e)).resolution;t instanceof dn&&(t.includedDynamicImporters.push(this),t.includeAllExports(!0))}includeVariable(e){if(!e.included){e.include(),this.graph.needsTreeshakingPass=!0;const t=e.module;if(t&&t instanceof dn&&(t.isExecuted||ln(t),t!==this)){const t=function(e,t){const s=R(t.sideEffectDependenciesByVariable,e,(()=>new Set));let i=e;const n=new Set([i]);for(;;){const e=i.module;if(i=i instanceof Bi?i.getDirectOriginalVariable():i instanceof Hi?i.syntheticNamespace:null,!i||n.has(i))break;n.add(i),s.add(e);const t=e.sideEffectDependenciesByVariable.get(i);if(t)for(const e of t)s.add(e)}return s}(e,this);for(const e of t)e.isExecuted||ln(e)}}}includeVariableInModule(e){this.includeVariable(e);const t=e.module;t&&t!==this&&this.imports.add(e)}shimMissingExport(e){this.options.onwarn({code:"SHIMMED_EXPORT",exporter:re(this.id),exportName:e,message:`Missing export "${e}" has been shimmed in module ${re(this.id)}.`}),this.exports[e]=cn}}function pn(e,t,s){if(e.module instanceof dn&&e.module!==s){const i=e.module.cycles;if(i.size>0){const n=s.cycles;for(const r of n)if(i.has(r)){t.alternativeReexportModules.set(e,s);break}}}}function fn(e){return e.endsWith(".js")?e.slice(0,-3):e}function mn(e,t){return e.autoId?`${e.basePath?e.basePath+"/":""}${fn(t)}`:e.id||""}function gn(e,t,s,i,n,r,a,o="return "){const{_:h,cnst:l,getDirectReturnFunction:c,getFunctionIntro:u,getPropertyAccess:d,n:p,s:f}=n;if(!s)return`${p}${p}${o}${function(e,t,s,i,n){if(e.length>0)return e[0].local;for(const{defaultVariableName:e,id:r,isChunk:a,name:o,namedExportsMode:h,namespaceVariableName:l,reexports:c}of t)if(c)return yn(o,c[0].imported,h,a,e,l,s,r,i,n)}(e,t,i,a,d)};`;let m="";for(const{defaultVariableName:e,id:n,isChunk:o,name:l,namedExportsMode:u,namespaceVariableName:f,reexports:g}of t)if(g&&s)for(const t of g)if("*"!==t.reexported){const s=yn(l,t.imported,u,o,e,f,i,n,a,d);if(m&&(m+=p),"*"!==t.imported&&t.needsLiveBinding){const[e,i]=c([],{functionReturn:!0,lineBreakIndent:null,name:null});m+=`Object.defineProperty(exports,${h}'${t.reexported}',${h}{${p}${r}enumerable:${h}true,${p}${r}get:${h}${e}${s}${i}${p}});`}else m+=`exports${d(t.reexported)}${h}=${h}${s};`}for(const{exported:t,local:s}of e){const e=`exports${d(t)}`,i=s;e!==i&&(m&&(m+=p),m+=`${e}${h}=${h}${i};`)}for(const{name:e,reexports:i}of t)if(i&&s)for(const t of i)if("*"===t.reexported){m&&(m+=p);const s=`{${p}${r}if${h}(k${h}!==${h}'default'${h}&&${h}!exports.hasOwnProperty(k))${h}${xn(e,t.needsLiveBinding,r,n)}${f}${p}}`;m+="var"===l&&t.needsLiveBinding?`Object.keys(${e}).forEach(${u(["k"],{isAsync:!1,name:null})}${s});`:`for${h}(${l} k in ${e})${h}${s}`}return m?`${p}${p}${m}`:""}function yn(e,t,s,i,n,r,a,o,h,l){if("default"===t){if(!i){const t=String(a(o)),s=Gs[t]?n:e;return Hs(t,h)?`${s}${l("default")}`:s}return s?`${e}${l("default")}`:e}return"*"===t?(i?!s:qs[String(a(o))])?r:e:`${e}${l(t)}`}function En(e,t,s,i,n){let r="";return e&&(t&&(r+=function(e){return`Object.defineProperty(exports,${e}'__esModule',${e}{${e}value:${e}true${e}});`}(i)),s&&(r&&(r+=n),r+=function(e){return`exports[Symbol.toStringTag]${e}=${e}'Module';`}(i))),r}const xn=(e,t,s,{_:i,getDirectReturnFunction:n,n:r})=>{if(t){const[t,a]=n([],{functionReturn:!0,lineBreakIndent:null,name:null});return`Object.defineProperty(exports,${i}k,${i}{${r}${s}${s}enumerable:${i}true,${r}${s}${s}get:${i}${t}${e}[k]${a}${r}${s}})`}return`exports[k]${i}=${i}${e}[k]`};function vn(e,t,s,i,n,r,a,o){const{_:h,cnst:l,n:c}=o,u=new Set,d=[],p=(e,t,s)=>{u.add(t),d.push(`${l} ${e}${h}=${h}/*#__PURE__*/${t}(${s});`)};for(const{defaultVariableName:s,imports:i,id:n,isChunk:r,name:a,namedExportsMode:o,namespaceVariableName:h,reexports:l}of e)if(r){for(const{imported:e,reexported:t}of[...i||[],...l||[]])if("*"===e&&"*"!==t){o||p(h,js,a);break}}else{const e=String(t(n));let r=!1,o=!1;for(const{imported:t,reexported:n}of[...i||[],...l||[]]){let i,l;"default"===t?r||(r=!0,s!==h&&(l=s,i=Gs[e])):"*"===t&&"*"!==n&&(o||(o=!0,i=qs[e],l=h)),i&&p(l,i,a)}}return`${Xs(u,r,a,o,s,i,n)}${d.length>0?`${d.join(c)}${c}${c}`:""}`}function bn(e){return"."===e[0]?fn(e):e}const An={assert:!0,buffer:!0,console:!0,constants:!0,domain:!0,events:!0,http:!0,https:!0,os:!0,path:!0,process:!0,punycode:!0,querystring:!0,stream:!0,string_decoder:!0,timers:!0,tty:!0,url:!0,util:!0,vm:!0,zlib:!0};function Sn(e,t){const s=t.map((({id:e})=>e)).filter((e=>e in An));s.length&&e({code:"MISSING_NODE_BUILTINS",message:`Creating a browser bundle that depends on Node.js built-in modules (${ie(s)}). You might need to include https://github.com/snowpackjs/rollup-plugin-polyfill-node`,modules:s})}const Pn=(e,t)=>e.split(".").map(t).join("");function kn(e,t,s,i,{_:n,getPropertyAccess:r}){const a=e.split(".");a[0]=("function"==typeof s?s(a[0]):s[a[0]])||a[0];const o=a.pop();let h=t,l=a.map((e=>(h+=r(e),`${h}${n}=${n}${h}${n}||${n}{}`))).concat(`${h}${r(o)}`).join(`,${n}`)+`${n}=${n}${i}`;return a.length>0&&(l=`(${l})`),l}function wn(e){let t=e.length;for(;t--;){const{imports:s,reexports:i}=e[t];if(s||i)return e.slice(0,t+1)}return[]}const Cn=({dependencies:e,exports:t})=>{const s=new Set(t.map((e=>e.exported)));s.add("default");for(const{reexports:t}of e)if(t)for(const e of t)"*"!==e.reexported&&s.add(e.reexported);return s},In=(e,t,{_:s,cnst:i,getObject:n,n:r})=>e?`${r}${t}${i} _starExcludes${s}=${s}${n([...e].map((e=>[e,"1"])),{lineBreakIndent:{base:t,t:t}})};`:"",Nn=(e,t,{_:s,n:i})=>e.length?`${i}${t}var ${e.join(`,${s}`)};`:"",_n=(e,t,s)=>$n(e.filter((e=>e.hoisted)).map((e=>({name:e.exported,value:e.local}))),t,s);function $n(e,t,{_:s,n:i}){return 0===e.length?"":1===e.length?`exports('${e[0].name}',${s}${e[0].value});${i}${i}`:`exports({${i}`+e.map((({name:e,value:i})=>`${t}${e}:${s}${i}`)).join(`,${i}`)+`${i}});${i}${i}`}const Tn=(e,t,s)=>$n(e.filter((e=>e.expression)).map((e=>({name:e.exported,value:e.local}))),t,s),Rn=(e,t,s)=>$n(e.filter((e=>e.local===ji)).map((e=>({name:e.exported,value:ji}))),t,s);function Mn(e,t,s){return e?`${t}${Pn(e,s)}`:"null"}var Dn={amd:function(e,{accessedGlobals:t,dependencies:s,exports:i,hasExports:n,id:r,indent:a,intro:o,isEntryFacade:h,isModuleFacade:l,namedExportsMode:c,outro:u,snippets:d,warn:p},{amd:f,esModule:m,externalLiveBindings:g,freeze:y,interop:E,namespaceToStringTag:x,strict:v}){Sn(p,s);const b=s.map((e=>`'${bn(e.id)}'`)),A=s.map((e=>e.name)),{n:S,getNonArrowFunctionIntro:P,_:k}=d;c&&n&&(A.unshift("exports"),b.unshift("'exports'")),t.has("require")&&(A.unshift("require"),b.unshift("'require'")),t.has("module")&&(A.unshift("module"),b.unshift("'module'"));const w=mn(f,r),C=(w?`'${w}',${k}`:"")+(b.length?`[${b.join(`,${k}`)}],${k}`:""),I=v?`${k}'use strict';`:"";e.prepend(`${o}${vn(s,E,g,y,x,t,a,d)}`);const N=gn(i,s,c,E,d,a,g);let _=En(c&&n,h&&m,l&&x,k,S);return _&&(_=S+S+_),e.append(`${N}${_}${u}`),e.indent(a).prepend(`${f.define}(${C}(${P(A,{isAsync:!1,name:null})}{${I}${S}${S}`).append(`${S}${S}}));`)},cjs:function(e,{accessedGlobals:t,dependencies:s,exports:i,hasExports:n,indent:r,intro:a,isEntryFacade:o,isModuleFacade:h,namedExportsMode:l,outro:c,snippets:u},{compact:d,esModule:p,externalLiveBindings:f,freeze:m,interop:g,namespaceToStringTag:y,strict:E}){const{_:x,n:v}=u,b=E?`'use strict';${v}${v}`:"";let A=En(l&&n,o&&p,h&&y,x,v);A&&(A+=v+v);const S=function(e,{_:t,cnst:s,n:i},n){let r="",a=!1;for(const{id:o,name:h,reexports:l,imports:c}of e)l||c?(r+=n&&a?",":`${r?`;${i}`:""}${s} `,a=!0,r+=`${h}${t}=${t}require('${o}')`):(r&&(r+=n&&!a?",":`;${i}`),a=!1,r+=`require('${o}')`);return r?`${r};${i}${i}`:""}(s,u,d),P=vn(s,g,f,m,y,t,r,u);e.prepend(`${b}${a}${A}${S}${P}`);const k=gn(i,s,l,g,u,r,f,`module.exports${x}=${x}`);return e.append(`${k}${c}`)},es:function(e,{accessedGlobals:t,indent:s,intro:i,outro:n,dependencies:r,exports:a,snippets:o},{externalLiveBindings:h,freeze:l,namespaceToStringTag:c}){const{_:u,n:d}=o,p=function(e,t){const s=[];for(const{id:i,reexports:n,imports:r,name:a}of e)if(n||r){if(r){let e=null,n=null;const a=[];for(const t of r)"default"===t.imported?e=t:"*"===t.imported?n=t:a.push(t);n&&s.push(`import${t}*${t}as ${n.local} from${t}'${i}';`),e&&0===a.length?s.push(`import ${e.local} from${t}'${i}';`):a.length>0&&s.push(`import ${e?`${e.local},${t}`:""}{${t}${a.map((e=>e.imported===e.local?e.imported:`${e.imported} as ${e.local}`)).join(`,${t}`)}${t}}${t}from${t}'${i}';`)}if(n){let e=null;const o=[],h=[];for(const t of n)"*"===t.reexported?e=t:"*"===t.imported?o.push(t):h.push(t);if(e&&s.push(`export${t}*${t}from${t}'${i}';`),o.length>0){r&&r.some((e=>"*"===e.imported&&e.local===a))||s.push(`import${t}*${t}as ${a} from${t}'${i}';`);for(const e of o)s.push(`export${t}{${t}${a===e.reexported?a:`${a} as ${e.reexported}`} };`)}h.length>0&&s.push(`export${t}{${t}${h.map((e=>e.imported===e.reexported?e.imported:`${e.imported} as ${e.reexported}`)).join(`,${t}`)}${t}}${t}from${t}'${i}';`)}}else s.push(`import${t}'${i}';`);return s}(r,u);p.length>0&&(i+=p.join(d)+d+d),(i+=Xs(null,t,s,o,h,l,c))&&e.prepend(i);const f=function(e,{_:t,cnst:s}){const i=[],n=[];for(const r of e)r.expression&&i.push(`${s} ${r.local}${t}=${t}${r.expression};`),n.push(r.exported===r.local?r.local:`${r.local} as ${r.exported}`);return n.length&&i.push(`export${t}{${t}${n.join(`,${t}`)}${t}};`),i}(a,o);return f.length&&e.append(d+d+f.join(d).trim()),n&&e.append(n),e.trim()},iife:function(e,{accessedGlobals:t,dependencies:s,exports:i,hasExports:n,indent:r,intro:a,namedExportsMode:o,outro:h,snippets:l,warn:c},{compact:u,esModule:d,extend:p,freeze:f,externalLiveBindings:m,globals:g,interop:y,name:E,namespaceToStringTag:x,strict:v}){const{_:b,cnst:A,getNonArrowFunctionIntro:S,getPropertyAccess:P,n:k}=l,w=E&&-1!==E.indexOf("."),C=!p&&!w;if(E&&C&&(te(I=E)||J.has(I)||ee.test(I)))return ci({code:"ILLEGAL_IDENTIFIER_AS_NAME",message:`Given name "${E}" is not a legal JS identifier. If you need this, you can try "output.extend: true".`});var I;Sn(c,s);const N=wn(s),_=N.map((e=>e.globalName||"null")),$=N.map((e=>e.name));n&&!E&&c({code:"MISSING_NAME_OPTION_FOR_IIFE_EXPORT",message:'If you do not supply "output.name", you may not be able to access the exports of an IIFE bundle.'}),o&&n&&(p?(_.unshift(`this${Pn(E,P)}${b}=${b}this${Pn(E,P)}${b}||${b}{}`),$.unshift("exports")):(_.unshift("{}"),$.unshift("exports")));const T=v?`${r}'use strict';${k}`:"",R=vn(s,y,m,f,x,t,r,l);e.prepend(`${a}${R}`);let M=`(${S($,{isAsync:!1,name:null})}{${k}${T}${k}`;n&&(!E||p&&o||(M=(C?`${A} ${E}`:`this${Pn(E,P)}`)+`${b}=${b}${M}`),w&&(M=function(e,t,s,{_:i,getPropertyAccess:n,s:r},a){const o=e.split(".");o[0]=("function"==typeof s?s(o[0]):s[o[0]])||o[0],o.pop();let h=t;return o.map((e=>(h+=n(e),`${h}${i}=${i}${h}${i}||${i}{}${r}`))).join(a?",":"\n")+(a&&o.length?";":"\n")}(E,"this",g,l,u)+M));let D=`${k}${k}})(${_.join(`,${b}`)});`;n&&!p&&o&&(D=`${k}${k}${r}return exports;${D}`);const O=gn(i,s,o,y,l,r,m);let L=En(o&&n,d,x,b,k);return L&&(L=k+k+L),e.append(`${O}${L}${h}`),e.indent(r).prepend(M).append(D)},system:function(e,{accessedGlobals:t,dependencies:s,exports:i,hasExports:n,indent:r,intro:a,snippets:o,outro:h,usesTopLevelAwait:l},{externalLiveBindings:c,freeze:u,name:d,namespaceToStringTag:p,strict:f,systemNullSetters:m}){const{_:g,getFunctionIntro:y,getNonArrowFunctionIntro:E,n:x,s:v}=o,{importBindings:b,setters:A,starExcludes:S}=function(e,t,s,{_:i,cnst:n,getObject:r,getPropertyAccess:a,n:o}){const h=[],l=[];let c=null;for(const{imports:u,reexports:d}of e){const p=[];if(u)for(const e of u)h.push(e.local),"*"===e.imported?p.push(`${e.local}${i}=${i}module;`):p.push(`${e.local}${i}=${i}module${a(e.imported)};`);if(d){const o=[];let h=!1;for(const{imported:e,reexported:t}of d)"*"===t?h=!0:o.push([t,"*"===e?"module":`module${a(e)}`]);if(o.length>1||h){const a=r(o,{lineBreakIndent:null});h?(c||(c=Cn({dependencies:e,exports:t})),p.push(`${n} setter${i}=${i}${a};`,`for${i}(${n} name in module)${i}{`,`${s}if${i}(!_starExcludes[name])${i}setter[name]${i}=${i}module[name];`,"}","exports(setter);")):p.push(`exports(${a});`)}else{const[e,t]=o[0];p.push(`exports('${e}',${i}${t});`)}}l.push(p.join(`${o}${s}${s}${s}`))}return{importBindings:h,setters:l,starExcludes:c}}(s,i,r,o),P=d?`'${d}',${g}`:"",k=t.has("module")?["exports","module"]:n?["exports"]:[];let w=`System.register(${P}[`+s.map((({id:e})=>`'${e}'`)).join(`,${g}`)+`],${g}(${E(k,{isAsync:!1,name:null})}{${x}${r}${f?"'use strict';":""}`+In(S,r,o)+Nn(b,r,o)+`${x}${r}return${g}{${A.length?`${x}${r}${r}setters:${g}[${A.map((e=>e?`${y(["module"],{isAsync:!1,name:null})}{${x}${r}${r}${r}${e}${x}${r}${r}}`:m?"null":`${y([],{isAsync:!1,name:null})}{}`)).join(`,${g}`)}],`:""}${x}`;w+=`${r}${r}execute:${g}(${E([],{isAsync:l,name:null})}{${x}${x}`;const C=`${r}${r}})${x}${r}}${v}${x}}));`;return e.prepend(a+Xs(null,t,r,o,c,u,p)+_n(i,r,o)),e.append(`${h}${x}${x}`+Tn(i,r,o)+Rn(i,r,o)),e.indent(`${r}${r}${r}`).append(C).prepend(w)},umd:function(e,{accessedGlobals:t,dependencies:s,exports:i,hasExports:n,id:r,indent:a,intro:o,namedExportsMode:h,outro:l,snippets:c,warn:u},{amd:d,compact:p,esModule:f,extend:m,externalLiveBindings:g,freeze:y,interop:E,name:x,namespaceToStringTag:v,globals:b,noConflict:A,strict:S}){const{_:P,cnst:k,getFunctionIntro:w,getNonArrowFunctionIntro:C,getPropertyAccess:I,n:N,s:_}=c,$=p?"f":"factory",T=p?"g":"global";if(n&&!x)return ci({code:"MISSING_NAME_OPTION_FOR_IIFE_EXPORT",message:'You must supply "output.name" for UMD bundles that have exports so that the exports are accessible in environments without a module loader.'});Sn(u,s);const R=s.map((e=>`'${bn(e.id)}'`)),M=s.map((e=>`require('${e.id}')`)),D=wn(s),O=D.map((e=>Mn(e.globalName,T,I))),L=D.map((e=>e.name));h&&(n||A)&&(R.unshift("'exports'"),M.unshift("exports"),O.unshift(kn(x,T,b,(m?`${Mn(x,T,I)}${P}||${P}`:"")+"{}",c)),L.unshift("exports"));const V=mn(d,r),B=(V?`'${V}',${P}`:"")+(R.length?`[${R.join(`,${P}`)}],${P}`:""),F=d.define,z=!h&&n?`module.exports${P}=${P}`:"",W=S?`${P}'use strict';${N}`:"";let j;if(A){const e=p?"e":"exports";let t;t=!h&&n?`${k} ${e}${P}=${P}${kn(x,T,b,`${$}(${O.join(`,${P}`)})`,c)};`:`${k} ${e}${P}=${P}${O.shift()};${N}${a}${a}${$}(${[e].concat(O).join(`,${P}`)});`,j=`(${w([],{isAsync:!1,name:null})}{${N}${a}${a}${k} current${P}=${P}${function(e,t,{_:s,getPropertyAccess:i}){let n=t;return e.split(".").map((e=>n+=i(e))).join(`${s}&&${s}`)}(x,T,c)};${N}${a}${a}${t}${N}${a}${a}${e}.noConflict${P}=${P}${w([],{isAsync:!1,name:null})}{${P}${Mn(x,T,I)}${P}=${P}current;${P}return ${e}${_}${P}};${N}${a}})()`}else j=`${$}(${O.join(`,${P}`)})`,!h&&n&&(j=kn(x,T,b,j,c));const U=n||A&&h||O.length>0,G=[$];U&&G.unshift(T);const H=U?`this,${P}`:"",q=U?`(${T}${P}=${P}typeof globalThis${P}!==${P}'undefined'${P}?${P}globalThis${P}:${P}${T}${P}||${P}self,${P}`:"",K=U?")":"",X=U?`${a}typeof exports${P}===${P}'object'${P}&&${P}typeof module${P}!==${P}'undefined'${P}?${P}${z}${$}(${M.join(`,${P}`)})${P}:${N}`:"",Y=`(${C(G,{isAsync:!1,name:null})}{${N}`+X+`${a}typeof ${F}${P}===${P}'function'${P}&&${P}${F}.amd${P}?${P}${F}(${B}${$})${P}:${N}`+`${a}${q}${j}${K};${N}`+`})(${H}(${C(L,{isAsync:!1,name:null})}{${W}${N}`,Q=N+N+"}));";e.prepend(`${o}${vn(s,E,g,y,v,t,a,c)}`);const Z=gn(i,s,h,E,c,a,g);let J=En(h&&n,f,v,P,N);return J&&(J=N+N+J),e.append(`${Z}${J}${l}`),e.trim().indent(a).append(Q).prepend(Y)}};class On{constructor(e,t){this.isOriginal=!0,this.filename=e,this.content=t}traceSegment(e,t,s){return{column:t,line:e,name:s,source:this}}}class Ln{constructor(e,t){this.sources=t,this.names=e.names,this.mappings=e.mappings}traceMappings(){const e=[],t=[],s=[],i=new Map,n=[];for(const r of this.mappings){const a=[];for(const n of r){if(1==n.length)continue;const r=this.sources[n[1]];if(!r)continue;const o=r.traceSegment(n[2],n[3],5===n.length?this.names[n[4]]:"");if(o){let r=e.lastIndexOf(o.source.filename);if(-1===r)r=e.length,e.push(o.source.filename),t[r]=o.source.content;else if(null==t[r])t[r]=o.source.content;else if(null!=o.source.content&&t[r]!==o.source.content)return ci({message:`Multiple conflicting contents for sourcemap source ${o.source.filename}`});const h=[n[0],r,o.line,o.column];if(o.name){let e=i.get(o.name);void 0===e&&(e=s.length,s.push(o.name),i.set(o.name,e)),h[4]=e}a.push(h)}}n.push(a)}return{mappings:n,names:s,sources:e,sourcesContent:t}}traceSegment(e,t,s){const i=this.mappings[e];if(!i)return null;let n=0,r=i.length-1;for(;n<=r;){const e=n+r>>1,a=i[e];if(a[0]===t){if(1==a.length)return null;const e=this.sources[a[1]];return e?e.traceSegment(a[2],a[3],5===a.length?this.names[a[4]]:s):null}a[0]>t?r=e-1:n=e+1}return null}}function Vn(e){return function(t,s){return s.mappings?new Ln(s,[t]):(e({code:"SOURCEMAP_BROKEN",message:`Sourcemap is likely to be incorrect: a plugin (${s.plugin}) was used to transform files, but didn't generate a sourcemap for the transformation. Consult the plugin documentation for help`,plugin:s.plugin,url:"https://rollupjs.org/guide/en/#warning-sourcemap-is-likely-to-be-incorrect"}),new Ln({mappings:[],names:[]},[t]))}}function Bn(e,t,s,i,n){let r;if(s){const t=s.sources,i=s.sourcesContent||[],n=N(e)||".",a=s.sourceRoot||".",o=t.map(((e,t)=>new On(T(n,a,e),i[t])));r=new Ln(s,o)}else r=new On(e,t);return i.reduce(n,r)}var Fn={},zn=Wn;function Wn(e,t){if(!e)throw new Error(t||"Assertion failed")}Wn.equal=function(e,t,s){if(e!=t)throw new Error(s||"Assertion failed: "+e+" != "+t)};var jn={exports:{}};"function"==typeof Object.create?jn.exports=function(e,t){t&&(e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}))}:jn.exports=function(e,t){if(t){e.super_=t;var s=function(){};s.prototype=t.prototype,e.prototype=new s,e.prototype.constructor=e}};var Un=zn,Gn=jn.exports;function Hn(e,t){return 55296==(64512&e.charCodeAt(t))&&!(t<0||t+1>=e.length)&&56320==(64512&e.charCodeAt(t+1))}function qn(e){return(e>>>24|e>>>8&65280|e<<8&16711680|(255&e)<<24)>>>0}function Kn(e){return 1===e.length?"0"+e:e}function Xn(e){return 7===e.length?"0"+e:6===e.length?"00"+e:5===e.length?"000"+e:4===e.length?"0000"+e:3===e.length?"00000"+e:2===e.length?"000000"+e:1===e.length?"0000000"+e:e}Fn.inherits=Gn,Fn.toArray=function(e,t){if(Array.isArray(e))return e.slice();if(!e)return[];var s=[];if("string"==typeof e)if(t){if("hex"===t)for((e=e.replace(/[^a-z0-9]+/gi,"")).length%2!=0&&(e="0"+e),n=0;n<e.length;n+=2)s.push(parseInt(e[n]+e[n+1],16))}else for(var i=0,n=0;n<e.length;n++){var r=e.charCodeAt(n);r<128?s[i++]=r:r<2048?(s[i++]=r>>6|192,s[i++]=63&r|128):Hn(e,n)?(r=65536+((1023&r)<<10)+(1023&e.charCodeAt(++n)),s[i++]=r>>18|240,s[i++]=r>>12&63|128,s[i++]=r>>6&63|128,s[i++]=63&r|128):(s[i++]=r>>12|224,s[i++]=r>>6&63|128,s[i++]=63&r|128)}else for(n=0;n<e.length;n++)s[n]=0|e[n];return s},Fn.toHex=function(e){for(var t="",s=0;s<e.length;s++)t+=Kn(e[s].toString(16));return t},Fn.htonl=qn,Fn.toHex32=function(e,t){for(var s="",i=0;i<e.length;i++){var n=e[i];"little"===t&&(n=qn(n)),s+=Xn(n.toString(16))}return s},Fn.zero2=Kn,Fn.zero8=Xn,Fn.join32=function(e,t,s,i){var n=s-t;Un(n%4==0);for(var r=new Array(n/4),a=0,o=t;a<r.length;a++,o+=4){var h;h="big"===i?e[o]<<24|e[o+1]<<16|e[o+2]<<8|e[o+3]:e[o+3]<<24|e[o+2]<<16|e[o+1]<<8|e[o],r[a]=h>>>0}return r},Fn.split32=function(e,t){for(var s=new Array(4*e.length),i=0,n=0;i<e.length;i++,n+=4){var r=e[i];"big"===t?(s[n]=r>>>24,s[n+1]=r>>>16&255,s[n+2]=r>>>8&255,s[n+3]=255&r):(s[n+3]=r>>>24,s[n+2]=r>>>16&255,s[n+1]=r>>>8&255,s[n]=255&r)}return s},Fn.rotr32=function(e,t){return e>>>t|e<<32-t},Fn.rotl32=function(e,t){return e<<t|e>>>32-t},Fn.sum32=function(e,t){return e+t>>>0},Fn.sum32_3=function(e,t,s){return e+t+s>>>0},Fn.sum32_4=function(e,t,s,i){return e+t+s+i>>>0},Fn.sum32_5=function(e,t,s,i,n){return e+t+s+i+n>>>0},Fn.sum64=function(e,t,s,i){var n=e[t],r=i+e[t+1]>>>0,a=(r<i?1:0)+s+n;e[t]=a>>>0,e[t+1]=r},Fn.sum64_hi=function(e,t,s,i){return(t+i>>>0<t?1:0)+e+s>>>0},Fn.sum64_lo=function(e,t,s,i){return t+i>>>0},Fn.sum64_4_hi=function(e,t,s,i,n,r,a,o){var h=0,l=t;return h+=(l=l+i>>>0)<t?1:0,h+=(l=l+r>>>0)<r?1:0,e+s+n+a+(h+=(l=l+o>>>0)<o?1:0)>>>0},Fn.sum64_4_lo=function(e,t,s,i,n,r,a,o){return t+i+r+o>>>0},Fn.sum64_5_hi=function(e,t,s,i,n,r,a,o,h,l){var c=0,u=t;return c+=(u=u+i>>>0)<t?1:0,c+=(u=u+r>>>0)<r?1:0,c+=(u=u+o>>>0)<o?1:0,e+s+n+a+h+(c+=(u=u+l>>>0)<l?1:0)>>>0},Fn.sum64_5_lo=function(e,t,s,i,n,r,a,o,h,l){return t+i+r+o+l>>>0},Fn.rotr64_hi=function(e,t,s){return(t<<32-s|e>>>s)>>>0},Fn.rotr64_lo=function(e,t,s){return(e<<32-s|t>>>s)>>>0},Fn.shr64_hi=function(e,t,s){return e>>>s},Fn.shr64_lo=function(e,t,s){return(e<<32-s|t>>>s)>>>0};var Yn={},Qn=Fn,Zn=zn;function Jn(){this.pending=null,this.pendingTotal=0,this.blockSize=this.constructor.blockSize,this.outSize=this.constructor.outSize,this.hmacStrength=this.constructor.hmacStrength,this.padLength=this.constructor.padLength/8,this.endian="big",this._delta8=this.blockSize/8,this._delta32=this.blockSize/32}Yn.BlockHash=Jn,Jn.prototype.update=function(e,t){if(e=Qn.toArray(e,t),this.pending?this.pending=this.pending.concat(e):this.pending=e,this.pendingTotal+=e.length,this.pending.length>=this._delta8){var s=(e=this.pending).length%this._delta8;this.pending=e.slice(e.length-s,e.length),0===this.pending.length&&(this.pending=null),e=Qn.join32(e,0,e.length-s,this.endian);for(var i=0;i<e.length;i+=this._delta32)this._update(e,i,i+this._delta32)}return this},Jn.prototype.digest=function(e){return this.update(this._pad()),Zn(null===this.pending),this._digest(e)},Jn.prototype._pad=function(){var e=this.pendingTotal,t=this._delta8,s=t-(e+this.padLength)%t,i=new Array(s+this.padLength);i[0]=128;for(var n=1;n<s;n++)i[n]=0;if(e<<=3,"big"===this.endian){for(var r=8;r<this.padLength;r++)i[n++]=0;i[n++]=0,i[n++]=0,i[n++]=0,i[n++]=0,i[n++]=e>>>24&255,i[n++]=e>>>16&255,i[n++]=e>>>8&255,i[n++]=255&e}else for(i[n++]=255&e,i[n++]=e>>>8&255,i[n++]=e>>>16&255,i[n++]=e>>>24&255,i[n++]=0,i[n++]=0,i[n++]=0,i[n++]=0,r=8;r<this.padLength;r++)i[n++]=0;return i};var er={},tr=Fn.rotr32;function sr(e,t,s){return e&t^~e&s}function ir(e,t,s){return e&t^e&s^t&s}function nr(e,t,s){return e^t^s}er.ft_1=function(e,t,s,i){return 0===e?sr(t,s,i):1===e||3===e?nr(t,s,i):2===e?ir(t,s,i):void 0},er.ch32=sr,er.maj32=ir,er.p32=nr,er.s0_256=function(e){return tr(e,2)^tr(e,13)^tr(e,22)},er.s1_256=function(e){return tr(e,6)^tr(e,11)^tr(e,25)},er.g0_256=function(e){return tr(e,7)^tr(e,18)^e>>>3},er.g1_256=function(e){return tr(e,17)^tr(e,19)^e>>>10};var rr=Fn,ar=Yn,or=er,hr=zn,lr=rr.sum32,cr=rr.sum32_4,ur=rr.sum32_5,dr=or.ch32,pr=or.maj32,fr=or.s0_256,mr=or.s1_256,gr=or.g0_256,yr=or.g1_256,Er=ar.BlockHash,xr=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298];function vr(){if(!(this instanceof vr))return new vr;Er.call(this),this.h=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225],this.k=xr,this.W=new Array(64)}rr.inherits(vr,Er);var br=vr;vr.blockSize=512,vr.outSize=256,vr.hmacStrength=192,vr.padLength=64,vr.prototype._update=function(e,t){for(var s=this.W,i=0;i<16;i++)s[i]=e[t+i];for(;i<s.length;i++)s[i]=cr(yr(s[i-2]),s[i-7],gr(s[i-15]),s[i-16]);var n=this.h[0],r=this.h[1],a=this.h[2],o=this.h[3],h=this.h[4],l=this.h[5],c=this.h[6],u=this.h[7];for(hr(this.k.length===s.length),i=0;i<s.length;i++){var d=ur(u,mr(h),dr(h,l,c),this.k[i],s[i]),p=lr(fr(n),pr(n,r,a));u=c,c=l,l=h,h=lr(o,d),o=a,a=r,r=n,n=lr(d,p)}this.h[0]=lr(this.h[0],n),this.h[1]=lr(this.h[1],r),this.h[2]=lr(this.h[2],a),this.h[3]=lr(this.h[3],o),this.h[4]=lr(this.h[4],h),this.h[5]=lr(this.h[5],l),this.h[6]=lr(this.h[6],c),this.h[7]=lr(this.h[7],u)},vr.prototype._digest=function(e){return"hex"===e?rr.toHex32(this.h,"big"):rr.split32(this.h,"big")};var Ar=br;const Sr=()=>Ar(),Pr={amd:Cr,cjs:Cr,es:wr,iife:Cr,system:wr,umd:Cr};function kr(e,t,s,i,n,r,a,o,h,l,c,u,d){const p=e.slice().reverse();for(const e of p)e.scope.addUsedOutsideNames(i,n,c,u);!function(e,t,s){for(const i of t){for(const t of i.scope.variables.values())t.included&&!(t.renderBaseName||t instanceof Bi&&t.getOriginalVariable()!==t)&&t.setRenderNames(null,Ze(t.name,e));if(s.has(i)){const t=i.namespace;t.setRenderNames(null,Ze(t.name,e))}}}(i,p,d),Pr[n](i,s,t,r,a,o,h,l);for(const e of p)e.scope.deconflict(n,c,u)}function wr(e,t,s,i,n,r,a,o){for(const t of s.dependencies)(n||t instanceof oe)&&(t.variableName=Ze(t.suggestedVariableName,e));for(const s of t){const t=s.module,i=s.name;s.isNamespace&&(n||t instanceof oe)?s.setRenderNames(null,(t instanceof oe?t:a.get(t)).variableName):t instanceof oe&&"default"===i?s.setRenderNames(null,Ze([...t.exportedVariables].some((([e,t])=>"*"===t&&e.included))?t.suggestedVariableName+"__default":t.suggestedVariableName,e)):s.setRenderNames(null,Ze(i,e))}for(const t of o)t.setRenderNames(null,Ze(t.name,e))}function Cr(e,t,{deconflictedDefault:s,deconflictedNamespace:i,dependencies:n},r,a,o,h){for(const t of n)t.variableName=Ze(t.suggestedVariableName,e);for(const t of i)t.namespaceVariableName=Ze(`${t.suggestedVariableName}__namespace`,e);for(const t of s)i.has(t)&&Ks(String(r(t.id)),o)?t.defaultVariableName=t.namespaceVariableName:t.defaultVariableName=Ze(`${t.suggestedVariableName}__default`,e);for(const e of t){const t=e.module;if(t instanceof oe){const s=e.name;if("default"===s){const s=String(r(t.id)),i=Gs[s]?t.defaultVariableName:t.variableName;Hs(s,o)?e.setRenderNames(i,"default"):e.setRenderNames(null,i)}else"*"===s?e.setRenderNames(null,qs[String(r(t.id))]?t.namespaceVariableName:t.variableName):e.setRenderNames(t.variableName,null)}else{const s=h.get(t);a&&e.isNamespace?e.setRenderNames(null,"default"===s.exportMode?s.namespaceVariableName:s.variableName):"default"===s.exportMode?e.setRenderNames(null,s.variableName):e.setRenderNames(s.variableName,s.getVariableExportName(e))}}}const Ir=/[\\'\r\n\u2028\u2029]/,Nr=/(['\r\n\u2028\u2029])/g,_r=/\\/g;function $r(e){return e.match(Ir)?e.replace(_r,"\\\\").replace(Nr,"\\$1"):e}function Tr(e,{exports:t,name:s,format:i},n,r,a){const o=e.getExportNames();if("default"===t){if(1!==o.length||"default"!==o[0])return ci(fi("default",o,r))}else if("none"===t&&o.length)return ci(fi("none",o,r));return"auto"===t&&(0===o.length?t="none":1===o.length&&"default"===o[0]?("cjs"===i&&n.has("exports")&&a(function(e){const t=re(e);return{code:di.PREFER_NAMED_EXPORTS,id:e,message:`Entry module "${t}" is implicitly using "default" export mode, which means for CommonJS output that its default export is assigned to "module.exports". For many tools, such CommonJS output will not be interchangeable with the original ES module. If this is intended, explicitly set "output.exports" to either "auto" or "default", otherwise you might want to consider changing the signature of "${t}" to use named exports only.`,url:"https://rollupjs.org/guide/en/#outputexports"}}(r)),t="default"):("es"!==i&&"system"!==i&&-1!==o.indexOf("default")&&a(function(e,t){return{code:di.MIXED_EXPORTS,id:e,message:`Entry module "${re(e)}" is using named and default exports together. Consumers of your bundle will have to use \`${t||"chunk"}["default"]\` to access the default export, which may not be what you want. Use \`output.exports: "named"\` to disable this warning`,url:"https://rollupjs.org/guide/en/#outputexports"}}(r,s)),t="named")),t}function Rr(e){const t=e.split("\n"),s=t.filter((e=>/^\t+/.test(e))),i=t.filter((e=>/^ {2,}/.test(e)));if(0===s.length&&0===i.length)return null;if(s.length>=i.length)return"\t";const n=i.reduce(((e,t)=>{const s=/^ +/.exec(t)[0].length;return Math.min(s,e)}),1/0);return new Array(n+1).join(" ")}function Mr(e,t,s,i,n){const r=e.getDependenciesToBeIncluded();for(const e of r){if(e instanceof oe){t.push(e);continue}const r=n.get(e);r===i?s.has(e)||(s.add(e),Mr(e,t,s,i,n)):t.push(r)}}function Dr(e){if(!e)return null;if("string"==typeof e&&(e=JSON.parse(e)),""===e.mappings)return{mappings:[],names:[],sources:[],version:3};let t;return t="string"==typeof e.mappings?function(e){for(var t=[],i=[],n=[0,0,0,0,0],a=0,o=0,h=0,l=0;o<e.length;o++){var c=e.charCodeAt(o);if(44===c)r(i,n,a),a=0;else if(59===c)r(i,n,a),a=0,t.push(i),i=[],n[0]=0;else{var u=s[c];if(void 0===u)throw new Error("Invalid character ("+String.fromCharCode(c)+")");var d=32&u;if(l+=(u&=31)<<h,d)h+=5;else{var p=1&l;l>>>=1,p&&(l=0===l?-2147483648:-l),n[a]+=l,a++,l=h=0}}}return r(i,n,a),t.push(i),t}(e.mappings):e.mappings,{...e,mappings:t}}function Or(e,t,s){return ae(e)?ci(Ai(`Invalid pattern "${e}" for "${t}", patterns can be neither absolute nor relative paths.`)):e.replace(/\[(\w+)\]/g,((e,i)=>{if(!s.hasOwnProperty(i))return ci(Ai(`"[${i}]" is not a valid placeholder in "${t}" pattern.`));const n=s[i]();return ae(n)?ci(Ai(`Invalid substitution "${n}" for placeholder "[${i}]" in "${t}" pattern, can be neither absolute nor relative path.`)):n}))}function Lr(e,t){const s=new Set(Object.keys(t).map((e=>e.toLowerCase())));if(!s.has(e.toLocaleLowerCase()))return e;const i=_(e);e=e.substr(0,e.length-i.length);let n,r=1;for(;s.has((n=e+ ++r+i).toLowerCase()););return n}const Vr=[".js",".jsx",".ts",".tsx"];function Br(e,t,s,i){const n="function"==typeof t?t(e.id):t[e.id];return n||(s?(i({code:"MISSING_GLOBAL_NAME",guess:e.variableName,message:`No name was provided for external module '${e.id}' in output.globals – guessing '${e.variableName}'`,source:e.id}),e.variableName):void 0)}class Fr{constructor(e,t,s,i,n,r,a,o,h,l){this.orderedModules=e,this.inputOptions=t,this.outputOptions=s,this.unsetOptions=i,this.pluginDriver=n,this.modulesById=r,this.chunkByModule=a,this.facadeChunkByModule=o,this.includedNamespaces=h,this.manualChunkAlias=l,this.entryModules=[],this.exportMode="named",this.facadeModule=null,this.id=null,this.namespaceVariableName="",this.needsExportsShim=!1,this.variableName="",this.accessedGlobalsByScope=new Map,this.dependencies=new Set,this.dynamicDependencies=new Set,this.dynamicEntryModules=[],this.dynamicName=null,this.exportNamesByVariable=new Map,this.exports=new Set,this.exportsByName=Object.create(null),this.fileName=null,this.implicitEntryModules=[],this.implicitlyLoadedBefore=new Set,this.imports=new Set,this.indentString=void 0,this.isEmpty=!0,this.name=null,this.renderedDependencies=null,this.renderedExports=null,this.renderedHash=void 0,this.renderedModuleSources=new Map,this.renderedModules=Object.create(null),this.renderedSource=null,this.sortedExportNames=null,this.strictFacade=!1,this.usedModules=void 0,this.execIndex=e.length>0?e[0].execIndex:1/0;const c=new Set(e);for(const t of e){t.namespace.included&&h.add(t),this.isEmpty&&t.isIncluded()&&(this.isEmpty=!1),(t.info.isEntry||s.preserveModules)&&this.entryModules.push(t);for(const e of t.includedDynamicImporters)c.has(e)||(this.dynamicEntryModules.push(t),t.info.syntheticNamedExports&&!s.preserveModules&&(h.add(t),this.exports.add(t.namespace)));t.implicitlyLoadedAfter.size>0&&this.implicitEntryModules.push(t)}this.suggestedVariableName=se(this.generateVariableName())}static generateFacade(e,t,s,i,n,r,a,o,h,l){const c=new Fr([],e,t,s,i,n,r,a,o,null);c.assignFacadeName(l,h),a.has(h)||a.set(h,c);for(const e of h.getDependenciesToBeIncluded())c.dependencies.add(e instanceof dn?r.get(e):e);return!c.dependencies.has(r.get(h))&&h.info.hasModuleSideEffects&&h.hasEffects()&&c.dependencies.add(r.get(h)),c.ensureReexportsAreAvailableForModule(h),c.facadeModule=h,c.strictFacade=!0,c}canModuleBeFacade(e,t){const s=e.getExportNamesByVariable();for(const t of this.exports)if(!s.has(t))return 0===s.size&&e.isUserDefinedEntryPoint&&"strict"===e.preserveSignature&&this.unsetOptions.has("preserveEntrySignatures")&&this.inputOptions.onwarn({code:"EMPTY_FACADE",id:e.id,message:`To preserve the export signature of the entry module "${re(e.id)}", an empty facade chunk was created. This often happens when creating a bundle for a web app where chunks are placed in script tags and exports are ignored. In this case it is recommended to set "preserveEntrySignatures: false" to avoid this and reduce the number of chunks. Otherwise if this is intentional, set "preserveEntrySignatures: 'strict'" explicitly to silence this warning.`,url:"https://rollupjs.org/guide/en/#preserveentrysignatures"}),!1;for(const i of t)if(!s.has(i)&&i.module!==e)return!1;return!0}generateExports(){this.sortedExportNames=null;const e=new Set(this.exports);if(null!==this.facadeModule&&(!1!==this.facadeModule.preserveSignature||this.strictFacade)){const t=this.facadeModule.getExportNamesByVariable();for(const[s,i]of t){this.exportNamesByVariable.set(s,[...i]);for(const e of i)this.exportsByName[e]=s;e.delete(s)}}this.outputOptions.minifyInternalExports?function(e,t,s){let i=0;for(const n of e){let e=n.name[0];if(t[e])do{e=Ye(++i),49===e.charCodeAt(0)&&(i+=9*64**(e.length-1),e=Ye(i))}while(Qe[e]||t[e]);t[e]=n,s.set(n,[e])}}(e,this.exportsByName,this.exportNamesByVariable):function(e,t,s){for(const i of e){let e=0,n=i.name;for(;t[n];)n=i.name+"$"+ ++e;t[n]=i,s.set(i,[n])}}(e,this.exportsByName,this.exportNamesByVariable),(this.outputOptions.preserveModules||this.facadeModule&&this.facadeModule.info.isEntry)&&(this.exportMode=Tr(this,this.outputOptions,this.unsetOptions,this.facadeModule.id,this.inputOptions.onwarn))}generateFacades(){var e;const t=[],s=new Set([...this.entryModules,...this.implicitEntryModules]),i=new Set(this.dynamicEntryModules.map((e=>e.namespace)));for(const e of s)if(e.preserveSignature)for(const t of e.getExportNamesByVariable().keys())i.add(t);for(const e of s){const s=Array.from(e.userChunkNames,(e=>({name:e})));if(0===s.length&&e.isUserDefinedEntryPoint&&s.push({}),s.push(...Array.from(e.chunkFileNames,(e=>({fileName:e})))),0===s.length&&s.push({}),!this.facadeModule){const t="strict"===e.preserveSignature||"exports-only"===e.preserveSignature&&0!==e.getExportNamesByVariable().size;(!t||this.outputOptions.preserveModules||this.canModuleBeFacade(e,i))&&(this.facadeModule=e,this.facadeChunkByModule.set(e,this),e.preserveSignature&&(this.strictFacade=t),this.assignFacadeName(s.shift(),e))}for(const i of s)t.push(Fr.generateFacade(this.inputOptions,this.outputOptions,this.unsetOptions,this.pluginDriver,this.modulesById,this.chunkByModule,this.facadeChunkByModule,this.includedNamespaces,e,i))}for(const t of this.dynamicEntryModules)t.info.syntheticNamedExports||(!this.facadeModule&&this.canModuleBeFacade(t,i)?(this.facadeModule=t,this.facadeChunkByModule.set(t,this),this.strictFacade=!0,this.dynamicName=zr(t)):this.facadeModule===t&&!this.strictFacade&&this.canModuleBeFacade(t,i)?this.strictFacade=!0:(null===(e=this.facadeChunkByModule.get(t))||void 0===e?void 0:e.strictFacade)||(this.includedNamespaces.add(t),this.exports.add(t.namespace)));return t}generateId(e,t,s,i){if(null!==this.fileName)return this.fileName;const[n,r]=this.facadeModule&&this.facadeModule.isUserDefinedEntryPoint?[t.entryFileNames,"output.entryFileNames"]:[t.chunkFileNames,"output.chunkFileNames"];return Lr(Or("function"==typeof n?n(this.getChunkInfo()):n,r,{format:()=>t.format,hash:()=>i?this.computeContentHashWithDependencies(e,t,s):"[hash]",name:()=>this.getChunkName()}),s)}generateIdPreserveModules(e,t,s,i){const n=this.orderedModules[0].id,r=this.outputOptions.sanitizeFileName(n);let a;if(k(n)){const s=_(n),o=i.has("entryFileNames")?"[name][assetExtname].js":t.entryFileNames,h=`${N(r)}/${Or("function"==typeof o?o(this.getChunkInfo()):o,"output.entryFileNames",{assetExtname:()=>Vr.includes(s)?"":s,ext:()=>s.substr(1),extname:()=>s,format:()=>t.format,name:()=>this.getChunkName()})}`,{preserveModulesRoot:l}=t;a=l&&h.startsWith(l)?h.slice(l.length).replace(/^[\\/]/,""):$(e,h)}else a=`_virtual/${I(r)}`;return Lr(C(a),s)}getChunkInfo(){const e=this.facadeModule,t=this.getChunkName.bind(this);return{exports:this.getExportNames(),facadeModuleId:e&&e.id,isDynamicEntry:this.dynamicEntryModules.length>0,isEntry:null!==e&&e.info.isEntry,isImplicitEntry:this.implicitEntryModules.length>0,modules:this.renderedModules,get name(){return t()},type:"chunk"}}getChunkInfoWithFileNames(){return Object.assign(this.getChunkInfo(),{code:void 0,dynamicImports:Array.from(this.dynamicDependencies,qi),fileName:this.id,implicitlyLoadedBefore:Array.from(this.implicitlyLoadedBefore,qi),importedBindings:this.getImportedBindingsPerDependency(),imports:Array.from(this.dependencies,qi),map:void 0,referencedFiles:this.getReferencedFiles()})}getChunkName(){return this.name||(this.name=this.outputOptions.sanitizeFileName(this.getFallbackChunkName()))}getExportNames(){return this.sortedExportNames||(this.sortedExportNames=Object.keys(this.exportsByName).sort())}getRenderedHash(){if(this.renderedHash)return this.renderedHash;const e=Sr(),t=this.pluginDriver.hookReduceValueSync("augmentChunkHash","",[this.getChunkInfo()],((e,t)=>(t&&(e+=t),e)));return e.update(t),e.update(this.renderedSource.toString()),e.update(this.getExportNames().map((e=>{const t=this.exportsByName[e];return`${re(t.module.id).replace(/\\/g,"/")}:${t.name}:${e}`})).join(",")),this.renderedHash=e.digest("hex")}getVariableExportName(e){return this.outputOptions.preserveModules&&e instanceof Gi?"*":this.exportNamesByVariable.get(e)[0]}link(){this.dependencies=function(e,t,s){const i=[],n=new Set;for(let r=t.length-1;r>=0;r--){const a=t[r];if(!n.has(a)){const t=[];Mr(a,t,n,e,s),i.unshift(t)}}const r=new Set;for(const e of i)for(const t of e)r.add(t);return r}(this,this.orderedModules,this.chunkByModule);for(const e of this.orderedModules)this.addDependenciesToChunk(e.dynamicDependencies,this.dynamicDependencies),this.addDependenciesToChunk(e.implicitlyLoadedBefore,this.implicitlyLoadedBefore),this.setUpChunkImportsAndExportsForModule(e)}preRender(e,t,s){const{_:i,getPropertyAccess:n,n:r}=s,a=new b({separator:`${r}${r}`});this.usedModules=[],this.indentString=function(e,t){if(!0!==t.indent)return t.indent;for(const t of e){const e=Rr(t.originalCode);if(null!==e)return e}return"\t"}(this.orderedModules,e);const o={dynamicImportFunction:e.dynamicImportFunction,exportNamesByVariable:this.exportNamesByVariable,format:e.format,freeze:e.freeze,indent:this.indentString,namespaceToStringTag:e.namespaceToStringTag,outputPluginDriver:this.pluginDriver,snippets:s};if(e.hoistTransitiveImports&&!this.outputOptions.preserveModules&&null!==this.facadeModule)for(const e of this.dependencies)e instanceof Fr&&this.inlineChunkDependencies(e);this.prepareModulesForRendering(s),this.setIdentifierRenderResolutions(e);let h="";const l=this.renderedModules;for(const t of this.orderedModules){let s=0;if(t.isIncluded()||this.includedNamespaces.has(t)){const i=t.render(o).trim();s=i.length(),s&&(e.compact&&-1!==i.lastLine().indexOf("//")&&i.append("\n"),this.renderedModuleSources.set(t,i),a.addSource(i),this.usedModules.push(t));const n=t.namespace;if(this.includedNamespaces.has(t)&&!this.outputOptions.preserveModules){const e=n.renderBlock(o);n.renderFirst()?h+=r+e:a.addSource(new A(e))}}const{renderedExports:i,removedExports:n}=t.getRenderedExports(),{renderedModuleSources:c}=this;l[t.id]={get code(){var e,s;return null!==(s=null===(e=c.get(t))||void 0===e?void 0:e.toString())&&void 0!==s?s:null},originalLength:t.originalCode.length,removedExports:n,renderedExports:i,renderedLength:s}}if(h&&a.prepend(h+r+r),this.needsExportsShim&&a.prepend(`${r}${s.cnst} _missingExportShim${i}=${i}void 0;${r}${r}`),e.compact?this.renderedSource=a:this.renderedSource=a.trim(),this.renderedHash=void 0,this.isEmpty&&0===this.getExportNames().length&&0===this.dependencies.size){const e=this.getChunkName();this.inputOptions.onwarn({chunkName:e,code:"EMPTY_BUNDLE",message:`Generated an empty chunk: "${e}"`})}this.setExternalRenderPaths(e,t),this.renderedDependencies=this.getChunkDependencyDeclarations(e,n),this.renderedExports="none"===this.exportMode?[]:this.getChunkExportDeclarations(e.format,n)}async render(e,t,s,i){nn("render format",2);const n=e.format,r=Dn[n];e.dynamicImportFunction&&"es"!==n&&this.inputOptions.onwarn(mi("output.dynamicImportFunction","outputdynamicImportFunction",'this option is ignored for formats other than "es"'));for(const e of this.dependencies){const t=this.renderedDependencies.get(e);if(e instanceof oe){const s=e.renderPath;t.id=$r(e.renormalizeRenderPath?this.getRelativePath(s,!1):s)}else t.namedExportsMode="default"!==e.exportMode,t.id=$r(this.getRelativePath(e.id,!1))}this.finaliseDynamicImports(e,i),this.finaliseImportMetas(n,i);const a=0!==this.renderedExports.length||[...this.renderedDependencies.values()].some((e=>e.reexports&&0!==e.reexports.length));let o=!1;const h=new Set;for(const e of this.orderedModules){e.usesTopLevelAwait&&(o=!0);const t=this.accessedGlobalsByScope.get(e.scope);if(t)for(const e of t)h.add(e)}if(o&&"es"!==n&&"system"!==n)return ci({code:"INVALID_TLA_FORMAT",message:`Module format ${n} does not support top-level await. Use the "es" or "system" output formats rather.`});if(!this.id)throw new Error("Internal Error: expecting chunk id");const l=r(this.renderedSource,{accessedGlobals:h,dependencies:[...this.renderedDependencies.values()],exports:this.renderedExports,hasExports:a,id:this.id,indent:this.indentString,intro:t.intro,isEntryFacade:this.outputOptions.preserveModules||null!==this.facadeModule&&this.facadeModule.info.isEntry,isModuleFacade:null!==this.facadeModule,namedExportsMode:"default"!==this.exportMode,outro:t.outro,snippets:i,usesTopLevelAwait:o,warn:this.inputOptions.onwarn},e);t.banner&&l.prepend(t.banner),t.footer&&l.append(t.footer);const u=l.toString();rn("render format",2);let d=null;const p=[];let f=await function({code:e,options:t,outputPluginDriver:s,renderChunk:i,sourcemapChain:n}){return s.hookReduceArg0("renderChunk",[e,i,t],((e,t,s)=>{if(null==t)return e;if("string"==typeof t&&(t={code:t,map:void 0}),null!==t.map){const e=Dr(t.map);n.push(e||{missing:!0,plugin:s.name})}return t.code}))}({code:u,options:e,outputPluginDriver:this.pluginDriver,renderChunk:s,sourcemapChain:p});if(e.sourcemap){let t;nn("sourcemap",2),t=e.file?T(e.sourcemapFile||e.file):e.dir?T(e.dir,this.id):T(this.id);const s=l.generateDecodedMap({});d=function(e,t,s,i,n,r){const a=Vn(r),o=s.filter((e=>!e.excludeFromSourcemap)).map((e=>Bn(e.id,e.originalCode,e.originalSourcemap,e.sourcemapChain,a)));let h=new Ln(t,o);h=i.reduce(a,h);let{sources:l,sourcesContent:u,names:d,mappings:p}=h.traceMappings();if(e){const t=N(e);l=l.map((e=>$(t,e))),e=I(e)}return u=n?null:u,new c({file:e,mappings:p,names:d,sources:l,sourcesContent:u})}(t,s,this.usedModules,p,e.sourcemapExcludeSources,this.inputOptions.onwarn),d.sources=d.sources.map((s=>{const{sourcemapPathTransform:i}=e;if(i){const e=i(s,`${t}.map`);return"string"!=typeof e&&ci(Ai("sourcemapPathTransform function must return a string.")),e}return s})).map(C),rn("sourcemap",2)}return e.compact||"\n"===f[f.length-1]||(f+="\n"),{code:f,map:d}}addDependenciesToChunk(e,t){for(const s of e)if(s instanceof dn){const e=this.chunkByModule.get(s);e&&e!==this&&t.add(e)}else t.add(s)}assignFacadeName({fileName:e,name:t},s){e?this.fileName=e:this.name=this.outputOptions.sanitizeFileName(t||zr(s))}checkCircularDependencyImport(e,t){const s=e.module;if(s instanceof dn){const o=this.chunkByModule.get(s);let h;do{if(h=t.alternativeReexportModules.get(e),h){const l=this.chunkByModule.get(h);l&&l!==o&&this.inputOptions.onwarn((i=s.getExportNamesByVariable().get(e)[0],n=s.id,r=h.id,a=t.id,{code:di.CYCLIC_CROSS_CHUNK_REEXPORT,exporter:n,importer:a,message:`Export "${i}" of module ${re(n)} was reexported through module ${re(r)} while both modules are dependencies of each other and will end up in different chunks by current Rollup settings. This scenario is not well supported at the moment as it will produce a circular dependency between chunks and will likely lead to broken execution order.\nEither change the import in ${re(a)} to point directly to the exporting module or do not use "preserveModules" to ensure these modules end up in the same chunk.`,reexporter:r})),t=h}}while(h)}var i,n,r,a}computeContentHashWithDependencies(e,t,s){const i=Sr();i.update([e.intro,e.outro,e.banner,e.footer].map((e=>e||"")).join(":")),i.update(t.format);const n=new Set([this]);for(const r of n)if(r instanceof oe?i.update(":"+r.renderPath):(i.update(r.getRenderedHash()),i.update(r.generateId(e,t,s,!1))),!(r instanceof oe))for(const e of[...r.dependencies,...r.dynamicDependencies])n.add(e);return i.digest("hex").substr(0,8)}ensureReexportsAreAvailableForModule(e){const t=e.getExportNamesByVariable();for(const s of t.keys()){const t=s instanceof Hi,i=t?s.getBaseVariable():s;if(!(i instanceof Gi&&this.outputOptions.preserveModules)){this.checkCircularDependencyImport(i,e);const s=i.module;if(s instanceof dn){const e=this.chunkByModule.get(s);e&&e!==this&&(e.exports.add(i),t&&this.imports.add(i))}}}}finaliseDynamicImports(e,t){const s="amd"===e.format;for(const[e,i]of this.renderedModuleSources)for(const{node:n,resolution:r}of e.dynamicImports){const e=this.chunkByModule.get(r),a=this.facadeChunkByModule.get(r);if(!r||!n.included||e===this)continue;const o=r instanceof dn?`'${this.getRelativePath((a||e).id,s)}'`:r instanceof oe?`'${r.renormalizeRenderPath?this.getRelativePath(r.renderPath,s):r.renderPath}'`:r;n.renderFinalResolution(i,o,r instanceof dn&&!(null==a?void 0:a.strictFacade)&&e.exportNamesByVariable.get(r.namespace)[0],t)}}finaliseImportMetas(e,t){for(const[s,i]of this.renderedModuleSources)for(const n of s.importMetas)n.renderFinalMechanism(i,this.id,e,t,this.pluginDriver)}generateVariableName(){if(this.manualChunkAlias)return this.manualChunkAlias;const e=this.entryModules[0]||this.implicitEntryModules[0]||this.dynamicEntryModules[0]||this.orderedModules[this.orderedModules.length-1];return e?e.chunkName||ne(e.id):"chunk"}getChunkDependencyDeclarations(e,t){const s=this.getImportSpecifiers(t),i=this.getReexportSpecifiers(),n=new Map;for(const t of this.dependencies){const r=s.get(t)||null,a=i.get(t)||null,o=t instanceof oe||"default"!==t.exportMode;n.set(t,{defaultVariableName:t.defaultVariableName,globalName:t instanceof oe&&("umd"===e.format||"iife"===e.format)&&Br(t,e.globals,null!==(r||a),this.inputOptions.onwarn),id:void 0,imports:r,isChunk:t instanceof Fr,name:t.variableName,namedExportsMode:o,namespaceVariableName:t.namespaceVariableName,reexports:a})}return n}getChunkExportDeclarations(e,t){const s=[];for(const i of this.getExportNames()){if("*"===i[0])continue;const n=this.exportsByName[i];if(!(n instanceof Hi)){const e=n.module;if(e&&this.chunkByModule.get(e)!==this)continue}let r=null,a=!1,o=n.getName(t);if(n instanceof mt){for(const e of n.declarations)if(e.parent instanceof ts||e instanceof ss&&e.declaration instanceof ts){a=!0;break}}else n instanceof Hi&&(r=o,"es"===e&&(o=n.renderName));s.push({exported:i,expression:r,hoisted:a,local:o})}return s}getDependenciesToBeDeconflicted(e,t,s){const i=new Set,n=new Set,r=new Set;for(const t of[...this.exportNamesByVariable.keys(),...this.imports])if(e||t.isNamespace){const a=t.module;if(a instanceof oe)i.add(a),e&&("default"===t.name?Gs[String(s(a.id))]&&n.add(a):"*"===t.name&&qs[String(s(a.id))]&&r.add(a));else{const s=this.chunkByModule.get(a);s!==this&&(i.add(s),e&&"default"===s.exportMode&&t.isNamespace&&r.add(s))}}if(t)for(const e of this.dependencies)i.add(e);return{deconflictedDefault:n,deconflictedNamespace:r,dependencies:i}}getFallbackChunkName(){return this.manualChunkAlias?this.manualChunkAlias:this.dynamicName?this.dynamicName:this.fileName?ne(this.fileName):ne(this.orderedModules[this.orderedModules.length-1].id)}getImportSpecifiers(e){const{interop:t}=this.outputOptions,s=new Map;for(const i of this.imports){const n=i.module;let r,a;if(n instanceof oe){if(r=n,a=i.name,"default"!==a&&"*"!==a&&"defaultOnly"===t(n.id))return ci(vi(n.id,a,!1))}else r=this.chunkByModule.get(n),a=r.getVariableExportName(i);R(s,r,(()=>[])).push({imported:a,local:i.getName(e)})}return s}getImportedBindingsPerDependency(){const e={};for(const[t,s]of this.renderedDependencies){const i=new Set;if(s.imports)for(const{imported:e}of s.imports)i.add(e);if(s.reexports)for(const{imported:e}of s.reexports)i.add(e);e[t.id]=[...i]}return e}getReexportSpecifiers(){const{externalLiveBindings:e,interop:t}=this.outputOptions,s=new Map;for(let i of this.getExportNames()){let n,r,a=!1;if("*"===i[0]){const s=i.substr(1);"defaultOnly"===t(s)&&this.inputOptions.onwarn(bi(s)),a=e,n=this.modulesById.get(s),r=i="*"}else{const s=this.exportsByName[i];if(s instanceof Hi)continue;const o=s.module;if(o instanceof dn){if(n=this.chunkByModule.get(o),n===this)continue;r=n.getVariableExportName(s),a=s.isReassigned}else{if(n=o,r=s.name,"default"!==r&&"*"!==r&&"defaultOnly"===t(o.id))return ci(vi(o.id,r,!0));a=e&&("default"!==r||Hs(String(t(o.id)),!0))}}R(s,n,(()=>[])).push({imported:r,needsLiveBinding:a,reexported:i})}return s}getReferencedFiles(){const e=[];for(const t of this.orderedModules)for(const s of t.importMetas){const t=s.getReferencedFileName(this.pluginDriver);t&&e.push(t)}return e}getRelativePath(e,t){let s=C($(N(this.id),e));return t&&s.endsWith(".js")&&(s=s.slice(0,-3)),".."===s?"../../"+I(e):""===s?"../"+I(e):s.startsWith("../")?s:"./"+s}inlineChunkDependencies(e){for(const t of e.dependencies)this.dependencies.has(t)||(this.dependencies.add(t),t instanceof Fr&&this.inlineChunkDependencies(t))}prepareModulesForRendering(e){var t;const s=this.accessedGlobalsByScope;for(const i of this.orderedModules){for(const{node:n,resolution:r}of i.dynamicImports)if(n.included)if(r instanceof dn){const i=this.chunkByModule.get(r);i===this?n.setInternalResolution(r.namespace):n.setExternalResolution((null===(t=this.facadeChunkByModule.get(r))||void 0===t?void 0:t.exportMode)||i.exportMode,r,this.outputOptions,e,this.pluginDriver,s)}else n.setExternalResolution("external",r,this.outputOptions,e,this.pluginDriver,s);for(const e of i.importMetas)e.addAccessedGlobals(this.outputOptions.format,s);this.includedNamespaces.has(i)&&!this.outputOptions.preserveModules&&i.namespace.prepare(s)}}setExternalRenderPaths(e,t){for(const s of[...this.dependencies,...this.dynamicDependencies])s instanceof oe&&s.setRenderPath(e,t)}setIdentifierRenderResolutions({format:e,interop:t,namespaceToStringTag:s}){const i=new Set;for(const t of this.getExportNames()){const s=this.exportsByName[t];"es"!==e&&"system"!==e&&s.isReassigned&&!s.isId?s.setRenderNames("exports",t):s instanceof Hi?i.add(s):s.setRenderNames(null,null)}for(const e of this.orderedModules)if(e.needsExportShim){this.needsExportsShim=!0;break}const n=new Set(["Object","Promise"]);switch(this.needsExportsShim&&n.add(ji),s&&n.add("Symbol"),e){case"system":n.add("module").add("exports");break;case"es":break;case"cjs":n.add("module").add("require").add("__filename").add("__dirname");default:n.add("exports");for(const e of ai)n.add(e)}kr(this.orderedModules,this.getDependenciesToBeDeconflicted("es"!==e&&"system"!==e,"amd"===e||"umd"===e||"iife"===e,t),this.imports,n,e,t,this.outputOptions.preserveModules,this.outputOptions.externalLiveBindings,this.chunkByModule,i,this.exportNamesByVariable,this.accessedGlobalsByScope,this.includedNamespaces)}setUpChunkImportsAndExportsForModule(e){const t=new Set(e.imports);if(!this.outputOptions.preserveModules&&this.includedNamespaces.has(e)){const s=e.namespace.getMemberVariables();for(const e of Object.values(s))t.add(e)}for(let s of t){s instanceof Bi&&(s=s.getOriginalVariable()),s instanceof Hi&&(s=s.getBaseVariable());const t=this.chunkByModule.get(s.module);t!==this&&(this.imports.add(s),!(s instanceof Gi&&this.outputOptions.preserveModules)&&s.module instanceof dn&&(t.exports.add(s),this.checkCircularDependencyImport(s,e)))}(this.includedNamespaces.has(e)||e.info.isEntry&&!1!==e.preserveSignature||e.includedDynamicImporters.some((e=>this.chunkByModule.get(e)!==this)))&&this.ensureReexportsAreAvailableForModule(e);for(const{node:t,resolution:s}of e.dynamicImports)t.included&&s instanceof dn&&this.chunkByModule.get(s)===this&&!this.includedNamespaces.has(s)&&(this.includedNamespaces.add(s),this.ensureReexportsAreAvailableForModule(s))}}function zr(e){return e.chunkName||ne(e.id)}var Wr;function jr(e,t,s){e in t&&s(function(e){return{code:di.FILE_NAME_CONFLICT,message:`The emitted file "${e}" overwrites a previously emitted file of the same name.`}}(e)),t[e]=Ur}!function(e){e[e.LOAD_AND_PARSE=0]="LOAD_AND_PARSE",e[e.ANALYSE=1]="ANALYSE",e[e.GENERATE=2]="GENERATE"}(Wr||(Wr={}));const Ur={type:"placeholder"};function Gr(e,t,s){if(!("string"==typeof e||e instanceof Uint8Array)){const e=t.fileName||t.name||s;return ci(Ai(`Could not set source for ${"string"==typeof e?`asset "${e}"`:"unnamed asset"}, asset source needs to be a string, Uint8Array or Buffer.`))}return e}function Hr(e,t){return"string"!=typeof e.fileName?ci((s=e.name||t,{code:di.ASSET_NOT_FINALISED,message:`Plugin error - Unable to get file name for asset "${s}". Ensure that the source is set and that generate is called first.`})):e.fileName;var s}function qr(e,t){var s;const i=e.fileName||e.module&&(null===(s=null==t?void 0:t.get(e.module))||void 0===s?void 0:s.id);return i||ci((n=e.fileName||e.name,{code:di.CHUNK_NOT_GENERATED,message:`Plugin error - Unable to get file name for chunk "${n}". Ensure that generate is called first.`}));var n}class Kr{constructor(e,t,s){this.graph=e,this.options=t,this.bundle=null,this.facadeChunkByModule=null,this.outputOptions=null,this.assertAssetsFinalized=()=>{for(const[t,s]of this.filesByReferenceId.entries())if("asset"===s.type&&"string"!=typeof s.fileName)return ci((e=s.name||t,{code:di.ASSET_SOURCE_MISSING,message:`Plugin error creating asset "${e}" - no asset source set.`}));var e},this.emitFile=e=>function(e){return Boolean(e&&("asset"===e.type||"chunk"===e.type))}(e)?function(e){const t=e.fileName||e.name;return!t||"string"==typeof t&&!ae(t)}(e)?"chunk"===e.type?this.emitChunk(e):this.emitAsset(e):ci(Ai(`The "fileName" or "name" properties of emitted files must be strings that are neither absolute nor relative paths, received "${e.fileName||e.name}".`)):ci(Ai(`Emitted files must be of type "asset" or "chunk", received "${e&&e.type}".`)),this.getFileName=e=>{const t=this.filesByReferenceId.get(e);return t?"chunk"===t.type?qr(t,this.facadeChunkByModule):Hr(t,e):ci((s=e,{code:di.FILE_NOT_FOUND,message:`Plugin error - Unable to get file name for unknown file "${s}".`}));var s},this.setAssetSource=(e,t)=>{const s=this.filesByReferenceId.get(e);if(!s)return ci((i=e,{code:di.ASSET_NOT_FOUND,message:`Plugin error - Unable to set the source for unknown asset "${i}".`}));var i,n;if("asset"!==s.type)return ci(Ai(`Asset sources can only be set for emitted assets but "${e}" is an emitted chunk.`));if(void 0!==s.source)return ci((n=s.name||e,{code:di.ASSET_SOURCE_ALREADY_SET,message:`Unable to set the source for asset "${n}", source already set.`}));const r=Gr(t,s,e);this.bundle?this.finalizeAsset(s,r,e,this.bundle):s.source=r},this.setOutputBundle=(e,t,s)=>{this.outputOptions=t,this.bundle=e,this.facadeChunkByModule=s;for(const e of this.filesByReferenceId.values())e.fileName&&jr(e.fileName,this.bundle,this.options.onwarn);for(const[e,t]of this.filesByReferenceId.entries())"asset"===t.type&&void 0!==t.source&&this.finalizeAsset(t,t.source,e,this.bundle)},this.filesByReferenceId=s?new Map(s.filesByReferenceId):new Map}assignReferenceId(e,t){let s;do{const e=Sr();s?e.update(s):e.update(t),s=e.digest("hex").substr(0,8)}while(this.filesByReferenceId.has(s));return this.filesByReferenceId.set(s,e),s}emitAsset(e){const t=void 0!==e.source?Gr(e.source,e,null):void 0,s={fileName:e.fileName,name:e.name,source:t,type:"asset"},i=this.assignReferenceId(s,e.fileName||e.name||e.type);return this.bundle&&(e.fileName&&jr(e.fileName,this.bundle,this.options.onwarn),void 0!==t&&this.finalizeAsset(s,t,i,this.bundle)),i}emitChunk(e){if(this.graph.phase>Wr.LOAD_AND_PARSE)return ci({code:di.INVALID_ROLLUP_PHASE,message:"Cannot emit chunks after module loading has finished."});if("string"!=typeof e.id)return ci(Ai(`Emitted chunks need to have a valid string id, received "${e.id}"`));const t={fileName:e.fileName,module:null,name:e.name||e.id,type:"chunk"};return this.graph.moduleLoader.emitChunk(e).then((e=>t.module=e)).catch((()=>{})),this.assignReferenceId(t,e.id)}finalizeAsset(e,t,s,i){const n=e.fileName||function(e,t){for(const[s,i]of Object.entries(e))if("asset"===i.type&&Xr(t,i.source))return s;return null}(i,t)||function(e,t,s,i){const n=s.sanitizeFileName(e||"asset");return Lr(Or("function"==typeof s.assetFileNames?s.assetFileNames({name:e,source:t,type:"asset"}):s.assetFileNames,"output.assetFileNames",{ext:()=>_(n).substr(1),extname:()=>_(n),hash(){const e=Sr();return e.update(n),e.update(":"),e.update(t),e.digest("hex").substr(0,8)},name:()=>n.substr(0,n.length-_(n).length)}),i)}(e.name,t,this.outputOptions,i),r={...e,fileName:n,source:t};this.filesByReferenceId.set(s,r);const{options:a}=this;i[n]={fileName:n,get isAsset(){return Pi('Accessing "isAsset" on files in the bundle is deprecated, please use "type === \'asset\'" instead',!0,a),!0},name:e.name,source:t,type:"asset"}}}function Xr(e,t){if("string"==typeof e)return e===t;if("string"==typeof t)return!1;if("equals"in e)return e.equals(t);if(e.length!==t.length)return!1;for(let s=0;s<e.length;s++)if(e[s]!==t[s])return!1;return!0}const Yr=(e,t)=>t?`${e}\n${t}`:e,Qr=(e,t)=>t?`${e}\n\n${t}`:e;function Zr(e,t){const s=[],i=new Set(t.keys()),n=Object.create(null);for(const[e,s]of t)Jr(e,n[s]=n[s]||[],i);for(const[e,t]of Object.entries(n))s.push({alias:e,modules:t});const r=new Map,{dependentEntryPointsByModule:a,dynamicEntryModules:o}=function(e){const t=new Set,s=new Map,i=new Set(e);for(const e of i){const n=new Set([e]);for(const r of n){R(s,r,(()=>new Set)).add(e);for(const e of r.getDependenciesToBeIncluded())e instanceof oe||n.add(e);for(const{resolution:e}of r.dynamicImports)e instanceof dn&&e.includedDynamicImporters.length>0&&(t.add(e),i.add(e));for(const e of r.implicitlyLoadedBefore)t.add(e),i.add(e)}}return{dependentEntryPointsByModule:s,dynamicEntryModules:t}}(e),h=function(e,t){const s=new Map;for(const i of t){const t=R(s,i,(()=>new Set));for(const s of[...i.includedDynamicImporters,...i.implicitlyLoadedAfter])for(const i of e.get(s))t.add(i)}return s}(a,o),l=new Set(e);function c(e,t){const s=new Set([e]);for(const n of s){const o=R(r,n,(()=>new Set));if(!t||!u(t,a.get(n))){o.add(e);for(const e of n.getDependenciesToBeIncluded())e instanceof oe||i.has(e)||s.add(e)}}}function u(e,t){const s=new Set(e);for(const e of s)if(!t.has(e)){if(l.has(e))return!1;const t=h.get(e);for(const e of t)s.add(e)}return!0}for(const t of e)i.has(t)||c(t,null);for(const e of o)i.has(e)||c(e,h.get(e));return s.push(...function(e,t){const s=Object.create(null);for(const[i,n]of t){let t="";for(const s of e)t+=n.has(s)?"X":"_";const r=s[t];r?r.push(i):s[t]=[i]}return Object.values(s).map((e=>({alias:null,modules:e})))}([...e,...o],r)),s}function Jr(e,t,s){const i=new Set([e]);for(const e of i){s.add(e),t.push(e);for(const t of e.dependencies)t instanceof oe||s.has(t)||i.add(t)}}const ea=(e,t)=>e.execIndex>t.execIndex?1:-1;function ta(e,t,s){const i=Symbol(e.id),n=[re(e.id)];let r=t;for(e.cycles.add(i);r!==e;)r.cycles.add(i),n.push(re(r.id)),r=s.get(r);return n.push(n[0]),n.reverse(),n}const sa=(e,t)=>t?`(${e})`:e,ia=/^(?!\d)[\w$]+$/;class na{constructor(e,t,s,i,n){this.outputOptions=e,this.unsetOptions=t,this.inputOptions=s,this.pluginDriver=i,this.graph=n,this.facadeChunkByModule=new Map,this.includedNamespaces=new Set}async generate(e){nn("GENERATE",1);const t=Object.create(null);this.pluginDriver.setOutputBundle(t,this.outputOptions,this.facadeChunkByModule);try{await this.pluginDriver.hookParallel("renderStart",[this.outputOptions,this.inputOptions]),nn("generate chunks",2);const e=await this.generateChunks();e.length>1&&(s=this.outputOptions,i=this.inputOptions.onwarn,"umd"===s.format||"iife"===s.format?ci(mi("output.format","outputformat","UMD and IIFE output formats are not supported for code-splitting builds",s.format)):"string"==typeof s.file?ci(mi("output.file","outputdir",'when building multiple chunks, the "output.dir" option must be used, not "output.file". To inline dynamic imports, set the "inlineDynamicImports" option')):s.sourcemapFile?ci(mi("output.sourcemapFile","outputsourcemapfile",'"output.sourcemapFile" is only supported for single-file builds')):!s.amd.autoId&&s.amd.id&&i(mi("output.amd.id","outputamd",'this option is only properly supported for single-file builds. Use "output.amd.autoId" and "output.amd.basePath" instead')));const n=function(e){if(0===e.length)return"/";if(1===e.length)return N(e[0]);const t=e.slice(1).reduce(((e,t)=>{const s=t.split(/\/+|\\+/);let i;for(i=0;e[i]===s[i]&&i<Math.min(e.length,s.length);i++);return e.slice(0,i)}),e[0].split(/\/+|\\+/));return t.length>1?t.join("/"):"/"}(function(e){const t=[];for(const s of e)for(const e of s.entryModules)k(e.id)&&t.push(e.id);return t}(e));rn("generate chunks",2),nn("render modules",2);const r=await async function(e,t){try{let[s,i,n,r]=await Promise.all([t.hookReduceValue("banner",e.banner(),[],Yr),t.hookReduceValue("footer",e.footer(),[],Yr),t.hookReduceValue("intro",e.intro(),[],Qr),t.hookReduceValue("outro",e.outro(),[],Qr)]);return n&&(n+="\n\n"),r&&(r=`\n\n${r}`),s.length&&(s+="\n"),i.length&&(i="\n"+i),{banner:s,footer:i,intro:n,outro:r}}catch(e){return ci({code:"ADDON_ERROR",message:`Could not retrieve ${e.hook}. Check configuration of plugin ${e.plugin}.\n\tError Message: ${e.message}`})}}(this.outputOptions,this.pluginDriver),a=function({compact:e,generatedCode:{arrowFunctions:t,constBindings:s,objectShorthand:i,reservedNamesAsProps:n}}){const{_:r,n:a,s:o}=e?{_:"",n:"",s:""}:{_:" ",n:"\n",s:";"},h=s?"const":"var",l=(e,{isAsync:t,name:s})=>`${t?"async ":""}function${s?` ${s}`:""}${r}(${e.join(`,${r}`)})${r}`,c=t?(e,{isAsync:t,name:s})=>{const i=1===e.length;return`${s?`${h} ${s}${r}=${r}`:""}${t?`async${i?" ":r}`:""}${i?e[0]:`(${e.join(`,${r}`)})`}${r}=>${r}`}:l,u=(e,{functionReturn:s,lineBreakIndent:i,name:n})=>[`${c(e,{isAsync:!1,name:n})}${t?i?`${a}${i.base}${i.t}`:"":`{${i?`${a}${i.base}${i.t}`:r}${s?"return ":""}`}`,t?`${n?";":""}${i?`${a}${i.base}`:""}`:`${o}${i?`${a}${i.base}`:r}}`],d=n?e=>ia.test(e):e=>!Qe[e]&&ia.test(e);return{_:r,cnst:h,getDirectReturnFunction:u,getDirectReturnIifeLeft:(e,s,{needsArrowReturnParens:i,needsWrappedFunction:n})=>{const[r,a]=u(e,{functionReturn:!0,lineBreakIndent:null,name:null});return`${sa(`${r}${sa(s,t&&i)}${a}`,t||n)}(`},getFunctionIntro:c,getNonArrowFunctionIntro:l,getObject(e,{lineBreakIndent:t}){const s=t?`${a}${t.base}${t.t}`:r;return`{${e.map((([e,t])=>{if(null===e)return`${s}${t}`;const n=!d(e);return e===t&&i&&!n?s+e:`${s}${n?`'${e}'`:e}:${r}${t}`})).join(",")}${0===e.length?"":t?`${a}${t.base}`:r}}`},getPropertyAccess:e=>d(e)?`.${e}`:`[${JSON.stringify(e)}]`,n:a,s:o}}(this.outputOptions);this.prerenderChunks(e,n,a),rn("render modules",2),await this.addFinalizedChunksToBundle(e,n,r,t,a)}catch(e){throw await this.pluginDriver.hookParallel("renderError",[e]),e}var s,i;return await this.pluginDriver.hookSeq("generateBundle",[this.outputOptions,t,e]),this.finaliseAssets(t),rn("GENERATE",1),t}async addFinalizedChunksToBundle(e,t,s,i,n){this.assignChunkIds(e,t,s,i);for(const t of e)i[t.id]=t.getChunkInfoWithFileNames();await Promise.all(e.map((async e=>{const t=i[e.id];Object.assign(t,await e.render(this.outputOptions,s,t,n))})))}async addManualChunks(e){const t=new Map,s=await Promise.all(Object.entries(e).map((async([e,t])=>({alias:e,entries:await this.graph.moduleLoader.addAdditionalModules(t)}))));for(const{alias:e,entries:i}of s)for(const s of i)aa(e,s,t);return t}assignChunkIds(e,t,s,i){const n=[],r=[];for(const t of e)(t.facadeModule&&t.facadeModule.isUserDefinedEntryPoint?n:r).push(t);const a=n.concat(r);for(const e of a)this.outputOptions.file?e.id=I(this.outputOptions.file):this.outputOptions.preserveModules?e.id=e.generateIdPreserveModules(t,this.outputOptions,i,this.unsetOptions):e.id=e.generateId(s,this.outputOptions,i,!0),i[e.id]=Ur}assignManualChunks(e){const t=new Map,s={getModuleIds:()=>this.graph.modulesById.keys(),getModuleInfo:this.graph.getModuleInfo};for(const i of this.graph.modulesById.values())if(i instanceof dn){const n=e(i.id,s);"string"==typeof n&&aa(n,i,t)}return t}finaliseAssets(e){for(const t of Object.values(e))if(t.type||(Pi('A plugin is directly adding properties to the bundle object in the "generateBundle" hook. This is deprecated and will be removed in a future Rollup version, please use "this.emitFile" instead.',!0,this.inputOptions),t.type="asset"),this.outputOptions.validate&&"string"==typeof t.code)try{this.graph.contextParse(t.code,{allowHashBang:!0,ecmaVersion:"latest"})}catch(e){this.inputOptions.onwarn(pi(t,e))}this.pluginDriver.finaliseAssets()}async generateChunks(){const{manualChunks:e}=this.outputOptions,t="object"==typeof e?await this.addManualChunks(e):this.assignManualChunks(e),s=[],i=new Map;for(const{alias:e,modules:n}of this.outputOptions.inlineDynamicImports?[{alias:null,modules:ra(this.graph.modulesById)}]:this.outputOptions.preserveModules?ra(this.graph.modulesById).map((e=>({alias:null,modules:[e]}))):Zr(this.graph.entryModules,t)){n.sort(ea);const t=new Fr(n,this.inputOptions,this.outputOptions,this.unsetOptions,this.pluginDriver,this.graph.modulesById,i,this.facadeChunkByModule,this.includedNamespaces,e);s.push(t);for(const e of n)i.set(e,t)}for(const e of s)e.link();const n=[];for(const e of s)n.push(...e.generateFacades());return[...s,...n]}prerenderChunks(e,t,s){for(const t of e)t.generateExports();for(const i of e)i.preRender(this.outputOptions,t,s)}}function ra(e){return[...e.values()].filter((e=>e instanceof dn&&(e.isIncluded()||e.info.isEntry||e.includedDynamicImporters.length>0)))}function aa(e,t,s){const i=s.get(t);if("string"==typeof i&&i!==e)return ci((n=t.id,r=e,a=i,{code:di.INVALID_CHUNK,message:`Cannot assign ${re(n)} to the "${r}" chunk as it is already in the "${a}" chunk.`}));var n,r,a;s.set(t,e)}var oa={3:"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",5:"class enum extends super const export import",6:"enum",strict:"implements interface let package private protected public static yield",strictBind:"eval arguments"},ha="break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this",la={5:ha,"5module":ha+" export import",6:ha+" const class extends export import super"},ca=/^in(stanceof)?$/,ua="ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࢠ-ࢴࢶ-ࣇऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-鿼ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞿꟂ-ꟊꟵ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",da="‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࣓-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿᫀᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷹᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿",pa=new RegExp("["+ua+"]"),fa=new RegExp("["+ua+da+"]");ua=da=null;var ma=[0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,349,41,7,1,79,28,11,0,9,21,107,20,28,22,13,52,76,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,190,0,80,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,43,8,8952,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42717,35,4148,12,221,3,5761,15,7472,3104,541,1507,4938],ga=[509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,370,1,154,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,82,0,12,1,19628,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,4759,9,787719,239];function ya(e,t){for(var s=65536,i=0;i<t.length;i+=2){if((s+=t[i])>e)return!1;if((s+=t[i+1])>=e)return!0}}function Ea(e,t){return e<65?36===e:e<91||(e<97?95===e:e<123||(e<=65535?e>=170&&pa.test(String.fromCharCode(e)):!1!==t&&ya(e,ma)))}function xa(e,t){return e<48?36===e:e<58||!(e<65)&&(e<91||(e<97?95===e:e<123||(e<=65535?e>=170&&fa.test(String.fromCharCode(e)):!1!==t&&(ya(e,ma)||ya(e,ga)))))}var va=function(e,t){void 0===t&&(t={}),this.label=e,this.keyword=t.keyword,this.beforeExpr=!!t.beforeExpr,this.startsExpr=!!t.startsExpr,this.isLoop=!!t.isLoop,this.isAssign=!!t.isAssign,this.prefix=!!t.prefix,this.postfix=!!t.postfix,this.binop=t.binop||null,this.updateContext=null};function ba(e,t){return new va(e,{beforeExpr:!0,binop:t})}var Aa={beforeExpr:!0},Sa={startsExpr:!0},Pa={};function ka(e,t){return void 0===t&&(t={}),t.keyword=e,Pa[e]=new va(e,t)}var wa={num:new va("num",Sa),regexp:new va("regexp",Sa),string:new va("string",Sa),name:new va("name",Sa),privateId:new va("privateId",Sa),eof:new va("eof"),bracketL:new va("[",{beforeExpr:!0,startsExpr:!0}),bracketR:new va("]"),braceL:new va("{",{beforeExpr:!0,startsExpr:!0}),braceR:new va("}"),parenL:new va("(",{beforeExpr:!0,startsExpr:!0}),parenR:new va(")"),comma:new va(",",Aa),semi:new va(";",Aa),colon:new va(":",Aa),dot:new va("."),question:new va("?",Aa),questionDot:new va("?."),arrow:new va("=>",Aa),template:new va("template"),invalidTemplate:new va("invalidTemplate"),ellipsis:new va("...",Aa),backQuote:new va("`",Sa),dollarBraceL:new va("${",{beforeExpr:!0,startsExpr:!0}),eq:new va("=",{beforeExpr:!0,isAssign:!0}),assign:new va("_=",{beforeExpr:!0,isAssign:!0}),incDec:new va("++/--",{prefix:!0,postfix:!0,startsExpr:!0}),prefix:new va("!/~",{beforeExpr:!0,prefix:!0,startsExpr:!0}),logicalOR:ba("||",1),logicalAND:ba("&&",2),bitwiseOR:ba("|",3),bitwiseXOR:ba("^",4),bitwiseAND:ba("&",5),equality:ba("==/!=/===/!==",6),relational:ba("</>/<=/>=",7),bitShift:ba("<</>>/>>>",8),plusMin:new va("+/-",{beforeExpr:!0,binop:9,prefix:!0,startsExpr:!0}),modulo:ba("%",10),star:ba("*",10),slash:ba("/",10),starstar:new va("**",{beforeExpr:!0}),coalesce:ba("??",1),_break:ka("break"),_case:ka("case",Aa),_catch:ka("catch"),_continue:ka("continue"),_debugger:ka("debugger"),_default:ka("default",Aa),_do:ka("do",{isLoop:!0,beforeExpr:!0}),_else:ka("else",Aa),_finally:ka("finally"),_for:ka("for",{isLoop:!0}),_function:ka("function",Sa),_if:ka("if"),_return:ka("return",Aa),_switch:ka("switch"),_throw:ka("throw",Aa),_try:ka("try"),_var:ka("var"),_const:ka("const"),_while:ka("while",{isLoop:!0}),_with:ka("with"),_new:ka("new",{beforeExpr:!0,startsExpr:!0}),_this:ka("this",Sa),_super:ka("super",Sa),_class:ka("class",Sa),_extends:ka("extends",Aa),_export:ka("export"),_import:ka("import",Sa),_null:ka("null",Sa),_true:ka("true",Sa),_false:ka("false",Sa),_in:ka("in",{beforeExpr:!0,binop:7}),_instanceof:ka("instanceof",{beforeExpr:!0,binop:7}),_typeof:ka("typeof",{beforeExpr:!0,prefix:!0,startsExpr:!0}),_void:ka("void",{beforeExpr:!0,prefix:!0,startsExpr:!0}),_delete:ka("delete",{beforeExpr:!0,prefix:!0,startsExpr:!0})},Ca=/\r\n?|\n|\u2028|\u2029/,Ia=new RegExp(Ca.source,"g");function Na(e){return 10===e||13===e||8232===e||8233===e}var _a=/[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/,$a=/(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,Ta=Object.prototype,Ra=Ta.hasOwnProperty,Ma=Ta.toString;function Da(e,t){return Ra.call(e,t)}var Oa=Array.isArray||function(e){return"[object Array]"===Ma.call(e)};function La(e){return new RegExp("^(?:"+e.replace(/ /g,"|")+")$")}var Va=function(e,t){this.line=e,this.column=t};Va.prototype.offset=function(e){return new Va(this.line,this.column+e)};var Ba=function(e,t,s){this.start=t,this.end=s,null!==e.sourceFile&&(this.source=e.sourceFile)};function Fa(e,t){for(var s=1,i=0;;){Ia.lastIndex=i;var n=Ia.exec(e);if(!(n&&n.index<t))return new Va(s,t-i);++s,i=n.index+n[0].length}}var za={ecmaVersion:null,sourceType:"script",onInsertedSemicolon:null,onTrailingComma:null,allowReserved:null,allowReturnOutsideFunction:!1,allowImportExportEverywhere:!1,allowAwaitOutsideFunction:null,allowSuperOutsideMethod:null,allowHashBang:!1,locations:!1,onToken:null,onComment:null,ranges:!1,program:null,sourceFile:null,directSourceFile:null,preserveParens:!1},Wa=!1;function ja(e){var t={};for(var s in za)t[s]=e&&Da(e,s)?e[s]:za[s];if("latest"===t.ecmaVersion?t.ecmaVersion=1e8:null==t.ecmaVersion?(!Wa&&"object"==typeof console&&console.warn&&(Wa=!0,console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.")),t.ecmaVersion=11):t.ecmaVersion>=2015&&(t.ecmaVersion-=2009),null==t.allowReserved&&(t.allowReserved=t.ecmaVersion<5),Oa(t.onToken)){var i=t.onToken;t.onToken=function(e){return i.push(e)}}return Oa(t.onComment)&&(t.onComment=function(e,t){return function(s,i,n,r,a,o){var h={type:s?"Block":"Line",value:i,start:n,end:r};e.locations&&(h.loc=new Ba(this,a,o)),e.ranges&&(h.range=[n,r]),t.push(h)}}(t,t.onComment)),t}var Ua=256;function Ga(e,t){return 2|(e?4:0)|(t?8:0)}var Ha=function(e,t,s){this.options=e=ja(e),this.sourceFile=e.sourceFile,this.keywords=La(la[e.ecmaVersion>=6?6:"module"===e.sourceType?"5module":5]);var i="";!0!==e.allowReserved&&(i=oa[e.ecmaVersion>=6?6:5===e.ecmaVersion?5:3],"module"===e.sourceType&&(i+=" await")),this.reservedWords=La(i);var n=(i?i+" ":"")+oa.strict;this.reservedWordsStrict=La(n),this.reservedWordsStrictBind=La(n+" "+oa.strictBind),this.input=String(t),this.containsEsc=!1,s?(this.pos=s,this.lineStart=this.input.lastIndexOf("\n",s-1)+1,this.curLine=this.input.slice(0,this.lineStart).split(Ca).length):(this.pos=this.lineStart=0,this.curLine=1),this.type=wa.eof,this.value=null,this.start=this.end=this.pos,this.startLoc=this.endLoc=this.curPosition(),this.lastTokEndLoc=this.lastTokStartLoc=null,this.lastTokStart=this.lastTokEnd=this.pos,this.context=this.initialContext(),this.exprAllowed=!0,this.inModule="module"===e.sourceType,this.strict=this.inModule||this.strictDirective(this.pos),this.potentialArrowAt=-1,this.potentialArrowInForAwait=!1,this.yieldPos=this.awaitPos=this.awaitIdentPos=0,this.labels=[],this.undefinedExports=Object.create(null),0===this.pos&&e.allowHashBang&&"#!"===this.input.slice(0,2)&&this.skipLineComment(2),this.scopeStack=[],this.enterScope(1),this.regexpState=null,this.privateNameStack=[]},qa={inFunction:{configurable:!0},inGenerator:{configurable:!0},inAsync:{configurable:!0},canAwait:{configurable:!0},allowSuper:{configurable:!0},allowDirectSuper:{configurable:!0},treatFunctionsAsVar:{configurable:!0},allowNewDotTarget:{configurable:!0},inClassStaticBlock:{configurable:!0}};Ha.prototype.parse=function(){var e=this.options.program||this.startNode();return this.nextToken(),this.parseTopLevel(e)},qa.inFunction.get=function(){return(2&this.currentVarScope().flags)>0},qa.inGenerator.get=function(){return(8&this.currentVarScope().flags)>0&&!this.currentVarScope().inClassFieldInit},qa.inAsync.get=function(){return(4&this.currentVarScope().flags)>0&&!this.currentVarScope().inClassFieldInit},qa.canAwait.get=function(){for(var e=this.scopeStack.length-1;e>=0;e--){var t=this.scopeStack[e];if(t.inClassFieldInit||t.flags&Ua)return!1;if(2&t.flags)return(4&t.flags)>0}return this.inModule&&this.options.ecmaVersion>=13||this.options.allowAwaitOutsideFunction},qa.allowSuper.get=function(){var e=this.currentThisScope(),t=e.flags,s=e.inClassFieldInit;return(64&t)>0||s||this.options.allowSuperOutsideMethod},qa.allowDirectSuper.get=function(){return(128&this.currentThisScope().flags)>0},qa.treatFunctionsAsVar.get=function(){return this.treatFunctionsAsVarInScope(this.currentScope())},qa.allowNewDotTarget.get=function(){var e=this.currentThisScope(),t=e.flags,s=e.inClassFieldInit;return(258&t)>0||s},qa.inClassStaticBlock.get=function(){return(this.currentVarScope().flags&Ua)>0},Ha.extend=function(){for(var e=[],t=arguments.length;t--;)e[t]=arguments[t];for(var s=this,i=0;i<e.length;i++)s=e[i](s);return s},Ha.parse=function(e,t){return new this(t,e).parse()},Ha.parseExpressionAt=function(e,t,s){var i=new this(s,e,t);return i.nextToken(),i.parseExpression()},Ha.tokenizer=function(e,t){return new this(t,e)},Object.defineProperties(Ha.prototype,qa);var Ka=Ha.prototype,Xa=/^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;function Ya(){this.shorthandAssign=this.trailingComma=this.parenthesizedAssign=this.parenthesizedBind=this.doubleProto=-1}Ka.strictDirective=function(e){for(;;){$a.lastIndex=e,e+=$a.exec(this.input)[0].length;var t=Xa.exec(this.input.slice(e));if(!t)return!1;if("use strict"===(t[1]||t[2])){$a.lastIndex=e+t[0].length;var s=$a.exec(this.input),i=s.index+s[0].length,n=this.input.charAt(i);return";"===n||"}"===n||Ca.test(s[0])&&!(/[(`.[+\-/*%<>=,?^&]/.test(n)||"!"===n&&"="===this.input.charAt(i+1))}e+=t[0].length,$a.lastIndex=e,e+=$a.exec(this.input)[0].length,";"===this.input[e]&&e++}},Ka.eat=function(e){return this.type===e&&(this.next(),!0)},Ka.isContextual=function(e){return this.type===wa.name&&this.value===e&&!this.containsEsc},Ka.eatContextual=function(e){return!!this.isContextual(e)&&(this.next(),!0)},Ka.expectContextual=function(e){this.eatContextual(e)||this.unexpected()},Ka.canInsertSemicolon=function(){return this.type===wa.eof||this.type===wa.braceR||Ca.test(this.input.slice(this.lastTokEnd,this.start))},Ka.insertSemicolon=function(){if(this.canInsertSemicolon())return this.options.onInsertedSemicolon&&this.options.onInsertedSemicolon(this.lastTokEnd,this.lastTokEndLoc),!0},Ka.semicolon=function(){this.eat(wa.semi)||this.insertSemicolon()||this.unexpected()},Ka.afterTrailingComma=function(e,t){if(this.type===e)return this.options.onTrailingComma&&this.options.onTrailingComma(this.lastTokStart,this.lastTokStartLoc),t||this.next(),!0},Ka.expect=function(e){this.eat(e)||this.unexpected()},Ka.unexpected=function(e){this.raise(null!=e?e:this.start,"Unexpected token")},Ka.checkPatternErrors=function(e,t){if(e){e.trailingComma>-1&&this.raiseRecoverable(e.trailingComma,"Comma is not permitted after the rest element");var s=t?e.parenthesizedAssign:e.parenthesizedBind;s>-1&&this.raiseRecoverable(s,"Parenthesized pattern")}},Ka.checkExpressionErrors=function(e,t){if(!e)return!1;var s=e.shorthandAssign,i=e.doubleProto;if(!t)return s>=0||i>=0;s>=0&&this.raise(s,"Shorthand property assignments are valid only in destructuring patterns"),i>=0&&this.raiseRecoverable(i,"Redefinition of __proto__ property")},Ka.checkYieldAwaitInDefaultParams=function(){this.yieldPos&&(!this.awaitPos||this.yieldPos<this.awaitPos)&&this.raise(this.yieldPos,"Yield expression cannot be a default value"),this.awaitPos&&this.raise(this.awaitPos,"Await expression cannot be a default value")},Ka.isSimpleAssignTarget=function(e){return"ParenthesizedExpression"===e.type?this.isSimpleAssignTarget(e.expression):"Identifier"===e.type||"MemberExpression"===e.type};var Qa=Ha.prototype;Qa.parseTopLevel=function(e){var t=Object.create(null);for(e.body||(e.body=[]);this.type!==wa.eof;){var s=this.parseStatement(null,!0,t);e.body.push(s)}if(this.inModule)for(var i=0,n=Object.keys(this.undefinedExports);i<n.length;i+=1){var r=n[i];this.raiseRecoverable(this.undefinedExports[r].start,"Export '"+r+"' is not defined")}return this.adaptDirectivePrologue(e.body),this.next(),e.sourceType=this.options.sourceType,this.finishNode(e,"Program")};var Za={kind:"loop"},Ja={kind:"switch"};Qa.isLet=function(e){if(this.options.ecmaVersion<6||!this.isContextual("let"))return!1;$a.lastIndex=this.pos;var t=$a.exec(this.input),s=this.pos+t[0].length,i=this.input.charCodeAt(s);if(91===i||92===i||i>55295&&i<56320)return!0;if(e)return!1;if(123===i)return!0;if(Ea(i,!0)){for(var n=s+1;xa(i=this.input.charCodeAt(n),!0);)++n;if(92===i||i>55295&&i<56320)return!0;var r=this.input.slice(s,n);if(!ca.test(r))return!0}return!1},Qa.isAsyncFunction=function(){if(this.options.ecmaVersion<8||!this.isContextual("async"))return!1;$a.lastIndex=this.pos;var e,t=$a.exec(this.input),s=this.pos+t[0].length;return!(Ca.test(this.input.slice(this.pos,s))||"function"!==this.input.slice(s,s+8)||s+8!==this.input.length&&(xa(e=this.input.charCodeAt(s+8))||e>55295&&e<56320))},Qa.parseStatement=function(e,t,s){var i,n=this.type,r=this.startNode();switch(this.isLet(e)&&(n=wa._var,i="let"),n){case wa._break:case wa._continue:return this.parseBreakContinueStatement(r,n.keyword);case wa._debugger:return this.parseDebuggerStatement(r);case wa._do:return this.parseDoStatement(r);case wa._for:return this.parseForStatement(r);case wa._function:return e&&(this.strict||"if"!==e&&"label"!==e)&&this.options.ecmaVersion>=6&&this.unexpected(),this.parseFunctionStatement(r,!1,!e);case wa._class:return e&&this.unexpected(),this.parseClass(r,!0);case wa._if:return this.parseIfStatement(r);case wa._return:return this.parseReturnStatement(r);case wa._switch:return this.parseSwitchStatement(r);case wa._throw:return this.parseThrowStatement(r);case wa._try:return this.parseTryStatement(r);case wa._const:case wa._var:return i=i||this.value,e&&"var"!==i&&this.unexpected(),this.parseVarStatement(r,i);case wa._while:return this.parseWhileStatement(r);case wa._with:return this.parseWithStatement(r);case wa.braceL:return this.parseBlock(!0,r);case wa.semi:return this.parseEmptyStatement(r);case wa._export:case wa._import:if(this.options.ecmaVersion>10&&n===wa._import){$a.lastIndex=this.pos;var a=$a.exec(this.input),o=this.pos+a[0].length,h=this.input.charCodeAt(o);if(40===h||46===h)return this.parseExpressionStatement(r,this.parseExpression())}return this.options.allowImportExportEverywhere||(t||this.raise(this.start,"'import' and 'export' may only appear at the top level"),this.inModule||this.raise(this.start,"'import' and 'export' may appear only with 'sourceType: module'")),n===wa._import?this.parseImport(r):this.parseExport(r,s);default:if(this.isAsyncFunction())return e&&this.unexpected(),this.next(),this.parseFunctionStatement(r,!0,!e);var l=this.value,c=this.parseExpression();return n===wa.name&&"Identifier"===c.type&&this.eat(wa.colon)?this.parseLabeledStatement(r,l,c,e):this.parseExpressionStatement(r,c)}},Qa.parseBreakContinueStatement=function(e,t){var s="break"===t;this.next(),this.eat(wa.semi)||this.insertSemicolon()?e.label=null:this.type!==wa.name?this.unexpected():(e.label=this.parseIdent(),this.semicolon());for(var i=0;i<this.labels.length;++i){var n=this.labels[i];if(null==e.label||n.name===e.label.name){if(null!=n.kind&&(s||"loop"===n.kind))break;if(e.label&&s)break}}return i===this.labels.length&&this.raise(e.start,"Unsyntactic "+t),this.finishNode(e,s?"BreakStatement":"ContinueStatement")},Qa.parseDebuggerStatement=function(e){return this.next(),this.semicolon(),this.finishNode(e,"DebuggerStatement")},Qa.parseDoStatement=function(e){return this.next(),this.labels.push(Za),e.body=this.parseStatement("do"),this.labels.pop(),this.expect(wa._while),e.test=this.parseParenExpression(),this.options.ecmaVersion>=6?this.eat(wa.semi):this.semicolon(),this.finishNode(e,"DoWhileStatement")},Qa.parseForStatement=function(e){this.next();var t=this.options.ecmaVersion>=9&&this.canAwait&&this.eatContextual("await")?this.lastTokStart:-1;if(this.labels.push(Za),this.enterScope(0),this.expect(wa.parenL),this.type===wa.semi)return t>-1&&this.unexpected(t),this.parseFor(e,null);var s=this.isLet();if(this.type===wa._var||this.type===wa._const||s){var i=this.startNode(),n=s?"let":this.value;return this.next(),this.parseVar(i,!0,n),this.finishNode(i,"VariableDeclaration"),(this.type===wa._in||this.options.ecmaVersion>=6&&this.isContextual("of"))&&1===i.declarations.length?(this.options.ecmaVersion>=9&&(this.type===wa._in?t>-1&&this.unexpected(t):e.await=t>-1),this.parseForIn(e,i)):(t>-1&&this.unexpected(t),this.parseFor(e,i))}var r=this.isContextual("let"),a=!1,o=new Ya,h=this.parseExpression(!(t>-1)||"await",o);return this.type===wa._in||(a=this.options.ecmaVersion>=6&&this.isContextual("of"))?(this.options.ecmaVersion>=9&&(this.type===wa._in?t>-1&&this.unexpected(t):e.await=t>-1),r&&a&&this.raise(h.start,"The left-hand side of a for-of loop may not start with 'let'."),this.toAssignable(h,!1,o),this.checkLValPattern(h),this.parseForIn(e,h)):(this.checkExpressionErrors(o,!0),t>-1&&this.unexpected(t),this.parseFor(e,h))},Qa.parseFunctionStatement=function(e,t,s){return this.next(),this.parseFunction(e,to|(s?0:so),!1,t)},Qa.parseIfStatement=function(e){return this.next(),e.test=this.parseParenExpression(),e.consequent=this.parseStatement("if"),e.alternate=this.eat(wa._else)?this.parseStatement("if"):null,this.finishNode(e,"IfStatement")},Qa.parseReturnStatement=function(e){return this.inFunction||this.options.allowReturnOutsideFunction||this.raise(this.start,"'return' outside of function"),this.next(),this.eat(wa.semi)||this.insertSemicolon()?e.argument=null:(e.argument=this.parseExpression(),this.semicolon()),this.finishNode(e,"ReturnStatement")},Qa.parseSwitchStatement=function(e){var t;this.next(),e.discriminant=this.parseParenExpression(),e.cases=[],this.expect(wa.braceL),this.labels.push(Ja),this.enterScope(0);for(var s=!1;this.type!==wa.braceR;)if(this.type===wa._case||this.type===wa._default){var i=this.type===wa._case;t&&this.finishNode(t,"SwitchCase"),e.cases.push(t=this.startNode()),t.consequent=[],this.next(),i?t.test=this.parseExpression():(s&&this.raiseRecoverable(this.lastTokStart,"Multiple default clauses"),s=!0,t.test=null),this.expect(wa.colon)}else t||this.unexpected(),t.consequent.push(this.parseStatement(null));return this.exitScope(),t&&this.finishNode(t,"SwitchCase"),this.next(),this.labels.pop(),this.finishNode(e,"SwitchStatement")},Qa.parseThrowStatement=function(e){return this.next(),Ca.test(this.input.slice(this.lastTokEnd,this.start))&&this.raise(this.lastTokEnd,"Illegal newline after throw"),e.argument=this.parseExpression(),this.semicolon(),this.finishNode(e,"ThrowStatement")};var eo=[];Qa.parseTryStatement=function(e){if(this.next(),e.block=this.parseBlock(),e.handler=null,this.type===wa._catch){var t=this.startNode();if(this.next(),this.eat(wa.parenL)){t.param=this.parseBindingAtom();var s="Identifier"===t.param.type;this.enterScope(s?32:0),this.checkLValPattern(t.param,s?4:2),this.expect(wa.parenR)}else this.options.ecmaVersion<10&&this.unexpected(),t.param=null,this.enterScope(0);t.body=this.parseBlock(!1),this.exitScope(),e.handler=this.finishNode(t,"CatchClause")}return e.finalizer=this.eat(wa._finally)?this.parseBlock():null,e.handler||e.finalizer||this.raise(e.start,"Missing catch or finally clause"),this.finishNode(e,"TryStatement")},Qa.parseVarStatement=function(e,t){return this.next(),this.parseVar(e,!1,t),this.semicolon(),this.finishNode(e,"VariableDeclaration")},Qa.parseWhileStatement=function(e){return this.next(),e.test=this.parseParenExpression(),this.labels.push(Za),e.body=this.parseStatement("while"),this.labels.pop(),this.finishNode(e,"WhileStatement")},Qa.parseWithStatement=function(e){return this.strict&&this.raise(this.start,"'with' in strict mode"),this.next(),e.object=this.parseParenExpression(),e.body=this.parseStatement("with"),this.finishNode(e,"WithStatement")},Qa.parseEmptyStatement=function(e){return this.next(),this.finishNode(e,"EmptyStatement")},Qa.parseLabeledStatement=function(e,t,s,i){for(var n=0,r=this.labels;n<r.length;n+=1)r[n].name===t&&this.raise(s.start,"Label '"+t+"' is already declared");for(var a=this.type.isLoop?"loop":this.type===wa._switch?"switch":null,o=this.labels.length-1;o>=0;o--){var h=this.labels[o];if(h.statementStart!==e.start)break;h.statementStart=this.start,h.kind=a}return this.labels.push({name:t,kind:a,statementStart:this.start}),e.body=this.parseStatement(i?-1===i.indexOf("label")?i+"label":i:"label"),this.labels.pop(),e.label=s,this.finishNode(e,"LabeledStatement")},Qa.parseExpressionStatement=function(e,t){return e.expression=t,this.semicolon(),this.finishNode(e,"ExpressionStatement")},Qa.parseBlock=function(e,t,s){for(void 0===e&&(e=!0),void 0===t&&(t=this.startNode()),t.body=[],this.expect(wa.braceL),e&&this.enterScope(0);this.type!==wa.braceR;){var i=this.parseStatement(null);t.body.push(i)}return s&&(this.strict=!1),this.next(),e&&this.exitScope(),this.finishNode(t,"BlockStatement")},Qa.parseFor=function(e,t){return e.init=t,this.expect(wa.semi),e.test=this.type===wa.semi?null:this.parseExpression(),this.expect(wa.semi),e.update=this.type===wa.parenR?null:this.parseExpression(),this.expect(wa.parenR),e.body=this.parseStatement("for"),this.exitScope(),this.labels.pop(),this.finishNode(e,"ForStatement")},Qa.parseForIn=function(e,t){var s=this.type===wa._in;return this.next(),"VariableDeclaration"===t.type&&null!=t.declarations[0].init&&(!s||this.options.ecmaVersion<8||this.strict||"var"!==t.kind||"Identifier"!==t.declarations[0].id.type)&&this.raise(t.start,(s?"for-in":"for-of")+" loop variable declaration may not have an initializer"),e.left=t,e.right=s?this.parseExpression():this.parseMaybeAssign(),this.expect(wa.parenR),e.body=this.parseStatement("for"),this.exitScope(),this.labels.pop(),this.finishNode(e,s?"ForInStatement":"ForOfStatement")},Qa.parseVar=function(e,t,s){for(e.declarations=[],e.kind=s;;){var i=this.startNode();if(this.parseVarId(i,s),this.eat(wa.eq)?i.init=this.parseMaybeAssign(t):"const"!==s||this.type===wa._in||this.options.ecmaVersion>=6&&this.isContextual("of")?"Identifier"===i.id.type||t&&(this.type===wa._in||this.isContextual("of"))?i.init=null:this.raise(this.lastTokEnd,"Complex binding patterns require an initialization value"):this.unexpected(),e.declarations.push(this.finishNode(i,"VariableDeclarator")),!this.eat(wa.comma))break}return e},Qa.parseVarId=function(e,t){e.id=this.parseBindingAtom(),this.checkLValPattern(e.id,"var"===t?1:2,!1)};var to=1,so=2;function io(e,t){var s=t.key.name,i=e[s],n="true";return"MethodDefinition"!==t.type||"get"!==t.kind&&"set"!==t.kind||(n=(t.static?"s":"i")+t.kind),"iget"===i&&"iset"===n||"iset"===i&&"iget"===n||"sget"===i&&"sset"===n||"sset"===i&&"sget"===n?(e[s]="true",!1):!!i||(e[s]=n,!1)}function no(e,t){var s=e.computed,i=e.key;return!s&&("Identifier"===i.type&&i.name===t||"Literal"===i.type&&i.value===t)}Qa.parseFunction=function(e,t,s,i,n){this.initFunction(e),(this.options.ecmaVersion>=9||this.options.ecmaVersion>=6&&!i)&&(this.type===wa.star&&t&so&&this.unexpected(),e.generator=this.eat(wa.star)),this.options.ecmaVersion>=8&&(e.async=!!i),t&to&&(e.id=4&t&&this.type!==wa.name?null:this.parseIdent(),!e.id||t&so||this.checkLValSimple(e.id,this.strict||e.generator||e.async?this.treatFunctionsAsVar?1:2:3));var r=this.yieldPos,a=this.awaitPos,o=this.awaitIdentPos;return this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0,this.enterScope(Ga(e.async,e.generator)),t&to||(e.id=this.type===wa.name?this.parseIdent():null),this.parseFunctionParams(e),this.parseFunctionBody(e,s,!1,n),this.yieldPos=r,this.awaitPos=a,this.awaitIdentPos=o,this.finishNode(e,t&to?"FunctionDeclaration":"FunctionExpression")},Qa.parseFunctionParams=function(e){this.expect(wa.parenL),e.params=this.parseBindingList(wa.parenR,!1,this.options.ecmaVersion>=8),this.checkYieldAwaitInDefaultParams()},Qa.parseClass=function(e,t){this.next();var s=this.strict;this.strict=!0,this.parseClassId(e,t),this.parseClassSuper(e);var i=this.enterClassBody(),n=this.startNode(),r=!1;for(n.body=[],this.expect(wa.braceL);this.type!==wa.braceR;){var a=this.parseClassElement(null!==e.superClass);a&&(n.body.push(a),"MethodDefinition"===a.type&&"constructor"===a.kind?(r&&this.raise(a.start,"Duplicate constructor in the same class"),r=!0):a.key&&"PrivateIdentifier"===a.key.type&&io(i,a)&&this.raiseRecoverable(a.key.start,"Identifier '#"+a.key.name+"' has already been declared"))}return this.strict=s,this.next(),e.body=this.finishNode(n,"ClassBody"),this.exitClassBody(),this.finishNode(e,t?"ClassDeclaration":"ClassExpression")},Qa.parseClassElement=function(e){if(this.eat(wa.semi))return null;var t=this.options.ecmaVersion,s=this.startNode(),i="",n=!1,r=!1,a="method",o=!1;if(this.eatContextual("static")){if(t>=13&&this.eat(wa.braceL))return this.parseClassStaticBlock(s),s;this.isClassElementNameStart()||this.type===wa.star?o=!0:i="static"}if(s.static=o,!i&&t>=8&&this.eatContextual("async")&&(!this.isClassElementNameStart()&&this.type!==wa.star||this.canInsertSemicolon()?i="async":r=!0),!i&&(t>=9||!r)&&this.eat(wa.star)&&(n=!0),!i&&!r&&!n){var h=this.value;(this.eatContextual("get")||this.eatContextual("set"))&&(this.isClassElementNameStart()?a=h:i=h)}if(i?(s.computed=!1,s.key=this.startNodeAt(this.lastTokStart,this.lastTokStartLoc),s.key.name=i,this.finishNode(s.key,"Identifier")):this.parseClassElementName(s),t<13||this.type===wa.parenL||"method"!==a||n||r){var l=!s.static&&no(s,"constructor"),c=l&&e;l&&"method"!==a&&this.raise(s.key.start,"Constructor can't have get/set modifier"),s.kind=l?"constructor":a,this.parseClassMethod(s,n,r,c)}else this.parseClassField(s);return s},Qa.isClassElementNameStart=function(){return this.type===wa.name||this.type===wa.privateId||this.type===wa.num||this.type===wa.string||this.type===wa.bracketL||this.type.keyword},Qa.parseClassElementName=function(e){this.type===wa.privateId?("constructor"===this.value&&this.raise(this.start,"Classes can't have an element named '#constructor'"),e.computed=!1,e.key=this.parsePrivateIdent()):this.parsePropertyName(e)},Qa.parseClassMethod=function(e,t,s,i){var n=e.key;"constructor"===e.kind?(t&&this.raise(n.start,"Constructor can't be a generator"),s&&this.raise(n.start,"Constructor can't be an async method")):e.static&&no(e,"prototype")&&this.raise(n.start,"Classes may not have a static property named prototype");var r=e.value=this.parseMethod(t,s,i);return"get"===e.kind&&0!==r.params.length&&this.raiseRecoverable(r.start,"getter should have no params"),"set"===e.kind&&1!==r.params.length&&this.raiseRecoverable(r.start,"setter should have exactly one param"),"set"===e.kind&&"RestElement"===r.params[0].type&&this.raiseRecoverable(r.params[0].start,"Setter cannot use rest params"),this.finishNode(e,"MethodDefinition")},Qa.parseClassField=function(e){if(no(e,"constructor")?this.raise(e.key.start,"Classes can't have a field named 'constructor'"):e.static&&no(e,"prototype")&&this.raise(e.key.start,"Classes can't have a static field named 'prototype'"),this.eat(wa.eq)){var t=this.currentThisScope(),s=t.inClassFieldInit;t.inClassFieldInit=!0,e.value=this.parseMaybeAssign(),t.inClassFieldInit=s}else e.value=null;return this.semicolon(),this.finishNode(e,"PropertyDefinition")},Qa.parseClassStaticBlock=function(e){e.body=[];var t=this.labels;for(this.labels=[],this.enterScope(320);this.type!==wa.braceR;){var s=this.parseStatement(null);e.body.push(s)}return this.next(),this.exitScope(),this.labels=t,this.finishNode(e,"StaticBlock")},Qa.parseClassId=function(e,t){this.type===wa.name?(e.id=this.parseIdent(),t&&this.checkLValSimple(e.id,2,!1)):(!0===t&&this.unexpected(),e.id=null)},Qa.parseClassSuper=function(e){e.superClass=this.eat(wa._extends)?this.parseExprSubscripts(!1):null},Qa.enterClassBody=function(){var e={declared:Object.create(null),used:[]};return this.privateNameStack.push(e),e.declared},Qa.exitClassBody=function(){for(var e=this.privateNameStack.pop(),t=e.declared,s=e.used,i=this.privateNameStack.length,n=0===i?null:this.privateNameStack[i-1],r=0;r<s.length;++r){var a=s[r];Da(t,a.name)||(n?n.used.push(a):this.raiseRecoverable(a.start,"Private field '#"+a.name+"' must be declared in an enclosing class"))}},Qa.parseExport=function(e,t){if(this.next(),this.eat(wa.star))return this.options.ecmaVersion>=11&&(this.eatContextual("as")?(e.exported=this.parseIdent(!0),this.checkExport(t,e.exported.name,this.lastTokStart)):e.exported=null),this.expectContextual("from"),this.type!==wa.string&&this.unexpected(),e.source=this.parseExprAtom(),this.semicolon(),this.finishNode(e,"ExportAllDeclaration");if(this.eat(wa._default)){var s;if(this.checkExport(t,"default",this.lastTokStart),this.type===wa._function||(s=this.isAsyncFunction())){var i=this.startNode();this.next(),s&&this.next(),e.declaration=this.parseFunction(i,4|to,!1,s)}else if(this.type===wa._class){var n=this.startNode();e.declaration=this.parseClass(n,"nullableID")}else e.declaration=this.parseMaybeAssign(),this.semicolon();return this.finishNode(e,"ExportDefaultDeclaration")}if(this.shouldParseExportStatement())e.declaration=this.parseStatement(null),"VariableDeclaration"===e.declaration.type?this.checkVariableExport(t,e.declaration.declarations):this.checkExport(t,e.declaration.id.name,e.declaration.id.start),e.specifiers=[],e.source=null;else{if(e.declaration=null,e.specifiers=this.parseExportSpecifiers(t),this.eatContextual("from"))this.type!==wa.string&&this.unexpected(),e.source=this.parseExprAtom();else{for(var r=0,a=e.specifiers;r<a.length;r+=1){var o=a[r];this.checkUnreserved(o.local),this.checkLocalExport(o.local)}e.source=null}this.semicolon()}return this.finishNode(e,"ExportNamedDeclaration")},Qa.checkExport=function(e,t,s){e&&(Da(e,t)&&this.raiseRecoverable(s,"Duplicate export '"+t+"'"),e[t]=!0)},Qa.checkPatternExport=function(e,t){var s=t.type;if("Identifier"===s)this.checkExport(e,t.name,t.start);else if("ObjectPattern"===s)for(var i=0,n=t.properties;i<n.length;i+=1){var r=n[i];this.checkPatternExport(e,r)}else if("ArrayPattern"===s)for(var a=0,o=t.elements;a<o.length;a+=1){var h=o[a];h&&this.checkPatternExport(e,h)}else"Property"===s?this.checkPatternExport(e,t.value):"AssignmentPattern"===s?this.checkPatternExport(e,t.left):"RestElement"===s?this.checkPatternExport(e,t.argument):"ParenthesizedExpression"===s&&this.checkPatternExport(e,t.expression)},Qa.checkVariableExport=function(e,t){if(e)for(var s=0,i=t;s<i.length;s+=1){var n=i[s];this.checkPatternExport(e,n.id)}},Qa.shouldParseExportStatement=function(){return"var"===this.type.keyword||"const"===this.type.keyword||"class"===this.type.keyword||"function"===this.type.keyword||this.isLet()||this.isAsyncFunction()},Qa.parseExportSpecifiers=function(e){var t=[],s=!0;for(this.expect(wa.braceL);!this.eat(wa.braceR);){if(s)s=!1;else if(this.expect(wa.comma),this.afterTrailingComma(wa.braceR))break;var i=this.startNode();i.local=this.parseIdent(!0),i.exported=this.eatContextual("as")?this.parseIdent(!0):i.local,this.checkExport(e,i.exported.name,i.exported.start),t.push(this.finishNode(i,"ExportSpecifier"))}return t},Qa.parseImport=function(e){return this.next(),this.type===wa.string?(e.specifiers=eo,e.source=this.parseExprAtom()):(e.specifiers=this.parseImportSpecifiers(),this.expectContextual("from"),e.source=this.type===wa.string?this.parseExprAtom():this.unexpected()),this.semicolon(),this.finishNode(e,"ImportDeclaration")},Qa.parseImportSpecifiers=function(){var e=[],t=!0;if(this.type===wa.name){var s=this.startNode();if(s.local=this.parseIdent(),this.checkLValSimple(s.local,2),e.push(this.finishNode(s,"ImportDefaultSpecifier")),!this.eat(wa.comma))return e}if(this.type===wa.star){var i=this.startNode();return this.next(),this.expectContextual("as"),i.local=this.parseIdent(),this.checkLValSimple(i.local,2),e.push(this.finishNode(i,"ImportNamespaceSpecifier")),e}for(this.expect(wa.braceL);!this.eat(wa.braceR);){if(t)t=!1;else if(this.expect(wa.comma),this.afterTrailingComma(wa.braceR))break;var n=this.startNode();n.imported=this.parseIdent(!0),this.eatContextual("as")?n.local=this.parseIdent():(this.checkUnreserved(n.imported),n.local=n.imported),this.checkLValSimple(n.local,2),e.push(this.finishNode(n,"ImportSpecifier"))}return e},Qa.adaptDirectivePrologue=function(e){for(var t=0;t<e.length&&this.isDirectiveCandidate(e[t]);++t)e[t].directive=e[t].expression.raw.slice(1,-1)},Qa.isDirectiveCandidate=function(e){return"ExpressionStatement"===e.type&&"Literal"===e.expression.type&&"string"==typeof e.expression.value&&('"'===this.input[e.start]||"'"===this.input[e.start])};var ro=Ha.prototype;ro.toAssignable=function(e,t,s){if(this.options.ecmaVersion>=6&&e)switch(e.type){case"Identifier":this.inAsync&&"await"===e.name&&this.raise(e.start,"Cannot use 'await' as identifier inside an async function");break;case"ObjectPattern":case"ArrayPattern":case"AssignmentPattern":case"RestElement":break;case"ObjectExpression":e.type="ObjectPattern",s&&this.checkPatternErrors(s,!0);for(var i=0,n=e.properties;i<n.length;i+=1){var r=n[i];this.toAssignable(r,t),"RestElement"!==r.type||"ArrayPattern"!==r.argument.type&&"ObjectPattern"!==r.argument.type||this.raise(r.argument.start,"Unexpected token")}break;case"Property":"init"!==e.kind&&this.raise(e.key.start,"Object pattern can't contain getter or setter"),this.toAssignable(e.value,t);break;case"ArrayExpression":e.type="ArrayPattern",s&&this.checkPatternErrors(s,!0),this.toAssignableList(e.elements,t);break;case"SpreadElement":e.type="RestElement",this.toAssignable(e.argument,t),"AssignmentPattern"===e.argument.type&&this.raise(e.argument.start,"Rest elements cannot have a default value");break;case"AssignmentExpression":"="!==e.operator&&this.raise(e.left.end,"Only '=' operator can be used for specifying default value."),e.type="AssignmentPattern",delete e.operator,this.toAssignable(e.left,t);break;case"ParenthesizedExpression":this.toAssignable(e.expression,t,s);break;case"ChainExpression":this.raiseRecoverable(e.start,"Optional chaining cannot appear in left-hand side");break;case"MemberExpression":if(!t)break;default:this.raise(e.start,"Assigning to rvalue")}else s&&this.checkPatternErrors(s,!0);return e},ro.toAssignableList=function(e,t){for(var s=e.length,i=0;i<s;i++){var n=e[i];n&&this.toAssignable(n,t)}if(s){var r=e[s-1];6===this.options.ecmaVersion&&t&&r&&"RestElement"===r.type&&"Identifier"!==r.argument.type&&this.unexpected(r.argument.start)}return e},ro.parseSpread=function(e){var t=this.startNode();return this.next(),t.argument=this.parseMaybeAssign(!1,e),this.finishNode(t,"SpreadElement")},ro.parseRestBinding=function(){var e=this.startNode();return this.next(),6===this.options.ecmaVersion&&this.type!==wa.name&&this.unexpected(),e.argument=this.parseBindingAtom(),this.finishNode(e,"RestElement")},ro.parseBindingAtom=function(){if(this.options.ecmaVersion>=6)switch(this.type){case wa.bracketL:var e=this.startNode();return this.next(),e.elements=this.parseBindingList(wa.bracketR,!0,!0),this.finishNode(e,"ArrayPattern");case wa.braceL:return this.parseObj(!0)}return this.parseIdent()},ro.parseBindingList=function(e,t,s){for(var i=[],n=!0;!this.eat(e);)if(n?n=!1:this.expect(wa.comma),t&&this.type===wa.comma)i.push(null);else{if(s&&this.afterTrailingComma(e))break;if(this.type===wa.ellipsis){var r=this.parseRestBinding();this.parseBindingListItem(r),i.push(r),this.type===wa.comma&&this.raise(this.start,"Comma is not permitted after the rest element"),this.expect(e);break}var a=this.parseMaybeDefault(this.start,this.startLoc);this.parseBindingListItem(a),i.push(a)}return i},ro.parseBindingListItem=function(e){return e},ro.parseMaybeDefault=function(e,t,s){if(s=s||this.parseBindingAtom(),this.options.ecmaVersion<6||!this.eat(wa.eq))return s;var i=this.startNodeAt(e,t);return i.left=s,i.right=this.parseMaybeAssign(),this.finishNode(i,"AssignmentPattern")},ro.checkLValSimple=function(e,t,s){void 0===t&&(t=0);var i=0!==t;switch(e.type){case"Identifier":this.strict&&this.reservedWordsStrictBind.test(e.name)&&this.raiseRecoverable(e.start,(i?"Binding ":"Assigning to ")+e.name+" in strict mode"),i&&(2===t&&"let"===e.name&&this.raiseRecoverable(e.start,"let is disallowed as a lexically bound name"),s&&(Da(s,e.name)&&this.raiseRecoverable(e.start,"Argument name clash"),s[e.name]=!0),5!==t&&this.declareName(e.name,t,e.start));break;case"ChainExpression":this.raiseRecoverable(e.start,"Optional chaining cannot appear in left-hand side");break;case"MemberExpression":i&&this.raiseRecoverable(e.start,"Binding member expression");break;case"ParenthesizedExpression":return i&&this.raiseRecoverable(e.start,"Binding parenthesized expression"),this.checkLValSimple(e.expression,t,s);default:this.raise(e.start,(i?"Binding":"Assigning to")+" rvalue")}},ro.checkLValPattern=function(e,t,s){switch(void 0===t&&(t=0),e.type){case"ObjectPattern":for(var i=0,n=e.properties;i<n.length;i+=1){var r=n[i];this.checkLValInnerPattern(r,t,s)}break;case"ArrayPattern":for(var a=0,o=e.elements;a<o.length;a+=1){var h=o[a];h&&this.checkLValInnerPattern(h,t,s)}break;default:this.checkLValSimple(e,t,s)}},ro.checkLValInnerPattern=function(e,t,s){switch(void 0===t&&(t=0),e.type){case"Property":this.checkLValInnerPattern(e.value,t,s);break;case"AssignmentPattern":this.checkLValPattern(e.left,t,s);break;case"RestElement":this.checkLValPattern(e.argument,t,s);break;default:this.checkLValPattern(e,t,s)}};var ao=function(e,t,s,i,n){this.token=e,this.isExpr=!!t,this.preserveSpace=!!s,this.override=i,this.generator=!!n},oo={b_stat:new ao("{",!1),b_expr:new ao("{",!0),b_tmpl:new ao("${",!1),p_stat:new ao("(",!1),p_expr:new ao("(",!0),q_tmpl:new ao("`",!0,!0,(function(e){return e.tryReadTemplateToken()})),f_stat:new ao("function",!1),f_expr:new ao("function",!0),f_expr_gen:new ao("function",!0,!1,null,!0),f_gen:new ao("function",!1,!1,null,!0)},ho=Ha.prototype;ho.initialContext=function(){return[oo.b_stat]},ho.curContext=function(){return this.context[this.context.length-1]},ho.braceIsBlock=function(e){var t=this.curContext();return t===oo.f_expr||t===oo.f_stat||(e!==wa.colon||t!==oo.b_stat&&t!==oo.b_expr?e===wa._return||e===wa.name&&this.exprAllowed?Ca.test(this.input.slice(this.lastTokEnd,this.start)):e===wa._else||e===wa.semi||e===wa.eof||e===wa.parenR||e===wa.arrow||(e===wa.braceL?t===oo.b_stat:e!==wa._var&&e!==wa._const&&e!==wa.name&&!this.exprAllowed):!t.isExpr)},ho.inGeneratorContext=function(){for(var e=this.context.length-1;e>=1;e--){var t=this.context[e];if("function"===t.token)return t.generator}return!1},ho.updateContext=function(e){var t,s=this.type;s.keyword&&e===wa.dot?this.exprAllowed=!1:(t=s.updateContext)?t.call(this,e):this.exprAllowed=s.beforeExpr},ho.overrideContext=function(e){this.curContext()!==e&&(this.context[this.context.length-1]=e)},wa.parenR.updateContext=wa.braceR.updateContext=function(){if(1!==this.context.length){var e=this.context.pop();e===oo.b_stat&&"function"===this.curContext().token&&(e=this.context.pop()),this.exprAllowed=!e.isExpr}else this.exprAllowed=!0},wa.braceL.updateContext=function(e){this.context.push(this.braceIsBlock(e)?oo.b_stat:oo.b_expr),this.exprAllowed=!0},wa.dollarBraceL.updateContext=function(){this.context.push(oo.b_tmpl),this.exprAllowed=!0},wa.parenL.updateContext=function(e){var t=e===wa._if||e===wa._for||e===wa._with||e===wa._while;this.context.push(t?oo.p_stat:oo.p_expr),this.exprAllowed=!0},wa.incDec.updateContext=function(){},wa._function.updateContext=wa._class.updateContext=function(e){!e.beforeExpr||e===wa._else||e===wa.semi&&this.curContext()!==oo.p_stat||e===wa._return&&Ca.test(this.input.slice(this.lastTokEnd,this.start))||(e===wa.colon||e===wa.braceL)&&this.curContext()===oo.b_stat?this.context.push(oo.f_stat):this.context.push(oo.f_expr),this.exprAllowed=!1},wa.backQuote.updateContext=function(){this.curContext()===oo.q_tmpl?this.context.pop():this.context.push(oo.q_tmpl),this.exprAllowed=!1},wa.star.updateContext=function(e){if(e===wa._function){var t=this.context.length-1;this.context[t]===oo.f_expr?this.context[t]=oo.f_expr_gen:this.context[t]=oo.f_gen}this.exprAllowed=!0},wa.name.updateContext=function(e){var t=!1;this.options.ecmaVersion>=6&&e!==wa.dot&&("of"===this.value&&!this.exprAllowed||"yield"===this.value&&this.inGeneratorContext())&&(t=!0),this.exprAllowed=t};var lo=Ha.prototype;function co(e){return"MemberExpression"===e.type&&"PrivateIdentifier"===e.property.type||"ChainExpression"===e.type&&co(e.expression)}lo.checkPropClash=function(e,t,s){if(!(this.options.ecmaVersion>=9&&"SpreadElement"===e.type||this.options.ecmaVersion>=6&&(e.computed||e.method||e.shorthand))){var i,n=e.key;switch(n.type){case"Identifier":i=n.name;break;case"Literal":i=String(n.value);break;default:return}var r=e.kind;if(this.options.ecmaVersion>=6)"__proto__"===i&&"init"===r&&(t.proto&&(s?s.doubleProto<0&&(s.doubleProto=n.start):this.raiseRecoverable(n.start,"Redefinition of __proto__ property")),t.proto=!0);else{var a=t[i="$"+i];a?("init"===r?this.strict&&a.init||a.get||a.set:a.init||a[r])&&this.raiseRecoverable(n.start,"Redefinition of property"):a=t[i]={init:!1,get:!1,set:!1},a[r]=!0}}},lo.parseExpression=function(e,t){var s=this.start,i=this.startLoc,n=this.parseMaybeAssign(e,t);if(this.type===wa.comma){var r=this.startNodeAt(s,i);for(r.expressions=[n];this.eat(wa.comma);)r.expressions.push(this.parseMaybeAssign(e,t));return this.finishNode(r,"SequenceExpression")}return n},lo.parseMaybeAssign=function(e,t,s){if(this.isContextual("yield")){if(this.inGenerator)return this.parseYield(e);this.exprAllowed=!1}var i=!1,n=-1,r=-1;t?(n=t.parenthesizedAssign,r=t.trailingComma,t.parenthesizedAssign=t.trailingComma=-1):(t=new Ya,i=!0);var a=this.start,o=this.startLoc;this.type!==wa.parenL&&this.type!==wa.name||(this.potentialArrowAt=this.start,this.potentialArrowInForAwait="await"===e);var h=this.parseMaybeConditional(e,t);if(s&&(h=s.call(this,h,a,o)),this.type.isAssign){var l=this.startNodeAt(a,o);return l.operator=this.value,this.type===wa.eq&&(h=this.toAssignable(h,!1,t)),i||(t.parenthesizedAssign=t.trailingComma=t.doubleProto=-1),t.shorthandAssign>=h.start&&(t.shorthandAssign=-1),this.type===wa.eq?this.checkLValPattern(h):this.checkLValSimple(h),l.left=h,this.next(),l.right=this.parseMaybeAssign(e),this.finishNode(l,"AssignmentExpression")}return i&&this.checkExpressionErrors(t,!0),n>-1&&(t.parenthesizedAssign=n),r>-1&&(t.trailingComma=r),h},lo.parseMaybeConditional=function(e,t){var s=this.start,i=this.startLoc,n=this.parseExprOps(e,t);if(this.checkExpressionErrors(t))return n;if(this.eat(wa.question)){var r=this.startNodeAt(s,i);return r.test=n,r.consequent=this.parseMaybeAssign(),this.expect(wa.colon),r.alternate=this.parseMaybeAssign(e),this.finishNode(r,"ConditionalExpression")}return n},lo.parseExprOps=function(e,t){var s=this.start,i=this.startLoc,n=this.parseMaybeUnary(t,!1,!1,e);return this.checkExpressionErrors(t)||n.start===s&&"ArrowFunctionExpression"===n.type?n:this.parseExprOp(n,s,i,-1,e)},lo.parseExprOp=function(e,t,s,i,n){var r=this.type.binop;if(null!=r&&(!n||this.type!==wa._in)&&r>i){var a=this.type===wa.logicalOR||this.type===wa.logicalAND,o=this.type===wa.coalesce;o&&(r=wa.logicalAND.binop);var h=this.value;this.next();var l=this.start,c=this.startLoc,u=this.parseExprOp(this.parseMaybeUnary(null,!1,!1,n),l,c,r,n),d=this.buildBinary(t,s,e,u,h,a||o);return(a&&this.type===wa.coalesce||o&&(this.type===wa.logicalOR||this.type===wa.logicalAND))&&this.raiseRecoverable(this.start,"Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"),this.parseExprOp(d,t,s,i,n)}return e},lo.buildBinary=function(e,t,s,i,n,r){var a=this.startNodeAt(e,t);return a.left=s,a.operator=n,a.right=i,this.finishNode(a,r?"LogicalExpression":"BinaryExpression")},lo.parseMaybeUnary=function(e,t,s,i){var n,r=this.start,a=this.startLoc;if(this.isContextual("await")&&this.canAwait)n=this.parseAwait(i),t=!0;else if(this.type.prefix){var o=this.startNode(),h=this.type===wa.incDec;o.operator=this.value,o.prefix=!0,this.next(),o.argument=this.parseMaybeUnary(null,!0,h,i),this.checkExpressionErrors(e,!0),h?this.checkLValSimple(o.argument):this.strict&&"delete"===o.operator&&"Identifier"===o.argument.type?this.raiseRecoverable(o.start,"Deleting local variable in strict mode"):"delete"===o.operator&&co(o.argument)?this.raiseRecoverable(o.start,"Private fields can not be deleted"):t=!0,n=this.finishNode(o,h?"UpdateExpression":"UnaryExpression")}else{if(n=this.parseExprSubscripts(e,i),this.checkExpressionErrors(e))return n;for(;this.type.postfix&&!this.canInsertSemicolon();){var l=this.startNodeAt(r,a);l.operator=this.value,l.prefix=!1,l.argument=n,this.checkLValSimple(n),this.next(),n=this.finishNode(l,"UpdateExpression")}}return s||!this.eat(wa.starstar)?n:t?void this.unexpected(this.lastTokStart):this.buildBinary(r,a,n,this.parseMaybeUnary(null,!1,!1,i),"**",!1)},lo.parseExprSubscripts=function(e,t){var s=this.start,i=this.startLoc,n=this.parseExprAtom(e,t);if("ArrowFunctionExpression"===n.type&&")"!==this.input.slice(this.lastTokStart,this.lastTokEnd))return n;var r=this.parseSubscripts(n,s,i,!1,t);return e&&"MemberExpression"===r.type&&(e.parenthesizedAssign>=r.start&&(e.parenthesizedAssign=-1),e.parenthesizedBind>=r.start&&(e.parenthesizedBind=-1),e.trailingComma>=r.start&&(e.trailingComma=-1)),r},lo.parseSubscripts=function(e,t,s,i,n){for(var r=this.options.ecmaVersion>=8&&"Identifier"===e.type&&"async"===e.name&&this.lastTokEnd===e.end&&!this.canInsertSemicolon()&&e.end-e.start==5&&this.potentialArrowAt===e.start,a=!1;;){var o=this.parseSubscript(e,t,s,i,r,a,n);if(o.optional&&(a=!0),o===e||"ArrowFunctionExpression"===o.type){if(a){var h=this.startNodeAt(t,s);h.expression=o,o=this.finishNode(h,"ChainExpression")}return o}e=o}},lo.parseSubscript=function(e,t,s,i,n,r,a){var o=this.options.ecmaVersion>=11,h=o&&this.eat(wa.questionDot);i&&h&&this.raise(this.lastTokStart,"Optional chaining cannot appear in the callee of new expressions");var l=this.eat(wa.bracketL);if(l||h&&this.type!==wa.parenL&&this.type!==wa.backQuote||this.eat(wa.dot)){var c=this.startNodeAt(t,s);c.object=e,l?(c.property=this.parseExpression(),this.expect(wa.bracketR)):this.type===wa.privateId&&"Super"!==e.type?c.property=this.parsePrivateIdent():c.property=this.parseIdent("never"!==this.options.allowReserved),c.computed=!!l,o&&(c.optional=h),e=this.finishNode(c,"MemberExpression")}else if(!i&&this.eat(wa.parenL)){var u=new Ya,d=this.yieldPos,p=this.awaitPos,f=this.awaitIdentPos;this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0;var m=this.parseExprList(wa.parenR,this.options.ecmaVersion>=8,!1,u);if(n&&!h&&!this.canInsertSemicolon()&&this.eat(wa.arrow))return this.checkPatternErrors(u,!1),this.checkYieldAwaitInDefaultParams(),this.awaitIdentPos>0&&this.raise(this.awaitIdentPos,"Cannot use 'await' as identifier inside an async function"),this.yieldPos=d,this.awaitPos=p,this.awaitIdentPos=f,this.parseArrowExpression(this.startNodeAt(t,s),m,!0,a);this.checkExpressionErrors(u,!0),this.yieldPos=d||this.yieldPos,this.awaitPos=p||this.awaitPos,this.awaitIdentPos=f||this.awaitIdentPos;var g=this.startNodeAt(t,s);g.callee=e,g.arguments=m,o&&(g.optional=h),e=this.finishNode(g,"CallExpression")}else if(this.type===wa.backQuote){(h||r)&&this.raise(this.start,"Optional chaining cannot appear in the tag of tagged template expressions");var y=this.startNodeAt(t,s);y.tag=e,y.quasi=this.parseTemplate({isTagged:!0}),e=this.finishNode(y,"TaggedTemplateExpression")}return e},lo.parseExprAtom=function(e,t){this.type===wa.slash&&this.readRegexp();var s,i=this.potentialArrowAt===this.start;switch(this.type){case wa._super:return this.allowSuper||this.raise(this.start,"'super' keyword outside a method"),s=this.startNode(),this.next(),this.type!==wa.parenL||this.allowDirectSuper||this.raise(s.start,"super() call outside constructor of a subclass"),this.type!==wa.dot&&this.type!==wa.bracketL&&this.type!==wa.parenL&&this.unexpected(),this.finishNode(s,"Super");case wa._this:return s=this.startNode(),this.next(),this.finishNode(s,"ThisExpression");case wa.name:var n=this.start,r=this.startLoc,a=this.containsEsc,o=this.parseIdent(!1);if(this.options.ecmaVersion>=8&&!a&&"async"===o.name&&!this.canInsertSemicolon()&&this.eat(wa._function))return this.overrideContext(oo.f_expr),this.parseFunction(this.startNodeAt(n,r),0,!1,!0,t);if(i&&!this.canInsertSemicolon()){if(this.eat(wa.arrow))return this.parseArrowExpression(this.startNodeAt(n,r),[o],!1,t);if(this.options.ecmaVersion>=8&&"async"===o.name&&this.type===wa.name&&!a&&(!this.potentialArrowInForAwait||"of"!==this.value||this.containsEsc))return o=this.parseIdent(!1),!this.canInsertSemicolon()&&this.eat(wa.arrow)||this.unexpected(),this.parseArrowExpression(this.startNodeAt(n,r),[o],!0,t)}return o;case wa.regexp:var h=this.value;return(s=this.parseLiteral(h.value)).regex={pattern:h.pattern,flags:h.flags},s;case wa.num:case wa.string:return this.parseLiteral(this.value);case wa._null:case wa._true:case wa._false:return(s=this.startNode()).value=this.type===wa._null?null:this.type===wa._true,s.raw=this.type.keyword,this.next(),this.finishNode(s,"Literal");case wa.parenL:var l=this.start,c=this.parseParenAndDistinguishExpression(i,t);return e&&(e.parenthesizedAssign<0&&!this.isSimpleAssignTarget(c)&&(e.parenthesizedAssign=l),e.parenthesizedBind<0&&(e.parenthesizedBind=l)),c;case wa.bracketL:return s=this.startNode(),this.next(),s.elements=this.parseExprList(wa.bracketR,!0,!0,e),this.finishNode(s,"ArrayExpression");case wa.braceL:return this.overrideContext(oo.b_expr),this.parseObj(!1,e);case wa._function:return s=this.startNode(),this.next(),this.parseFunction(s,0);case wa._class:return this.parseClass(this.startNode(),!1);case wa._new:return this.parseNew();case wa.backQuote:return this.parseTemplate();case wa._import:return this.options.ecmaVersion>=11?this.parseExprImport():this.unexpected();default:this.unexpected()}},lo.parseExprImport=function(){var e=this.startNode();this.containsEsc&&this.raiseRecoverable(this.start,"Escape sequence in keyword import");var t=this.parseIdent(!0);switch(this.type){case wa.parenL:return this.parseDynamicImport(e);case wa.dot:return e.meta=t,this.parseImportMeta(e);default:this.unexpected()}},lo.parseDynamicImport=function(e){if(this.next(),e.source=this.parseMaybeAssign(),!this.eat(wa.parenR)){var t=this.start;this.eat(wa.comma)&&this.eat(wa.parenR)?this.raiseRecoverable(t,"Trailing comma is not allowed in import()"):this.unexpected(t)}return this.finishNode(e,"ImportExpression")},lo.parseImportMeta=function(e){this.next();var t=this.containsEsc;return e.property=this.parseIdent(!0),"meta"!==e.property.name&&this.raiseRecoverable(e.property.start,"The only valid meta property for import is 'import.meta'"),t&&this.raiseRecoverable(e.start,"'import.meta' must not contain escaped characters"),"module"===this.options.sourceType||this.options.allowImportExportEverywhere||this.raiseRecoverable(e.start,"Cannot use 'import.meta' outside a module"),this.finishNode(e,"MetaProperty")},lo.parseLiteral=function(e){var t=this.startNode();return t.value=e,t.raw=this.input.slice(this.start,this.end),110===t.raw.charCodeAt(t.raw.length-1)&&(t.bigint=t.raw.slice(0,-1).replace(/_/g,"")),this.next(),this.finishNode(t,"Literal")},lo.parseParenExpression=function(){this.expect(wa.parenL);var e=this.parseExpression();return this.expect(wa.parenR),e},lo.parseParenAndDistinguishExpression=function(e,t){var s,i=this.start,n=this.startLoc,r=this.options.ecmaVersion>=8;if(this.options.ecmaVersion>=6){this.next();var a,o=this.start,h=this.startLoc,l=[],c=!0,u=!1,d=new Ya,p=this.yieldPos,f=this.awaitPos;for(this.yieldPos=0,this.awaitPos=0;this.type!==wa.parenR;){if(c?c=!1:this.expect(wa.comma),r&&this.afterTrailingComma(wa.parenR,!0)){u=!0;break}if(this.type===wa.ellipsis){a=this.start,l.push(this.parseParenItem(this.parseRestBinding())),this.type===wa.comma&&this.raise(this.start,"Comma is not permitted after the rest element");break}l.push(this.parseMaybeAssign(!1,d,this.parseParenItem))}var m=this.lastTokEnd,g=this.lastTokEndLoc;if(this.expect(wa.parenR),e&&!this.canInsertSemicolon()&&this.eat(wa.arrow))return this.checkPatternErrors(d,!1),this.checkYieldAwaitInDefaultParams(),this.yieldPos=p,this.awaitPos=f,this.parseParenArrowList(i,n,l,t);l.length&&!u||this.unexpected(this.lastTokStart),a&&this.unexpected(a),this.checkExpressionErrors(d,!0),this.yieldPos=p||this.yieldPos,this.awaitPos=f||this.awaitPos,l.length>1?((s=this.startNodeAt(o,h)).expressions=l,this.finishNodeAt(s,"SequenceExpression",m,g)):s=l[0]}else s=this.parseParenExpression();if(this.options.preserveParens){var y=this.startNodeAt(i,n);return y.expression=s,this.finishNode(y,"ParenthesizedExpression")}return s},lo.parseParenItem=function(e){return e},lo.parseParenArrowList=function(e,t,s,i){return this.parseArrowExpression(this.startNodeAt(e,t),s,i)};var uo=[];lo.parseNew=function(){this.containsEsc&&this.raiseRecoverable(this.start,"Escape sequence in keyword new");var e=this.startNode(),t=this.parseIdent(!0);if(this.options.ecmaVersion>=6&&this.eat(wa.dot)){e.meta=t;var s=this.containsEsc;return e.property=this.parseIdent(!0),"target"!==e.property.name&&this.raiseRecoverable(e.property.start,"The only valid meta property for new is 'new.target'"),s&&this.raiseRecoverable(e.start,"'new.target' must not contain escaped characters"),this.allowNewDotTarget||this.raiseRecoverable(e.start,"'new.target' can only be used in functions and class static block"),this.finishNode(e,"MetaProperty")}var i=this.start,n=this.startLoc,r=this.type===wa._import;return e.callee=this.parseSubscripts(this.parseExprAtom(),i,n,!0,!1),r&&"ImportExpression"===e.callee.type&&this.raise(i,"Cannot use new with import()"),this.eat(wa.parenL)?e.arguments=this.parseExprList(wa.parenR,this.options.ecmaVersion>=8,!1):e.arguments=uo,this.finishNode(e,"NewExpression")},lo.parseTemplateElement=function(e){var t=e.isTagged,s=this.startNode();return this.type===wa.invalidTemplate?(t||this.raiseRecoverable(this.start,"Bad escape sequence in untagged template literal"),s.value={raw:this.value,cooked:null}):s.value={raw:this.input.slice(this.start,this.end).replace(/\r\n?/g,"\n"),cooked:this.value},this.next(),s.tail=this.type===wa.backQuote,this.finishNode(s,"TemplateElement")},lo.parseTemplate=function(e){void 0===e&&(e={});var t=e.isTagged;void 0===t&&(t=!1);var s=this.startNode();this.next(),s.expressions=[];var i=this.parseTemplateElement({isTagged:t});for(s.quasis=[i];!i.tail;)this.type===wa.eof&&this.raise(this.pos,"Unterminated template literal"),this.expect(wa.dollarBraceL),s.expressions.push(this.parseExpression()),this.expect(wa.braceR),s.quasis.push(i=this.parseTemplateElement({isTagged:t}));return this.next(),this.finishNode(s,"TemplateLiteral")},lo.isAsyncProp=function(e){return!e.computed&&"Identifier"===e.key.type&&"async"===e.key.name&&(this.type===wa.name||this.type===wa.num||this.type===wa.string||this.type===wa.bracketL||this.type.keyword||this.options.ecmaVersion>=9&&this.type===wa.star)&&!Ca.test(this.input.slice(this.lastTokEnd,this.start))},lo.parseObj=function(e,t){var s=this.startNode(),i=!0,n={};for(s.properties=[],this.next();!this.eat(wa.braceR);){if(i)i=!1;else if(this.expect(wa.comma),this.options.ecmaVersion>=5&&this.afterTrailingComma(wa.braceR))break;var r=this.parseProperty(e,t);e||this.checkPropClash(r,n,t),s.properties.push(r)}return this.finishNode(s,e?"ObjectPattern":"ObjectExpression")},lo.parseProperty=function(e,t){var s,i,n,r,a=this.startNode();if(this.options.ecmaVersion>=9&&this.eat(wa.ellipsis))return e?(a.argument=this.parseIdent(!1),this.type===wa.comma&&this.raise(this.start,"Comma is not permitted after the rest element"),this.finishNode(a,"RestElement")):(this.type===wa.parenL&&t&&(t.parenthesizedAssign<0&&(t.parenthesizedAssign=this.start),t.parenthesizedBind<0&&(t.parenthesizedBind=this.start)),a.argument=this.parseMaybeAssign(!1,t),this.type===wa.comma&&t&&t.trailingComma<0&&(t.trailingComma=this.start),this.finishNode(a,"SpreadElement"));this.options.ecmaVersion>=6&&(a.method=!1,a.shorthand=!1,(e||t)&&(n=this.start,r=this.startLoc),e||(s=this.eat(wa.star)));var o=this.containsEsc;return this.parsePropertyName(a),!e&&!o&&this.options.ecmaVersion>=8&&!s&&this.isAsyncProp(a)?(i=!0,s=this.options.ecmaVersion>=9&&this.eat(wa.star),this.parsePropertyName(a,t)):i=!1,this.parsePropertyValue(a,e,s,i,n,r,t,o),this.finishNode(a,"Property")},lo.parsePropertyValue=function(e,t,s,i,n,r,a,o){if((s||i)&&this.type===wa.colon&&this.unexpected(),this.eat(wa.colon))e.value=t?this.parseMaybeDefault(this.start,this.startLoc):this.parseMaybeAssign(!1,a),e.kind="init";else if(this.options.ecmaVersion>=6&&this.type===wa.parenL)t&&this.unexpected(),e.kind="init",e.method=!0,e.value=this.parseMethod(s,i);else if(t||o||!(this.options.ecmaVersion>=5)||e.computed||"Identifier"!==e.key.type||"get"!==e.key.name&&"set"!==e.key.name||this.type===wa.comma||this.type===wa.braceR||this.type===wa.eq)this.options.ecmaVersion>=6&&!e.computed&&"Identifier"===e.key.type?((s||i)&&this.unexpected(),this.checkUnreserved(e.key),"await"!==e.key.name||this.awaitIdentPos||(this.awaitIdentPos=n),e.kind="init",t?e.value=this.parseMaybeDefault(n,r,this.copyNode(e.key)):this.type===wa.eq&&a?(a.shorthandAssign<0&&(a.shorthandAssign=this.start),e.value=this.parseMaybeDefault(n,r,this.copyNode(e.key))):e.value=this.copyNode(e.key),e.shorthand=!0):this.unexpected();else{(s||i)&&this.unexpected(),e.kind=e.key.name,this.parsePropertyName(e),e.value=this.parseMethod(!1);var h="get"===e.kind?0:1;if(e.value.params.length!==h){var l=e.value.start;"get"===e.kind?this.raiseRecoverable(l,"getter should have no params"):this.raiseRecoverable(l,"setter should have exactly one param")}else"set"===e.kind&&"RestElement"===e.value.params[0].type&&this.raiseRecoverable(e.value.params[0].start,"Setter cannot use rest params")}},lo.parsePropertyName=function(e){if(this.options.ecmaVersion>=6){if(this.eat(wa.bracketL))return e.computed=!0,e.key=this.parseMaybeAssign(),this.expect(wa.bracketR),e.key;e.computed=!1}return e.key=this.type===wa.num||this.type===wa.string?this.parseExprAtom():this.parseIdent("never"!==this.options.allowReserved)},lo.initFunction=function(e){e.id=null,this.options.ecmaVersion>=6&&(e.generator=e.expression=!1),this.options.ecmaVersion>=8&&(e.async=!1)},lo.parseMethod=function(e,t,s){var i=this.startNode(),n=this.yieldPos,r=this.awaitPos,a=this.awaitIdentPos;return this.initFunction(i),this.options.ecmaVersion>=6&&(i.generator=e),this.options.ecmaVersion>=8&&(i.async=!!t),this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0,this.enterScope(64|Ga(t,i.generator)|(s?128:0)),this.expect(wa.parenL),i.params=this.parseBindingList(wa.parenR,!1,this.options.ecmaVersion>=8),this.checkYieldAwaitInDefaultParams(),this.parseFunctionBody(i,!1,!0,!1),this.yieldPos=n,this.awaitPos=r,this.awaitIdentPos=a,this.finishNode(i,"FunctionExpression")},lo.parseArrowExpression=function(e,t,s,i){var n=this.yieldPos,r=this.awaitPos,a=this.awaitIdentPos;return this.enterScope(16|Ga(s,!1)),this.initFunction(e),this.options.ecmaVersion>=8&&(e.async=!!s),this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0,e.params=this.toAssignableList(t,!0),this.parseFunctionBody(e,!0,!1,i),this.yieldPos=n,this.awaitPos=r,this.awaitIdentPos=a,this.finishNode(e,"ArrowFunctionExpression")},lo.parseFunctionBody=function(e,t,s,i){var n=t&&this.type!==wa.braceL,r=this.strict,a=!1;if(n)e.body=this.parseMaybeAssign(i),e.expression=!0,this.checkParams(e,!1);else{var o=this.options.ecmaVersion>=7&&!this.isSimpleParamList(e.params);r&&!o||(a=this.strictDirective(this.end))&&o&&this.raiseRecoverable(e.start,"Illegal 'use strict' directive in function with non-simple parameter list");var h=this.labels;this.labels=[],a&&(this.strict=!0),this.checkParams(e,!r&&!a&&!t&&!s&&this.isSimpleParamList(e.params)),this.strict&&e.id&&this.checkLValSimple(e.id,5),e.body=this.parseBlock(!1,void 0,a&&!r),e.expression=!1,this.adaptDirectivePrologue(e.body.body),this.labels=h}this.exitScope()},lo.isSimpleParamList=function(e){for(var t=0,s=e;t<s.length;t+=1)if("Identifier"!==s[t].type)return!1;return!0},lo.checkParams=function(e,t){for(var s=Object.create(null),i=0,n=e.params;i<n.length;i+=1){var r=n[i];this.checkLValInnerPattern(r,1,t?null:s)}},lo.parseExprList=function(e,t,s,i){for(var n=[],r=!0;!this.eat(e);){if(r)r=!1;else if(this.expect(wa.comma),t&&this.afterTrailingComma(e))break;var a=void 0;s&&this.type===wa.comma?a=null:this.type===wa.ellipsis?(a=this.parseSpread(i),i&&this.type===wa.comma&&i.trailingComma<0&&(i.trailingComma=this.start)):a=this.parseMaybeAssign(!1,i),n.push(a)}return n},lo.checkUnreserved=function(e){var t=e.start,s=e.end,i=e.name;this.inGenerator&&"yield"===i&&this.raiseRecoverable(t,"Cannot use 'yield' as identifier inside a generator"),this.inAsync&&"await"===i&&this.raiseRecoverable(t,"Cannot use 'await' as identifier inside an async function"),this.currentThisScope().inClassFieldInit&&"arguments"===i&&this.raiseRecoverable(t,"Cannot use 'arguments' in class field initializer"),!this.inClassStaticBlock||"arguments"!==i&&"await"!==i||this.raise(t,"Cannot use "+i+" in class static initialization block"),this.keywords.test(i)&&this.raise(t,"Unexpected keyword '"+i+"'"),this.options.ecmaVersion<6&&-1!==this.input.slice(t,s).indexOf("\\")||(this.strict?this.reservedWordsStrict:this.reservedWords).test(i)&&(this.inAsync||"await"!==i||this.raiseRecoverable(t,"Cannot use keyword 'await' outside an async function"),this.raiseRecoverable(t,"The keyword '"+i+"' is reserved"))},lo.parseIdent=function(e,t){var s=this.startNode();return this.type===wa.name?s.name=this.value:this.type.keyword?(s.name=this.type.keyword,"class"!==s.name&&"function"!==s.name||this.lastTokEnd===this.lastTokStart+1&&46===this.input.charCodeAt(this.lastTokStart)||this.context.pop()):this.unexpected(),this.next(!!e),this.finishNode(s,"Identifier"),e||(this.checkUnreserved(s),"await"!==s.name||this.awaitIdentPos||(this.awaitIdentPos=s.start)),s},lo.parsePrivateIdent=function(){var e=this.startNode();return this.type===wa.privateId?e.name=this.value:this.unexpected(),this.next(),this.finishNode(e,"PrivateIdentifier"),0===this.privateNameStack.length?this.raise(e.start,"Private field '#"+e.name+"' must be declared in an enclosing class"):this.privateNameStack[this.privateNameStack.length-1].used.push(e),e},lo.parseYield=function(e){this.yieldPos||(this.yieldPos=this.start);var t=this.startNode();return this.next(),this.type===wa.semi||this.canInsertSemicolon()||this.type!==wa.star&&!this.type.startsExpr?(t.delegate=!1,t.argument=null):(t.delegate=this.eat(wa.star),t.argument=this.parseMaybeAssign(e)),this.finishNode(t,"YieldExpression")},lo.parseAwait=function(e){this.awaitPos||(this.awaitPos=this.start);var t=this.startNode();return this.next(),t.argument=this.parseMaybeUnary(null,!0,!1,e),this.finishNode(t,"AwaitExpression")};var po=Ha.prototype;po.raise=function(e,t){var s=Fa(this.input,e);t+=" ("+s.line+":"+s.column+")";var i=new SyntaxError(t);throw i.pos=e,i.loc=s,i.raisedAt=this.pos,i},po.raiseRecoverable=po.raise,po.curPosition=function(){if(this.options.locations)return new Va(this.curLine,this.pos-this.lineStart)};var fo=Ha.prototype,mo=function(e){this.flags=e,this.var=[],this.lexical=[],this.functions=[],this.inClassFieldInit=!1};fo.enterScope=function(e){this.scopeStack.push(new mo(e))},fo.exitScope=function(){this.scopeStack.pop()},fo.treatFunctionsAsVarInScope=function(e){return 2&e.flags||!this.inModule&&1&e.flags},fo.declareName=function(e,t,s){var i=!1;if(2===t){var n=this.currentScope();i=n.lexical.indexOf(e)>-1||n.functions.indexOf(e)>-1||n.var.indexOf(e)>-1,n.lexical.push(e),this.inModule&&1&n.flags&&delete this.undefinedExports[e]}else if(4===t)this.currentScope().lexical.push(e);else if(3===t){var r=this.currentScope();i=this.treatFunctionsAsVar?r.lexical.indexOf(e)>-1:r.lexical.indexOf(e)>-1||r.var.indexOf(e)>-1,r.functions.push(e)}else for(var a=this.scopeStack.length-1;a>=0;--a){var o=this.scopeStack[a];if(o.lexical.indexOf(e)>-1&&!(32&o.flags&&o.lexical[0]===e)||!this.treatFunctionsAsVarInScope(o)&&o.functions.indexOf(e)>-1){i=!0;break}if(o.var.push(e),this.inModule&&1&o.flags&&delete this.undefinedExports[e],259&o.flags)break}i&&this.raiseRecoverable(s,"Identifier '"+e+"' has already been declared")},fo.checkLocalExport=function(e){-1===this.scopeStack[0].lexical.indexOf(e.name)&&-1===this.scopeStack[0].var.indexOf(e.name)&&(this.undefinedExports[e.name]=e)},fo.currentScope=function(){return this.scopeStack[this.scopeStack.length-1]},fo.currentVarScope=function(){for(var e=this.scopeStack.length-1;;e--){var t=this.scopeStack[e];if(259&t.flags)return t}},fo.currentThisScope=function(){for(var e=this.scopeStack.length-1;;e--){var t=this.scopeStack[e];if(259&t.flags&&!(16&t.flags))return t}};var go=function(e,t,s){this.type="",this.start=t,this.end=0,e.options.locations&&(this.loc=new Ba(e,s)),e.options.directSourceFile&&(this.sourceFile=e.options.directSourceFile),e.options.ranges&&(this.range=[t,0])},yo=Ha.prototype;function Eo(e,t,s,i){return e.type=t,e.end=s,this.options.locations&&(e.loc.end=i),this.options.ranges&&(e.range[1]=s),e}yo.startNode=function(){return new go(this,this.start,this.startLoc)},yo.startNodeAt=function(e,t){return new go(this,e,t)},yo.finishNode=function(e,t){return Eo.call(this,e,t,this.lastTokEnd,this.lastTokEndLoc)},yo.finishNodeAt=function(e,t,s,i){return Eo.call(this,e,t,s,i)},yo.copyNode=function(e){var t=new go(this,e.start,this.startLoc);for(var s in e)t[s]=e[s];return t};var xo="ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS",vo=xo+" Extended_Pictographic",bo={9:xo,10:vo,11:vo,12:"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS Extended_Pictographic EBase EComp EMod EPres ExtPict"},Ao="Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu",So="Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb",Po=So+" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd",ko=Po+" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho",wo={9:So,10:Po,11:ko,12:"Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi"},Co={};function Io(e){var t=Co[e]={binary:La(bo[e]+" "+Ao),nonBinary:{General_Category:La(Ao),Script:La(wo[e])}};t.nonBinary.Script_Extensions=t.nonBinary.Script,t.nonBinary.gc=t.nonBinary.General_Category,t.nonBinary.sc=t.nonBinary.Script,t.nonBinary.scx=t.nonBinary.Script_Extensions}Io(9),Io(10),Io(11),Io(12);var No=Ha.prototype,_o=function(e){this.parser=e,this.validFlags="gim"+(e.options.ecmaVersion>=6?"uy":"")+(e.options.ecmaVersion>=9?"s":"")+(e.options.ecmaVersion>=13?"d":""),this.unicodeProperties=Co[e.options.ecmaVersion>=12?12:e.options.ecmaVersion],this.source="",this.flags="",this.start=0,this.switchU=!1,this.switchN=!1,this.pos=0,this.lastIntValue=0,this.lastStringValue="",this.lastAssertionIsQuantifiable=!1,this.numCapturingParens=0,this.maxBackReference=0,this.groupNames=[],this.backReferenceNames=[]};function $o(e){return e<=65535?String.fromCharCode(e):(e-=65536,String.fromCharCode(55296+(e>>10),56320+(1023&e)))}function To(e){return 36===e||e>=40&&e<=43||46===e||63===e||e>=91&&e<=94||e>=123&&e<=125}function Ro(e){return e>=65&&e<=90||e>=97&&e<=122}function Mo(e){return Ro(e)||95===e}function Do(e){return Mo(e)||Oo(e)}function Oo(e){return e>=48&&e<=57}function Lo(e){return e>=48&&e<=57||e>=65&&e<=70||e>=97&&e<=102}function Vo(e){return e>=65&&e<=70?e-65+10:e>=97&&e<=102?e-97+10:e-48}function Bo(e){return e>=48&&e<=55}_o.prototype.reset=function(e,t,s){var i=-1!==s.indexOf("u");this.start=0|e,this.source=t+"",this.flags=s,this.switchU=i&&this.parser.options.ecmaVersion>=6,this.switchN=i&&this.parser.options.ecmaVersion>=9},_o.prototype.raise=function(e){this.parser.raiseRecoverable(this.start,"Invalid regular expression: /"+this.source+"/: "+e)},_o.prototype.at=function(e,t){void 0===t&&(t=!1);var s=this.source,i=s.length;if(e>=i)return-1;var n=s.charCodeAt(e);if(!t&&!this.switchU||n<=55295||n>=57344||e+1>=i)return n;var r=s.charCodeAt(e+1);return r>=56320&&r<=57343?(n<<10)+r-56613888:n},_o.prototype.nextIndex=function(e,t){void 0===t&&(t=!1);var s=this.source,i=s.length;if(e>=i)return i;var n,r=s.charCodeAt(e);return!t&&!this.switchU||r<=55295||r>=57344||e+1>=i||(n=s.charCodeAt(e+1))<56320||n>57343?e+1:e+2},_o.prototype.current=function(e){return void 0===e&&(e=!1),this.at(this.pos,e)},_o.prototype.lookahead=function(e){return void 0===e&&(e=!1),this.at(this.nextIndex(this.pos,e),e)},_o.prototype.advance=function(e){void 0===e&&(e=!1),this.pos=this.nextIndex(this.pos,e)},_o.prototype.eat=function(e,t){return void 0===t&&(t=!1),this.current(t)===e&&(this.advance(t),!0)},No.validateRegExpFlags=function(e){for(var t=e.validFlags,s=e.flags,i=0;i<s.length;i++){var n=s.charAt(i);-1===t.indexOf(n)&&this.raise(e.start,"Invalid regular expression flag"),s.indexOf(n,i+1)>-1&&this.raise(e.start,"Duplicate regular expression flag")}},No.validateRegExpPattern=function(e){this.regexp_pattern(e),!e.switchN&&this.options.ecmaVersion>=9&&e.groupNames.length>0&&(e.switchN=!0,this.regexp_pattern(e))},No.regexp_pattern=function(e){e.pos=0,e.lastIntValue=0,e.lastStringValue="",e.lastAssertionIsQuantifiable=!1,e.numCapturingParens=0,e.maxBackReference=0,e.groupNames.length=0,e.backReferenceNames.length=0,this.regexp_disjunction(e),e.pos!==e.source.length&&(e.eat(41)&&e.raise("Unmatched ')'"),(e.eat(93)||e.eat(125))&&e.raise("Lone quantifier brackets")),e.maxBackReference>e.numCapturingParens&&e.raise("Invalid escape");for(var t=0,s=e.backReferenceNames;t<s.length;t+=1){var i=s[t];-1===e.groupNames.indexOf(i)&&e.raise("Invalid named capture referenced")}},No.regexp_disjunction=function(e){for(this.regexp_alternative(e);e.eat(124);)this.regexp_alternative(e);this.regexp_eatQuantifier(e,!0)&&e.raise("Nothing to repeat"),e.eat(123)&&e.raise("Lone quantifier brackets")},No.regexp_alternative=function(e){for(;e.pos<e.source.length&&this.regexp_eatTerm(e););},No.regexp_eatTerm=function(e){return this.regexp_eatAssertion(e)?(e.lastAssertionIsQuantifiable&&this.regexp_eatQuantifier(e)&&e.switchU&&e.raise("Invalid quantifier"),!0):!!(e.switchU?this.regexp_eatAtom(e):this.regexp_eatExtendedAtom(e))&&(this.regexp_eatQuantifier(e),!0)},No.regexp_eatAssertion=function(e){var t=e.pos;if(e.lastAssertionIsQuantifiable=!1,e.eat(94)||e.eat(36))return!0;if(e.eat(92)){if(e.eat(66)||e.eat(98))return!0;e.pos=t}if(e.eat(40)&&e.eat(63)){var s=!1;if(this.options.ecmaVersion>=9&&(s=e.eat(60)),e.eat(61)||e.eat(33))return this.regexp_disjunction(e),e.eat(41)||e.raise("Unterminated group"),e.lastAssertionIsQuantifiable=!s,!0}return e.pos=t,!1},No.regexp_eatQuantifier=function(e,t){return void 0===t&&(t=!1),!!this.regexp_eatQuantifierPrefix(e,t)&&(e.eat(63),!0)},No.regexp_eatQuantifierPrefix=function(e,t){return e.eat(42)||e.eat(43)||e.eat(63)||this.regexp_eatBracedQuantifier(e,t)},No.regexp_eatBracedQuantifier=function(e,t){var s=e.pos;if(e.eat(123)){var i=0,n=-1;if(this.regexp_eatDecimalDigits(e)&&(i=e.lastIntValue,e.eat(44)&&this.regexp_eatDecimalDigits(e)&&(n=e.lastIntValue),e.eat(125)))return-1!==n&&n<i&&!t&&e.raise("numbers out of order in {} quantifier"),!0;e.switchU&&!t&&e.raise("Incomplete quantifier"),e.pos=s}return!1},No.regexp_eatAtom=function(e){return this.regexp_eatPatternCharacters(e)||e.eat(46)||this.regexp_eatReverseSolidusAtomEscape(e)||this.regexp_eatCharacterClass(e)||this.regexp_eatUncapturingGroup(e)||this.regexp_eatCapturingGroup(e)},No.regexp_eatReverseSolidusAtomEscape=function(e){var t=e.pos;if(e.eat(92)){if(this.regexp_eatAtomEscape(e))return!0;e.pos=t}return!1},No.regexp_eatUncapturingGroup=function(e){var t=e.pos;if(e.eat(40)){if(e.eat(63)&&e.eat(58)){if(this.regexp_disjunction(e),e.eat(41))return!0;e.raise("Unterminated group")}e.pos=t}return!1},No.regexp_eatCapturingGroup=function(e){if(e.eat(40)){if(this.options.ecmaVersion>=9?this.regexp_groupSpecifier(e):63===e.current()&&e.raise("Invalid group"),this.regexp_disjunction(e),e.eat(41))return e.numCapturingParens+=1,!0;e.raise("Unterminated group")}return!1},No.regexp_eatExtendedAtom=function(e){return e.eat(46)||this.regexp_eatReverseSolidusAtomEscape(e)||this.regexp_eatCharacterClass(e)||this.regexp_eatUncapturingGroup(e)||this.regexp_eatCapturingGroup(e)||this.regexp_eatInvalidBracedQuantifier(e)||this.regexp_eatExtendedPatternCharacter(e)},No.regexp_eatInvalidBracedQuantifier=function(e){return this.regexp_eatBracedQuantifier(e,!0)&&e.raise("Nothing to repeat"),!1},No.regexp_eatSyntaxCharacter=function(e){var t=e.current();return!!To(t)&&(e.lastIntValue=t,e.advance(),!0)},No.regexp_eatPatternCharacters=function(e){for(var t=e.pos,s=0;-1!==(s=e.current())&&!To(s);)e.advance();return e.pos!==t},No.regexp_eatExtendedPatternCharacter=function(e){var t=e.current();return!(-1===t||36===t||t>=40&&t<=43||46===t||63===t||91===t||94===t||124===t||(e.advance(),0))},No.regexp_groupSpecifier=function(e){if(e.eat(63)){if(this.regexp_eatGroupName(e))return-1!==e.groupNames.indexOf(e.lastStringValue)&&e.raise("Duplicate capture group name"),void e.groupNames.push(e.lastStringValue);e.raise("Invalid group")}},No.regexp_eatGroupName=function(e){if(e.lastStringValue="",e.eat(60)){if(this.regexp_eatRegExpIdentifierName(e)&&e.eat(62))return!0;e.raise("Invalid capture group name")}return!1},No.regexp_eatRegExpIdentifierName=function(e){if(e.lastStringValue="",this.regexp_eatRegExpIdentifierStart(e)){for(e.lastStringValue+=$o(e.lastIntValue);this.regexp_eatRegExpIdentifierPart(e);)e.lastStringValue+=$o(e.lastIntValue);return!0}return!1},No.regexp_eatRegExpIdentifierStart=function(e){var t=e.pos,s=this.options.ecmaVersion>=11,i=e.current(s);return e.advance(s),92===i&&this.regexp_eatRegExpUnicodeEscapeSequence(e,s)&&(i=e.lastIntValue),function(e){return Ea(e,!0)||36===e||95===e}(i)?(e.lastIntValue=i,!0):(e.pos=t,!1)},No.regexp_eatRegExpIdentifierPart=function(e){var t=e.pos,s=this.options.ecmaVersion>=11,i=e.current(s);return e.advance(s),92===i&&this.regexp_eatRegExpUnicodeEscapeSequence(e,s)&&(i=e.lastIntValue),function(e){return xa(e,!0)||36===e||95===e||8204===e||8205===e}(i)?(e.lastIntValue=i,!0):(e.pos=t,!1)},No.regexp_eatAtomEscape=function(e){return!!(this.regexp_eatBackReference(e)||this.regexp_eatCharacterClassEscape(e)||this.regexp_eatCharacterEscape(e)||e.switchN&&this.regexp_eatKGroupName(e))||(e.switchU&&(99===e.current()&&e.raise("Invalid unicode escape"),e.raise("Invalid escape")),!1)},No.regexp_eatBackReference=function(e){var t=e.pos;if(this.regexp_eatDecimalEscape(e)){var s=e.lastIntValue;if(e.switchU)return s>e.maxBackReference&&(e.maxBackReference=s),!0;if(s<=e.numCapturingParens)return!0;e.pos=t}return!1},No.regexp_eatKGroupName=function(e){if(e.eat(107)){if(this.regexp_eatGroupName(e))return e.backReferenceNames.push(e.lastStringValue),!0;e.raise("Invalid named reference")}return!1},No.regexp_eatCharacterEscape=function(e){return this.regexp_eatControlEscape(e)||this.regexp_eatCControlLetter(e)||this.regexp_eatZero(e)||this.regexp_eatHexEscapeSequence(e)||this.regexp_eatRegExpUnicodeEscapeSequence(e,!1)||!e.switchU&&this.regexp_eatLegacyOctalEscapeSequence(e)||this.regexp_eatIdentityEscape(e)},No.regexp_eatCControlLetter=function(e){var t=e.pos;if(e.eat(99)){if(this.regexp_eatControlLetter(e))return!0;e.pos=t}return!1},No.regexp_eatZero=function(e){return 48===e.current()&&!Oo(e.lookahead())&&(e.lastIntValue=0,e.advance(),!0)},No.regexp_eatControlEscape=function(e){var t=e.current();return 116===t?(e.lastIntValue=9,e.advance(),!0):110===t?(e.lastIntValue=10,e.advance(),!0):118===t?(e.lastIntValue=11,e.advance(),!0):102===t?(e.lastIntValue=12,e.advance(),!0):114===t&&(e.lastIntValue=13,e.advance(),!0)},No.regexp_eatControlLetter=function(e){var t=e.current();return!!Ro(t)&&(e.lastIntValue=t%32,e.advance(),!0)},No.regexp_eatRegExpUnicodeEscapeSequence=function(e,t){void 0===t&&(t=!1);var s,i=e.pos,n=t||e.switchU;if(e.eat(117)){if(this.regexp_eatFixedHexDigits(e,4)){var r=e.lastIntValue;if(n&&r>=55296&&r<=56319){var a=e.pos;if(e.eat(92)&&e.eat(117)&&this.regexp_eatFixedHexDigits(e,4)){var o=e.lastIntValue;if(o>=56320&&o<=57343)return e.lastIntValue=1024*(r-55296)+(o-56320)+65536,!0}e.pos=a,e.lastIntValue=r}return!0}if(n&&e.eat(123)&&this.regexp_eatHexDigits(e)&&e.eat(125)&&(s=e.lastIntValue)>=0&&s<=1114111)return!0;n&&e.raise("Invalid unicode escape"),e.pos=i}return!1},No.regexp_eatIdentityEscape=function(e){if(e.switchU)return!!this.regexp_eatSyntaxCharacter(e)||!!e.eat(47)&&(e.lastIntValue=47,!0);var t=e.current();return!(99===t||e.switchN&&107===t||(e.lastIntValue=t,e.advance(),0))},No.regexp_eatDecimalEscape=function(e){e.lastIntValue=0;var t=e.current();if(t>=49&&t<=57){do{e.lastIntValue=10*e.lastIntValue+(t-48),e.advance()}while((t=e.current())>=48&&t<=57);return!0}return!1},No.regexp_eatCharacterClassEscape=function(e){var t=e.current();if(function(e){return 100===e||68===e||115===e||83===e||119===e||87===e}(t))return e.lastIntValue=-1,e.advance(),!0;if(e.switchU&&this.options.ecmaVersion>=9&&(80===t||112===t)){if(e.lastIntValue=-1,e.advance(),e.eat(123)&&this.regexp_eatUnicodePropertyValueExpression(e)&&e.eat(125))return!0;e.raise("Invalid property name")}return!1},No.regexp_eatUnicodePropertyValueExpression=function(e){var t=e.pos;if(this.regexp_eatUnicodePropertyName(e)&&e.eat(61)){var s=e.lastStringValue;if(this.regexp_eatUnicodePropertyValue(e)){var i=e.lastStringValue;return this.regexp_validateUnicodePropertyNameAndValue(e,s,i),!0}}if(e.pos=t,this.regexp_eatLoneUnicodePropertyNameOrValue(e)){var n=e.lastStringValue;return this.regexp_validateUnicodePropertyNameOrValue(e,n),!0}return!1},No.regexp_validateUnicodePropertyNameAndValue=function(e,t,s){Da(e.unicodeProperties.nonBinary,t)||e.raise("Invalid property name"),e.unicodeProperties.nonBinary[t].test(s)||e.raise("Invalid property value")},No.regexp_validateUnicodePropertyNameOrValue=function(e,t){e.unicodeProperties.binary.test(t)||e.raise("Invalid property name")},No.regexp_eatUnicodePropertyName=function(e){var t=0;for(e.lastStringValue="";Mo(t=e.current());)e.lastStringValue+=$o(t),e.advance();return""!==e.lastStringValue},No.regexp_eatUnicodePropertyValue=function(e){var t=0;for(e.lastStringValue="";Do(t=e.current());)e.lastStringValue+=$o(t),e.advance();return""!==e.lastStringValue},No.regexp_eatLoneUnicodePropertyNameOrValue=function(e){return this.regexp_eatUnicodePropertyValue(e)},No.regexp_eatCharacterClass=function(e){if(e.eat(91)){if(e.eat(94),this.regexp_classRanges(e),e.eat(93))return!0;e.raise("Unterminated character class")}return!1},No.regexp_classRanges=function(e){for(;this.regexp_eatClassAtom(e);){var t=e.lastIntValue;if(e.eat(45)&&this.regexp_eatClassAtom(e)){var s=e.lastIntValue;!e.switchU||-1!==t&&-1!==s||e.raise("Invalid character class"),-1!==t&&-1!==s&&t>s&&e.raise("Range out of order in character class")}}},No.regexp_eatClassAtom=function(e){var t=e.pos;if(e.eat(92)){if(this.regexp_eatClassEscape(e))return!0;if(e.switchU){var s=e.current();(99===s||Bo(s))&&e.raise("Invalid class escape"),e.raise("Invalid escape")}e.pos=t}var i=e.current();return 93!==i&&(e.lastIntValue=i,e.advance(),!0)},No.regexp_eatClassEscape=function(e){var t=e.pos;if(e.eat(98))return e.lastIntValue=8,!0;if(e.switchU&&e.eat(45))return e.lastIntValue=45,!0;if(!e.switchU&&e.eat(99)){if(this.regexp_eatClassControlLetter(e))return!0;e.pos=t}return this.regexp_eatCharacterClassEscape(e)||this.regexp_eatCharacterEscape(e)},No.regexp_eatClassControlLetter=function(e){var t=e.current();return!(!Oo(t)&&95!==t||(e.lastIntValue=t%32,e.advance(),0))},No.regexp_eatHexEscapeSequence=function(e){var t=e.pos;if(e.eat(120)){if(this.regexp_eatFixedHexDigits(e,2))return!0;e.switchU&&e.raise("Invalid escape"),e.pos=t}return!1},No.regexp_eatDecimalDigits=function(e){var t=e.pos,s=0;for(e.lastIntValue=0;Oo(s=e.current());)e.lastIntValue=10*e.lastIntValue+(s-48),e.advance();return e.pos!==t},No.regexp_eatHexDigits=function(e){var t=e.pos,s=0;for(e.lastIntValue=0;Lo(s=e.current());)e.lastIntValue=16*e.lastIntValue+Vo(s),e.advance();return e.pos!==t},No.regexp_eatLegacyOctalEscapeSequence=function(e){if(this.regexp_eatOctalDigit(e)){var t=e.lastIntValue;if(this.regexp_eatOctalDigit(e)){var s=e.lastIntValue;t<=3&&this.regexp_eatOctalDigit(e)?e.lastIntValue=64*t+8*s+e.lastIntValue:e.lastIntValue=8*t+s}else e.lastIntValue=t;return!0}return!1},No.regexp_eatOctalDigit=function(e){var t=e.current();return Bo(t)?(e.lastIntValue=t-48,e.advance(),!0):(e.lastIntValue=0,!1)},No.regexp_eatFixedHexDigits=function(e,t){var s=e.pos;e.lastIntValue=0;for(var i=0;i<t;++i){var n=e.current();if(!Lo(n))return e.pos=s,!1;e.lastIntValue=16*e.lastIntValue+Vo(n),e.advance()}return!0};var Fo=function(e){this.type=e.type,this.value=e.value,this.start=e.start,this.end=e.end,e.options.locations&&(this.loc=new Ba(e,e.startLoc,e.endLoc)),e.options.ranges&&(this.range=[e.start,e.end])},zo=Ha.prototype;function Wo(e){return"function"!=typeof BigInt?null:BigInt(e.replace(/_/g,""))}function jo(e){return e<=65535?String.fromCharCode(e):(e-=65536,String.fromCharCode(55296+(e>>10),56320+(1023&e)))}zo.next=function(e){!e&&this.type.keyword&&this.containsEsc&&this.raiseRecoverable(this.start,"Escape sequence in keyword "+this.type.keyword),this.options.onToken&&this.options.onToken(new Fo(this)),this.lastTokEnd=this.end,this.lastTokStart=this.start,this.lastTokEndLoc=this.endLoc,this.lastTokStartLoc=this.startLoc,this.nextToken()},zo.getToken=function(){return this.next(),new Fo(this)},"undefined"!=typeof Symbol&&(zo[Symbol.iterator]=function(){var e=this;return{next:function(){var t=e.getToken();return{done:t.type===wa.eof,value:t}}}}),zo.nextToken=function(){var e=this.curContext();return e&&e.preserveSpace||this.skipSpace(),this.start=this.pos,this.options.locations&&(this.startLoc=this.curPosition()),this.pos>=this.input.length?this.finishToken(wa.eof):e.override?e.override(this):void this.readToken(this.fullCharCodeAtPos())},zo.readToken=function(e){return Ea(e,this.options.ecmaVersion>=6)||92===e?this.readWord():this.getTokenFromCode(e)},zo.fullCharCodeAtPos=function(){var e=this.input.charCodeAt(this.pos);if(e<=55295||e>=56320)return e;var t=this.input.charCodeAt(this.pos+1);return t<=56319||t>=57344?e:(e<<10)+t-56613888},zo.skipBlockComment=function(){var e,t=this.options.onComment&&this.curPosition(),s=this.pos,i=this.input.indexOf("*/",this.pos+=2);if(-1===i&&this.raise(this.pos-2,"Unterminated comment"),this.pos=i+2,this.options.locations)for(Ia.lastIndex=s;(e=Ia.exec(this.input))&&e.index<this.pos;)++this.curLine,this.lineStart=e.index+e[0].length;this.options.onComment&&this.options.onComment(!0,this.input.slice(s+2,i),s,this.pos,t,this.curPosition())},zo.skipLineComment=function(e){for(var t=this.pos,s=this.options.onComment&&this.curPosition(),i=this.input.charCodeAt(this.pos+=e);this.pos<this.input.length&&!Na(i);)i=this.input.charCodeAt(++this.pos);this.options.onComment&&this.options.onComment(!1,this.input.slice(t+e,this.pos),t,this.pos,s,this.curPosition())},zo.skipSpace=function(){e:for(;this.pos<this.input.length;){var e=this.input.charCodeAt(this.pos);switch(e){case 32:case 160:++this.pos;break;case 13:10===this.input.charCodeAt(this.pos+1)&&++this.pos;case 10:case 8232:case 8233:++this.pos,this.options.locations&&(++this.curLine,this.lineStart=this.pos);break;case 47:switch(this.input.charCodeAt(this.pos+1)){case 42:this.skipBlockComment();break;case 47:this.skipLineComment(2);break;default:break e}break;default:if(!(e>8&&e<14||e>=5760&&_a.test(String.fromCharCode(e))))break e;++this.pos}}},zo.finishToken=function(e,t){this.end=this.pos,this.options.locations&&(this.endLoc=this.curPosition());var s=this.type;this.type=e,this.value=t,this.updateContext(s)},zo.readToken_dot=function(){var e=this.input.charCodeAt(this.pos+1);if(e>=48&&e<=57)return this.readNumber(!0);var t=this.input.charCodeAt(this.pos+2);return this.options.ecmaVersion>=6&&46===e&&46===t?(this.pos+=3,this.finishToken(wa.ellipsis)):(++this.pos,this.finishToken(wa.dot))},zo.readToken_slash=function(){var e=this.input.charCodeAt(this.pos+1);return this.exprAllowed?(++this.pos,this.readRegexp()):61===e?this.finishOp(wa.assign,2):this.finishOp(wa.slash,1)},zo.readToken_mult_modulo_exp=function(e){var t=this.input.charCodeAt(this.pos+1),s=1,i=42===e?wa.star:wa.modulo;return this.options.ecmaVersion>=7&&42===e&&42===t&&(++s,i=wa.starstar,t=this.input.charCodeAt(this.pos+2)),61===t?this.finishOp(wa.assign,s+1):this.finishOp(i,s)},zo.readToken_pipe_amp=function(e){var t=this.input.charCodeAt(this.pos+1);return t===e?this.options.ecmaVersion>=12&&61===this.input.charCodeAt(this.pos+2)?this.finishOp(wa.assign,3):this.finishOp(124===e?wa.logicalOR:wa.logicalAND,2):61===t?this.finishOp(wa.assign,2):this.finishOp(124===e?wa.bitwiseOR:wa.bitwiseAND,1)},zo.readToken_caret=function(){return 61===this.input.charCodeAt(this.pos+1)?this.finishOp(wa.assign,2):this.finishOp(wa.bitwiseXOR,1)},zo.readToken_plus_min=function(e){var t=this.input.charCodeAt(this.pos+1);return t===e?45!==t||this.inModule||62!==this.input.charCodeAt(this.pos+2)||0!==this.lastTokEnd&&!Ca.test(this.input.slice(this.lastTokEnd,this.pos))?this.finishOp(wa.incDec,2):(this.skipLineComment(3),this.skipSpace(),this.nextToken()):61===t?this.finishOp(wa.assign,2):this.finishOp(wa.plusMin,1)},zo.readToken_lt_gt=function(e){var t=this.input.charCodeAt(this.pos+1),s=1;return t===e?(s=62===e&&62===this.input.charCodeAt(this.pos+2)?3:2,61===this.input.charCodeAt(this.pos+s)?this.finishOp(wa.assign,s+1):this.finishOp(wa.bitShift,s)):33!==t||60!==e||this.inModule||45!==this.input.charCodeAt(this.pos+2)||45!==this.input.charCodeAt(this.pos+3)?(61===t&&(s=2),this.finishOp(wa.relational,s)):(this.skipLineComment(4),this.skipSpace(),this.nextToken())},zo.readToken_eq_excl=function(e){var t=this.input.charCodeAt(this.pos+1);return 61===t?this.finishOp(wa.equality,61===this.input.charCodeAt(this.pos+2)?3:2):61===e&&62===t&&this.options.ecmaVersion>=6?(this.pos+=2,this.finishToken(wa.arrow)):this.finishOp(61===e?wa.eq:wa.prefix,1)},zo.readToken_question=function(){var e=this.options.ecmaVersion;if(e>=11){var t=this.input.charCodeAt(this.pos+1);if(46===t){var s=this.input.charCodeAt(this.pos+2);if(s<48||s>57)return this.finishOp(wa.questionDot,2)}if(63===t)return e>=12&&61===this.input.charCodeAt(this.pos+2)?this.finishOp(wa.assign,3):this.finishOp(wa.coalesce,2)}return this.finishOp(wa.question,1)},zo.readToken_numberSign=function(){var e=35;if(this.options.ecmaVersion>=13&&(++this.pos,Ea(e=this.fullCharCodeAtPos(),!0)||92===e))return this.finishToken(wa.privateId,this.readWord1());this.raise(this.pos,"Unexpected character '"+jo(e)+"'")},zo.getTokenFromCode=function(e){switch(e){case 46:return this.readToken_dot();case 40:return++this.pos,this.finishToken(wa.parenL);case 41:return++this.pos,this.finishToken(wa.parenR);case 59:return++this.pos,this.finishToken(wa.semi);case 44:return++this.pos,this.finishToken(wa.comma);case 91:return++this.pos,this.finishToken(wa.bracketL);case 93:return++this.pos,this.finishToken(wa.bracketR);case 123:return++this.pos,this.finishToken(wa.braceL);case 125:return++this.pos,this.finishToken(wa.braceR);case 58:return++this.pos,this.finishToken(wa.colon);case 96:if(this.options.ecmaVersion<6)break;return++this.pos,this.finishToken(wa.backQuote);case 48:var t=this.input.charCodeAt(this.pos+1);if(120===t||88===t)return this.readRadixNumber(16);if(this.options.ecmaVersion>=6){if(111===t||79===t)return this.readRadixNumber(8);if(98===t||66===t)return this.readRadixNumber(2)}case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return this.readNumber(!1);case 34:case 39:return this.readString(e);case 47:return this.readToken_slash();case 37:case 42:return this.readToken_mult_modulo_exp(e);case 124:case 38:return this.readToken_pipe_amp(e);case 94:return this.readToken_caret();case 43:case 45:return this.readToken_plus_min(e);case 60:case 62:return this.readToken_lt_gt(e);case 61:case 33:return this.readToken_eq_excl(e);case 63:return this.readToken_question();case 126:return this.finishOp(wa.prefix,1);case 35:return this.readToken_numberSign()}this.raise(this.pos,"Unexpected character '"+jo(e)+"'")},zo.finishOp=function(e,t){var s=this.input.slice(this.pos,this.pos+t);return this.pos+=t,this.finishToken(e,s)},zo.readRegexp=function(){for(var e,t,s=this.pos;;){this.pos>=this.input.length&&this.raise(s,"Unterminated regular expression");var i=this.input.charAt(this.pos);if(Ca.test(i)&&this.raise(s,"Unterminated regular expression"),e)e=!1;else{if("["===i)t=!0;else if("]"===i&&t)t=!1;else if("/"===i&&!t)break;e="\\"===i}++this.pos}var n=this.input.slice(s,this.pos);++this.pos;var r=this.pos,a=this.readWord1();this.containsEsc&&this.unexpected(r);var o=this.regexpState||(this.regexpState=new _o(this));o.reset(s,n,a),this.validateRegExpFlags(o),this.validateRegExpPattern(o);var h=null;try{h=new RegExp(n,a)}catch(e){}return this.finishToken(wa.regexp,{pattern:n,flags:a,value:h})},zo.readInt=function(e,t,s){for(var i=this.options.ecmaVersion>=12&&void 0===t,n=s&&48===this.input.charCodeAt(this.pos),r=this.pos,a=0,o=0,h=0,l=null==t?1/0:t;h<l;++h,++this.pos){var c=this.input.charCodeAt(this.pos),u=void 0;if(i&&95===c)n&&this.raiseRecoverable(this.pos,"Numeric separator is not allowed in legacy octal numeric literals"),95===o&&this.raiseRecoverable(this.pos,"Numeric separator must be exactly one underscore"),0===h&&this.raiseRecoverable(this.pos,"Numeric separator is not allowed at the first of digits"),o=c;else{if((u=c>=97?c-97+10:c>=65?c-65+10:c>=48&&c<=57?c-48:1/0)>=e)break;o=c,a=a*e+u}}return i&&95===o&&this.raiseRecoverable(this.pos-1,"Numeric separator is not allowed at the last of digits"),this.pos===r||null!=t&&this.pos-r!==t?null:a},zo.readRadixNumber=function(e){var t=this.pos;this.pos+=2;var s=this.readInt(e);return null==s&&this.raise(this.start+2,"Expected number in radix "+e),this.options.ecmaVersion>=11&&110===this.input.charCodeAt(this.pos)?(s=Wo(this.input.slice(t,this.pos)),++this.pos):Ea(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number"),this.finishToken(wa.num,s)},zo.readNumber=function(e){var t=this.pos;e||null!==this.readInt(10,void 0,!0)||this.raise(t,"Invalid number");var s=this.pos-t>=2&&48===this.input.charCodeAt(t);s&&this.strict&&this.raise(t,"Invalid number");var i=this.input.charCodeAt(this.pos);if(!s&&!e&&this.options.ecmaVersion>=11&&110===i){var n=Wo(this.input.slice(t,this.pos));return++this.pos,Ea(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number"),this.finishToken(wa.num,n)}s&&/[89]/.test(this.input.slice(t,this.pos))&&(s=!1),46!==i||s||(++this.pos,this.readInt(10),i=this.input.charCodeAt(this.pos)),69!==i&&101!==i||s||(43!==(i=this.input.charCodeAt(++this.pos))&&45!==i||++this.pos,null===this.readInt(10)&&this.raise(t,"Invalid number")),Ea(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number");var r,a=(r=this.input.slice(t,this.pos),s?parseInt(r,8):parseFloat(r.replace(/_/g,"")));return this.finishToken(wa.num,a)},zo.readCodePoint=function(){var e;if(123===this.input.charCodeAt(this.pos)){this.options.ecmaVersion<6&&this.unexpected();var t=++this.pos;e=this.readHexChar(this.input.indexOf("}",this.pos)-this.pos),++this.pos,e>1114111&&this.invalidStringToken(t,"Code point out of bounds")}else e=this.readHexChar(4);return e},zo.readString=function(e){for(var t="",s=++this.pos;;){this.pos>=this.input.length&&this.raise(this.start,"Unterminated string constant");var i=this.input.charCodeAt(this.pos);if(i===e)break;92===i?(t+=this.input.slice(s,this.pos),t+=this.readEscapedChar(!1),s=this.pos):8232===i||8233===i?(this.options.ecmaVersion<10&&this.raise(this.start,"Unterminated string constant"),++this.pos,this.options.locations&&(this.curLine++,this.lineStart=this.pos)):(Na(i)&&this.raise(this.start,"Unterminated string constant"),++this.pos)}return t+=this.input.slice(s,this.pos++),this.finishToken(wa.string,t)};var Uo={};zo.tryReadTemplateToken=function(){this.inTemplateElement=!0;try{this.readTmplToken()}catch(e){if(e!==Uo)throw e;this.readInvalidTemplateToken()}this.inTemplateElement=!1},zo.invalidStringToken=function(e,t){if(this.inTemplateElement&&this.options.ecmaVersion>=9)throw Uo;this.raise(e,t)},zo.readTmplToken=function(){for(var e="",t=this.pos;;){this.pos>=this.input.length&&this.raise(this.start,"Unterminated template");var s=this.input.charCodeAt(this.pos);if(96===s||36===s&&123===this.input.charCodeAt(this.pos+1))return this.pos!==this.start||this.type!==wa.template&&this.type!==wa.invalidTemplate?(e+=this.input.slice(t,this.pos),this.finishToken(wa.template,e)):36===s?(this.pos+=2,this.finishToken(wa.dollarBraceL)):(++this.pos,this.finishToken(wa.backQuote));if(92===s)e+=this.input.slice(t,this.pos),e+=this.readEscapedChar(!0),t=this.pos;else if(Na(s)){switch(e+=this.input.slice(t,this.pos),++this.pos,s){case 13:10===this.input.charCodeAt(this.pos)&&++this.pos;case 10:e+="\n";break;default:e+=String.fromCharCode(s)}this.options.locations&&(++this.curLine,this.lineStart=this.pos),t=this.pos}else++this.pos}},zo.readInvalidTemplateToken=function(){for(;this.pos<this.input.length;this.pos++)switch(this.input[this.pos]){case"\\":++this.pos;break;case"$":if("{"!==this.input[this.pos+1])break;case"`":return this.finishToken(wa.invalidTemplate,this.input.slice(this.start,this.pos))}this.raise(this.start,"Unterminated template")},zo.readEscapedChar=function(e){var t=this.input.charCodeAt(++this.pos);switch(++this.pos,t){case 110:return"\n";case 114:return"\r";case 120:return String.fromCharCode(this.readHexChar(2));case 117:return jo(this.readCodePoint());case 116:return"\t";case 98:return"\b";case 118:return"\v";case 102:return"\f";case 13:10===this.input.charCodeAt(this.pos)&&++this.pos;case 10:return this.options.locations&&(this.lineStart=this.pos,++this.curLine),"";case 56:case 57:if(this.strict&&this.invalidStringToken(this.pos-1,"Invalid escape sequence"),e){var s=this.pos-1;return this.invalidStringToken(s,"Invalid escape sequence in template string"),null}default:if(t>=48&&t<=55){var i=this.input.substr(this.pos-1,3).match(/^[0-7]+/)[0],n=parseInt(i,8);return n>255&&(i=i.slice(0,-1),n=parseInt(i,8)),this.pos+=i.length-1,t=this.input.charCodeAt(this.pos),"0"===i&&56!==t&&57!==t||!this.strict&&!e||this.invalidStringToken(this.pos-1-i.length,e?"Octal literal in template string":"Octal literal in strict mode"),String.fromCharCode(n)}return Na(t)?"":String.fromCharCode(t)}},zo.readHexChar=function(e){var t=this.pos,s=this.readInt(16,e);return null===s&&this.invalidStringToken(t,"Bad character escape sequence"),s},zo.readWord1=function(){this.containsEsc=!1;for(var e="",t=!0,s=this.pos,i=this.options.ecmaVersion>=6;this.pos<this.input.length;){var n=this.fullCharCodeAtPos();if(xa(n,i))this.pos+=n<=65535?1:2;else{if(92!==n)break;this.containsEsc=!0,e+=this.input.slice(s,this.pos);var r=this.pos;117!==this.input.charCodeAt(++this.pos)&&this.invalidStringToken(this.pos,"Expecting Unicode escape sequence \\uXXXX"),++this.pos;var a=this.readCodePoint();(t?Ea:xa)(a,i)||this.invalidStringToken(r,"Invalid Unicode escape"),e+=jo(a),s=this.pos}t=!1}return e+this.input.slice(s,this.pos)},zo.readWord=function(){var e=this.readWord1(),t=wa.name;return this.keywords.test(e)&&(t=Pa[e]),this.finishToken(t,e)},Ha.acorn={Parser:Ha,version:"8.5.0",defaultOptions:za,Position:Va,SourceLocation:Ba,getLineInfo:Fa,Node:go,TokenType:va,tokTypes:wa,keywordTypes:Pa,TokContext:ao,tokContexts:oo,isIdentifierChar:xa,isIdentifierStart:Ea,Token:Fo,isNewLine:Na,lineBreak:Ca,lineBreakG:Ia,nonASCIIwhitespace:_a};const Go=e=>()=>{ci({code:"NO_FS_IN_BROWSER",message:`Cannot access the file system (via "${e}") when using the browser build of Rollup. Make sure you supply a plugin with custom resolveId and load hooks to Rollup.`,url:"https://rollupjs.org/guide/en/#a-simple-example"})},Ho=Go("fs.readFile"),qo=Go("fs.writeFile");class Ko{constructor(e=1){this.maxParallel=e,this.queue=new Array,this.workerCount=0}run(e){return new Promise(((t,s)=>{this.queue.push({reject:s,resolve:t,task:e}),this.work()}))}async work(){if(this.workerCount>=this.maxParallel)return;let e;for(this.workerCount++;e=this.queue.shift();){const{reject:t,resolve:s,task:i}=e;try{s(await i())}catch(e){t(e)}}this.workerCount--}}async function Xo(e,t,s,i,n,r,a,o){const h=await function(e,t,s,i,n,r,a){let o=null,h=null;if(n){o=new Set;for(const s of n)e===s.source&&t===s.importer&&o.add(s.plugin);h=(e,t)=>({...e,resolve:(e,s,{custom:r,isEntry:a,skipSelf:o}=K)=>i(e,s,r,a,o?[...n,{importer:s,plugin:t,source:e}]:n)})}return s.hookFirst("resolveId",[e,t,{custom:r,isEntry:a}],h,o)}(e,t,i,n,r,a,o);return h}const Yo="at position ",Qo="at output position ";function Zo(e,t,{hook:s,id:i}={}){return"string"==typeof e&&(e={message:e}),e.code&&e.code!==di.PLUGIN_ERROR&&(e.pluginCode=e.code),e.code=di.PLUGIN_ERROR,e.plugin=t,s&&(e.hook=s),i&&(e.id=i),ci(e)}const Jo=[{active:!0,deprecated:"resolveAssetUrl",replacement:"resolveFileUrl"}],eh={delete:()=>!1,get(){},has:()=>!1,set(){}};function th(e){return e.startsWith(Yo)||e.startsWith(Qo)?ci({code:"ANONYMOUS_PLUGIN_CACHE",message:"A plugin is trying to use the Rollup cache but is not declaring a plugin name or cacheKey."}):ci({code:"DUPLICATE_PLUGIN_NAME",message:`The plugin name ${e} is being used twice in the same build. Plugin names must be distinct or provide a cacheKey (please post an issue to the plugin if you are a plugin user).`})}function sh(e,t,s,i){const n=t.id,r=[];let a=null===e.map?null:Dr(e.map);const o=e.code;let h=e.ast;const l=[],u=[];let d=!1;const p=()=>d=!0;let f;const m=e.code;return s.hookReduceArg0("transform",[m,n],(function(e,s,n){let a,o;if("string"==typeof s)a=s;else{if(!s||"object"!=typeof s)return e;if(t.updateOptions(s),null==s.code)return(s.map||s.ast)&&i((l=n.name,{code:di.NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE,message:`The plugin "${l}" returned a "map" or "ast" without returning a "code". This will be ignored.`})),e;({code:a,map:o,ast:h}=s)}var l;return null!==o&&r.push(Dr("string"==typeof o?JSON.parse(o):o)||{missing:!0,plugin:n.name}),a}),((e,t)=>{return f=t,{...e,addWatchFile(t){l.push(t),e.addWatchFile(t)},cache:d?e.cache:(h=e.cache,g=p,{delete:e=>(g(),h.delete(e)),get:e=>(g(),h.get(e)),has:e=>(g(),h.has(e)),set:(e,t)=>(g(),h.set(e,t))}),emitAsset:(t,s)=>(u.push({name:t,source:s,type:"asset"}),e.emitAsset(t,s)),emitChunk:(t,s)=>(u.push({id:t,name:s&&s.name,type:"chunk"}),e.emitChunk(t,s)),emitFile:e=>(u.push(e),s.emitFile(e)),error:(t,s)=>("string"==typeof t&&(t={message:t}),s&&ui(t,s,m,n),t.id=n,t.hook="transform",e.error(t)),getCombinedSourcemap(){const e=function(e,t,s,i,n){return i.length?{version:3,...Bn(e,t,s,i,Vn(n)).traceMappings()}:s}(n,o,a,r,i);return e?(a!==e&&(a=e,r.length=0),new c({...e,file:null,sourcesContent:e.sourcesContent})):new A(o).generateMap({hires:!0,includeContent:!0,source:n})},setAssetSource(){return this.error({code:"INVALID_SETASSETSOURCE",message:"setAssetSource cannot be called in transform for caching reasons. Use emitFile with a source, or call setAssetSource in another hook."})},warn(t,s){"string"==typeof t&&(t={message:t}),s&&ui(t,s,m,n),t.id=n,t.hook="transform",e.warn(t)}};var h,g})).catch((e=>Zo(e,f.name,{hook:"transform",id:n}))).then((e=>(d||u.length&&(t.transformFiles=u),{ast:h,code:e,customTransformCache:d,meta:t.info.meta,originalCode:o,originalSourcemap:a,sourcemapChain:r,transformDependencies:l})))}class ih{constructor(e,t,s,i){this.graph=e,this.modulesById=t,this.options=s,this.pluginDriver=i,this.implicitEntryModules=new Set,this.indexedEntryModules=[],this.latestLoadModulesPromise=Promise.resolve(),this.nextEntryModuleIndex=0,this.readQueue=new Ko,this.resolveId=async(e,t,s,i,n=null)=>this.addDefaultsToResolvedId(this.getNormalizedResolvedIdWithoutDefaults(!this.options.external(e,t,!1)&&await Xo(e,t,this.options.preserveSymlinks,this.pluginDriver,this.resolveId,n,s,"boolean"==typeof i?i:!t),t,e)),this.hasModuleSideEffects=s.treeshake?s.treeshake.moduleSideEffects:()=>!0,this.readQueue.maxParallel=s.maxParallelFileReads}async addAdditionalModules(e){const t=this.extendLoadModulesPromise(Promise.all(e.map((e=>this.loadEntryModule(e,!1,void 0,null)))));return await this.awaitLoadModulesPromise(),t}async addEntryModules(e,t){const s=this.nextEntryModuleIndex;this.nextEntryModuleIndex+=e.length;const i=await this.extendLoadModulesPromise(Promise.all(e.map((({id:e,importer:t})=>this.loadEntryModule(e,!0,t,null)))).then((i=>{let n=s;for(let s=0;s<i.length;s++){const r=i[s];r.isUserDefinedEntryPoint=r.isUserDefinedEntryPoint||t,rh(r,e[s],t);const a=this.indexedEntryModules.find((e=>e.module===r));a?a.index=Math.min(a.index,n):this.indexedEntryModules.push({index:n,module:r}),n++}return this.indexedEntryModules.sort((({index:e},{index:t})=>e>t?1:-1)),i})));return await this.awaitLoadModulesPromise(),{entryModules:this.indexedEntryModules.map((({module:e})=>e)),implicitEntryModules:[...this.implicitEntryModules],newEntryModules:i}}async emitChunk({fileName:e,id:t,importer:s,name:i,implicitlyLoadedAfterOneOf:n,preserveSignature:r}){const a={fileName:e||null,id:t,importer:s,name:i||null},o=n?await this.addEntryWithImplicitDependants(a,n):(await this.addEntryModules([a],!1)).newEntryModules[0];return null!=r&&(o.preserveSignature=r),o}addDefaultsToResolvedId(e){var t,s;if(!e)return null;const i=e.external||!1;return{external:i,id:e.id,meta:e.meta||X,moduleSideEffects:null!==(t=e.moduleSideEffects)&&void 0!==t?t:this.hasModuleSideEffects(e.id,!!i),syntheticNamedExports:null!==(s=e.syntheticNamedExports)&&void 0!==s&&s}}addEntryWithImplicitDependants(e,t){return this.extendLoadModulesPromise(this.loadEntryModule(e.id,!1,e.importer,null).then((async s=>{if(rh(s,e,!1),!s.info.isEntry){this.implicitEntryModules.add(s);const i=await Promise.all(t.map((t=>this.loadEntryModule(t,!1,e.importer,s.id))));for(const e of i)s.implicitlyLoadedAfter.add(e);for(const e of s.implicitlyLoadedAfter)e.implicitlyLoadedBefore.add(s)}return s})))}async addModuleSource(e,t,s){let i;nn("load modules",3);try{i=await this.readQueue.run((async()=>{var t;return null!==(t=await this.pluginDriver.hookFirst("load",[e]))&&void 0!==t?t:await Ho(e)}))}catch(s){rn("load modules",3);let i=`Could not load ${e}`;throw t&&(i+=` (imported by ${re(t)})`),i+=`: ${s.message}`,s.message=i,s}rn("load modules",3);const n="string"==typeof i?{code:i}:"object"==typeof i&&"string"==typeof i.code?i:ci(function(e){return{code:di.BAD_LOADER,message:`Error loading ${re(e)}: plugin load hook should return a string, a { code, map } object, or nothing/null`}}(e)),r=this.graph.cachedModules.get(e);if(r&&!r.customTransformCache&&r.originalCode===n.code){if(r.transformFiles)for(const e of r.transformFiles)this.pluginDriver.emitFile(e);s.setSource(r)}else s.updateOptions(n),s.setSource(await sh(n,s,this.pluginDriver,this.options.onwarn))}async awaitLoadModulesPromise(){let e;do{e=this.latestLoadModulesPromise,await e}while(e!==this.latestLoadModulesPromise)}extendLoadModulesPromise(e){return this.latestLoadModulesPromise=Promise.all([e,this.latestLoadModulesPromise]),this.latestLoadModulesPromise.catch((()=>{})),e}async fetchDynamicDependencies(e,t){const s=await Promise.all(t.map((t=>t.then((async([t,s])=>null===s?null:"string"==typeof s?(t.resolution=s,null):t.resolution=await this.fetchResolvedDependency(re(s.id),e.id,s))))));for(const t of s)t&&(e.dynamicDependencies.add(t),t.dynamicImporters.push(e.id))}async fetchModule({id:e,meta:t,moduleSideEffects:s,syntheticNamedExports:i},n,r){const a=this.modulesById.get(e);if(a instanceof dn){if(r){a.info.isEntry=!0,this.implicitEntryModules.delete(a);for(const e of a.implicitlyLoadedAfter)e.implicitlyLoadedBefore.delete(a);a.implicitlyLoadedAfter.clear()}return a}const o=new dn(this.graph,e,this.options,r,s,i,t);this.modulesById.set(e,o),this.graph.watchFiles[e]=!0,await this.addModuleSource(e,n,o);const h=this.getResolveStaticDependencyPromises(o),l=this.getResolveDynamicImportPromises(o);return Promise.all([...h,...l]).then((()=>this.pluginDriver.hookParallel("moduleParsed",[o.info]))).catch((()=>{})),await Promise.all([this.fetchStaticDependencies(o,h),this.fetchDynamicDependencies(o,l)]),o.linkImports(),o}fetchResolvedDependency(e,t,s){if(s.external){const{external:i,id:n,moduleSideEffects:r,meta:a}=s;this.modulesById.has(n)||this.modulesById.set(n,new oe(this.options,n,r,a,"absolute"!==i&&k(n)));const o=this.modulesById.get(n);return o instanceof oe?Promise.resolve(o):ci(function(e,t){return{code:di.INVALID_EXTERNAL_ID,message:`'${e}' is imported as an external by ${re(t)}, but is already an existing non-external module id.`}}(e,t))}return this.fetchModule(s,t,!1)}async fetchStaticDependencies(e,t){for(const s of await Promise.all(t.map((t=>t.then((([t,s])=>this.fetchResolvedDependency(t,e.id,s)))))))e.dependencies.add(s),s.importers.push(e.id);if(!this.options.treeshake||"no-treeshake"===e.info.hasModuleSideEffects)for(const t of e.dependencies)t instanceof dn&&(t.importedFromNotTreeshaken=!0)}getNormalizedResolvedIdWithoutDefaults(e,t,s){const{makeAbsoluteExternalsRelative:i}=this.options;if(e){if("object"==typeof e){const n=e.external||this.options.external(e.id,t,!0);return{...e,external:n&&("relative"===n||!k(e.id)||!0===n&&ah(e.id,s,i)||"absolute")}}const n=this.options.external(e,t,!0);return{external:n&&(ah(e,s,i)||"absolute"),id:n&&i?nh(e,t):e}}const n=i?nh(s,t):s;return!1===e||this.options.external(n,t,!0)?{external:ah(n,s,i)||"absolute",id:n}:null}getResolveDynamicImportPromises(e){return e.dynamicImports.map((async t=>{const s=await this.resolveDynamicImport(e,"string"==typeof t.argument?t.argument:t.argument.esTreeNode,e.id);return s&&"object"==typeof s&&(t.id=s.id),[t,s]}))}getResolveStaticDependencyPromises(e){return Array.from(e.sources,(async t=>[t,e.resolvedIds[t]=e.resolvedIds[t]||this.handleResolveId(await this.resolveId(t,e.id,X,!1),t,e.id)]))}handleResolveId(e,t,s){return null===e?w(t)?ci(function(e,t){return{code:di.UNRESOLVED_IMPORT,message:`Could not resolve '${e}' from ${re(t)}`}}(t,s)):(this.options.onwarn(function(e,t){return{code:di.UNRESOLVED_IMPORT,importer:re(t),message:`'${e}' is imported by ${re(t)}, but could not be resolved – treating it as an external dependency`,source:e,url:"https://rollupjs.org/guide/en/#warning-treating-module-as-external-dependency"}}(t,s)),{external:!0,id:t,meta:X,moduleSideEffects:this.hasModuleSideEffects(t,!0),syntheticNamedExports:!1}):(e.external&&e.syntheticNamedExports&&this.options.onwarn(function(e,t){return{code:di.EXTERNAL_SYNTHETIC_EXPORTS,importer:re(t),message:`External '${e}' can not have 'syntheticNamedExports' enabled.`,source:e}}(t,s)),e)}async loadEntryModule(e,t,s,i){const n=await Xo(e,s,this.options.preserveSymlinks,this.pluginDriver,this.resolveId,null,X,!0);return null==n?ci(null===i?function(e){return{code:di.UNRESOLVED_ENTRY,message:`Could not resolve entry module (${re(e)}).`}}(e):function(e,t){return{code:di.MISSING_IMPLICIT_DEPENDANT,message:`Module "${re(e)}" that should be implicitly loaded before "${re(t)}" could not be resolved.`}}(e,i)):!1===n||"object"==typeof n&&n.external?ci(null===i?function(e){return{code:di.UNRESOLVED_ENTRY,message:`Entry module cannot be external (${re(e)}).`}}(e):function(e,t){return{code:di.MISSING_IMPLICIT_DEPENDANT,message:`Module "${re(e)}" that should be implicitly loaded before "${re(t)}" cannot be external.`}}(e,i)):this.fetchModule(this.addDefaultsToResolvedId("object"==typeof n?n:{id:n}),void 0,t)}async resolveDynamicImport(e,t,s){const i=await this.pluginDriver.hookFirst("resolveDynamicImport",[t,s]);return"string"!=typeof t?"string"==typeof i?i:i?{external:!1,moduleSideEffects:!0,...i}:null:null==i?e.resolvedIds[t]=e.resolvedIds[t]||this.handleResolveId(await this.resolveId(t,e.id,X,!1),t,e.id):this.handleResolveId(this.addDefaultsToResolvedId(this.getNormalizedResolvedIdWithoutDefaults(i,s,t)),t,s)}}function nh(e,t){return w(e)?t?T(t,"..",e):T(e):e}function rh(e,{fileName:t,name:s},i){null!==t?e.chunkFileNames.add(t):null!==s&&(null===e.chunkName&&(e.chunkName=s),i&&e.userChunkNames.add(s))}function ah(e,t,s){return!0===s||"ifRelativeSource"===s&&w(t)||!k(e)}class oh extends gt{constructor(){super(),this.parent=null,this.variables.set("undefined",new Vi)}findVariable(e){let t=this.variables.get(e);return t||(t=new _t(e),this.variables.set(e,t)),t}}function hh(e,t,s,i,n,r){let a=!1;return(...o)=>(a||(a=!0,Pi({message:`The "this.${t}" plugin context function used by plugin ${i} is deprecated. The "this.${s}" plugin context function should be used instead.`,plugin:i},n,r)),e(...o))}function lh(e,s,i,n,r,a){let o,h=!0;if("string"!=typeof e.cacheKey&&(e.name.startsWith(Yo)||e.name.startsWith(Qo)||a.has(e.name)?h=!1:a.add(e.name)),s)if(h){const t=e.cacheKey||e.name;c=s[t]||(s[t]=Object.create(null)),o={delete:e=>delete c[e],get(e){const t=c[e];if(t)return t[0]=0,t[1]},has(e){const t=c[e];return!!t&&(t[0]=0,!0)},set(e,t){c[e]=[0,t]}}}else l=e.name,o={delete:()=>th(l),get:()=>th(l),has:()=>th(l),set:()=>th(l)};else o=eh;var l,c;const u={addWatchFile(e){if(i.phase>=Wr.GENERATE)return this.error({code:di.INVALID_ROLLUP_PHASE,message:"Cannot call addWatchFile after the build has finished."});i.watchFiles[e]=!0},cache:o,emitAsset:hh(((e,t)=>r.emitFile({name:e,source:t,type:"asset"})),"emitAsset","emitFile",e.name,!0,n),emitChunk:hh(((e,t)=>r.emitFile({id:e,name:t&&t.name,type:"chunk"})),"emitChunk","emitFile",e.name,!0,n),emitFile:r.emitFile.bind(r),error:t=>Zo(t,e.name),getAssetFileName:hh(r.getFileName,"getAssetFileName","getFileName",e.name,!0,n),getChunkFileName:hh(r.getFileName,"getChunkFileName","getFileName",e.name,!0,n),getFileName:r.getFileName,getModuleIds:()=>i.modulesById.keys(),getModuleInfo:i.getModuleInfo,getWatchFiles:()=>Object.keys(i.watchFiles),isExternal:hh(((e,t,s=!1)=>n.external(e,t,s)),"isExternal","resolve",e.name,!0,n),meta:{rollupVersion:t,watchMode:i.watchMode},get moduleIds(){const t=i.modulesById.keys();return function*(){Pi({message:`Accessing "this.moduleIds" on the plugin context by plugin ${e.name} is deprecated. The "this.getModuleIds" plugin context function should be used instead.`,plugin:e.name},!1,n),yield*t}()},parse:i.contextParse.bind(i),resolve:(t,s,{custom:n,isEntry:r,skipSelf:a}=K)=>i.moduleLoader.resolveId(t,s,n,r,a?[{importer:s,plugin:e,source:t}]:null),resolveId:hh(((e,t)=>i.moduleLoader.resolveId(e,t,K,void 0).then((e=>e&&e.id))),"resolveId","resolve",e.name,!0,n),setAssetSource:r.setAssetSource,warn(t){"string"==typeof t&&(t={message:t}),t.code&&(t.pluginCode=t.code),t.code="PLUGIN_WARNING",t.plugin=e.name,n.onwarn(t)}};return u}const ch=Object.keys({buildEnd:1,buildStart:1,closeBundle:1,closeWatcher:1,load:1,moduleParsed:1,options:1,resolveDynamicImport:1,resolveId:1,transform:1,watchChange:1});function uh(e,t){return ci({code:"INVALID_PLUGIN_HOOK",message:`Error running plugin hook ${e} for ${t}, expected a function hook.`})}class dh{constructor(e,t,s,i,n){this.graph=e,this.options=t,this.pluginContexts=new Map,function(e,t){for(const{active:s,deprecated:i,replacement:n}of Jo)for(const r of e)i in r&&Pi({message:`The "${i}" hook used by plugin ${r.name} is deprecated. The "${n}" hook should be used instead.`,plugin:r.name},s,t)}(s,t),this.pluginCache=i,this.fileEmitter=new Kr(e,t,n&&n.fileEmitter),this.emitFile=this.fileEmitter.emitFile.bind(this.fileEmitter),this.getFileName=this.fileEmitter.getFileName.bind(this.fileEmitter),this.finaliseAssets=this.fileEmitter.assertAssetsFinalized.bind(this.fileEmitter),this.setOutputBundle=this.fileEmitter.setOutputBundle.bind(this.fileEmitter),this.plugins=s.concat(n?n.plugins:[]);const r=new Set;for(const s of this.plugins)this.pluginContexts.set(s,lh(s,i,e,t,this.fileEmitter,r));if(n)for(const e of s)for(const s of ch)s in e&&t.onwarn((a=e.name,o=s,{code:di.INPUT_HOOK_IN_OUTPUT_PLUGIN,message:`The "${o}" hook used by the output plugin ${a} is a build time hook and will not be run for that plugin. Either this plugin cannot be used as an output plugin, or it should have an option to configure it as an output plugin.`}));var a,o}createOutputPluginDriver(e){return new dh(this.graph,this.options,e,this.pluginCache,this)}hookFirst(e,t,s,i){let n=Promise.resolve(void 0);for(const r of this.plugins)i&&i.has(r)||(n=n.then((i=>null!=i?i:this.runHook(e,t,r,!1,s))));return n}hookFirstSync(e,t,s){for(const i of this.plugins){const n=this.runHookSync(e,t,i,s);if(null!=n)return n}return null}hookParallel(e,t,s){const i=[];for(const n of this.plugins){const r=this.runHook(e,t,n,!1,s);r&&i.push(r)}return Promise.all(i).then((()=>{}))}hookReduceArg0(e,[t,...s],i,n){let r=Promise.resolve(t);for(const t of this.plugins)r=r.then((r=>{const a=[r,...s],o=this.runHook(e,a,t,!1,n);return o?o.then((e=>i.call(this.pluginContexts.get(t),r,e,t))):r}));return r}hookReduceArg0Sync(e,[t,...s],i,n){for(const r of this.plugins){const a=[t,...s],o=this.runHookSync(e,a,r,n);t=i.call(this.pluginContexts.get(r),t,o,r)}return t}hookReduceValue(e,t,s,i,n){let r=Promise.resolve(t);for(const t of this.plugins)r=r.then((r=>{const a=this.runHook(e,s,t,!0,n);return a?a.then((e=>i.call(this.pluginContexts.get(t),r,e,t))):r}));return r}hookReduceValueSync(e,t,s,i,n){let r=t;for(const t of this.plugins){const a=this.runHookSync(e,s,t,n);r=i.call(this.pluginContexts.get(t),r,a,t)}return r}hookSeq(e,t,s){let i=Promise.resolve();for(const n of this.plugins)i=i.then((()=>this.runHook(e,t,n,!1,s)));return i}hookSeqSync(e,t,s){for(const i of this.plugins)this.runHookSync(e,t,i,s)}runHook(e,t,s,i,n){const r=s[e];if(!r)return;let a=this.pluginContexts.get(s);return n&&(a=n(a,s)),Promise.resolve().then((()=>"function"!=typeof r?i?r:uh(e,s.name):r.apply(a,t))).catch((t=>Zo(t,s.name,{hook:e})))}runHookSync(e,t,s,i){const n=s[e];if(!n)return;let r=this.pluginContexts.get(s);i&&(r=i(r,s));try{return"function"!=typeof n?uh(e,s.name):n.apply(r,t)}catch(t){return Zo(t,s.name,{hook:e})}}}class ph{constructor(e,t){var s,i;if(this.options=e,this.cachedModules=new Map,this.deoptimizationTracker=new F,this.entryModules=[],this.modulesById=new Map,this.needsTreeshakingPass=!1,this.phase=Wr.LOAD_AND_PARSE,this.scope=new oh,this.watchFiles=Object.create(null),this.watchMode=!1,this.externalModules=[],this.implicitEntryModules=[],this.modules=[],this.getModuleInfo=e=>{const t=this.modulesById.get(e);return t?t.info:null},!1!==e.cache){if(null===(s=e.cache)||void 0===s?void 0:s.modules)for(const t of e.cache.modules)this.cachedModules.set(t.id,t);this.pluginCache=(null===(i=e.cache)||void 0===i?void 0:i.plugins)||Object.create(null);for(const e in this.pluginCache){const t=this.pluginCache[e];for(const e of Object.values(t))e[0]++}}if(t){this.watchMode=!0;const e=(...e)=>this.pluginDriver.hookSeqSync("watchChange",e),s=()=>this.pluginDriver.hookSeqSync("closeWatcher",[]);t.on("change",e),t.on("close",s),t.once("restart",(()=>{t.removeListener("change",e),t.removeListener("close",s)}))}this.pluginDriver=new dh(this,e,e.plugins,this.pluginCache),this.acornParser=Ha.extend(...e.acornInjectPlugins),this.moduleLoader=new ih(this,this.modulesById,this.options,this.pluginDriver)}async build(){nn("generate module graph",2),await this.generateModuleGraph(),rn("generate module graph",2),nn("sort modules",2),this.phase=Wr.ANALYSE,this.sortModules(),rn("sort modules",2),nn("mark included statements",2),this.includeStatements(),rn("mark included statements",2),this.phase=Wr.GENERATE}contextParse(e,t={}){const s=t.onComment,i=[];t.onComment=s&&"function"==typeof s?(e,n,r,a,...o)=>(i.push({end:a,start:r,type:e?"Block":"Line",value:n}),s.call(t,e,n,r,a,...o)):i;const n=this.acornParser.parse(e,{...this.options.acorn,...t});return"object"==typeof s&&s.push(...i),t.onComment=s,function(e,t,s){const i=[],n=[];for(const t of e)$e.test(t.value)?i.push(t):Se.test(t.value)&&n.push(t);for(const e of n)Te(t,e,!1);we(t,{annotationIndex:0,annotations:i,code:s})}(i,n,e),n}getCache(){for(const e in this.pluginCache){const t=this.pluginCache[e];let s=!0;for(const[e,i]of Object.entries(t))i[0]>=this.options.experimentalCacheExpiry?delete t[e]:s=!1;s&&delete this.pluginCache[e]}return{modules:this.modules.map((e=>e.toJSON())),plugins:this.pluginCache}}async generateModuleGraph(){var e;if(({entryModules:this.entryModules,implicitEntryModules:this.implicitEntryModules}=await this.moduleLoader.addEntryModules((e=this.options.input,Array.isArray(e)?e.map((e=>({fileName:null,id:e,implicitlyLoadedAfter:[],importer:void 0,name:null}))):Object.entries(e).map((([e,t])=>({fileName:null,id:t,implicitlyLoadedAfter:[],importer:void 0,name:e})))),!0)),0===this.entryModules.length)throw new Error("You must supply options.input to rollup");for(const e of this.modulesById.values())e instanceof dn?this.modules.push(e):this.externalModules.push(e)}includeStatements(){for(const e of[...this.entryModules,...this.implicitEntryModules])ln(e);if(this.options.treeshake){let e=1;do{nn(`treeshaking pass ${e}`,3),this.needsTreeshakingPass=!1;for(const e of this.modules)e.isExecuted&&("no-treeshake"===e.info.hasModuleSideEffects?e.includeAllInBundle():e.include());if(1===e)for(const e of[...this.entryModules,...this.implicitEntryModules])!1!==e.preserveSignature&&(e.includeAllExports(!1),this.needsTreeshakingPass=!0);rn("treeshaking pass "+e++,3)}while(this.needsTreeshakingPass)}else for(const e of this.modules)e.includeAllInBundle();for(const e of this.externalModules)e.warnUnusedImports();for(const e of this.implicitEntryModules)for(const t of e.implicitlyLoadedAfter)t.info.isEntry||t.isIncluded()||ci(yi(t))}sortModules(){const{orderedModules:e,cyclePaths:t}=function(e){let t=0;const s=[],i=new Set,n=new Set,r=new Map,a=[],o=e=>{if(e instanceof dn){for(const t of e.dependencies)r.has(t)?i.has(t)||s.push(ta(t,e,r)):(r.set(t,e),o(t));for(const t of e.implicitlyLoadedBefore)n.add(t);for(const{resolution:t}of e.dynamicImports)t instanceof dn&&n.add(t);a.push(e)}e.execIndex=t++,i.add(e)};for(const t of e)r.has(t)||(r.set(t,null),o(t));for(const e of n)r.has(e)||(r.set(e,null),o(e));return{cyclePaths:s,orderedModules:a}}(this.entryModules);for(const e of t)this.options.onwarn({code:"CIRCULAR_DEPENDENCY",cycle:e,importer:e[0],message:`Circular dependency: ${e.join(" -> ")}`});this.modules=e;for(const e of this.modules)e.bindReferences();this.warnForMissingExports()}warnForMissingExports(){for(const e of this.modules)for(const t of Object.values(e.importDescriptions))"*"===t.name||t.module.getVariableForExportName(t.name)||e.warn({code:"NON_EXISTENT_EXPORT",message:`Non-existent export '${t.name}' is imported from ${re(t.module.id)}`,name:t.name,source:t.module.id},t.start)}}function fh(e){return Array.isArray(e)?e.filter(Boolean):e?[e]:[]}const mh=e=>console.warn(e.message||e);function gh(e,t,s,i,n=/$./){const r=new Set(t),a=Object.keys(e).filter((e=>!(r.has(e)||n.test(e))));a.length>0&&i({code:"UNKNOWN_OPTION",message:`Unknown ${s}: ${a.join(", ")}. Allowed options: ${[...r].sort().join(", ")}`})}const yh={recommended:{annotations:!0,correctVarValueBeforeDeclaration:!1,moduleSideEffects:()=>!0,propertyReadSideEffects:!0,tryCatchDeoptimization:!0,unknownGlobalSideEffects:!1},safest:{annotations:!0,correctVarValueBeforeDeclaration:!0,moduleSideEffects:()=>!0,propertyReadSideEffects:!0,tryCatchDeoptimization:!0,unknownGlobalSideEffects:!0},smallest:{annotations:!0,correctVarValueBeforeDeclaration:!1,moduleSideEffects:()=>!1,propertyReadSideEffects:!1,tryCatchDeoptimization:!1,unknownGlobalSideEffects:!1}},Eh={es2015:{arrowFunctions:!0,constBindings:!0,objectShorthand:!0,reservedNamesAsProps:!0},es5:{arrowFunctions:!1,constBindings:!1,objectShorthand:!1,reservedNamesAsProps:!0}},xh=(e,t,s,i)=>{var n;const r=null===(n=e)||void 0===n?void 0:n.preset;if(r){const i=t[r];if(i)return{...i,...e};ci(mi(`${s}.preset`,vh(s),`valid values are ${ie(Object.keys(t))}`,r))}return((e,t,s)=>i=>{if("string"==typeof i){const n=e[i];if(n)return n;ci(mi(t,vh(t),`valid values are ${s}${ie(Object.keys(e))}. You can also supply an object for more fine-grained control`,i))}return i&&"object"==typeof i?i:{}})(t,s,i)(e)},vh=e=>e.split(".").join("").toLowerCase(),bh=e=>{const{onwarn:t}=e;return t?e=>{e.toString=()=>{let t="";return e.plugin&&(t+=`(${e.plugin} plugin) `),e.loc&&(t+=`${re(e.loc.file)} (${e.loc.line}:${e.loc.column}) `),t+=e.message,t},t(e,mh)}:mh},Ah=e=>({allowAwaitOutsideFunction:!0,ecmaVersion:"latest",preserveParens:!1,sourceType:"module",...e.acorn}),Sh=e=>fh(e.acornInjectPlugins),Ph=e=>{var t;return(null===(t=e.cache)||void 0===t?void 0:t.cache)||e.cache},kh=e=>{if(!0===e)return()=>!0;if("function"==typeof e)return(t,...s)=>!t.startsWith("\0")&&e(t,...s)||!1;if(e){const t=new Set,s=[];for(const i of fh(e))i instanceof RegExp?s.push(i):t.add(i);return(e,...i)=>t.has(e)||s.some((t=>t.test(e)))}return()=>!1},wh=(e,t,s)=>{const i=e.inlineDynamicImports;return i&&ki('The "inlineDynamicImports" option is deprecated. Use the "output.inlineDynamicImports" option instead.',!1,t,s),i},Ch=e=>{const t=e.input;return null==t?[]:"string"==typeof t?[t]:t},Ih=(e,t,s)=>{const i=e.manualChunks;return i&&ki('The "manualChunks" option is deprecated. Use the "output.manualChunks" option instead.',!1,t,s),i},Nh=e=>{const t=e.maxParallelFileReads;return"number"==typeof t?t<=0?1/0:t:20},_h=(e,t)=>{const s=e.moduleContext;if("function"==typeof s)return e=>{var i;return null!==(i=s(e))&&void 0!==i?i:t};if(s){const e=Object.create(null);for(const[t,i]of Object.entries(s))e[T(t)]=i;return s=>e[s]||t}return()=>t},$h=(e,t)=>{const s=e.preserveEntrySignatures;return null==s&&t.add("preserveEntrySignatures"),null!=s?s:"strict"},Th=(e,t,s)=>{const i=e.preserveModules;return i&&ki('The "preserveModules" option is deprecated. Use the "output.preserveModules" option instead.',!1,t,s),i},Rh=(e,t,s)=>{const i=e.treeshake;if(!1===i)return!1;const n=xh(e.treeshake,yh,"treeshake","false, true, ");return void 0!==n.pureExternalModules&&ki('The "treeshake.pureExternalModules" option is deprecated. The "treeshake.moduleSideEffects" option should be used instead. "treeshake.pureExternalModules: true" is equivalent to "treeshake.moduleSideEffects: \'no-external\'"',!0,t,s),{annotations:!1!==n.annotations,correctVarValueBeforeDeclaration:!0===n.correctVarValueBeforeDeclaration,moduleSideEffects:"object"==typeof i&&i.pureExternalModules?Mh(i.moduleSideEffects,i.pureExternalModules):Mh(n.moduleSideEffects,void 0),propertyReadSideEffects:"always"===n.propertyReadSideEffects?"always":!1!==n.propertyReadSideEffects,tryCatchDeoptimization:!1!==n.tryCatchDeoptimization,unknownGlobalSideEffects:!1!==n.unknownGlobalSideEffects}},Mh=(e,t)=>{if("boolean"==typeof e)return()=>e;if("no-external"===e)return(e,t)=>!t;if("function"==typeof e)return(t,s)=>!!t.startsWith("\0")||!1!==e(t,s);if(Array.isArray(e)){const t=new Set(e);return e=>t.has(e)}e&&ci(mi("treeshake.moduleSideEffects","treeshake",'please use one of false, "no-external", a function or an array'));const s=kh(t);return(e,t)=>!(t&&s(e))};function Dh(e){const t=/^[a-z]:/i.exec(e),s=t?t[0]:"";return s+e.substr(s.length).replace(/[\0?*:]/g,"_")}const Oh=(e,t,s)=>{const{file:i}=e;if("string"==typeof i){if(t)return ci(mi("output.file","outputdir",'you must set "output.dir" instead of "output.file" when using the "output.preserveModules" option'));if(!Array.isArray(s.input))return ci(mi("output.file","outputdir",'you must set "output.dir" instead of "output.file" when providing named inputs'))}return i},Lh=e=>{const t=e.format;switch(t){case void 0:case"es":case"esm":case"module":return"es";case"cjs":case"commonjs":return"cjs";case"system":case"systemjs":return"system";case"amd":case"iife":case"umd":return t;default:return ci({message:'You must specify "output.format", which can be one of "amd", "cjs", "system", "es", "iife" or "umd".',url:"https://rollupjs.org/guide/en/#outputformat"})}},Vh=(e,t)=>{var s;const i=(null!==(s=e.inlineDynamicImports)&&void 0!==s?s:t.inlineDynamicImports)||!1,{input:n}=t;return i&&(Array.isArray(n)?n:Object.keys(n)).length>1?ci(mi("output.inlineDynamicImports","outputinlinedynamicimports",'multiple inputs are not supported when "output.inlineDynamicImports" is true')):i},Bh=(e,t,s)=>{var i;const n=(null!==(i=e.preserveModules)&&void 0!==i?i:s.preserveModules)||!1;if(n){if(t)return ci(mi("output.inlineDynamicImports","outputinlinedynamicimports",'this option is not supported for "output.preserveModules"'));if(!1===s.preserveEntrySignatures)return ci(mi("preserveEntrySignatures","preserveentrysignatures",'setting this option to false is not supported for "output.preserveModules"'))}return n},Fh=(e,t)=>{const s=e.preferConst;return null!=s&&Pi('The "output.preferConst" option is deprecated. Use the "output.generatedCode.constBindings" option instead.',!1,t),!!s},zh=e=>{const{preserveModulesRoot:t}=e;if(null!=t)return T(t)},Wh=e=>{const t={autoId:!1,basePath:"",define:"define",...e.amd};if((t.autoId||t.basePath)&&t.id)return ci(mi("output.amd.id","outputamd",'this option cannot be used together with "output.amd.autoId"/"output.amd.basePath"'));if(t.basePath&&!t.autoId)return ci(mi("output.amd.basePath","outputamd",'this option only works with "output.amd.autoId"'));let s;return s=t.autoId?{autoId:!0,basePath:t.basePath,define:t.define}:{autoId:!1,define:t.define,id:t.id},s},jh=(e,t)=>{const s=e[t];return"function"==typeof s?s:()=>s||""},Uh=(e,t)=>{const{dir:s}=e;return"string"==typeof s&&"string"==typeof t?ci(mi("output.dir","outputdir",'you must set either "output.file" for a single-file build or "output.dir" when generating multiple chunks')):s},Gh=(e,t)=>{const s=e.dynamicImportFunction;return s&&Pi('The "output.dynamicImportFunction" option is deprecated. Use the "renderDynamicImport" plugin hook instead.',!1,t),s},Hh=(e,t)=>{const s=e.entryFileNames;return null==s&&t.add("entryFileNames"),null!=s?s:"[name].js"};function qh(e,t){const s=e.exports;if(null==s)t.add("exports");else if(!["default","named","none","auto"].includes(s))return ci((i=s,{code:di.INVALID_EXPORT_OPTION,message:`"output.exports" must be "default", "named", "none", "auto", or left unspecified (defaults to "auto"), received "${i}"`,url:"https://rollupjs.org/guide/en/#outputexports"}));var i;return s||"auto"}const Kh=(e,t)=>{const s=xh(e.generatedCode,Eh,"output.generatedCode","");return{arrowFunctions:!0===s.arrowFunctions,constBindings:!0===s.constBindings||t,objectShorthand:!0===s.objectShorthand,reservedNamesAsProps:!0===s.reservedNamesAsProps}},Xh=(e,t)=>{if(t)return"";const s=e.indent;return!1===s?"":null==s||s},Yh=new Set(["auto","esModule","default","defaultOnly",!0,!1]),Qh=(e,t)=>{const s=e.interop,i=new Set,n=e=>{if(!i.has(e)){if(i.add(e),!Yh.has(e))return ci(mi("output.interop","outputinterop",`use one of ${Array.from(Yh.values(),(e=>JSON.stringify(e))).join(", ")}`,e));"boolean"==typeof e&&Pi({message:`The boolean value "${e}" for the "output.interop" option is deprecated. Use ${e?'"auto"':'"esModule", "default" or "defaultOnly"'} instead.`,url:"https://rollupjs.org/guide/en/#outputinterop"},!1,t)}return e};if("function"==typeof s){const e=Object.create(null);let t=null;return i=>null===i?t||n(t=s(i)):i in e?e[i]:n(e[i]=s(i))}return void 0===s?()=>!0:()=>n(s)},Zh=(e,t,s,i)=>{const n=e.manualChunks||i.manualChunks;if(n){if(t)return ci(mi("output.manualChunks","outputmanualchunks",'this option is not supported for "output.inlineDynamicImports"'));if(s)return ci(mi("output.manualChunks","outputmanualchunks",'this option is not supported for "output.preserveModules"'))}return n||{}},Jh=(e,t,s)=>{var i;return null!==(i=e.minifyInternalExports)&&void 0!==i?i:s||"es"===t||"system"===t};function el(e,t){for(let s=0;s<e.length;s++){const i=e[s];i.name||(i.name=`${t}${s+1}`)}}async function tl(e,t,s,i,n){const{options:r,outputPluginDriver:a,unsetOptions:o}=function(e,t,s,i){if(!e)throw new Error("You must supply an options object");const n=fh(e.plugins);el(n,Qo);const r=t.createOutputPluginDriver(n);return{...sl(s,i,e,r),outputPluginDriver:r}}(i,n.pluginDriver,t,s),h=new na(r,o,t,a,n),l=await h.generate(e);if(e){if(!r.dir&&!r.file)return ci({code:"MISSING_OPTION",message:'You must specify "output.file" or "output.dir" for the build.'});await Promise.all(Object.values(l).map((e=>function(e,t){const s=T(t.dir||N(t.file),e.fileName);let i,n;if("asset"===e.type)n=e.source;else if(n=e.code,t.sourcemap&&e.map){let r;"inline"===t.sourcemap?r=e.map.toUrl():(r=`${I(e.fileName)}.map`,i=qo(`${s}.map`,e.map.toString())),"hidden"!==t.sourcemap&&(n+=`//# sourceMappingURL=${r}\n`)}return Promise.all([qo(s,n),i])}(e,r)))),await a.hookParallel("writeBundle",[r,l])}return c=l,{output:Object.values(c).filter((e=>Object.keys(e).length>0)).sort(((e,t)=>{const s=nl(e),i=nl(t);return s===i?0:s<i?-1:1}))};var c}function sl(e,t,s,i){return function(e,t,s){var i,n,r,a,o,h,l;const c=new Set(s),u=e.compact||!1,d=Lh(e),p=Vh(e,t),f=Bh(e,p,t),m=Oh(e,f,t),g=Fh(e,t),y={amd:Wh(e),assetFileNames:null!==(i=e.assetFileNames)&&void 0!==i?i:"assets/[name]-[hash][extname]",banner:jh(e,"banner"),chunkFileNames:null!==(n=e.chunkFileNames)&&void 0!==n?n:"[name]-[hash].js",compact:u,dir:Uh(e,m),dynamicImportFunction:Gh(e,t),entryFileNames:Hh(e,c),esModule:null===(r=e.esModule)||void 0===r||r,exports:qh(e,c),extend:e.extend||!1,externalLiveBindings:null===(a=e.externalLiveBindings)||void 0===a||a,file:m,footer:jh(e,"footer"),format:d,freeze:null===(o=e.freeze)||void 0===o||o,generatedCode:Kh(e,g),globals:e.globals||{},hoistTransitiveImports:null===(h=e.hoistTransitiveImports)||void 0===h||h,indent:Xh(e,u),inlineDynamicImports:p,interop:Qh(e,t),intro:jh(e,"intro"),manualChunks:Zh(e,p,f,t),minifyInternalExports:Jh(e,d,u),name:e.name,namespaceToStringTag:e.namespaceToStringTag||!1,noConflict:e.noConflict||!1,outro:jh(e,"outro"),paths:e.paths||{},plugins:fh(e.plugins),preferConst:g,preserveModules:f,preserveModulesRoot:zh(e),sanitizeFileName:"function"==typeof e.sanitizeFileName?e.sanitizeFileName:!1===e.sanitizeFileName?e=>e:Dh,sourcemap:e.sourcemap||!1,sourcemapExcludeSources:e.sourcemapExcludeSources||!1,sourcemapFile:e.sourcemapFile,sourcemapPathTransform:e.sourcemapPathTransform,strict:null===(l=e.strict)||void 0===l||l,systemNullSetters:e.systemNullSetters||!1,validate:e.validate||!1};return gh(e,Object.keys(y),"output options",t.onwarn),{options:y,unsetOptions:c}}(i.hookReduceArg0Sync("outputOptions",[s.output||s],((e,t)=>t||e),(e=>{const t=()=>e.error({code:di.CANNOT_EMIT_FROM_OPTIONS_HOOK,message:'Cannot emit files or set asset sources in the "outputOptions" hook, use the "renderStart" hook instead.'});return{...e,emitFile:t,setAssetSource:t}})),e,t)}var il;function nl(e){return"asset"===e.type?il.ASSET:e.isEntry?il.ENTRY_CHUNK:il.SECONDARY_CHUNK}!function(e){e[e.ENTRY_CHUNK=0]="ENTRY_CHUNK",e[e.SECONDARY_CHUNK=1]="SECONDARY_CHUNK",e[e.ASSET=2]="ASSET"}(il||(il={})),e.VERSION=t,e.defineConfig=function(e){return e},e.rollup=function(e){return async function(e,s){const{options:i,unsetOptions:n}=await async function(e,s){if(!e)throw new Error("You must supply an options object to rollup");const i=fh(e.plugins),{options:n,unsetOptions:r}=function(e){var t,s,i;const n=new Set,r=null!==(t=e.context)&&void 0!==t?t:"undefined",a=bh(e),o=e.strictDeprecations||!1,h={acorn:Ah(e),acornInjectPlugins:Sh(e),cache:Ph(e),context:r,experimentalCacheExpiry:null!==(s=e.experimentalCacheExpiry)&&void 0!==s?s:10,external:kh(e.external),inlineDynamicImports:wh(e,a,o),input:Ch(e),makeAbsoluteExternalsRelative:null===(i=e.makeAbsoluteExternalsRelative)||void 0===i||i,manualChunks:Ih(e,a,o),maxParallelFileReads:Nh(e),moduleContext:_h(e,r),onwarn:a,perf:e.perf||!1,plugins:fh(e.plugins),preserveEntrySignatures:$h(e,n),preserveModules:Th(e,a,o),preserveSymlinks:e.preserveSymlinks||!1,shimMissingExports:e.shimMissingExports||!1,strictDeprecations:o,treeshake:Rh(e,a,o)};return gh(e,[...Object.keys(h),"watch"],"input options",h.onwarn,/^(output)$/),{options:h,unsetOptions:n}}(await i.reduce(function(e){return async(s,i)=>i.options&&await i.options.call({meta:{rollupVersion:t,watchMode:e}},await s)||s}(s),Promise.resolve(e)));return el(n.plugins,Yo),{options:n,unsetOptions:r}}(e,null!==s);hn(i);const r=new ph(i,s),a=!1!==e.cache;delete i.cache,delete e.cache,nn("BUILD",1);try{await r.pluginDriver.hookParallel("buildStart",[i]),await r.build()}catch(e){const t=Object.keys(r.watchFiles);throw t.length>0&&(e.watchFiles=t),await r.pluginDriver.hookParallel("buildEnd",[e]),await r.pluginDriver.hookParallel("closeBundle",[]),e}await r.pluginDriver.hookParallel("buildEnd",[]),rn("BUILD",1);const o={cache:a?r.getCache():void 0,async close(){o.closed||(o.closed=!0,await r.pluginDriver.hookParallel("closeBundle",[]))},closed:!1,generate:async e=>o.closed?ci(Si()):tl(!1,i,n,e,r),watchFiles:Object.keys(r.watchFiles),write:async e=>o.closed?ci(Si()):tl(!0,i,n,e,r)};return i.perf&&(o.getTimings=sn),o}(e,null)},Object.defineProperty(e,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).rollup={});
+//# sourceMappingURL=rollup.browser.js.map
diff -urN /chromium-112.0.5615.49/third_party/node/node_modules/rollup/dist/rollup.js /chromium-111.0.5563.110/third_party/node/node_modules/rollup/dist/rollup.js
--- a/third_party/node/node_modules/rollup/dist/rollup.js	2023-02-03 20:05:52.000000000 +0000
+++ b/third_party/node/node_modules/rollup/dist/rollup.js	2023-01-12 22:12:55.000000000 +0000
@@ -1,7 +1,8 @@
 /*
   @license
-	Rollup.js v3.12.0
-	Sat, 28 Jan 2023 05:55:49 GMT - commit 01ddea09dfdf1c396c1c24ba3d97743698fe1508
+	Rollup.js v2.58.0
+	Fri, 01 Oct 2021 06:54:03 GMT - commit 3a404a07f41a10d10b7af536f05b90ea46d8ad3d
+
 
 	https://github.com/rollup/rollup
 
@@ -9,17 +10,13 @@
 */
 'use strict';
 
-Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
+Object.defineProperty(exports, '__esModule', { value: true });
 
 const rollup = require('./shared/rollup.js');
-require('node:path');
 require('path');
-require('node:process');
-require('node:perf_hooks');
-require('node:crypto');
-require('node:fs/promises');
-require('node:events');
-require('tty');
+require('crypto');
+require('fs');
+require('events');
 
 
 
diff -urN /chromium-112.0.5615.49/third_party/node/node_modules/rollup/dist/shared/index.js /chromium-111.0.5563.110/third_party/node/node_modules/rollup/dist/shared/index.js
--- a/third_party/node/node_modules/rollup/dist/shared/index.js	2023-02-03 20:05:52.000000000 +0000
+++ b/third_party/node/node_modules/rollup/dist/shared/index.js	2023-01-12 22:12:55.000000000 +0000
@@ -1,7 +1,8 @@
 /*
   @license
-	Rollup.js v3.12.0
-	Sat, 28 Jan 2023 05:55:49 GMT - commit 01ddea09dfdf1c396c1c24ba3d97743698fe1508
+	Rollup.js v2.58.0
+	Fri, 01 Oct 2021 06:54:03 GMT - commit 3a404a07f41a10d10b7af536f05b90ea46d8ad3d
+
 
 	https://github.com/rollup/rollup
 
@@ -9,21 +10,21 @@
 */
 'use strict';
 
-const rollup = require('./rollup.js');
-const require$$0$1 = require('fs');
+const require$$0$1 = require('events');
+const fs$4 = require('fs');
+const path$1 = require('path');
 const require$$2 = require('util');
 const require$$1 = require('stream');
-const require$$0$2 = require('path');
+const rollup = require('./rollup.js');
 const require$$2$1 = require('os');
-const require$$0$3 = require('events');
 
-var chokidar = {};
+var chokidar$1 = {};
 
-const fs$3 = require$$0$1;
+const fs$3 = fs$4;
 const { Readable } = require$$1;
-const sysPath$3 = require$$0$2;
+const sysPath$3 = path$1;
 const { promisify: promisify$3 } = require$$2;
-const picomatch$1 = rollup.picomatchExports;
+const picomatch$1 = rollup.picomatch;
 
 const readdir$1 = promisify$3(fs$3.readdir);
 const stat$3 = promisify$3(fs$3.stat);
@@ -305,11 +306,7 @@
 
 var readdirp_1 = readdirp$1;
 
-var anymatchExports = {};
-var anymatch$2 = {
-  get exports(){ return anymatchExports; },
-  set exports(v){ anymatchExports = v; },
-};
+var anymatch$2 = {exports: {}};
 
 /*!
  * normalize-path <https://github.com/jonschlinkert/normalize-path>
@@ -347,9 +344,9 @@
   return prefix + segs.join('/');
 };
 
-Object.defineProperty(anymatchExports, "__esModule", { value: true });
+Object.defineProperty(anymatch$2.exports, "__esModule", { value: true });
 
-const picomatch = rollup.picomatchExports;
+const picomatch = rollup.picomatch;
 const normalizePath$1 = normalizePath$2;
 
 /**
@@ -394,7 +391,7 @@
     throw new TypeError('anymatch: second argument must be a string: got ' +
       Object.prototype.toString.call(_path))
   }
-  const path = normalizePath$1(_path, false);
+  const path = normalizePath$1(_path);
 
   for (let index = 0; index < negPatterns.length; index++) {
     const nglob = negPatterns[index];
@@ -623,7 +620,7 @@
 };
 
 var isGlob$1 = isGlob$2;
-var pathPosixDirname = require$$0$2.posix.dirname;
+var pathPosixDirname = path$1.posix.dirname;
 var isWin32 = require$$2$1.platform() === 'win32';
 
 var slash = '/';
@@ -667,117 +664,117 @@
 
 (function (exports) {
 
-	exports.isInteger = num => {
-	  if (typeof num === 'number') {
-	    return Number.isInteger(num);
-	  }
-	  if (typeof num === 'string' && num.trim() !== '') {
-	    return Number.isInteger(Number(num));
-	  }
-	  return false;
-	};
-
-	/**
-	 * Find a node of the given type
-	 */
-
-	exports.find = (node, type) => node.nodes.find(node => node.type === type);
-
-	/**
-	 * Find a node of the given type
-	 */
-
-	exports.exceedsLimit = (min, max, step = 1, limit) => {
-	  if (limit === false) return false;
-	  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;
-	  return ((Number(max) - Number(min)) / Number(step)) >= limit;
-	};
-
-	/**
-	 * Escape the given node with '\\' before node.value
-	 */
-
-	exports.escapeNode = (block, n = 0, type) => {
-	  let node = block.nodes[n];
-	  if (!node) return;
-
-	  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {
-	    if (node.escaped !== true) {
-	      node.value = '\\' + node.value;
-	      node.escaped = true;
-	    }
-	  }
-	};
-
-	/**
-	 * Returns true if the given brace node should be enclosed in literal braces
-	 */
-
-	exports.encloseBrace = node => {
-	  if (node.type !== 'brace') return false;
-	  if ((node.commas >> 0 + node.ranges >> 0) === 0) {
-	    node.invalid = true;
-	    return true;
-	  }
-	  return false;
-	};
-
-	/**
-	 * Returns true if a brace node is invalid.
-	 */
-
-	exports.isInvalidBrace = block => {
-	  if (block.type !== 'brace') return false;
-	  if (block.invalid === true || block.dollar) return true;
-	  if ((block.commas >> 0 + block.ranges >> 0) === 0) {
-	    block.invalid = true;
-	    return true;
-	  }
-	  if (block.open !== true || block.close !== true) {
-	    block.invalid = true;
-	    return true;
-	  }
-	  return false;
-	};
-
-	/**
-	 * Returns true if a node is an open or close node
-	 */
-
-	exports.isOpenOrClose = node => {
-	  if (node.type === 'open' || node.type === 'close') {
-	    return true;
-	  }
-	  return node.open === true || node.close === true;
-	};
-
-	/**
-	 * Reduce an array of text nodes.
-	 */
-
-	exports.reduce = nodes => nodes.reduce((acc, node) => {
-	  if (node.type === 'text') acc.push(node.value);
-	  if (node.type === 'range') node.type = 'text';
-	  return acc;
-	}, []);
-
-	/**
-	 * Flatten an array
-	 */
-
-	exports.flatten = (...args) => {
-	  const result = [];
-	  const flat = arr => {
-	    for (let i = 0; i < arr.length; i++) {
-	      let ele = arr[i];
-	      Array.isArray(ele) ? flat(ele) : ele !== void 0 && result.push(ele);
-	    }
-	    return result;
-	  };
-	  flat(args);
-	  return result;
-	};
-} (utils$3));
+exports.isInteger = num => {
+  if (typeof num === 'number') {
+    return Number.isInteger(num);
+  }
+  if (typeof num === 'string' && num.trim() !== '') {
+    return Number.isInteger(Number(num));
+  }
+  return false;
+};
+
+/**
+ * Find a node of the given type
+ */
+
+exports.find = (node, type) => node.nodes.find(node => node.type === type);
+
+/**
+ * Find a node of the given type
+ */
+
+exports.exceedsLimit = (min, max, step = 1, limit) => {
+  if (limit === false) return false;
+  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;
+  return ((Number(max) - Number(min)) / Number(step)) >= limit;
+};
+
+/**
+ * Escape the given node with '\\' before node.value
+ */
+
+exports.escapeNode = (block, n = 0, type) => {
+  let node = block.nodes[n];
+  if (!node) return;
+
+  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {
+    if (node.escaped !== true) {
+      node.value = '\\' + node.value;
+      node.escaped = true;
+    }
+  }
+};
+
+/**
+ * Returns true if the given brace node should be enclosed in literal braces
+ */
+
+exports.encloseBrace = node => {
+  if (node.type !== 'brace') return false;
+  if ((node.commas >> 0 + node.ranges >> 0) === 0) {
+    node.invalid = true;
+    return true;
+  }
+  return false;
+};
+
+/**
+ * Returns true if a brace node is invalid.
+ */
+
+exports.isInvalidBrace = block => {
+  if (block.type !== 'brace') return false;
+  if (block.invalid === true || block.dollar) return true;
+  if ((block.commas >> 0 + block.ranges >> 0) === 0) {
+    block.invalid = true;
+    return true;
+  }
+  if (block.open !== true || block.close !== true) {
+    block.invalid = true;
+    return true;
+  }
+  return false;
+};
+
+/**
+ * Returns true if a node is an open or close node
+ */
+
+exports.isOpenOrClose = node => {
+  if (node.type === 'open' || node.type === 'close') {
+    return true;
+  }
+  return node.open === true || node.close === true;
+};
+
+/**
+ * Reduce an array of text nodes.
+ */
+
+exports.reduce = nodes => nodes.reduce((acc, node) => {
+  if (node.type === 'text') acc.push(node.value);
+  if (node.type === 'range') node.type = 'text';
+  return acc;
+}, []);
+
+/**
+ * Flatten an array
+ */
+
+exports.flatten = (...args) => {
+  const result = [];
+  const flat = arr => {
+    for (let i = 0; i < arr.length; i++) {
+      let ele = arr[i];
+      Array.isArray(ele) ? flat(ele) : ele !== void 0 && result.push(ele);
+    }
+    return result;
+  };
+  flat(args);
+  return result;
+};
+}(utils$3));
 
 const utils$2 = utils$3;
 
@@ -2083,12 +2080,6 @@
 
 var braces_1 = braces$1;
 
-var binaryExtensionsExports = {};
-var binaryExtensions$1 = {
-  get exports(){ return binaryExtensionsExports; },
-  set exports(v){ binaryExtensionsExports = v; },
-};
-
 const require$$0 = [
 	"3dm",
 	"3ds",
@@ -2350,12 +2341,10 @@
 	"zipx"
 ];
 
-(function (module) {
-	module.exports = require$$0;
-} (binaryExtensions$1));
+var binaryExtensions$1 = require$$0;
 
-const path = require$$0$2;
-const binaryExtensions = binaryExtensionsExports;
+const path = path$1;
+const binaryExtensions = binaryExtensions$1;
 
 const extensions = new Set(binaryExtensions);
 
@@ -2365,73 +2354,73 @@
 
 (function (exports) {
 
-	const {sep} = require$$0$2;
-	const {platform} = process;
-	const os = require$$2$1;
-
-	exports.EV_ALL = 'all';
-	exports.EV_READY = 'ready';
-	exports.EV_ADD = 'add';
-	exports.EV_CHANGE = 'change';
-	exports.EV_ADD_DIR = 'addDir';
-	exports.EV_UNLINK = 'unlink';
-	exports.EV_UNLINK_DIR = 'unlinkDir';
-	exports.EV_RAW = 'raw';
-	exports.EV_ERROR = 'error';
-
-	exports.STR_DATA = 'data';
-	exports.STR_END = 'end';
-	exports.STR_CLOSE = 'close';
-
-	exports.FSEVENT_CREATED = 'created';
-	exports.FSEVENT_MODIFIED = 'modified';
-	exports.FSEVENT_DELETED = 'deleted';
-	exports.FSEVENT_MOVED = 'moved';
-	exports.FSEVENT_CLONED = 'cloned';
-	exports.FSEVENT_UNKNOWN = 'unknown';
-	exports.FSEVENT_TYPE_FILE = 'file';
-	exports.FSEVENT_TYPE_DIRECTORY = 'directory';
-	exports.FSEVENT_TYPE_SYMLINK = 'symlink';
-
-	exports.KEY_LISTENERS = 'listeners';
-	exports.KEY_ERR = 'errHandlers';
-	exports.KEY_RAW = 'rawEmitters';
-	exports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];
-
-	exports.DOT_SLASH = `.${sep}`;
-
-	exports.BACK_SLASH_RE = /\\/g;
-	exports.DOUBLE_SLASH_RE = /\/\//;
-	exports.SLASH_OR_BACK_SLASH_RE = /[/\\]/;
-	exports.DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
-	exports.REPLACER_RE = /^\.[/\\]/;
-
-	exports.SLASH = '/';
-	exports.SLASH_SLASH = '//';
-	exports.BRACE_START = '{';
-	exports.BANG = '!';
-	exports.ONE_DOT = '.';
-	exports.TWO_DOTS = '..';
-	exports.STAR = '*';
-	exports.GLOBSTAR = '**';
-	exports.ROOT_GLOBSTAR = '/**/*';
-	exports.SLASH_GLOBSTAR = '/**';
-	exports.DIR_SUFFIX = 'Dir';
-	exports.ANYMATCH_OPTS = {dot: true};
-	exports.STRING_TYPE = 'string';
-	exports.FUNCTION_TYPE = 'function';
-	exports.EMPTY_STR = '';
-	exports.EMPTY_FN = () => {};
-	exports.IDENTITY_FN = val => val;
-
-	exports.isWindows = platform === 'win32';
-	exports.isMacos = platform === 'darwin';
-	exports.isLinux = platform === 'linux';
-	exports.isIBMi = os.type() === 'OS400';
-} (constants));
+const {sep} = path$1;
+const {platform} = process;
+const os = require$$2$1;
+
+exports.EV_ALL = 'all';
+exports.EV_READY = 'ready';
+exports.EV_ADD = 'add';
+exports.EV_CHANGE = 'change';
+exports.EV_ADD_DIR = 'addDir';
+exports.EV_UNLINK = 'unlink';
+exports.EV_UNLINK_DIR = 'unlinkDir';
+exports.EV_RAW = 'raw';
+exports.EV_ERROR = 'error';
+
+exports.STR_DATA = 'data';
+exports.STR_END = 'end';
+exports.STR_CLOSE = 'close';
+
+exports.FSEVENT_CREATED = 'created';
+exports.FSEVENT_MODIFIED = 'modified';
+exports.FSEVENT_DELETED = 'deleted';
+exports.FSEVENT_MOVED = 'moved';
+exports.FSEVENT_CLONED = 'cloned';
+exports.FSEVENT_UNKNOWN = 'unknown';
+exports.FSEVENT_TYPE_FILE = 'file';
+exports.FSEVENT_TYPE_DIRECTORY = 'directory';
+exports.FSEVENT_TYPE_SYMLINK = 'symlink';
+
+exports.KEY_LISTENERS = 'listeners';
+exports.KEY_ERR = 'errHandlers';
+exports.KEY_RAW = 'rawEmitters';
+exports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];
+
+exports.DOT_SLASH = `.${sep}`;
+
+exports.BACK_SLASH_RE = /\\/g;
+exports.DOUBLE_SLASH_RE = /\/\//;
+exports.SLASH_OR_BACK_SLASH_RE = /[/\\]/;
+exports.DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
+exports.REPLACER_RE = /^\.[/\\]/;
+
+exports.SLASH = '/';
+exports.SLASH_SLASH = '//';
+exports.BRACE_START = '{';
+exports.BANG = '!';
+exports.ONE_DOT = '.';
+exports.TWO_DOTS = '..';
+exports.STAR = '*';
+exports.GLOBSTAR = '**';
+exports.ROOT_GLOBSTAR = '/**/*';
+exports.SLASH_GLOBSTAR = '/**';
+exports.DIR_SUFFIX = 'Dir';
+exports.ANYMATCH_OPTS = {dot: true};
+exports.STRING_TYPE = 'string';
+exports.FUNCTION_TYPE = 'function';
+exports.EMPTY_STR = '';
+exports.EMPTY_FN = () => {};
+exports.IDENTITY_FN = val => val;
+
+exports.isWindows = platform === 'win32';
+exports.isMacos = platform === 'darwin';
+exports.isLinux = platform === 'linux';
+exports.isIBMi = os.type() === 'OS400';
+}(constants));
 
-const fs$2 = require$$0$1;
-const sysPath$2 = require$$0$2;
+const fs$2 = fs$4;
+const sysPath$2 = path$1;
 const { promisify: promisify$2 } = require$$2;
 const isBinaryPath = isBinaryPath$1;
 const {
@@ -2713,7 +2702,7 @@
 /**
  * @mixin
  */
-let NodeFsHandler$1 = class NodeFsHandler {
+class NodeFsHandler$1 {
 
 /**
  * @param {import("../index").FSWatcher} fsW
@@ -2841,15 +2830,7 @@
   if (!this.fsw.options.followSymlinks) {
     // watch symlink directly (don't follow) and detect changes
     this.fsw._incrReadyCount();
-
-    let linkPath;
-    try {
-      linkPath = await fsrealpath(path);
-    } catch (e) {
-      this.fsw._emitReady();
-      return true;
-    }
-
+    const linkPath = await fsrealpath(path);
     if (this.fsw.closed) return;
     if (dir.has(item)) {
       if (this.fsw._symlinkPaths.get(full) !== linkPath) {
@@ -3069,20 +3050,16 @@
   }
 }
 
-};
+}
 
 var nodefsHandler = NodeFsHandler$1;
 
-var fseventsHandlerExports = {};
-var fseventsHandler = {
-  get exports(){ return fseventsHandlerExports; },
-  set exports(v){ fseventsHandlerExports = v; },
-};
+var fseventsHandler = {exports: {}};
 
 const require$$3 = /*@__PURE__*/rollup.getAugmentedNamespace(rollup.fseventsImporter);
 
-const fs$1 = require$$0$1;
-const sysPath$1 = require$$0$2;
+const fs$1 = fs$4;
+const sysPath$1 = path$1;
 const { promisify: promisify$1 } = require$$2;
 
 let fsevents;
@@ -3293,7 +3270,7 @@
 /**
  * @mixin
  */
-let FsEventsHandler$1 = class FsEventsHandler {
+class FsEventsHandler$1 {
 
 /**
  * @param {import('../index').FSWatcher} fsw
@@ -3599,24 +3576,24 @@
   }
 }
 
-};
+}
 
 fseventsHandler.exports = FsEventsHandler$1;
-fseventsHandlerExports.canUse = canUse;
+fseventsHandler.exports.canUse = canUse;
 
-const { EventEmitter } = require$$0$3;
-const fs = require$$0$1;
-const sysPath = require$$0$2;
+const { EventEmitter } = require$$0$1;
+const fs = fs$4;
+const sysPath = path$1;
 const { promisify } = require$$2;
 const readdirp = readdirp_1;
-const anymatch = anymatchExports.default;
+const anymatch = anymatch$2.exports.default;
 const globParent = globParent$1;
 const isGlob = isGlob$2;
 const braces = braces_1;
 const normalizePath = normalizePath$2;
 
 const NodeFsHandler = nodefsHandler;
-const FsEventsHandler = fseventsHandlerExports;
+const FsEventsHandler = fseventsHandler.exports;
 const {
   EV_ALL,
   EV_READY,
@@ -4560,7 +4537,7 @@
 }
 
 // Export FSWatcher class
-chokidar.FSWatcher = FSWatcher;
+chokidar$1.FSWatcher = FSWatcher;
 
 /**
  * Instantiates watcher with paths to be tracked.
@@ -4574,7 +4551,9 @@
   return watcher;
 };
 
-chokidar.watch = watch;
+chokidar$1.watch = watch;
+
+const chokidar = chokidar$1;
 
 exports.chokidar = chokidar;
 //# sourceMappingURL=index.js.map
diff -urN /chromium-112.0.5615.49/third_party/node/node_modules/rollup/dist/shared/loadConfigFile.js /chromium-111.0.5563.110/third_party/node/node_modules/rollup/dist/shared/loadConfigFile.js
--- a/third_party/node/node_modules/rollup/dist/shared/loadConfigFile.js	2023-02-03 20:05:52.000000000 +0000
+++ b/third_party/node/node_modules/rollup/dist/shared/loadConfigFile.js	2023-01-12 22:12:55.000000000 +0000
@@ -1,7 +1,8 @@
 /*
   @license
-	Rollup.js v3.12.0
-	Sat, 28 Jan 2023 05:55:49 GMT - commit 01ddea09dfdf1c396c1c24ba3d97743698fe1508
+	Rollup.js v2.58.0
+	Fri, 01 Oct 2021 06:54:03 GMT - commit 3a404a07f41a10d10b7af536f05b90ea46d8ad3d
+
 
 	https://github.com/rollup/rollup
 
@@ -9,22 +10,118 @@
 */
 'use strict';
 
-const promises = require('node:fs/promises');
-const node_path = require('node:path');
-const process = require('node:process');
-const node_url = require('node:url');
+const fs = require('fs');
+const path = require('path');
+const url = require('url');
+const tty = require('tty');
 const rollup = require('./rollup.js');
+const mergeOptions = require('./mergeOptions.js');
+
+function _interopNamespaceDefault(e) {
+  const n = Object.create(null);
+  if (e) {
+    for (const k in e) {
+      n[k] = e[k];
+    }
+  }
+  n.default = e;
+  return n;
+}
+
+const fs__namespace = /*#__PURE__*/_interopNamespaceDefault(fs);
+const path__namespace = /*#__PURE__*/_interopNamespaceDefault(path);
+const tty__namespace = /*#__PURE__*/_interopNamespaceDefault(tty);
+
+const env = process.env;
+
+const isDisabled = "NO_COLOR" in env;
+const isForced = "FORCE_COLOR" in env;
+const isWindows = process.platform === "win32";
+
+const isCompatibleTerminal =
+  tty__namespace && tty__namespace.isatty(1) && env.TERM && env.TERM !== "dumb";
+
+const isCI =
+  "CI" in env &&
+  ("GITHUB_ACTIONS" in env || "GITLAB_CI" in env || "CIRCLECI" in env);
+
+let enabled =
+  !isDisabled && (isForced || isWindows || isCompatibleTerminal || isCI);
+
+const raw = (open, close, searchRegex, replaceValue) => (s) =>
+  enabled
+    ? open +
+      (~(s += "").indexOf(close, 4) // skip opening \x1b[
+        ? s.replace(searchRegex, replaceValue)
+        : s) +
+      close
+    : s;
+
+const init = (open, close) => {
+  return raw(
+    `\x1b[${open}m`,
+    `\x1b[${close}m`,
+    new RegExp(`\\x1b\\[${close}m`, "g"),
+    `\x1b[${open}m`
+  )
+};
+
+const options = Object.defineProperty({}, "enabled", {
+  get: () => enabled,
+  set: (value) => (enabled = value),
+});
+const bold = raw("\x1b[1m", "\x1b[22m", /\x1b\[22m/g, "\x1b[22m\x1b[1m");
+const dim = raw("\x1b[2m", "\x1b[22m", /\x1b\[22m/g, "\x1b[22m\x1b[2m");
+const underline = init(4, 24);
+const red = init(31, 39);
+const green = init(32, 39);
+const yellow = init(33, 39);
+const cyan = init(36, 39);
+const gray = init(90, 39);
+
+// @see https://no-color.org
+// @see https://www.npmjs.com/package/chalk
+if (process.env.FORCE_COLOR === '0' || process.env.NO_COLOR) {
+    options.enabled = false;
+}
+// log to stderr to keep `rollup main.js > bundle.js` from breaking
+const stderr = console.error.bind(console);
+function handleError(err, recover = false) {
+    let description = err.message || err;
+    if (err.name)
+        description = `${err.name}: ${description}`;
+    const message = (err.plugin ? `(plugin ${err.plugin}) ${description}` : description) || err;
+    stderr(bold(red(`[!] ${bold(message.toString())}`)));
+    if (err.url) {
+        stderr(cyan(err.url));
+    }
+    if (err.loc) {
+        stderr(`${rollup.relativeId((err.loc.file || err.id))} (${err.loc.line}:${err.loc.column})`);
+    }
+    else if (err.id) {
+        stderr(rollup.relativeId(err.id));
+    }
+    if (err.frame) {
+        stderr(dim(err.frame));
+    }
+    if (err.stack) {
+        stderr(dim(err.stack));
+    }
+    stderr('');
+    if (!recover)
+        process.exit(1);
+}
 
 function batchWarnings() {
     let count = 0;
-    const deferredWarnings = new Map();
+    let deferredWarnings = new Map();
     let warningOccurred = false;
     return {
-        add(warning) {
+        add: (warning) => {
             count += 1;
             warningOccurred = true;
             if (warning.code in deferredHandlers) {
-                rollup.getOrCreate(deferredWarnings, warning.code, rollup.getNewArray).push(warning);
+                rollup.getOrCreate(deferredWarnings, warning.code, () => []).push(warning);
             }
             else if (warning.code in immediateHandlers) {
                 immediateHandlers[warning.code](warning);
@@ -33,12 +130,12 @@
                 title(warning.message);
                 if (warning.url)
                     info(warning.url);
-                const id = warning.loc?.file || warning.id;
+                const id = (warning.loc && warning.loc.file) || warning.id;
                 if (id) {
                     const loc = warning.loc
                         ? `${rollup.relativeId(id)} (${warning.loc.line}:${warning.loc.column})`
                         : rollup.relativeId(id);
-                    rollup.stderr(rollup.bold(rollup.relativeId(loc)));
+                    stderr(bold(rollup.relativeId(loc)));
                 }
                 if (warning.frame)
                     info(warning.frame);
@@ -47,14 +144,14 @@
         get count() {
             return count;
         },
-        flush() {
+        flush: () => {
             if (count === 0)
                 return;
-            const codes = [...deferredWarnings.keys()].sort((a, b) => deferredWarnings.get(b).length - deferredWarnings.get(a).length);
+            const codes = Array.from(deferredWarnings.keys()).sort((a, b) => deferredWarnings.get(b).length - deferredWarnings.get(a).length);
             for (const code of codes) {
                 deferredHandlers[code](deferredWarnings.get(code));
             }
-            deferredWarnings.clear();
+            deferredWarnings = new Map();
             count = 0;
         },
         get warningOccurred() {
@@ -63,13 +160,13 @@
     };
 }
 const immediateHandlers = {
-    MISSING_NODE_BUILTINS(warning) {
+    MISSING_NODE_BUILTINS: warning => {
         title(`Missing shims for Node.js built-ins`);
-        rollup.stderr(`Creating a browser bundle that depends on ${rollup.printQuotedStringList(warning.ids)}. You might need to include https://github.com/FredKSchott/rollup-plugin-polyfill-node`);
+        stderr(`Creating a browser bundle that depends on ${rollup.printQuotedStringList(warning.modules)}. You might need to include https://github.com/snowpackjs/rollup-plugin-polyfill-node`);
     },
-    UNKNOWN_OPTION(warning) {
+    UNKNOWN_OPTION: warning => {
         title(`You have passed an unrecognized option`);
-        rollup.stderr(warning.message);
+        stderr(warning.message);
     }
 };
 const deferredHandlers = {
@@ -77,59 +174,62 @@
         title(`Circular dependenc${warnings.length > 1 ? 'ies' : 'y'}`);
         const displayed = warnings.length > 5 ? warnings.slice(0, 3) : warnings;
         for (const warning of displayed) {
-            rollup.stderr(warning.ids.map(rollup.relativeId).join(' -> '));
+            stderr(warning.cycle.join(' -> '));
         }
         if (warnings.length > displayed.length) {
-            rollup.stderr(`...and ${warnings.length - displayed.length} more`);
+            stderr(`...and ${warnings.length - displayed.length} more`);
         }
     },
     EMPTY_BUNDLE(warnings) {
         title(`Generated${warnings.length === 1 ? ' an' : ''} empty ${warnings.length > 1 ? 'chunks' : 'chunk'}`);
-        rollup.stderr(rollup.printQuotedStringList(warnings.map(warning => warning.names[0])));
+        stderr(warnings.map(warning => warning.chunkName).join(', '));
     },
     EVAL(warnings) {
         title('Use of eval is strongly discouraged');
-        info(rollup.getRollupUrl(rollup.URL_AVOIDING_EVAL));
+        info('https://rollupjs.org/guide/en/#avoiding-eval');
         showTruncatedWarnings(warnings);
     },
     MISSING_EXPORT(warnings) {
         title('Missing exports');
-        info(rollup.getRollupUrl(rollup.URL_NAME_IS_NOT_EXPORTED));
+        info('https://rollupjs.org/guide/en/#error-name-is-not-exported-by-module');
         for (const warning of warnings) {
-            rollup.stderr(rollup.bold(rollup.relativeId(warning.id)));
-            rollup.stderr(`${warning.binding} is not exported by ${rollup.relativeId(warning.exporter)}`);
-            rollup.stderr(rollup.gray(warning.frame));
+            stderr(bold(warning.importer));
+            stderr(`${warning.missing} is not exported by ${warning.exporter}`);
+            stderr(gray(warning.frame));
         }
     },
     MISSING_GLOBAL_NAME(warnings) {
         title(`Missing global variable ${warnings.length > 1 ? 'names' : 'name'}`);
-        info(rollup.getRollupUrl(rollup.URL_OUTPUT_GLOBALS));
-        rollup.stderr(`Use "output.globals" to specify browser global variable names corresponding to external modules:`);
+        stderr(`Use output.globals to specify browser global variable names corresponding to external modules`);
         for (const warning of warnings) {
-            rollup.stderr(`${rollup.bold(warning.id)} (guessing "${warning.names[0]}")`);
+            stderr(`${bold(warning.source)} (guessing '${warning.guess}')`);
         }
     },
-    MIXED_EXPORTS(warnings) {
+    MIXED_EXPORTS: warnings => {
         title('Mixing named and default exports');
-        info(rollup.getRollupUrl(rollup.URL_OUTPUT_EXPORTS));
-        rollup.stderr(rollup.bold('The following entry modules are using named and default exports together:'));
-        warnings.sort((a, b) => (a.id < b.id ? -1 : 1));
+        info(`https://rollupjs.org/guide/en/#outputexports`);
+        stderr(bold('The following entry modules are using named and default exports together:'));
         const displayedWarnings = warnings.length > 5 ? warnings.slice(0, 3) : warnings;
         for (const warning of displayedWarnings) {
-            rollup.stderr(rollup.relativeId(warning.id));
+            stderr(rollup.relativeId(warning.id));
         }
         if (displayedWarnings.length < warnings.length) {
-            rollup.stderr(`...and ${warnings.length - displayedWarnings.length} other entry modules`);
+            stderr(`...and ${warnings.length - displayedWarnings.length} other entry modules`);
         }
-        rollup.stderr(`\nConsumers of your bundle will have to use chunk.default to access their default export, which may not be what you want. Use \`output.exports: "named"\` to disable this warning.`);
+        stderr(`\nConsumers of your bundle will have to use chunk['default'] to access their default export, which may not be what you want. Use \`output.exports: 'named'\` to disable this warning`);
     },
     NAMESPACE_CONFLICT(warnings) {
         title(`Conflicting re-exports`);
         for (const warning of warnings) {
-            rollup.stderr(`"${rollup.bold(rollup.relativeId(warning.reexporter))}" re-exports "${warning.binding}" from both "${rollup.relativeId(warning.ids[0])}" and "${rollup.relativeId(warning.ids[1])}" (will be ignored).`);
+            stderr(`"${bold(rollup.relativeId(warning.reexporter))}" re-exports "${warning.name}" from both "${rollup.relativeId(warning.sources[0])}" and "${rollup.relativeId(warning.sources[1])}" (will be ignored)`);
         }
     },
+    NON_EXISTENT_EXPORT(warnings) {
+        title(`Import of non-existent ${warnings.length > 1 ? 'exports' : 'export'}`);
+        showTruncatedWarnings(warnings);
+    },
     PLUGIN_WARNING(warnings) {
+        var _a;
         const nestedByPlugin = nest(warnings, 'plugin');
         for (const { key: plugin, items } of nestedByPlugin) {
             const nestedByMessage = nest(items, 'message');
@@ -139,13 +239,13 @@
                 for (const warning of items) {
                     if (warning.url && warning.url !== lastUrl)
                         info((lastUrl = warning.url));
-                    const id = warning.id || warning.loc?.file;
+                    const id = warning.id || ((_a = warning.loc) === null || _a === void 0 ? void 0 : _a.file);
                     if (id) {
                         let loc = rollup.relativeId(id);
                         if (warning.loc) {
                             loc += `: (${warning.loc.line}:${warning.loc.column})`;
                         }
-                        rollup.stderr(rollup.bold(loc));
+                        stderr(bold(loc));
                     }
                     if (warning.frame)
                         info(warning.frame);
@@ -155,49 +255,51 @@
     },
     SOURCEMAP_BROKEN(warnings) {
         title(`Broken sourcemap`);
-        info(rollup.getRollupUrl(rollup.URL_SOURCEMAP_IS_LIKELY_TO_BE_INCORRECT));
-        const plugins = [...new Set(warnings.map(({ plugin }) => plugin).filter(Boolean))];
-        rollup.stderr(`Plugins that transform code (such as ${rollup.printQuotedStringList(plugins)}) should generate accompanying sourcemaps.`);
+        info('https://rollupjs.org/guide/en/#warning-sourcemap-is-likely-to-be-incorrect');
+        const plugins = [
+            ...new Set(warnings.map(warning => warning.plugin).filter(Boolean))
+        ];
+        stderr(`Plugins that transform code (such as ${rollup.printQuotedStringList(plugins)}) should generate accompanying sourcemaps`);
     },
     THIS_IS_UNDEFINED(warnings) {
-        title('"this" has been rewritten to "undefined"');
-        info(rollup.getRollupUrl(rollup.URL_THIS_IS_UNDEFINED));
+        title('`this` has been rewritten to `undefined`');
+        info('https://rollupjs.org/guide/en/#error-this-is-undefined');
         showTruncatedWarnings(warnings);
     },
     UNRESOLVED_IMPORT(warnings) {
         title('Unresolved dependencies');
-        info(rollup.getRollupUrl(rollup.URL_TREATING_MODULE_AS_EXTERNAL_DEPENDENCY));
+        info('https://rollupjs.org/guide/en/#warning-treating-module-as-external-dependency');
         const dependencies = new Map();
         for (const warning of warnings) {
-            rollup.getOrCreate(dependencies, rollup.relativeId(warning.exporter), rollup.getNewArray).push(rollup.relativeId(warning.id));
+            rollup.getOrCreate(dependencies, warning.source, () => []).push(warning.importer);
         }
-        for (const [dependency, importers] of dependencies) {
-            rollup.stderr(`${rollup.bold(dependency)} (imported by ${rollup.printQuotedStringList(importers)})`);
+        for (const dependency of dependencies.keys()) {
+            const importers = dependencies.get(dependency);
+            stderr(`${bold(dependency)} (imported by ${importers.join(', ')})`);
         }
     },
     UNUSED_EXTERNAL_IMPORT(warnings) {
         title('Unused external imports');
         for (const warning of warnings) {
-            rollup.stderr(warning.names +
+            stderr(warning.names +
                 ' imported from external module "' +
-                warning.exporter +
+                warning.source +
                 '" but never used in ' +
-                rollup.printQuotedStringList(warning.ids.map(rollup.relativeId)) +
-                '.');
+                rollup.printQuotedStringList(warning.sources.map(id => rollup.relativeId(id))));
         }
     }
 };
-function title(string_) {
-    rollup.stderr(rollup.bold(rollup.yellow(`(!) ${string_}`)));
+function title(str) {
+    stderr(bold(yellow(`(!) ${str}`)));
 }
 function info(url) {
-    rollup.stderr(rollup.gray(url));
+    stderr(gray(url));
 }
-function nest(array, property) {
+function nest(array, prop) {
     const nested = [];
     const lookup = new Map();
     for (const item of array) {
-        const key = item[property];
+        const key = item[prop];
         rollup.getOrCreate(lookup, key, () => {
             const items = {
                 items: [],
@@ -213,21 +315,21 @@
     const nestedByModule = nest(warnings, 'id');
     const displayedByModule = nestedByModule.length > 5 ? nestedByModule.slice(0, 3) : nestedByModule;
     for (const { key: id, items } of displayedByModule) {
-        rollup.stderr(rollup.bold(rollup.relativeId(id)));
-        rollup.stderr(rollup.gray(items[0].frame));
+        stderr(bold(rollup.relativeId(id)));
+        stderr(gray(items[0].frame));
         if (items.length > 1) {
-            rollup.stderr(`...and ${items.length - 1} other ${items.length > 2 ? 'occurrences' : 'occurrence'}`);
+            stderr(`...and ${items.length - 1} other ${items.length > 2 ? 'occurrences' : 'occurrence'}`);
         }
     }
     if (nestedByModule.length > displayedByModule.length) {
-        rollup.stderr(`\n...and ${nestedByModule.length - displayedByModule.length} other files`);
+        stderr(`\n...and ${nestedByModule.length - displayedByModule.length} other files`);
     }
 }
 
 const stdinName = '-';
 let stdinResult = null;
-function stdinPlugin(argument) {
-    const suffix = typeof argument == 'string' && argument.length > 0 ? '.' + argument : '';
+function stdinPlugin(arg) {
+    const suffix = typeof arg == 'string' && arg.length ? '.' + arg : '';
     return {
         load(id) {
             if (id === stdinName || id.startsWith(stdinName + '.')) {
@@ -252,8 +354,8 @@
             const result = chunks.join('');
             resolve(result);
         })
-            .on('error', error => {
-            reject(error);
+            .on('error', err => {
+            reject(err);
         });
     });
 }
@@ -269,7 +371,7 @@
                 for (const specifier of inputSpecifiers) {
                     if ((await this.resolve(specifier)) === null) {
                         if (lastAwaitedSpecifier !== specifier) {
-                            rollup.stderr(`waiting for input ${rollup.bold(specifier)}...`);
+                            stderr(`waiting for input ${bold(specifier)}...`);
                             lastAwaitedSpecifier = specifier;
                         }
                         await new Promise(resolve => setTimeout(resolve, 500));
@@ -283,61 +385,59 @@
     };
 }
 
-async function addCommandPluginsToInputOptions(inputOptions, command) {
+function addCommandPluginsToInputOptions(inputOptions, command) {
     if (command.stdin !== false) {
         inputOptions.plugins.push(stdinPlugin(command.stdin));
     }
     if (command.waitForBundleInput === true) {
         inputOptions.plugins.push(waitForInputPlugin());
     }
-    await addPluginsFromCommandOption(command.plugin, inputOptions);
+    addPluginsFromCommandOption(command.plugin, inputOptions);
 }
-async function addPluginsFromCommandOption(commandPlugin, inputOptions) {
+function addPluginsFromCommandOption(commandPlugin, inputOptions) {
     if (commandPlugin) {
-        const plugins = await rollup.normalizePluginOption(commandPlugin);
+        const plugins = Array.isArray(commandPlugin) ? commandPlugin : [commandPlugin];
         for (const plugin of plugins) {
             if (/[={}]/.test(plugin)) {
                 // -p plugin=value
                 // -p "{transform(c,i){...}}"
-                await loadAndRegisterPlugin(inputOptions, plugin);
+                loadAndRegisterPlugin(inputOptions, plugin);
             }
             else {
                 // split out plugins joined by commas
                 // -p node-resolve,commonjs,buble
-                for (const p of plugin.split(',')) {
-                    await loadAndRegisterPlugin(inputOptions, p);
-                }
+                plugin.split(',').forEach((plugin) => loadAndRegisterPlugin(inputOptions, plugin));
             }
         }
     }
 }
-async function loadAndRegisterPlugin(inputOptions, pluginText) {
+function loadAndRegisterPlugin(inputOptions, pluginText) {
     let plugin = null;
-    let pluginArgument = undefined;
+    let pluginArg = undefined;
     if (pluginText[0] === '{') {
         // -p "{transform(c,i){...}}"
         plugin = new Function('return ' + pluginText);
     }
     else {
-        const match = pluginText.match(/^([\w./:@\\^{|}-]+)(=(.*))?$/);
+        const match = pluginText.match(/^([@./\\\w|^{}-]+)(=(.*))?$/);
         if (match) {
             // -p plugin
             // -p plugin=arg
             pluginText = match[1];
-            pluginArgument = new Function('return ' + match[3])();
+            pluginArg = new Function('return ' + match[3])();
         }
         else {
             throw new Error(`Invalid --plugin argument format: ${JSON.stringify(pluginText)}`);
         }
-        if (!/^\.|^rollup-plugin-|[/@\\]/.test(pluginText)) {
+        if (!/^\.|^rollup-plugin-|[@/\\]/.test(pluginText)) {
             // Try using plugin prefix variations first if applicable.
             // Prefix order is significant - left has higher precedence.
             for (const prefix of ['@rollup/plugin-', 'rollup-plugin-']) {
                 try {
-                    plugin = await requireOrImport(prefix + pluginText);
+                    plugin = require(prefix + pluginText);
                     break;
                 }
-                catch {
+                catch (_a) {
                     // if this does not work, we try requiring the actual name below
                 }
             }
@@ -345,16 +445,11 @@
         if (!plugin) {
             try {
                 if (pluginText[0] == '.')
-                    pluginText = node_path.resolve(pluginText);
-                // Windows absolute paths must be specified as file:// protocol URL
-                // Note that we do not have coverage for Windows-only code paths
-                else if (/^[A-Za-z]:\\/.test(pluginText)) {
-                    pluginText = node_url.pathToFileURL(node_path.resolve(pluginText)).href;
-                }
-                plugin = await requireOrImport(pluginText);
+                    pluginText = path__namespace.resolve(pluginText);
+                plugin = require(pluginText);
             }
-            catch (error) {
-                throw new Error(`Cannot load plugin "${pluginText}": ${error.message}.`);
+            catch (err) {
+                throw new Error(`Cannot load plugin "${pluginText}": ${err.message}.`);
             }
         }
     }
@@ -366,129 +461,112 @@
     if (!plugin) {
         throw new Error(`Cannot find entry for plugin "${pluginText}". The plugin needs to export a function either as "default" or "${getCamelizedPluginBaseName(pluginText)}" for Rollup to recognize it.`);
     }
-    inputOptions.plugins.push(typeof plugin === 'function' ? plugin.call(plugin, pluginArgument) : plugin);
+    inputOptions.plugins.push(typeof plugin === 'function' ? plugin.call(plugin, pluginArg) : plugin);
 }
 function getCamelizedPluginBaseName(pluginText) {
-    return (pluginText.match(/(@rollup\/plugin-|rollup-plugin-)(.+)$/)?.[2] || pluginText)
-        .split(/[/\\]/)
+    var _a;
+    return (((_a = pluginText.match(/(@rollup\/plugin-|rollup-plugin-)(.+)$/)) === null || _a === void 0 ? void 0 : _a[2]) || pluginText)
+        .split(/[\\/]/)
         .slice(-1)[0]
         .split('.')[0]
         .split('-')
         .map((part, index) => (index === 0 || !part ? part : part[0].toUpperCase() + part.slice(1)))
         .join('');
 }
-async function requireOrImport(pluginPath) {
-    try {
-        // eslint-disable-next-line unicorn/prefer-module
-        return require(pluginPath);
-    }
-    catch {
-        return import(pluginPath);
-    }
-}
 
-async function loadConfigFile(fileName, commandOptions = {}) {
-    const configs = await getConfigList(getDefaultFromCjs(await getConfigFileExport(fileName, commandOptions)), commandOptions);
+function supportsNativeESM() {
+    return Number(/^v(\d+)/.exec(process.version)[1]) >= 13;
+}
+async function loadAndParseConfigFile(fileName, commandOptions = {}) {
+    const configs = await loadConfigFile(fileName, commandOptions);
     const warnings = batchWarnings();
     try {
-        const normalizedConfigs = [];
-        for (const config of configs) {
-            const options = await rollup.mergeOptions(config, commandOptions, warnings.add);
-            await addCommandPluginsToInputOptions(options, commandOptions);
-            normalizedConfigs.push(options);
-        }
+        const normalizedConfigs = configs.map(config => {
+            const options = mergeOptions.mergeOptions(config, commandOptions, warnings.add);
+            addCommandPluginsToInputOptions(options, commandOptions);
+            return options;
+        });
         return { options: normalizedConfigs, warnings };
     }
-    catch (error_) {
+    catch (err) {
         warnings.flush();
-        throw error_;
+        throw err;
     }
 }
-async function getConfigFileExport(fileName, commandOptions) {
-    if (commandOptions.configPlugin || commandOptions.bundleConfigAsCjs) {
-        try {
-            return await loadTranspiledConfigFile(fileName, commandOptions);
-        }
-        catch (error_) {
-            if (error_.message.includes('not defined in ES module scope')) {
-                return rollup.error(rollup.errorCannotBundleConfigAsEsm(error_));
-            }
-            throw error_;
-        }
-    }
-    let cannotLoadEsm = false;
-    const handleWarning = (warning) => {
-        if (warning.message.includes('To load an ES module')) {
-            cannotLoadEsm = true;
-        }
-    };
-    process.on('warning', handleWarning);
-    try {
-        const fileUrl = node_url.pathToFileURL(fileName);
-        if (process.env.ROLLUP_WATCH) {
-            // We are adding the current date to allow reloads in watch mode
-            fileUrl.search = `?${Date.now()}`;
-        }
-        return (await import(fileUrl.href)).default;
-    }
-    catch (error_) {
-        if (cannotLoadEsm) {
-            return rollup.error(rollup.errorCannotLoadConfigAsCjs(error_));
-        }
-        if (error_.message.includes('not defined in ES module scope')) {
-            return rollup.error(rollup.errorCannotLoadConfigAsEsm(error_));
-        }
-        throw error_;
-    }
-    finally {
-        process.off('warning', handleWarning);
-    }
+async function loadConfigFile(fileName, commandOptions) {
+    const extension = path__namespace.extname(fileName);
+    const configFileExport = commandOptions.configPlugin ||
+        !(extension === '.cjs' || (extension === '.mjs' && supportsNativeESM()))
+        ? await getDefaultFromTranspiledConfigFile(fileName, commandOptions)
+        : extension === '.cjs'
+            ? getDefaultFromCjs(require(fileName))
+            : (await import(url.pathToFileURL(fileName).href)).default;
+    return getConfigList(configFileExport, commandOptions);
 }
 function getDefaultFromCjs(namespace) {
-    return namespace.default || namespace;
+    return namespace.__esModule ? namespace.default : namespace;
 }
-async function loadTranspiledConfigFile(fileName, { bundleConfigAsCjs, configPlugin, silent }) {
+async function getDefaultFromTranspiledConfigFile(fileName, commandOptions) {
     const warnings = batchWarnings();
     const inputOptions = {
-        external: (id) => (id[0] !== '.' && !node_path.isAbsolute(id)) || id.slice(-5, id.length) === '.json',
+        external: (id) => (id[0] !== '.' && !path__namespace.isAbsolute(id)) || id.slice(-5, id.length) === '.json',
         input: fileName,
         onwarn: warnings.add,
         plugins: [],
         treeshake: false
     };
-    await addPluginsFromCommandOption(configPlugin, inputOptions);
+    addPluginsFromCommandOption(commandOptions.configPlugin, inputOptions);
     const bundle = await rollup.rollup(inputOptions);
-    if (!silent && warnings.count > 0) {
-        rollup.stderr(rollup.bold(`loaded ${rollup.relativeId(fileName)} with warnings`));
+    if (!commandOptions.silent && warnings.count > 0) {
+        stderr(bold(`loaded ${rollup.relativeId(fileName)} with warnings`));
         warnings.flush();
     }
     const { output: [{ code }] } = await bundle.generate({
         exports: 'named',
-        format: bundleConfigAsCjs ? 'cjs' : 'es',
+        format: 'cjs',
         plugins: [
             {
                 name: 'transpile-import-meta',
                 resolveImportMeta(property, { moduleId }) {
                     if (property === 'url') {
-                        return `'${node_url.pathToFileURL(moduleId).href}'`;
+                        return `'${url.pathToFileURL(moduleId).href}'`;
                     }
                     if (property == null) {
-                        return `{url:'${node_url.pathToFileURL(moduleId).href}'}`;
+                        return `{url:'${url.pathToFileURL(moduleId).href}'}`;
                     }
                 }
             }
         ]
     });
-    return loadConfigFromWrittenFile(node_path.join(node_path.dirname(fileName), `rollup.config-${Date.now()}.${bundleConfigAsCjs ? 'cjs' : 'mjs'}`), code);
+    return loadConfigFromBundledFile(fileName, code);
 }
-async function loadConfigFromWrittenFile(bundledFileName, bundledCode) {
-    await promises.writeFile(bundledFileName, bundledCode);
+async function loadConfigFromBundledFile(fileName, bundledCode) {
+    const resolvedFileName = fs__namespace.realpathSync(fileName);
+    const extension = path__namespace.extname(resolvedFileName);
+    const defaultLoader = require.extensions[extension];
+    require.extensions[extension] = (module, requiredFileName) => {
+        if (requiredFileName === resolvedFileName) {
+            module._compile(bundledCode, requiredFileName);
+        }
+        else {
+            defaultLoader(module, requiredFileName);
+        }
+    };
+    delete require.cache[resolvedFileName];
     try {
-        return (await import(node_url.pathToFileURL(bundledFileName).href)).default;
-    }
-    finally {
-        // Not awaiting here saves some ms while potentially hiding a non-critical error
-        promises.unlink(bundledFileName);
+        const config = getDefaultFromCjs(require(fileName));
+        require.extensions[extension] = defaultLoader;
+        return config;
+    }
+    catch (err) {
+        if (err.code === 'ERR_REQUIRE_ESM') {
+            return rollup.error({
+                code: 'TRANSPILED_ESM_CONFIG',
+                message: `While loading the Rollup configuration from "${rollup.relativeId(fileName)}", Node tried to require an ES module from a CommonJS file, which is not supported. A common cause is if there is a package.json file with "type": "module" in the same folder. You can try to fix this by changing the extension of your configuration file to ".cjs" or ".mjs" depending on the content, which will prevent Rollup from trying to preprocess the file but rather hand it to Node directly.`,
+                url: 'https://rollupjs.org/guide/en/#using-untranspiled-config-files'
+            });
+        }
+        throw err;
     }
 }
 async function getConfigList(configFileExport, commandOptions) {
@@ -496,13 +574,23 @@
         ? configFileExport(commandOptions)
         : configFileExport);
     if (Object.keys(config).length === 0) {
-        return rollup.error(rollup.errorMissingConfig());
+        return rollup.error({
+            code: 'MISSING_CONFIG',
+            message: 'Config file must export an options object, or an array of options objects',
+            url: 'https://rollupjs.org/guide/en/#configuration-files'
+        });
     }
     return Array.isArray(config) ? config : [config];
 }
 
 exports.addCommandPluginsToInputOptions = addCommandPluginsToInputOptions;
 exports.batchWarnings = batchWarnings;
-exports.loadConfigFile = loadConfigFile;
+exports.bold = bold;
+exports.cyan = cyan;
+exports.green = green;
+exports.handleError = handleError;
+exports.loadAndParseConfigFile = loadAndParseConfigFile;
+exports.stderr = stderr;
 exports.stdinName = stdinName;
+exports.underline = underline;
 //# sourceMappingURL=loadConfigFile.js.map
diff -urN /chromium-112.0.5615.49/third_party/node/node_modules/rollup/dist/shared/mergeOptions.js /chromium-111.0.5563.110/third_party/node/node_modules/rollup/dist/shared/mergeOptions.js
--- a/third_party/node/node_modules/rollup/dist/shared/mergeOptions.js	1970-01-01 00:00:00.000000000 +0000
+++ b/third_party/node/node_modules/rollup/dist/shared/mergeOptions.js	2023-01-12 22:12:55.000000000 +0000
@@ -0,0 +1,172 @@
+/*
+  @license
+	Rollup.js v2.58.0
+	Fri, 01 Oct 2021 06:54:03 GMT - commit 3a404a07f41a10d10b7af536f05b90ea46d8ad3d
+
+
+	https://github.com/rollup/rollup
+
+	Released under the MIT License.
+*/
+'use strict';
+
+const rollup = require('./rollup.js');
+
+const commandAliases = {
+    c: 'config',
+    d: 'dir',
+    e: 'external',
+    f: 'format',
+    g: 'globals',
+    h: 'help',
+    i: 'input',
+    m: 'sourcemap',
+    n: 'name',
+    o: 'file',
+    p: 'plugin',
+    v: 'version',
+    w: 'watch'
+};
+function mergeOptions(config, rawCommandOptions = { external: [], globals: undefined }, defaultOnWarnHandler = rollup.defaultOnWarn) {
+    const command = getCommandOptions(rawCommandOptions);
+    const inputOptions = mergeInputOptions(config, command, defaultOnWarnHandler);
+    const warn = inputOptions.onwarn;
+    if (command.output) {
+        Object.assign(command, command.output);
+    }
+    const outputOptionsArray = rollup.ensureArray(config.output);
+    if (outputOptionsArray.length === 0)
+        outputOptionsArray.push({});
+    const outputOptions = outputOptionsArray.map(singleOutputOptions => mergeOutputOptions(singleOutputOptions, command, warn));
+    rollup.warnUnknownOptions(command, Object.keys(inputOptions).concat(Object.keys(outputOptions[0]).filter(option => option !== 'sourcemapPathTransform'), Object.keys(commandAliases), 'config', 'environment', 'plugin', 'silent', 'failAfterWarnings', 'stdin', 'waitForBundleInput', 'configPlugin'), 'CLI flags', warn, /^_$|output$|config/);
+    inputOptions.output = outputOptions;
+    return inputOptions;
+}
+function getCommandOptions(rawCommandOptions) {
+    const external = rawCommandOptions.external && typeof rawCommandOptions.external === 'string'
+        ? rawCommandOptions.external.split(',')
+        : [];
+    return {
+        ...rawCommandOptions,
+        external,
+        globals: typeof rawCommandOptions.globals === 'string'
+            ? rawCommandOptions.globals.split(',').reduce((globals, globalDefinition) => {
+                const [id, variableName] = globalDefinition.split(':');
+                globals[id] = variableName;
+                if (external.indexOf(id) === -1) {
+                    external.push(id);
+                }
+                return globals;
+            }, Object.create(null))
+            : undefined
+    };
+}
+function mergeInputOptions(config, overrides, defaultOnWarnHandler) {
+    const getOption = (name) => { var _a; return (_a = overrides[name]) !== null && _a !== void 0 ? _a : config[name]; };
+    const inputOptions = {
+        acorn: getOption('acorn'),
+        acornInjectPlugins: config.acornInjectPlugins,
+        cache: config.cache,
+        context: getOption('context'),
+        experimentalCacheExpiry: getOption('experimentalCacheExpiry'),
+        external: getExternal(config, overrides),
+        inlineDynamicImports: getOption('inlineDynamicImports'),
+        input: getOption('input') || [],
+        makeAbsoluteExternalsRelative: getOption('makeAbsoluteExternalsRelative'),
+        manualChunks: getOption('manualChunks'),
+        maxParallelFileReads: getOption('maxParallelFileReads'),
+        moduleContext: getOption('moduleContext'),
+        onwarn: getOnWarn(config, defaultOnWarnHandler),
+        perf: getOption('perf'),
+        plugins: rollup.ensureArray(config.plugins),
+        preserveEntrySignatures: getOption('preserveEntrySignatures'),
+        preserveModules: getOption('preserveModules'),
+        preserveSymlinks: getOption('preserveSymlinks'),
+        shimMissingExports: getOption('shimMissingExports'),
+        strictDeprecations: getOption('strictDeprecations'),
+        treeshake: getObjectOption(config, overrides, 'treeshake', rollup.objectifyOptionWithPresets(rollup.treeshakePresets, 'treeshake', 'false, true, ')),
+        watch: getWatch(config, overrides, 'watch')
+    };
+    rollup.warnUnknownOptions(config, Object.keys(inputOptions), 'input options', inputOptions.onwarn, /^output$/);
+    return inputOptions;
+}
+const getExternal = (config, overrides) => {
+    const configExternal = config.external;
+    return typeof configExternal === 'function'
+        ? (source, importer, isResolved) => configExternal(source, importer, isResolved) || overrides.external.indexOf(source) !== -1
+        : rollup.ensureArray(configExternal).concat(overrides.external);
+};
+const getOnWarn = (config, defaultOnWarnHandler) => config.onwarn
+    ? warning => config.onwarn(warning, defaultOnWarnHandler)
+    : defaultOnWarnHandler;
+const getObjectOption = (config, overrides, name, objectifyValue = value => (typeof value === 'object' ? value : {})) => {
+    const commandOption = normalizeObjectOptionValue(overrides[name], objectifyValue);
+    const configOption = normalizeObjectOptionValue(config[name], objectifyValue);
+    if (commandOption !== undefined) {
+        return commandOption && { ...configOption, ...commandOption };
+    }
+    return configOption;
+};
+const getWatch = (config, overrides, name) => config.watch !== false && getObjectOption(config, overrides, name);
+const normalizeObjectOptionValue = (optionValue, objectifyValue) => {
+    if (!optionValue) {
+        return optionValue;
+    }
+    if (Array.isArray(optionValue)) {
+        return optionValue.reduce((result, value) => value && result && { ...result, ...objectifyValue(value) }, {});
+    }
+    return objectifyValue(optionValue);
+};
+function mergeOutputOptions(config, overrides, warn) {
+    const getOption = (name) => { var _a; return (_a = overrides[name]) !== null && _a !== void 0 ? _a : config[name]; };
+    const outputOptions = {
+        amd: getObjectOption(config, overrides, 'amd'),
+        assetFileNames: getOption('assetFileNames'),
+        banner: getOption('banner'),
+        chunkFileNames: getOption('chunkFileNames'),
+        compact: getOption('compact'),
+        dir: getOption('dir'),
+        dynamicImportFunction: getOption('dynamicImportFunction'),
+        entryFileNames: getOption('entryFileNames'),
+        esModule: getOption('esModule'),
+        exports: getOption('exports'),
+        extend: getOption('extend'),
+        externalLiveBindings: getOption('externalLiveBindings'),
+        file: getOption('file'),
+        footer: getOption('footer'),
+        format: getOption('format'),
+        freeze: getOption('freeze'),
+        generatedCode: getObjectOption(config, overrides, 'generatedCode', rollup.objectifyOptionWithPresets(rollup.generatedCodePresets, 'output.generatedCode', '')),
+        globals: getOption('globals'),
+        hoistTransitiveImports: getOption('hoistTransitiveImports'),
+        indent: getOption('indent'),
+        inlineDynamicImports: getOption('inlineDynamicImports'),
+        interop: getOption('interop'),
+        intro: getOption('intro'),
+        manualChunks: getOption('manualChunks'),
+        minifyInternalExports: getOption('minifyInternalExports'),
+        name: getOption('name'),
+        namespaceToStringTag: getOption('namespaceToStringTag'),
+        noConflict: getOption('noConflict'),
+        outro: getOption('outro'),
+        paths: getOption('paths'),
+        plugins: rollup.ensureArray(config.plugins),
+        preferConst: getOption('preferConst'),
+        preserveModules: getOption('preserveModules'),
+        preserveModulesRoot: getOption('preserveModulesRoot'),
+        sanitizeFileName: getOption('sanitizeFileName'),
+        sourcemap: getOption('sourcemap'),
+        sourcemapExcludeSources: getOption('sourcemapExcludeSources'),
+        sourcemapFile: getOption('sourcemapFile'),
+        sourcemapPathTransform: getOption('sourcemapPathTransform'),
+        strict: getOption('strict'),
+        systemNullSetters: getOption('systemNullSetters'),
+        validate: getOption('validate')
+    };
+    rollup.warnUnknownOptions(config, Object.keys(outputOptions), 'output options', warn);
+    return outputOptions;
+}
+
+exports.commandAliases = commandAliases;
+exports.mergeOptions = mergeOptions;
+//# sourceMappingURL=mergeOptions.js.map
diff -urN /chromium-112.0.5615.49/third_party/node/node_modules/rollup/dist/shared/rollup.js /chromium-111.0.5563.110/third_party/node/node_modules/rollup/dist/shared/rollup.js
--- a/third_party/node/node_modules/rollup/dist/shared/rollup.js	2023-02-03 20:05:52.000000000 +0000
+++ b/third_party/node/node_modules/rollup/dist/shared/rollup.js	2023-01-12 22:12:55.000000000 +0000
@@ -1,7 +1,8 @@
 /*
   @license
-	Rollup.js v3.12.0
-	Sat, 28 Jan 2023 05:55:49 GMT - commit 01ddea09dfdf1c396c1c24ba3d97743698fe1508
+	Rollup.js v2.58.0
+	Fri, 01 Oct 2021 06:54:03 GMT - commit 3a404a07f41a10d10b7af536f05b90ea46d8ad3d
+
 
 	https://github.com/rollup/rollup
 
@@ -9,17 +10,13 @@
 */
 'use strict';
 
-const node_path = require('node:path');
-const require$$0$1 = require('path');
-const process$1 = require('node:process');
-const node_perf_hooks = require('node:perf_hooks');
-const node_crypto = require('node:crypto');
-const promises = require('node:fs/promises');
-const node_events = require('node:events');
-const tty = require('tty');
+const path$2 = require('path');
+const crypto = require('crypto');
+const fs = require('fs');
+const require$$0 = require('events');
 
 function _interopNamespaceDefault(e) {
-  const n = Object.create(null, { [Symbol.toStringTag]: { value: 'Module' } });
+  const n = Object.create(null);
   if (e) {
     for (const k in e) {
       n[k] = e[k];
@@ -29,9 +26,7 @@
   return n;
 }
 
-const tty__namespace = /*#__PURE__*/_interopNamespaceDefault(tty);
-
-var version$1 = "3.12.0";
+var version$1 = "2.58.0";
 
 function ensureArray$1(items) {
     if (Array.isArray(items)) {
@@ -43,54 +38,6 @@
     return [];
 }
 
-// troubleshooting
-const URL_AVOIDING_EVAL = 'troubleshooting/#avoiding-eval';
-const URL_NAME_IS_NOT_EXPORTED = 'troubleshooting/#error-name-is-not-exported-by-module';
-const URL_THIS_IS_UNDEFINED = 'troubleshooting/#error-this-is-undefined';
-const URL_TREATING_MODULE_AS_EXTERNAL_DEPENDENCY = 'troubleshooting/#warning-treating-module-as-external-dependency';
-const URL_SOURCEMAP_IS_LIKELY_TO_BE_INCORRECT = 'troubleshooting/#warning-sourcemap-is-likely-to-be-incorrect';
-// configuration-options
-const URL_MAXPARALLELFILEOPS = 'configuration-options/#maxparallelfileops';
-const URL_OUTPUT_AMD_ID = 'configuration-options/#output-amd-id';
-const URL_OUTPUT_AMD_BASEPATH = 'configuration-options/#output-amd-basepath';
-const URL_OUTPUT_DIR = 'configuration-options/#output-dir';
-const URL_OUTPUT_DYNAMICIMPORTFUNCTION = 'configuration-options/#output-dynamicimportfunction';
-const URL_OUTPUT_EXPORTS = 'configuration-options/#output-exports';
-const URL_OUTPUT_EXTEND = 'configuration-options/#output-extend';
-const URL_OUTPUT_FORMAT = 'configuration-options/#output-format';
-const URL_OUTPUT_GENERATEDCODE = 'configuration-options/#output-generatedcode';
-const URL_OUTPUT_GENERATEDCODE_CONSTBINDINGS = 'configuration-options/#output-generatedcode-constbindings';
-const URL_OUTPUT_GENERATEDCODE_SYMBOLS = 'configuration-options/#output-generatedcode-symbols';
-const URL_OUTPUT_GLOBALS = 'configuration-options/#output-globals';
-const URL_OUTPUT_INLINEDYNAMICIMPORTS = 'configuration-options/#output-inlinedynamicimports';
-const URL_OUTPUT_INTEROP = 'configuration-options/#output-interop';
-const URL_OUTPUT_MANUALCHUNKS = 'configuration-options/#output-manualchunks';
-const URL_OUTPUT_NAME = 'configuration-options/#output-name';
-const URL_OUTPUT_PRESERVEMODULES = 'configuration-options/#output-preservemodules';
-const URL_OUTPUT_SOURCEMAPBASEURL = 'configuration-options/#output-sourcemapbaseurl';
-const URL_OUTPUT_SOURCEMAPFILE = 'configuration-options/#output-sourcemapfile';
-const URL_PRESERVEENTRYSIGNATURES = 'configuration-options/#preserveentrysignatures';
-const URL_TREESHAKE = 'configuration-options/#treeshake';
-const URL_TREESHAKE_MODULESIDEEFFECTS = 'configuration-options/#treeshake-modulesideeffects';
-const URL_WATCH = 'configuration-options/#watch';
-// command-line-interface
-const URL_BUNDLE_CONFIG_AS_CJS = 'command-line-interface/#bundleconfigascjs';
-const URL_CONFIGURATION_FILES = 'command-line-interface/#configuration-files';
-const URL_RENDERDYNAMICIMPORT = 'plugin-development/#renderdynamicimport';
-const URL_THIS_GETMODULEIDS = 'plugin-development/#this-getmoduleids';
-const URL_THIS_GETMODULEINFO = 'plugin-development/#this-getmoduleinfo';
-
-async function asyncFlatten(array) {
-    do {
-        array = (await Promise.all(array)).flat(Infinity);
-    } while (array.some((v) => v?.then));
-    return array;
-}
-
-const BLANK = Object.freeze(Object.create(null));
-const EMPTY_OBJECT = Object.freeze({});
-const EMPTY_ARRAY = Object.freeze([]);
-
 function getLocator$1(source, options) {
     if (options === void 0) { options = {}; }
     var offsetLine = options.offsetLine || 0;
@@ -132,14 +79,14 @@
     return getLocator$1(source, options)(search, options && options.startIndex);
 }
 
-function spaces(index) {
+function spaces(i) {
     let result = '';
-    while (index--)
+    while (i--)
         result += ' ';
     return result;
 }
-function tabsToSpaces(value) {
-    return value.replace(/^\t+/, match => match.split('\t').join('  '));
+function tabsToSpaces(str) {
+    return str.replace(/^\t+/, match => match.split('\t').join('  '));
 }
 function getCodeFrame(source, line, column) {
     let lines = source.split('\n');
@@ -152,33 +99,20 @@
     }
     const digits = String(frameEnd).length;
     return lines
-        .map((sourceLine, index) => {
-        const isErrorLine = frameStart + index + 1 === line;
-        let lineNumber = String(index + frameStart + 1);
-        while (lineNumber.length < digits)
-            lineNumber = ` ${lineNumber}`;
+        .map((str, i) => {
+        const isErrorLine = frameStart + i + 1 === line;
+        let lineNum = String(i + frameStart + 1);
+        while (lineNum.length < digits)
+            lineNum = ` ${lineNum}`;
         if (isErrorLine) {
-            const indicator = spaces(digits + 2 + tabsToSpaces(sourceLine.slice(0, column)).length) + '^';
-            return `${lineNumber}: ${tabsToSpaces(sourceLine)}\n${indicator}`;
+            const indicator = spaces(digits + 2 + tabsToSpaces(str.slice(0, column)).length) + '^';
+            return `${lineNum}: ${tabsToSpaces(str)}\n${indicator}`;
         }
-        return `${lineNumber}: ${tabsToSpaces(sourceLine)}`;
+        return `${lineNum}: ${tabsToSpaces(str)}`;
     })
         .join('\n');
 }
 
-const ABSOLUTE_PATH_REGEX = /^(?:\/|(?:[A-Za-z]:)?[/\\|])/;
-const RELATIVE_PATH_REGEX = /^\.?\.(\/|$)/;
-function isAbsolute(path) {
-    return ABSOLUTE_PATH_REGEX.test(path);
-}
-function isRelative(path) {
-    return RELATIVE_PATH_REGEX.test(path);
-}
-const BACKSLASH_REGEX = /\\/g;
-function normalize(path) {
-    return path.replace(BACKSLASH_REGEX, '/');
-}
-
 function printQuotedStringList(list, verbs) {
     const isSingleItem = list.length <= 1;
     const quotedList = list.map(item => `"${item}"`);
@@ -191,673 +125,373 @@
     return output;
 }
 
-const ANY_SLASH_REGEX = /[/\\]/;
-function relative(from, to) {
-    const fromParts = from.split(ANY_SLASH_REGEX).filter(Boolean);
-    const toParts = to.split(ANY_SLASH_REGEX).filter(Boolean);
-    if (fromParts[0] === '.')
-        fromParts.shift();
-    if (toParts[0] === '.')
-        toParts.shift();
-    while (fromParts[0] && toParts[0] && fromParts[0] === toParts[0]) {
-        fromParts.shift();
-        toParts.shift();
-    }
-    while (toParts[0] === '..' && fromParts.length > 0) {
-        toParts.shift();
-        fromParts.pop();
-    }
-    while (fromParts.pop()) {
-        toParts.unshift('..');
-    }
-    return toParts.join('/');
+const absolutePath = /^(?:\/|(?:[A-Za-z]:)?[\\|/])/;
+const relativePath = /^\.?\.\//;
+function isAbsolute(path) {
+    return absolutePath.test(path);
+}
+function isRelative(path) {
+    return relativePath.test(path);
+}
+function normalize(path) {
+    if (path.indexOf('\\') == -1)
+        return path;
+    return path.replace(/\\/g, '/');
 }
 
 function getAliasName(id) {
-    const base = node_path.basename(id);
-    return base.slice(0, Math.max(0, base.length - node_path.extname(id).length));
+    const base = path$2.basename(id);
+    return base.substr(0, base.length - path$2.extname(id).length);
 }
 function relativeId(id) {
     if (!isAbsolute(id))
         return id;
-    return relative(node_path.resolve(), id);
+    return path$2.relative(path$2.resolve(), id);
 }
 function isPathFragment(name) {
     // starting with "/", "./", "../", "C:/"
     return (name[0] === '/' || (name[0] === '.' && (name[1] === '/' || name[1] === '.')) || isAbsolute(name));
 }
-const UPPER_DIR_REGEX = /^(\.\.\/)*\.\.$/;
-function getImportPath(importerId, targetPath, stripJsExtension, ensureFileName) {
-    let relativePath = normalize(relative(node_path.dirname(importerId), targetPath));
-    if (stripJsExtension && relativePath.endsWith('.js')) {
-        relativePath = relativePath.slice(0, -3);
-    }
-    if (ensureFileName) {
-        if (relativePath === '')
-            return '../' + node_path.basename(targetPath);
-        if (UPPER_DIR_REGEX.test(relativePath)) {
-            return [...relativePath.split('/'), '..', node_path.basename(targetPath)].join('/');
-        }
-    }
-    return relativePath ? (relativePath.startsWith('..') ? relativePath : './' + relativePath) : '.';
-}
-
-function isValidUrl(url) {
-    try {
-        new URL(url);
-    }
-    catch {
-        return false;
-    }
-    return true;
-}
-function getRollupUrl(snippet) {
-    return `https://rollupjs.org/${snippet}`;
-}
 
 function error(base) {
-    if (!(base instanceof Error)) {
+    if (!(base instanceof Error))
         base = Object.assign(new Error(base.message), base);
-        Object.defineProperty(base, 'name', { value: 'RollupError' });
-    }
     throw base;
 }
-function augmentCodeLocation(properties, pos, source, id) {
+function augmentCodeLocation(props, pos, source, id) {
     if (typeof pos === 'object') {
         const { line, column } = pos;
-        properties.loc = { column, file: id, line };
+        props.loc = { column, file: id, line };
     }
     else {
-        properties.pos = pos;
+        props.pos = pos;
         const { line, column } = locate(source, pos, { offsetLine: 1 });
-        properties.loc = { column, file: id, line };
+        props.loc = { column, file: id, line };
     }
-    if (properties.frame === undefined) {
-        const { line, column } = properties.loc;
-        properties.frame = getCodeFrame(source, line, column);
-    }
-}
-// Error codes should be sorted alphabetically while errors should be sorted by
-// error code below
-const ADDON_ERROR = 'ADDON_ERROR', ALREADY_CLOSED = 'ALREADY_CLOSED', AMBIGUOUS_EXTERNAL_NAMESPACES = 'AMBIGUOUS_EXTERNAL_NAMESPACES', ANONYMOUS_PLUGIN_CACHE = 'ANONYMOUS_PLUGIN_CACHE', ASSET_NOT_FINALISED = 'ASSET_NOT_FINALISED', ASSET_NOT_FOUND = 'ASSET_NOT_FOUND', ASSET_SOURCE_ALREADY_SET = 'ASSET_SOURCE_ALREADY_SET', ASSET_SOURCE_MISSING = 'ASSET_SOURCE_MISSING', BAD_LOADER = 'BAD_LOADER', CANNOT_CALL_NAMESPACE = 'CANNOT_CALL_NAMESPACE', CANNOT_EMIT_FROM_OPTIONS_HOOK = 'CANNOT_EMIT_FROM_OPTIONS_HOOK', CHUNK_NOT_GENERATED = 'CHUNK_NOT_GENERATED', CHUNK_INVALID = 'CHUNK_INVALID', CIRCULAR_DEPENDENCY = 'CIRCULAR_DEPENDENCY', CIRCULAR_REEXPORT = 'CIRCULAR_REEXPORT', CYCLIC_CROSS_CHUNK_REEXPORT = 'CYCLIC_CROSS_CHUNK_REEXPORT', DEPRECATED_FEATURE = 'DEPRECATED_FEATURE', DUPLICATE_IMPORT_OPTIONS = 'DUPLICATE_IMPORT_OPTIONS', DUPLICATE_PLUGIN_NAME = 'DUPLICATE_PLUGIN_NAME', EMPTY_BUNDLE = 'EMPTY_BUNDLE', EVAL = 'EVAL', EXTERNAL_SYNTHETIC_EXPORTS = 'EXTERNAL_SYNTHETIC_EXPORTS', FAIL_AFTER_WARNINGS = 'FAIL_AFTER_WARNINGS', FILE_NAME_CONFLICT = 'FILE_NAME_CONFLICT', FILE_NOT_FOUND = 'FILE_NOT_FOUND', ILLEGAL_IDENTIFIER_AS_NAME = 'ILLEGAL_IDENTIFIER_AS_NAME', ILLEGAL_REASSIGNMENT = 'ILLEGAL_REASSIGNMENT', INCONSISTENT_IMPORT_ASSERTIONS = 'INCONSISTENT_IMPORT_ASSERTIONS', INPUT_HOOK_IN_OUTPUT_PLUGIN = 'INPUT_HOOK_IN_OUTPUT_PLUGIN', INVALID_CHUNK = 'INVALID_CHUNK', INVALID_CONFIG_MODULE_FORMAT = 'INVALID_CONFIG_MODULE_FORMAT', INVALID_EXPORT_OPTION = 'INVALID_EXPORT_OPTION', INVALID_EXTERNAL_ID = 'INVALID_EXTERNAL_ID', INVALID_OPTION = 'INVALID_OPTION', INVALID_PLUGIN_HOOK = 'INVALID_PLUGIN_HOOK', INVALID_ROLLUP_PHASE = 'INVALID_ROLLUP_PHASE', INVALID_SETASSETSOURCE = 'INVALID_SETASSETSOURCE', INVALID_TLA_FORMAT = 'INVALID_TLA_FORMAT', MISSING_CONFIG = 'MISSING_CONFIG', MISSING_EXPORT = 'MISSING_EXPORT', MISSING_EXTERNAL_CONFIG = 'MISSING_EXTERNAL_CONFIG', MISSING_GLOBAL_NAME = 'MISSING_GLOBAL_NAME', MISSING_IMPLICIT_DEPENDANT = 'MISSING_IMPLICIT_DEPENDANT', MISSING_NAME_OPTION_FOR_IIFE_EXPORT = 'MISSING_NAME_OPTION_FOR_IIFE_EXPORT', MISSING_NODE_BUILTINS = 'MISSING_NODE_BUILTINS', MISSING_OPTION = 'MISSING_OPTION', MIXED_EXPORTS = 'MIXED_EXPORTS', MODULE_LEVEL_DIRECTIVE = 'MODULE_LEVEL_DIRECTIVE', NAMESPACE_CONFLICT = 'NAMESPACE_CONFLICT', NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE = 'NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE', ONLY_INLINE_SOURCEMAPS = 'ONLY_INLINE_SOURCEMAPS', PARSE_ERROR = 'PARSE_ERROR', PLUGIN_ERROR = 'PLUGIN_ERROR', SHIMMED_EXPORT = 'SHIMMED_EXPORT', SOURCEMAP_BROKEN = 'SOURCEMAP_BROKEN', SOURCEMAP_ERROR = 'SOURCEMAP_ERROR', SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT = 'SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT', THIS_IS_UNDEFINED = 'THIS_IS_UNDEFINED', UNEXPECTED_NAMED_IMPORT = 'UNEXPECTED_NAMED_IMPORT', UNKNOWN_OPTION = 'UNKNOWN_OPTION', UNRESOLVED_ENTRY = 'UNRESOLVED_ENTRY', UNRESOLVED_IMPORT = 'UNRESOLVED_IMPORT', UNUSED_EXTERNAL_IMPORT = 'UNUSED_EXTERNAL_IMPORT', VALIDATION_ERROR = 'VALIDATION_ERROR';
-function errorAddonNotGenerated(message, hook, plugin) {
-    return {
-        code: ADDON_ERROR,
-        message: `Could not retrieve "${hook}". Check configuration of plugin "${plugin}".
-\tError Message: ${message}`
-    };
-}
-function errorAlreadyClosed() {
-    return {
-        code: ALREADY_CLOSED,
-        message: 'Bundle is already closed, no more calls to "generate" or "write" are allowed.'
-    };
-}
-function errorAmbiguousExternalNamespaces(binding, reexportingModule, usedModule, sources) {
-    return {
-        binding,
-        code: AMBIGUOUS_EXTERNAL_NAMESPACES,
-        ids: sources,
-        message: `Ambiguous external namespace resolution: "${relativeId(reexportingModule)}" re-exports "${binding}" from one of the external modules ${printQuotedStringList(sources.map(module => relativeId(module)))}, guessing "${relativeId(usedModule)}".`,
-        reexporter: reexportingModule
-    };
-}
-function errorAnonymousPluginCache() {
-    return {
-        code: ANONYMOUS_PLUGIN_CACHE,
-        message: 'A plugin is trying to use the Rollup cache but is not declaring a plugin name or cacheKey.'
-    };
-}
-function errorAssetNotFinalisedForFileName(name) {
-    return {
-        code: ASSET_NOT_FINALISED,
-        message: `Plugin error - Unable to get file name for asset "${name}". Ensure that the source is set and that generate is called first. If you reference assets via import.meta.ROLLUP_FILE_URL_<referenceId>, you need to either have set their source after "renderStart" or need to provide an explicit "fileName" when emitting them.`
-    };
-}
-function errorAssetReferenceIdNotFoundForSetSource(assetReferenceId) {
-    return {
-        code: ASSET_NOT_FOUND,
-        message: `Plugin error - Unable to set the source for unknown asset "${assetReferenceId}".`
-    };
-}
-function errorAssetSourceAlreadySet(name) {
-    return {
-        code: ASSET_SOURCE_ALREADY_SET,
-        message: `Unable to set the source for asset "${name}", source already set.`
-    };
-}
-function errorNoAssetSourceSet(assetName) {
-    return {
-        code: ASSET_SOURCE_MISSING,
-        message: `Plugin error creating asset "${assetName}" - no asset source set.`
-    };
-}
-function errorBadLoader(id) {
+    if (props.frame === undefined) {
+        const { line, column } = props.loc;
+        props.frame = getCodeFrame(source, line, column);
+    }
+}
+var Errors;
+(function (Errors) {
+    Errors["ALREADY_CLOSED"] = "ALREADY_CLOSED";
+    Errors["ASSET_NOT_FINALISED"] = "ASSET_NOT_FINALISED";
+    Errors["ASSET_NOT_FOUND"] = "ASSET_NOT_FOUND";
+    Errors["ASSET_SOURCE_ALREADY_SET"] = "ASSET_SOURCE_ALREADY_SET";
+    Errors["ASSET_SOURCE_MISSING"] = "ASSET_SOURCE_MISSING";
+    Errors["BAD_LOADER"] = "BAD_LOADER";
+    Errors["CANNOT_EMIT_FROM_OPTIONS_HOOK"] = "CANNOT_EMIT_FROM_OPTIONS_HOOK";
+    Errors["CHUNK_NOT_GENERATED"] = "CHUNK_NOT_GENERATED";
+    Errors["CHUNK_INVALID"] = "CHUNK_INVALID";
+    Errors["CIRCULAR_REEXPORT"] = "CIRCULAR_REEXPORT";
+    Errors["CYCLIC_CROSS_CHUNK_REEXPORT"] = "CYCLIC_CROSS_CHUNK_REEXPORT";
+    Errors["DEPRECATED_FEATURE"] = "DEPRECATED_FEATURE";
+    Errors["EXTERNAL_SYNTHETIC_EXPORTS"] = "EXTERNAL_SYNTHETIC_EXPORTS";
+    Errors["FILE_NAME_CONFLICT"] = "FILE_NAME_CONFLICT";
+    Errors["FILE_NOT_FOUND"] = "FILE_NOT_FOUND";
+    Errors["INPUT_HOOK_IN_OUTPUT_PLUGIN"] = "INPUT_HOOK_IN_OUTPUT_PLUGIN";
+    Errors["INVALID_CHUNK"] = "INVALID_CHUNK";
+    Errors["INVALID_EXPORT_OPTION"] = "INVALID_EXPORT_OPTION";
+    Errors["INVALID_EXTERNAL_ID"] = "INVALID_EXTERNAL_ID";
+    Errors["INVALID_OPTION"] = "INVALID_OPTION";
+    Errors["INVALID_PLUGIN_HOOK"] = "INVALID_PLUGIN_HOOK";
+    Errors["INVALID_ROLLUP_PHASE"] = "INVALID_ROLLUP_PHASE";
+    Errors["MISSING_EXPORT"] = "MISSING_EXPORT";
+    Errors["MISSING_IMPLICIT_DEPENDANT"] = "MISSING_IMPLICIT_DEPENDANT";
+    Errors["MIXED_EXPORTS"] = "MIXED_EXPORTS";
+    Errors["NAMESPACE_CONFLICT"] = "NAMESPACE_CONFLICT";
+    Errors["AMBIGUOUS_EXTERNAL_NAMESPACES"] = "AMBIGUOUS_EXTERNAL_NAMESPACES";
+    Errors["NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE"] = "NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE";
+    Errors["PLUGIN_ERROR"] = "PLUGIN_ERROR";
+    Errors["PREFER_NAMED_EXPORTS"] = "PREFER_NAMED_EXPORTS";
+    Errors["SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT"] = "SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT";
+    Errors["UNEXPECTED_NAMED_IMPORT"] = "UNEXPECTED_NAMED_IMPORT";
+    Errors["UNRESOLVED_ENTRY"] = "UNRESOLVED_ENTRY";
+    Errors["UNRESOLVED_IMPORT"] = "UNRESOLVED_IMPORT";
+    Errors["VALIDATION_ERROR"] = "VALIDATION_ERROR";
+})(Errors || (Errors = {}));
+function errAssetNotFinalisedForFileName(name) {
     return {
-        code: BAD_LOADER,
-        message: `Error loading "${relativeId(id)}": plugin load hook should return a string, a { code, map } object, or nothing/null.`
+        code: Errors.ASSET_NOT_FINALISED,
+        message: `Plugin error - Unable to get file name for asset "${name}". Ensure that the source is set and that generate is called first.`
     };
 }
-function errorCannotCallNamespace(name) {
+function errCannotEmitFromOptionsHook() {
     return {
-        code: CANNOT_CALL_NAMESPACE,
-        message: `Cannot call a namespace ("${name}").`
-    };
-}
-function errorCannotEmitFromOptionsHook() {
-    return {
-        code: CANNOT_EMIT_FROM_OPTIONS_HOOK,
+        code: Errors.CANNOT_EMIT_FROM_OPTIONS_HOOK,
         message: `Cannot emit files or set asset sources in the "outputOptions" hook, use the "renderStart" hook instead.`
     };
 }
-function errorChunkNotGeneratedForFileName(name) {
+function errChunkNotGeneratedForFileName(name) {
     return {
-        code: CHUNK_NOT_GENERATED,
-        message: `Plugin error - Unable to get file name for emitted chunk "${name}". You can only get file names once chunks have been generated after the "renderStart" hook.`
+        code: Errors.CHUNK_NOT_GENERATED,
+        message: `Plugin error - Unable to get file name for chunk "${name}". Ensure that generate is called first.`
     };
 }
-function errorChunkInvalid({ fileName, code }, exception) {
-    const errorProperties = {
-        code: CHUNK_INVALID,
+function errChunkInvalid({ fileName, code }, exception) {
+    const errorProps = {
+        code: Errors.CHUNK_INVALID,
         message: `Chunk "${fileName}" is not valid JavaScript: ${exception.message}.`
     };
-    augmentCodeLocation(errorProperties, exception.loc, code, fileName);
-    return errorProperties;
+    augmentCodeLocation(errorProps, exception.loc, code, fileName);
+    return errorProps;
 }
-function errorCircularDependency(cyclePath) {
+function errCircularReexport(exportName, importedModule) {
     return {
-        code: CIRCULAR_DEPENDENCY,
-        ids: cyclePath,
-        message: `Circular dependency: ${cyclePath.map(relativeId).join(' -> ')}`
+        code: Errors.CIRCULAR_REEXPORT,
+        id: importedModule,
+        message: `"${exportName}" cannot be exported from ${relativeId(importedModule)} as it is a reexport that references itself.`
     };
 }
-function errorCircularReexport(exportName, exporter) {
+function errCyclicCrossChunkReexport(exportName, exporter, reexporter, importer) {
     return {
-        code: CIRCULAR_REEXPORT,
+        code: Errors.CYCLIC_CROSS_CHUNK_REEXPORT,
         exporter,
-        message: `"${exportName}" cannot be exported from "${relativeId(exporter)}" as it is a reexport that references itself.`
-    };
-}
-function errorCyclicCrossChunkReexport(exportName, exporter, reexporter, importer) {
-    return {
-        code: CYCLIC_CROSS_CHUNK_REEXPORT,
-        exporter,
-        id: importer,
-        message: `Export "${exportName}" of module "${relativeId(exporter)}" was reexported through module "${relativeId(reexporter)}" while both modules are dependencies of each other and will end up in different chunks by current Rollup settings. This scenario is not well supported at the moment as it will produce a circular dependency between chunks and will likely lead to broken execution order.\nEither change the import in "${relativeId(importer)}" to point directly to the exporting module or do not use "preserveModules" to ensure these modules end up in the same chunk.`,
+        importer,
+        message: `Export "${exportName}" of module ${relativeId(exporter)} was reexported through module ${relativeId(reexporter)} while both modules are dependencies of each other and will end up in different chunks by current Rollup settings. This scenario is not well supported at the moment as it will produce a circular dependency between chunks and will likely lead to broken execution order.\nEither change the import in ${relativeId(importer)} to point directly to the exporting module or do not use "preserveModules" to ensure these modules end up in the same chunk.`,
         reexporter
     };
 }
-function errorDeprecation(deprecation, urlSnippet, plugin) {
-    return {
-        code: DEPRECATED_FEATURE,
-        message: deprecation,
-        url: getRollupUrl(urlSnippet),
-        ...(plugin ? { plugin } : {})
-    };
-}
-function errorDuplicateImportOptions() {
-    return {
-        code: DUPLICATE_IMPORT_OPTIONS,
-        message: 'Either use --input, or pass input path as argument'
-    };
-}
-function errorDuplicatePluginName(plugin) {
-    return {
-        code: DUPLICATE_PLUGIN_NAME,
-        message: `The plugin name ${plugin} is being used twice in the same build. Plugin names must be distinct or provide a cacheKey (please post an issue to the plugin if you are a plugin user).`
-    };
-}
-function errorEmptyChunk(chunkName) {
+function errAssetReferenceIdNotFoundForSetSource(assetReferenceId) {
     return {
-        code: EMPTY_BUNDLE,
-        message: `Generated an empty chunk: "${chunkName}".`,
-        names: [chunkName]
+        code: Errors.ASSET_NOT_FOUND,
+        message: `Plugin error - Unable to set the source for unknown asset "${assetReferenceId}".`
     };
 }
-function errorEval(id) {
+function errAssetSourceAlreadySet(name) {
     return {
-        code: EVAL,
-        id,
-        message: `Use of eval in "${relativeId(id)}" is strongly discouraged as it poses security risks and may cause issues with minification.`,
-        url: getRollupUrl(URL_AVOIDING_EVAL)
+        code: Errors.ASSET_SOURCE_ALREADY_SET,
+        message: `Unable to set the source for asset "${name}", source already set.`
     };
 }
-function errorExternalSyntheticExports(id, importer) {
+function errNoAssetSourceSet(assetName) {
     return {
-        code: EXTERNAL_SYNTHETIC_EXPORTS,
-        exporter: id,
-        message: `External "${id}" cannot have "syntheticNamedExports" enabled (imported by "${relativeId(importer)}").`
+        code: Errors.ASSET_SOURCE_MISSING,
+        message: `Plugin error creating asset "${assetName}" - no asset source set.`
     };
 }
-function errorFailAfterWarnings() {
+function errBadLoader(id) {
     return {
-        code: FAIL_AFTER_WARNINGS,
-        message: 'Warnings occurred and --failAfterWarnings flag present.'
+        code: Errors.BAD_LOADER,
+        message: `Error loading ${relativeId(id)}: plugin load hook should return a string, a { code, map } object, or nothing/null`
     };
 }
-function errorFileNameConflict(fileName) {
+function errDeprecation(deprecation) {
     return {
-        code: FILE_NAME_CONFLICT,
-        message: `The emitted file "${fileName}" overwrites a previously emitted file of the same name.`
+        code: Errors.DEPRECATED_FEATURE,
+        ...(typeof deprecation === 'string' ? { message: deprecation } : deprecation)
     };
 }
-function errorFileReferenceIdNotFoundForFilename(assetReferenceId) {
+function errFileReferenceIdNotFoundForFilename(assetReferenceId) {
     return {
-        code: FILE_NOT_FOUND,
+        code: Errors.FILE_NOT_FOUND,
         message: `Plugin error - Unable to get file name for unknown file "${assetReferenceId}".`
     };
 }
-function errorIllegalIdentifierAsName(name) {
+function errFileNameConflict(fileName) {
     return {
-        code: ILLEGAL_IDENTIFIER_AS_NAME,
-        message: `Given name "${name}" is not a legal JS identifier. If you need this, you can try "output.extend: true".`,
-        url: getRollupUrl(URL_OUTPUT_EXTEND)
-    };
-}
-function errorIllegalImportReassignment(name, importingId) {
-    return {
-        code: ILLEGAL_REASSIGNMENT,
-        message: `Illegal reassignment of import "${name}" in "${relativeId(importingId)}".`
-    };
-}
-function errorInconsistentImportAssertions(existingAssertions, newAssertions, source, importer) {
-    return {
-        code: INCONSISTENT_IMPORT_ASSERTIONS,
-        message: `Module "${relativeId(importer)}" tried to import "${relativeId(source)}" with ${formatAssertions$1(newAssertions)} assertions, but it was already imported elsewhere with ${formatAssertions$1(existingAssertions)} assertions. Please ensure that import assertions for the same module are always consistent.`
+        code: Errors.FILE_NAME_CONFLICT,
+        message: `The emitted file "${fileName}" overwrites a previously emitted file of the same name.`
     };
 }
-const formatAssertions$1 = (assertions) => {
-    const entries = Object.entries(assertions);
-    if (entries.length === 0)
-        return 'no';
-    return entries.map(([key, value]) => `"${key}": "${value}"`).join(', ');
-};
-function errorInputHookInOutputPlugin(pluginName, hookName) {
+function errInputHookInOutputPlugin(pluginName, hookName) {
     return {
-        code: INPUT_HOOK_IN_OUTPUT_PLUGIN,
+        code: Errors.INPUT_HOOK_IN_OUTPUT_PLUGIN,
         message: `The "${hookName}" hook used by the output plugin ${pluginName} is a build time hook and will not be run for that plugin. Either this plugin cannot be used as an output plugin, or it should have an option to configure it as an output plugin.`
     };
 }
-function errorCannotAssignModuleToChunk(moduleId, assignToAlias, currentAlias) {
-    return {
-        code: INVALID_CHUNK,
-        message: `Cannot assign "${relativeId(moduleId)}" to the "${assignToAlias}" chunk as it is already in the "${currentAlias}" chunk.`
-    };
-}
-function errorCannotBundleConfigAsEsm(originalError) {
-    return {
-        cause: originalError,
-        code: INVALID_CONFIG_MODULE_FORMAT,
-        message: `Rollup transpiled your configuration to an  ES module even though it appears to contain CommonJS elements. To resolve this, you can pass the "--bundleConfigAsCjs" flag to Rollup or change your configuration to only contain valid ESM code.\n\nOriginal error: ${originalError.message}`,
-        stack: originalError.stack,
-        url: getRollupUrl(URL_BUNDLE_CONFIG_AS_CJS)
-    };
-}
-function errorCannotLoadConfigAsCjs(originalError) {
-    return {
-        cause: originalError,
-        code: INVALID_CONFIG_MODULE_FORMAT,
-        message: `Node tried to load your configuration file as CommonJS even though it is likely an ES module. To resolve this, change the extension of your configuration to ".mjs", set "type": "module" in your package.json file or pass the "--bundleConfigAsCjs" flag.\n\nOriginal error: ${originalError.message}`,
-        stack: originalError.stack,
-        url: getRollupUrl(URL_BUNDLE_CONFIG_AS_CJS)
-    };
-}
-function errorCannotLoadConfigAsEsm(originalError) {
-    return {
-        cause: originalError,
-        code: INVALID_CONFIG_MODULE_FORMAT,
-        message: `Node tried to load your configuration as an ES module even though it is likely CommonJS. To resolve this, change the extension of your configuration to ".cjs" or pass the "--bundleConfigAsCjs" flag.\n\nOriginal error: ${originalError.message}`,
-        stack: originalError.stack,
-        url: getRollupUrl(URL_BUNDLE_CONFIG_AS_CJS)
-    };
-}
-function errorInvalidExportOptionValue(optionValue) {
-    return {
-        code: INVALID_EXPORT_OPTION,
-        message: `"output.exports" must be "default", "named", "none", "auto", or left unspecified (defaults to "auto"), received "${optionValue}".`,
-        url: getRollupUrl(URL_OUTPUT_EXPORTS)
-    };
-}
-function errorIncompatibleExportOptionValue(optionValue, keys, entryModule) {
+function errCannotAssignModuleToChunk(moduleId, assignToAlias, currentAlias) {
     return {
-        code: INVALID_EXPORT_OPTION,
-        message: `"${optionValue}" was specified for "output.exports", but entry module "${relativeId(entryModule)}" has the following exports: ${printQuotedStringList(keys)}`,
-        url: getRollupUrl(URL_OUTPUT_EXPORTS)
+        code: Errors.INVALID_CHUNK,
+        message: `Cannot assign ${relativeId(moduleId)} to the "${assignToAlias}" chunk as it is already in the "${currentAlias}" chunk.`
     };
 }
-function errorInternalIdCannotBeExternal(source, importer) {
+function errInvalidExportOptionValue(optionValue) {
     return {
-        code: INVALID_EXTERNAL_ID,
-        message: `"${source}" is imported as an external by "${relativeId(importer)}", but is already an existing non-external module id.`
+        code: Errors.INVALID_EXPORT_OPTION,
+        message: `"output.exports" must be "default", "named", "none", "auto", or left unspecified (defaults to "auto"), received "${optionValue}"`,
+        url: `https://rollupjs.org/guide/en/#outputexports`
     };
 }
-function errorInvalidOption(option, urlSnippet, explanation, value) {
+function errIncompatibleExportOptionValue(optionValue, keys, entryModule) {
     return {
-        code: INVALID_OPTION,
-        message: `Invalid value ${value === undefined ? '' : `${JSON.stringify(value)} `}for option "${option}" - ${explanation}.`,
-        url: getRollupUrl(urlSnippet)
+        code: 'INVALID_EXPORT_OPTION',
+        message: `"${optionValue}" was specified for "output.exports", but entry module "${relativeId(entryModule)}" has the following exports: ${keys.join(', ')}`
     };
 }
-function errorInvalidAddonPluginHook(hook, plugin) {
+function errInternalIdCannotBeExternal(source, importer) {
     return {
-        code: INVALID_PLUGIN_HOOK,
-        hook,
-        message: `Error running plugin hook "${hook}" for plugin "${plugin}", expected a string, a function hook or an object with a "handler" string or function.`,
-        plugin
+        code: Errors.INVALID_EXTERNAL_ID,
+        message: `'${source}' is imported as an external by ${relativeId(importer)}, but is already an existing non-external module id.`
     };
 }
-function errorInvalidFunctionPluginHook(hook, plugin) {
+function errInvalidOption(option, urlHash, explanation, value) {
     return {
-        code: INVALID_PLUGIN_HOOK,
-        hook,
-        message: `Error running plugin hook "${hook}" for plugin "${plugin}", expected a function hook or an object with a "handler" function.`,
-        plugin
+        code: Errors.INVALID_OPTION,
+        message: `Invalid value ${value !== undefined ? `${JSON.stringify(value)} ` : ''}for option "${option}" - ${explanation}.`,
+        url: `https://rollupjs.org/guide/en/#${urlHash}`
     };
 }
-function errorInvalidRollupPhaseForAddWatchFile() {
+function errInvalidRollupPhaseForAddWatchFile() {
     return {
-        code: INVALID_ROLLUP_PHASE,
-        message: `Cannot call "addWatchFile" after the build has finished.`
+        code: Errors.INVALID_ROLLUP_PHASE,
+        message: `Cannot call addWatchFile after the build has finished.`
     };
 }
-function errorInvalidRollupPhaseForChunkEmission() {
+function errInvalidRollupPhaseForChunkEmission() {
     return {
-        code: INVALID_ROLLUP_PHASE,
+        code: Errors.INVALID_ROLLUP_PHASE,
         message: `Cannot emit chunks after module loading has finished.`
     };
 }
-function errorInvalidSetAssetSourceCall() {
+function errMissingExport(exportName, importingModule, importedModule) {
     return {
-        code: INVALID_SETASSETSOURCE,
-        message: `setAssetSource cannot be called in transform for caching reasons. Use emitFile with a source, or call setAssetSource in another hook.`
+        code: Errors.MISSING_EXPORT,
+        message: `'${exportName}' is not exported by ${relativeId(importedModule)}, imported by ${relativeId(importingModule)}`,
+        url: `https://rollupjs.org/guide/en/#error-name-is-not-exported-by-module`
     };
 }
-function errorInvalidFormatForTopLevelAwait(id, format) {
+function errImplicitDependantCannotBeExternal(unresolvedId, implicitlyLoadedBefore) {
     return {
-        code: INVALID_TLA_FORMAT,
-        id,
-        message: `Module format "${format}" does not support top-level await. Use the "es" or "system" output formats rather.`
-    };
-}
-function errorMissingConfig() {
-    return {
-        code: MISSING_CONFIG,
-        message: 'Config file must export an options object, or an array of options objects',
-        url: getRollupUrl(URL_CONFIGURATION_FILES)
-    };
-}
-function errorMissingExport(binding, importingModule, exporter) {
-    const isJson = node_path.extname(exporter) === '.json';
-    return {
-        binding,
-        code: MISSING_EXPORT,
-        exporter,
-        id: importingModule,
-        message: `"${binding}" is not exported by "${relativeId(exporter)}", imported by "${relativeId(importingModule)}".${isJson ? ' (Note that you need @rollup/plugin-json to import JSON files)' : ''}`,
-        url: getRollupUrl(URL_NAME_IS_NOT_EXPORTED)
-    };
-}
-function errorMissingExternalConfig(file) {
-    return {
-        code: MISSING_EXTERNAL_CONFIG,
-        message: `Could not resolve config file "${file}"`
-    };
-}
-function errorMissingGlobalName(externalId, guess) {
-    return {
-        code: MISSING_GLOBAL_NAME,
-        id: externalId,
-        message: `No name was provided for external module "${externalId}" in "output.globals" – guessing "${guess}".`,
-        names: [guess],
-        url: getRollupUrl(URL_OUTPUT_GLOBALS)
-    };
-}
-function errorImplicitDependantCannotBeExternal(unresolvedId, implicitlyLoadedBefore) {
-    return {
-        code: MISSING_IMPLICIT_DEPENDANT,
+        code: Errors.MISSING_IMPLICIT_DEPENDANT,
         message: `Module "${relativeId(unresolvedId)}" that should be implicitly loaded before "${relativeId(implicitlyLoadedBefore)}" cannot be external.`
     };
 }
-function errorUnresolvedImplicitDependant(unresolvedId, implicitlyLoadedBefore) {
+function errUnresolvedImplicitDependant(unresolvedId, implicitlyLoadedBefore) {
     return {
-        code: MISSING_IMPLICIT_DEPENDANT,
+        code: Errors.MISSING_IMPLICIT_DEPENDANT,
         message: `Module "${relativeId(unresolvedId)}" that should be implicitly loaded before "${relativeId(implicitlyLoadedBefore)}" could not be resolved.`
     };
 }
-function errorImplicitDependantIsNotIncluded(module) {
-    const implicitDependencies = [...module.implicitlyLoadedBefore]
-        .map(dependency => relativeId(dependency.id))
-        .sort();
+function errImplicitDependantIsNotIncluded(module) {
+    const implicitDependencies = Array.from(module.implicitlyLoadedBefore, dependency => relativeId(dependency.id)).sort();
     return {
-        code: MISSING_IMPLICIT_DEPENDANT,
+        code: Errors.MISSING_IMPLICIT_DEPENDANT,
         message: `Module "${relativeId(module.id)}" that should be implicitly loaded before ${printQuotedStringList(implicitDependencies)} is not included in the module graph. Either it was not imported by an included module or only via a tree-shaken dynamic import, or no imported bindings were used and it had otherwise no side-effects.`
     };
 }
-function errorMissingNameOptionForIifeExport() {
-    return {
-        code: MISSING_NAME_OPTION_FOR_IIFE_EXPORT,
-        message: `If you do not supply "output.name", you may not be able to access the exports of an IIFE bundle.`,
-        url: getRollupUrl(URL_OUTPUT_NAME)
-    };
-}
-function errorMissingNameOptionForUmdExport() {
-    return {
-        code: MISSING_NAME_OPTION_FOR_IIFE_EXPORT,
-        message: 'You must supply "output.name" for UMD bundles that have exports so that the exports are accessible in environments without a module loader.',
-        url: getRollupUrl(URL_OUTPUT_NAME)
-    };
-}
-function errorMissingNodeBuiltins(externalBuiltins) {
-    return {
-        code: MISSING_NODE_BUILTINS,
-        ids: externalBuiltins,
-        message: `Creating a browser bundle that depends on Node.js built-in modules (${printQuotedStringList(externalBuiltins)}). You might need to include https://github.com/FredKSchott/rollup-plugin-polyfill-node`
-    };
-}
-// eslint-disable-next-line unicorn/prevent-abbreviations
-function errorMissingFileOrDirOption() {
+function errMixedExport(facadeModuleId, name) {
     return {
-        code: MISSING_OPTION,
-        message: 'You must specify "output.file" or "output.dir" for the build.',
-        url: getRollupUrl(URL_OUTPUT_DIR)
-    };
-}
-function errorMixedExport(facadeModuleId, name) {
-    return {
-        code: MIXED_EXPORTS,
+        code: Errors.MIXED_EXPORTS,
         id: facadeModuleId,
-        message: `Entry module "${relativeId(facadeModuleId)}" is using named and default exports together. Consumers of your bundle will have to use \`${name || 'chunk'}.default\` to access the default export, which may not be what you want. Use \`output.exports: "named"\` to disable this warning.`,
-        url: getRollupUrl(URL_OUTPUT_EXPORTS)
+        message: `Entry module "${relativeId(facadeModuleId)}" is using named and default exports together. Consumers of your bundle will have to use \`${name || 'chunk'}["default"]\` to access the default export, which may not be what you want. Use \`output.exports: "named"\` to disable this warning`,
+        url: `https://rollupjs.org/guide/en/#outputexports`
     };
 }
-function errorModuleLevelDirective(directive, id) {
+function errNamespaceConflict(name, reexportingModule, additionalExportAllModule) {
     return {
-        code: MODULE_LEVEL_DIRECTIVE,
-        id,
-        message: `Module level directives cause errors when bundled, "${directive}" in "${relativeId(id)}" was ignored.`
+        code: Errors.NAMESPACE_CONFLICT,
+        message: `Conflicting namespaces: "${relativeId(reexportingModule.id)}" re-exports "${name}" from both "${relativeId(reexportingModule.exportsAll[name])}" and "${relativeId(additionalExportAllModule.exportsAll[name])}" (will be ignored)`,
+        name,
+        reexporter: reexportingModule.id,
+        sources: [reexportingModule.exportsAll[name], additionalExportAllModule.exportsAll[name]]
     };
 }
-function errorNamespaceConflict(binding, reexportingModuleId, sources) {
+function errAmbiguousExternalNamespaces(name, reexportingModule, usedExternalModule, externalModules) {
     return {
-        binding,
-        code: NAMESPACE_CONFLICT,
-        ids: sources,
-        message: `Conflicting namespaces: "${relativeId(reexportingModuleId)}" re-exports "${binding}" from one of the modules ${printQuotedStringList(sources.map(moduleId => relativeId(moduleId)))} (will be ignored).`,
-        reexporter: reexportingModuleId
+        code: Errors.AMBIGUOUS_EXTERNAL_NAMESPACES,
+        message: `Ambiguous external namespace resolution: "${relativeId(reexportingModule)}" re-exports "${name}" from one of the external modules ${printQuotedStringList(externalModules.map(module => relativeId(module)))}, guessing "${relativeId(usedExternalModule)}".`,
+        name,
+        reexporter: reexportingModule,
+        sources: externalModules
     };
 }
-function errorNoTransformMapOrAstWithoutCode(pluginName) {
+function errNoTransformMapOrAstWithoutCode(pluginName) {
     return {
-        code: NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE,
+        code: Errors.NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE,
         message: `The plugin "${pluginName}" returned a "map" or "ast" without returning ` +
             'a "code". This will be ignored.'
     };
 }
-function errorOnlyInlineSourcemapsForStdout() {
-    return {
-        code: ONLY_INLINE_SOURCEMAPS,
-        message: 'Only inline sourcemaps are supported when bundling to stdout.'
-    };
-}
-function errorParseError(error, moduleId) {
-    let message = error.message.replace(/ \(\d+:\d+\)$/, '');
-    if (moduleId.endsWith('.json')) {
-        message += ' (Note that you need @rollup/plugin-json to import JSON files)';
-    }
-    else if (!moduleId.endsWith('.js')) {
-        message += ' (Note that you need plugins to import files that are not JavaScript)';
-    }
-    return {
-        cause: error,
-        code: PARSE_ERROR,
-        id: moduleId,
-        message
-    };
-}
-function errorPluginError(error, plugin, { hook, id } = {}) {
-    if (typeof error === 'string')
-        error = { message: error };
-    if (error.code && error.code !== PLUGIN_ERROR) {
-        error.pluginCode = error.code;
-    }
-    error.code = PLUGIN_ERROR;
-    error.plugin = plugin;
-    if (hook) {
-        error.hook = hook;
-    }
-    if (id) {
-        error.id = id;
-    }
-    return error;
-}
-function errorShimmedExport(id, binding) {
-    return {
-        binding,
-        code: SHIMMED_EXPORT,
-        exporter: id,
-        message: `Missing export "${binding}" has been shimmed in module "${relativeId(id)}".`
-    };
-}
-function errorSourcemapBroken(plugin) {
-    return {
-        code: SOURCEMAP_BROKEN,
-        message: `Sourcemap is likely to be incorrect: a plugin (${plugin}) was used to transform files, but didn't generate a sourcemap for the transformation. Consult the plugin documentation for help`,
-        plugin,
-        url: getRollupUrl(URL_SOURCEMAP_IS_LIKELY_TO_BE_INCORRECT)
-    };
-}
-function errorConflictingSourcemapSources(filename) {
+function errPreferNamedExports(facadeModuleId) {
+    const file = relativeId(facadeModuleId);
     return {
-        code: SOURCEMAP_BROKEN,
-        message: `Multiple conflicting contents for sourcemap source ${filename}`
+        code: Errors.PREFER_NAMED_EXPORTS,
+        id: facadeModuleId,
+        message: `Entry module "${file}" is implicitly using "default" export mode, which means for CommonJS output that its default export is assigned to "module.exports". For many tools, such CommonJS output will not be interchangeable with the original ES module. If this is intended, explicitly set "output.exports" to either "auto" or "default", otherwise you might want to consider changing the signature of "${file}" to use named exports only.`,
+        url: `https://rollupjs.org/guide/en/#outputexports`
     };
 }
-function errorInvalidSourcemapForError(error, id, column, line, pos) {
+function errSyntheticNamedExportsNeedNamespaceExport(id, syntheticNamedExportsOption) {
     return {
-        cause: error,
-        code: SOURCEMAP_ERROR,
+        code: Errors.SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT,
         id,
-        loc: {
-            column,
-            file: id,
-            line
-        },
-        message: `Error when using sourcemap for reporting an error: ${error.message}`,
-        pos
-    };
-}
-function errorSyntheticNamedExportsNeedNamespaceExport(id, syntheticNamedExportsOption) {
-    return {
-        code: SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT,
-        exporter: id,
-        message: `Module "${relativeId(id)}" that is marked with \`syntheticNamedExports: ${JSON.stringify(syntheticNamedExportsOption)}\` needs ${typeof syntheticNamedExportsOption === 'string' && syntheticNamedExportsOption !== 'default'
-            ? `an explicit export named "${syntheticNamedExportsOption}"`
+        message: `Module "${relativeId(id)}" that is marked with 'syntheticNamedExports: ${JSON.stringify(syntheticNamedExportsOption)}' needs ${typeof syntheticNamedExportsOption === 'string' && syntheticNamedExportsOption !== 'default'
+            ? `an export named "${syntheticNamedExportsOption}"`
             : 'a default export'} that does not reexport an unresolved named export of the same module.`
     };
 }
-function errorThisIsUndefined() {
-    return {
-        code: THIS_IS_UNDEFINED,
-        message: `The 'this' keyword is equivalent to 'undefined' at the top level of an ES module, and has been rewritten`,
-        url: getRollupUrl(URL_THIS_IS_UNDEFINED)
-    };
-}
-function errorUnexpectedNamedImport(id, imported, isReexport) {
+function errUnexpectedNamedImport(id, imported, isReexport) {
     const importType = isReexport ? 'reexport' : 'import';
     return {
-        code: UNEXPECTED_NAMED_IMPORT,
-        exporter: id,
-        message: `The named export "${imported}" was ${importType}ed from the external module "${relativeId(id)}" even though its interop type is "defaultOnly". Either remove or change this ${importType} or change the value of the "output.interop" option.`,
-        url: getRollupUrl(URL_OUTPUT_INTEROP)
+        code: Errors.UNEXPECTED_NAMED_IMPORT,
+        id,
+        message: `The named export "${imported}" was ${importType}ed from the external module ${relativeId(id)} even though its interop type is "defaultOnly". Either remove or change this ${importType} or change the value of the "output.interop" option.`,
+        url: 'https://rollupjs.org/guide/en/#outputinterop'
     };
 }
-function errorUnexpectedNamespaceReexport(id) {
+function errUnexpectedNamespaceReexport(id) {
     return {
-        code: UNEXPECTED_NAMED_IMPORT,
-        exporter: id,
-        message: `There was a namespace "*" reexport from the external module "${relativeId(id)}" even though its interop type is "defaultOnly". This will be ignored as namespace reexports only reexport named exports. If this is not intended, either remove or change this reexport or change the value of the "output.interop" option.`,
-        url: getRollupUrl(URL_OUTPUT_INTEROP)
+        code: Errors.UNEXPECTED_NAMED_IMPORT,
+        id,
+        message: `There was a namespace "*" reexport from the external module ${relativeId(id)} even though its interop type is "defaultOnly". This will be ignored as namespace reexports only reexport named exports. If this is not intended, either remove or change this reexport or change the value of the "output.interop" option.`,
+        url: 'https://rollupjs.org/guide/en/#outputinterop'
     };
 }
-function errorUnknownOption(optionType, unknownOptions, validOptions) {
+function errEntryCannotBeExternal(unresolvedId) {
     return {
-        code: UNKNOWN_OPTION,
-        message: `Unknown ${optionType}: ${unknownOptions.join(', ')}. Allowed options: ${validOptions.join(', ')}`
+        code: Errors.UNRESOLVED_ENTRY,
+        message: `Entry module cannot be external (${relativeId(unresolvedId)}).`
     };
 }
-function errorEntryCannotBeExternal(unresolvedId) {
+function errUnresolvedEntry(unresolvedId) {
     return {
-        code: UNRESOLVED_ENTRY,
-        message: `Entry module "${relativeId(unresolvedId)}" cannot be external.`
+        code: Errors.UNRESOLVED_ENTRY,
+        message: `Could not resolve entry module (${relativeId(unresolvedId)}).`
     };
 }
-function errorUnresolvedEntry(unresolvedId) {
+function errUnresolvedImport(source, importer) {
     return {
-        code: UNRESOLVED_ENTRY,
-        message: `Could not resolve entry module "${relativeId(unresolvedId)}".`
+        code: Errors.UNRESOLVED_IMPORT,
+        message: `Could not resolve '${source}' from ${relativeId(importer)}`
     };
 }
-function errorUnresolvedImport(source, importer) {
+function errUnresolvedImportTreatedAsExternal(source, importer) {
     return {
-        code: UNRESOLVED_IMPORT,
-        exporter: source,
-        id: importer,
-        message: `Could not resolve "${source}" from "${relativeId(importer)}"`
+        code: Errors.UNRESOLVED_IMPORT,
+        importer: relativeId(importer),
+        message: `'${source}' is imported by ${relativeId(importer)}, but could not be resolved – treating it as an external dependency`,
+        source,
+        url: 'https://rollupjs.org/guide/en/#warning-treating-module-as-external-dependency'
     };
 }
-function errorUnresolvedImportTreatedAsExternal(source, importer) {
+function errExternalSyntheticExports(source, importer) {
     return {
-        code: UNRESOLVED_IMPORT,
-        exporter: source,
-        id: importer,
-        message: `"${source}" is imported by "${relativeId(importer)}", but could not be resolved – treating it as an external dependency.`,
-        url: getRollupUrl(URL_TREATING_MODULE_AS_EXTERNAL_DEPENDENCY)
+        code: Errors.EXTERNAL_SYNTHETIC_EXPORTS,
+        importer: relativeId(importer),
+        message: `External '${source}' can not have 'syntheticNamedExports' enabled.`,
+        source
     };
 }
-function errorUnusedExternalImports(externalId, names, importers) {
+function errFailedValidation(message) {
     return {
-        code: UNUSED_EXTERNAL_IMPORT,
-        exporter: externalId,
-        ids: importers,
-        message: `${printQuotedStringList(names, [
-            'is',
-            'are'
-        ])} imported from external module "${externalId}" but never used in ${printQuotedStringList(importers.map(importer => relativeId(importer)))}.`,
-        names
+        code: Errors.VALIDATION_ERROR,
+        message
     };
 }
-function errorFailedValidation(message) {
+function errAlreadyClosed() {
     return {
-        code: VALIDATION_ERROR,
-        message
+        code: Errors.ALREADY_CLOSED,
+        message: 'Bundle is already closed, no more calls to "generate" or "write" are allowed.'
     };
 }
-function warnDeprecation(deprecation, urlSnippet, activeDeprecation, options, plugin) {
-    warnDeprecationWithOptions(deprecation, urlSnippet, activeDeprecation, options.onwarn, options.strictDeprecations, plugin);
+function warnDeprecation(deprecation, activeDeprecation, options) {
+    warnDeprecationWithOptions(deprecation, activeDeprecation, options.onwarn, options.strictDeprecations);
 }
-function warnDeprecationWithOptions(deprecation, urlSnippet, activeDeprecation, warn, strictDeprecations, plugin) {
+function warnDeprecationWithOptions(deprecation, activeDeprecation, warn, strictDeprecations) {
     if (activeDeprecation || strictDeprecations) {
-        const warning = errorDeprecation(deprecation, urlSnippet, plugin);
+        const warning = errDeprecation(deprecation);
         if (strictDeprecations) {
             return error(warning);
         }
@@ -870,14 +504,20 @@
     const validOptionSet = new Set(validOptions);
     const unknownOptions = Object.keys(passedOptions).filter(key => !(validOptionSet.has(key) || ignoredKeys.test(key)));
     if (unknownOptions.length > 0) {
-        warn(errorUnknownOption(optionType, unknownOptions, [...validOptionSet].sort()));
+        warn({
+            code: 'UNKNOWN_OPTION',
+            message: `Unknown ${optionType}: ${unknownOptions.join(', ')}. Allowed options: ${[
+                ...validOptionSet
+            ]
+                .sort()
+                .join(', ')}`
+        });
     }
 }
 const treeshakePresets = {
     recommended: {
         annotations: true,
         correctVarValueBeforeDeclaration: false,
-        manualPureFunctions: EMPTY_ARRAY,
         moduleSideEffects: () => true,
         propertyReadSideEffects: true,
         tryCatchDeoptimization: true,
@@ -886,7 +526,6 @@
     safest: {
         annotations: true,
         correctVarValueBeforeDeclaration: true,
-        manualPureFunctions: EMPTY_ARRAY,
         moduleSideEffects: () => true,
         propertyReadSideEffects: true,
         tryCatchDeoptimization: true,
@@ -895,7 +534,6 @@
     smallest: {
         annotations: true,
         correctVarValueBeforeDeclaration: false,
-        manualPureFunctions: EMPTY_ARRAY,
         moduleSideEffects: () => false,
         propertyReadSideEffects: false,
         tryCatchDeoptimization: false,
@@ -907,230 +545,52 @@
         arrowFunctions: true,
         constBindings: true,
         objectShorthand: true,
-        reservedNamesAsProps: true,
-        symbols: true
+        reservedNamesAsProps: true
     },
     es5: {
         arrowFunctions: false,
         constBindings: false,
         objectShorthand: false,
-        reservedNamesAsProps: true,
-        symbols: false
+        reservedNamesAsProps: true
     }
 };
-const objectifyOption = (value) => value && typeof value === 'object' ? value : {};
-const objectifyOptionWithPresets = (presets, optionName, urlSnippet, additionalValues) => (value) => {
+const objectifyOptionWithPresets = (presets, optionName, additionalValues) => (value) => {
     if (typeof value === 'string') {
         const preset = presets[value];
         if (preset) {
             return preset;
         }
-        error(errorInvalidOption(optionName, urlSnippet, `valid values are ${additionalValues}${printQuotedStringList(Object.keys(presets))}. You can also supply an object for more fine-grained control`, value));
+        error(errInvalidOption(optionName, getHashFromObjectOption(optionName), `valid values are ${additionalValues}${printQuotedStringList(Object.keys(presets))}. You can also supply an object for more fine-grained control`, value));
     }
-    return objectifyOption(value);
+    return value && typeof value === 'object' ? value : {};
 };
-const getOptionWithPreset = (value, presets, optionName, urlSnippet, additionalValues) => {
-    const presetName = value?.preset;
+const getOptionWithPreset = (value, presets, optionName, additionalValues) => {
+    var _a;
+    const presetName = (_a = value) === null || _a === void 0 ? void 0 : _a.preset;
     if (presetName) {
         const preset = presets[presetName];
         if (preset) {
             return { ...preset, ...value };
         }
         else {
-            error(errorInvalidOption(`${optionName}.preset`, urlSnippet, `valid values are ${printQuotedStringList(Object.keys(presets))}`, presetName));
+            error(errInvalidOption(`${optionName}.preset`, getHashFromObjectOption(optionName), `valid values are ${printQuotedStringList(Object.keys(presets))}`, presetName));
         }
     }
-    return objectifyOptionWithPresets(presets, optionName, urlSnippet, additionalValues)(value);
-};
-const normalizePluginOption = async (plugins) => (await asyncFlatten([plugins])).filter(Boolean);
-
-const commandAliases = {
-    c: 'config',
-    d: 'dir',
-    e: 'external',
-    f: 'format',
-    g: 'globals',
-    h: 'help',
-    i: 'input',
-    m: 'sourcemap',
-    n: 'name',
-    o: 'file',
-    p: 'plugin',
-    v: 'version',
-    w: 'watch'
-};
-const EMPTY_COMMAND_OPTIONS = { external: [], globals: undefined };
-async function mergeOptions(config, rawCommandOptions = EMPTY_COMMAND_OPTIONS, defaultOnWarnHandler = defaultOnWarn) {
-    const command = getCommandOptions(rawCommandOptions);
-    const inputOptions = await mergeInputOptions(config, command, defaultOnWarnHandler);
-    const warn = inputOptions.onwarn;
-    if (command.output) {
-        Object.assign(command, command.output);
-    }
-    const outputOptionsArray = ensureArray$1(config.output);
-    if (outputOptionsArray.length === 0)
-        outputOptionsArray.push({});
-    const outputOptions = await Promise.all(outputOptionsArray.map(singleOutputOptions => mergeOutputOptions(singleOutputOptions, command, warn)));
-    warnUnknownOptions(command, [
-        ...Object.keys(inputOptions),
-        ...Object.keys(outputOptions[0]).filter(option => option !== 'sourcemapPathTransform'),
-        ...Object.keys(commandAliases),
-        'bundleConfigAsCjs',
-        'config',
-        'environment',
-        'plugin',
-        'silent',
-        'failAfterWarnings',
-        'stdin',
-        'waitForBundleInput',
-        'configPlugin'
-    ], 'CLI flags', warn, /^_$|output$|config/);
-    inputOptions.output = outputOptions;
-    return inputOptions;
-}
-function getCommandOptions(rawCommandOptions) {
-    const external = rawCommandOptions.external && typeof rawCommandOptions.external === 'string'
-        ? rawCommandOptions.external.split(',')
-        : [];
-    return {
-        ...rawCommandOptions,
-        external,
-        globals: typeof rawCommandOptions.globals === 'string'
-            ? rawCommandOptions.globals.split(',').reduce((globals, globalDefinition) => {
-                const [id, variableName] = globalDefinition.split(':');
-                globals[id] = variableName;
-                if (!external.includes(id)) {
-                    external.push(id);
-                }
-                return globals;
-            }, Object.create(null))
-            : undefined
-    };
-}
-async function mergeInputOptions(config, overrides, defaultOnWarnHandler) {
-    const getOption = (name) => overrides[name] ?? config[name];
-    const inputOptions = {
-        acorn: getOption('acorn'),
-        acornInjectPlugins: config.acornInjectPlugins,
-        cache: config.cache,
-        context: getOption('context'),
-        experimentalCacheExpiry: getOption('experimentalCacheExpiry'),
-        external: getExternal(config, overrides),
-        inlineDynamicImports: getOption('inlineDynamicImports'),
-        input: getOption('input') || [],
-        makeAbsoluteExternalsRelative: getOption('makeAbsoluteExternalsRelative'),
-        manualChunks: getOption('manualChunks'),
-        maxParallelFileOps: getOption('maxParallelFileOps'),
-        maxParallelFileReads: getOption('maxParallelFileReads'),
-        moduleContext: getOption('moduleContext'),
-        onwarn: getOnWarn(config, defaultOnWarnHandler),
-        perf: getOption('perf'),
-        plugins: await normalizePluginOption(config.plugins),
-        preserveEntrySignatures: getOption('preserveEntrySignatures'),
-        preserveModules: getOption('preserveModules'),
-        preserveSymlinks: getOption('preserveSymlinks'),
-        shimMissingExports: getOption('shimMissingExports'),
-        strictDeprecations: getOption('strictDeprecations'),
-        treeshake: getObjectOption(config, overrides, 'treeshake', objectifyOptionWithPresets(treeshakePresets, 'treeshake', URL_TREESHAKE, 'false, true, ')),
-        watch: getWatch(config, overrides)
-    };
-    warnUnknownOptions(config, Object.keys(inputOptions), 'input options', inputOptions.onwarn, /^output$/);
-    return inputOptions;
-}
-const getExternal = (config, overrides) => {
-    const configExternal = config.external;
-    return typeof configExternal === 'function'
-        ? (source, importer, isResolved) => configExternal(source, importer, isResolved) || overrides.external.includes(source)
-        : [...ensureArray$1(configExternal), ...overrides.external];
-};
-const getOnWarn = (config, defaultOnWarnHandler) => config.onwarn ? warning => config.onwarn(warning, defaultOnWarnHandler) : defaultOnWarnHandler;
-const getObjectOption = (config, overrides, name, objectifyValue = objectifyOption) => {
-    const commandOption = normalizeObjectOptionValue(overrides[name], objectifyValue);
-    const configOption = normalizeObjectOptionValue(config[name], objectifyValue);
-    if (commandOption !== undefined) {
-        return commandOption && { ...configOption, ...commandOption };
-    }
-    return configOption;
-};
-const getWatch = (config, overrides) => config.watch !== false && getObjectOption(config, overrides, 'watch');
-const isWatchEnabled = (optionValue) => {
-    if (Array.isArray(optionValue)) {
-        return optionValue.reduce((result, value) => (typeof value === 'boolean' ? value : result), false);
-    }
-    return optionValue === true;
-};
-const normalizeObjectOptionValue = (optionValue, objectifyValue) => {
-    if (!optionValue) {
-        return optionValue;
-    }
-    if (Array.isArray(optionValue)) {
-        return optionValue.reduce((result, value) => value && result && { ...result, ...objectifyValue(value) }, {});
-    }
-    return objectifyValue(optionValue);
+    return objectifyOptionWithPresets(presets, optionName, additionalValues)(value);
 };
-async function mergeOutputOptions(config, overrides, warn) {
-    const getOption = (name) => overrides[name] ?? config[name];
-    const outputOptions = {
-        amd: getObjectOption(config, overrides, 'amd'),
-        assetFileNames: getOption('assetFileNames'),
-        banner: getOption('banner'),
-        chunkFileNames: getOption('chunkFileNames'),
-        compact: getOption('compact'),
-        dir: getOption('dir'),
-        dynamicImportFunction: getOption('dynamicImportFunction'),
-        dynamicImportInCjs: getOption('dynamicImportInCjs'),
-        entryFileNames: getOption('entryFileNames'),
-        esModule: getOption('esModule'),
-        experimentalMinChunkSize: getOption('experimentalMinChunkSize'),
-        exports: getOption('exports'),
-        extend: getOption('extend'),
-        externalImportAssertions: getOption('externalImportAssertions'),
-        externalLiveBindings: getOption('externalLiveBindings'),
-        file: getOption('file'),
-        footer: getOption('footer'),
-        format: getOption('format'),
-        freeze: getOption('freeze'),
-        generatedCode: getObjectOption(config, overrides, 'generatedCode', objectifyOptionWithPresets(generatedCodePresets, 'output.generatedCode', URL_OUTPUT_GENERATEDCODE, '')),
-        globals: getOption('globals'),
-        hoistTransitiveImports: getOption('hoistTransitiveImports'),
-        indent: getOption('indent'),
-        inlineDynamicImports: getOption('inlineDynamicImports'),
-        interop: getOption('interop'),
-        intro: getOption('intro'),
-        manualChunks: getOption('manualChunks'),
-        minifyInternalExports: getOption('minifyInternalExports'),
-        name: getOption('name'),
-        namespaceToStringTag: getOption('namespaceToStringTag'),
-        noConflict: getOption('noConflict'),
-        outro: getOption('outro'),
-        paths: getOption('paths'),
-        plugins: await normalizePluginOption(config.plugins),
-        preferConst: getOption('preferConst'),
-        preserveModules: getOption('preserveModules'),
-        preserveModulesRoot: getOption('preserveModulesRoot'),
-        sanitizeFileName: getOption('sanitizeFileName'),
-        sourcemap: getOption('sourcemap'),
-        sourcemapBaseUrl: getOption('sourcemapBaseUrl'),
-        sourcemapExcludeSources: getOption('sourcemapExcludeSources'),
-        sourcemapFile: getOption('sourcemapFile'),
-        sourcemapPathTransform: getOption('sourcemapPathTransform'),
-        strict: getOption('strict'),
-        systemNullSetters: getOption('systemNullSetters'),
-        validate: getOption('validate')
-    };
-    warnUnknownOptions(config, Object.keys(outputOptions), 'output options', warn);
-    return outputOptions;
-}
+const getHashFromObjectOption = (optionName) => optionName.split('.').join('').toLowerCase();
 
 let fsEvents;
 let fsEventsImportError;
-async function loadFsEvents() {
-    try {
-        ({ default: fsEvents } = await import('fsevents'));
-    }
-    catch (error) {
-        fsEventsImportError = error;
-    }
+function loadFsEvents() {
+    const moduleName = 'fsevents';
+    return Promise.resolve().then(() => /*#__PURE__*/_interopNamespaceDefault(require(moduleName)))
+        .then(namespace => {
+        fsEvents = namespace.default;
+    })
+        .catch(err => {
+        fsEventsImportError = err;
+    });
 }
 // A call to this function will be injected into the chokidar code
 function getFsEvents() {
@@ -1139,523 +599,349 @@
     return fsEvents;
 }
 
-const fseventsImporter = /*#__PURE__*/Object.defineProperty({
+const fseventsImporter = {
   __proto__: null,
-  getFsEvents,
-  loadFsEvents
-}, Symbol.toStringTag, { value: 'Module' });
-
-const {
-  env = {},
-  argv = [],
-  platform = "",
-} = typeof process === "undefined" ? {} : process;
-
-const isDisabled = "NO_COLOR" in env || argv.includes("--no-color");
-const isForced = "FORCE_COLOR" in env || argv.includes("--color");
-const isWindows = platform === "win32";
-const isDumbTerminal = env.TERM === "dumb";
-
-const isCompatibleTerminal =
-  tty__namespace && tty__namespace.isatty && tty__namespace.isatty(1) && env.TERM && !isDumbTerminal;
-
-const isCI =
-  "CI" in env &&
-  ("GITHUB_ACTIONS" in env || "GITLAB_CI" in env || "CIRCLECI" in env);
-
-const isColorSupported =
-  !isDisabled &&
-  (isForced || (isWindows && !isDumbTerminal) || isCompatibleTerminal || isCI);
-
-const replaceClose = (
-  index,
-  string,
-  close,
-  replace,
-  head = string.substring(0, index) + replace,
-  tail = string.substring(index + close.length),
-  next = tail.indexOf(close)
-) => head + (next < 0 ? tail : replaceClose(next, tail, close, replace));
-
-const clearBleed = (index, string, open, close, replace) =>
-  index < 0
-    ? open + string + close
-    : open + replaceClose(index, string, close, replace) + close;
-
-const filterEmpty =
-  (open, close, replace = open, at = open.length + 1) =>
-  (string) =>
-    string || !(string === "" || string === undefined)
-      ? clearBleed(
-          ("" + string).indexOf(close, at),
-          string,
-          open,
-          close,
-          replace
-        )
-      : "";
-
-const init = (open, close, replace) =>
-  filterEmpty(`\x1b[${open}m`, `\x1b[${close}m`, replace);
-
-const colors = {
-  reset: init(0, 0),
-  bold: init(1, 22, "\x1b[22m\x1b[1m"),
-  dim: init(2, 22, "\x1b[22m\x1b[2m"),
-  italic: init(3, 23),
-  underline: init(4, 24),
-  inverse: init(7, 27),
-  hidden: init(8, 28),
-  strikethrough: init(9, 29),
-  black: init(30, 39),
-  red: init(31, 39),
-  green: init(32, 39),
-  yellow: init(33, 39),
-  blue: init(34, 39),
-  magenta: init(35, 39),
-  cyan: init(36, 39),
-  white: init(37, 39),
-  gray: init(90, 39),
-  bgBlack: init(40, 49),
-  bgRed: init(41, 49),
-  bgGreen: init(42, 49),
-  bgYellow: init(43, 49),
-  bgBlue: init(44, 49),
-  bgMagenta: init(45, 49),
-  bgCyan: init(46, 49),
-  bgWhite: init(47, 49),
-  blackBright: init(90, 39),
-  redBright: init(91, 39),
-  greenBright: init(92, 39),
-  yellowBright: init(93, 39),
-  blueBright: init(94, 39),
-  magentaBright: init(95, 39),
-  cyanBright: init(96, 39),
-  whiteBright: init(97, 39),
-  bgBlackBright: init(100, 49),
-  bgRedBright: init(101, 49),
-  bgGreenBright: init(102, 49),
-  bgYellowBright: init(103, 49),
-  bgBlueBright: init(104, 49),
-  bgMagentaBright: init(105, 49),
-  bgCyanBright: init(106, 49),
-  bgWhiteBright: init(107, 49),
-};
-
-const createColors = ({ useColor = isColorSupported } = {}) =>
-  useColor
-    ? colors
-    : Object.keys(colors).reduce(
-        (colors, key) => ({ ...colors, [key]: String }),
-        {}
-      );
+  loadFsEvents,
+  getFsEvents
+};
 
-createColors();
+var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
 
-// @see https://no-color.org
-// @see https://www.npmjs.com/package/chalk
-const { bold, cyan, dim, gray, green, red, underline, yellow } = createColors({
-    useColor: process$1.env.FORCE_COLOR !== '0' && !process$1.env.NO_COLOR
-});
+function getAugmentedNamespace(n) {
+	if (n.__esModule) return n;
+	var a = Object.defineProperty({}, '__esModule', {value: true});
+	Object.keys(n).forEach(function (k) {
+		var d = Object.getOwnPropertyDescriptor(n, k);
+		Object.defineProperty(a, k, d.get ? d : {
+			enumerable: true,
+			get: function () {
+				return n[k];
+			}
+		});
+	});
+	return a;
+}
 
-// log to stderr to keep `rollup main.js > bundle.js` from breaking
-const stderr = (...parameters) => process$1.stderr.write(`${parameters.join('')}\n`);
-function handleError(error, recover = false) {
-    const name = error.name || error.cause?.name;
-    const nameSection = name ? `${name}: ` : '';
-    const pluginSection = error.plugin ? `(plugin ${error.plugin}) ` : '';
-    const message = `${pluginSection}${nameSection}${error.message}`;
-    const outputLines = [bold(red(`[!] ${bold(message.toString())}`))];
-    if (error.url) {
-        outputLines.push(cyan(error.url));
-    }
-    if (error.loc) {
-        outputLines.push(`${relativeId((error.loc.file || error.id))} (${error.loc.line}:${error.loc.column})`);
-    }
-    else if (error.id) {
-        outputLines.push(relativeId(error.id));
-    }
-    if (error.frame) {
-        outputLines.push(dim(error.frame));
-    }
-    if (error.stack) {
-        outputLines.push(dim(error.stack?.replace(`${nameSection}${error.message}\n`, '')));
-    }
-    outputLines.push('', '');
-    stderr(outputLines.join('\n'));
-    // eslint-disable-next-line unicorn/no-process-exit
-    if (!recover)
-        process$1.exit(1);
-}
-
-const comma = ','.charCodeAt(0);
-const semicolon = ';'.charCodeAt(0);
-const chars$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
-const intToChar = new Uint8Array(64); // 64 possible chars.
-const charToInt = new Uint8Array(128); // z is 122 in ASCII
-for (let i = 0; i < chars$1.length; i++) {
-    const c = chars$1.charCodeAt(i);
-    intToChar[i] = c;
-    charToInt[c] = i;
-}
-// Provide a fallback for older environments.
-const td = typeof TextDecoder !== 'undefined'
-    ? /* #__PURE__ */ new TextDecoder()
-    : typeof Buffer !== 'undefined'
-        ? {
-            decode(buf) {
-                const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
-                return out.toString();
-            },
-        }
-        : {
-            decode(buf) {
-                let out = '';
-                for (let i = 0; i < buf.length; i++) {
-                    out += String.fromCharCode(buf[i]);
-                }
-                return out;
-            },
-        };
+var charToInteger = {};
+var chars$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
+for (var i = 0; i < chars$1.length; i++) {
+    charToInteger[chars$1.charCodeAt(i)] = i;
+}
 function decode(mappings) {
-    const state = new Int32Array(5);
-    const decoded = [];
-    let index = 0;
-    do {
-        const semi = indexOf(mappings, index);
-        const line = [];
-        let sorted = true;
-        let lastCol = 0;
-        state[0] = 0;
-        for (let i = index; i < semi; i++) {
-            let seg;
-            i = decodeInteger(mappings, i, state, 0); // genColumn
-            const col = state[0];
-            if (col < lastCol)
-                sorted = false;
-            lastCol = col;
-            if (hasMoreVlq(mappings, i, semi)) {
-                i = decodeInteger(mappings, i, state, 1); // sourcesIndex
-                i = decodeInteger(mappings, i, state, 2); // sourceLine
-                i = decodeInteger(mappings, i, state, 3); // sourceColumn
-                if (hasMoreVlq(mappings, i, semi)) {
-                    i = decodeInteger(mappings, i, state, 4); // namesIndex
-                    seg = [col, state[1], state[2], state[3], state[4]];
-                }
-                else {
-                    seg = [col, state[1], state[2], state[3]];
-                }
+    var decoded = [];
+    var line = [];
+    var segment = [
+        0,
+        0,
+        0,
+        0,
+        0,
+    ];
+    var j = 0;
+    for (var i = 0, shift = 0, value = 0; i < mappings.length; i++) {
+        var c = mappings.charCodeAt(i);
+        if (c === 44) { // ","
+            segmentify(line, segment, j);
+            j = 0;
+        }
+        else if (c === 59) { // ";"
+            segmentify(line, segment, j);
+            j = 0;
+            decoded.push(line);
+            line = [];
+            segment[0] = 0;
+        }
+        else {
+            var integer = charToInteger[c];
+            if (integer === undefined) {
+                throw new Error('Invalid character (' + String.fromCharCode(c) + ')');
+            }
+            var hasContinuationBit = integer & 32;
+            integer &= 31;
+            value += integer << shift;
+            if (hasContinuationBit) {
+                shift += 5;
             }
             else {
-                seg = [col];
+                var shouldNegate = value & 1;
+                value >>>= 1;
+                if (shouldNegate) {
+                    value = value === 0 ? -0x80000000 : -value;
+                }
+                segment[j] += value;
+                j++;
+                value = shift = 0; // reset
             }
-            line.push(seg);
         }
-        if (!sorted)
-            sort(line);
-        decoded.push(line);
-        index = semi + 1;
-    } while (index <= mappings.length);
-    return decoded;
-}
-function indexOf(mappings, index) {
-    const idx = mappings.indexOf(';', index);
-    return idx === -1 ? mappings.length : idx;
-}
-function decodeInteger(mappings, pos, state, j) {
-    let value = 0;
-    let shift = 0;
-    let integer = 0;
-    do {
-        const c = mappings.charCodeAt(pos++);
-        integer = charToInt[c];
-        value |= (integer & 31) << shift;
-        shift += 5;
-    } while (integer & 32);
-    const shouldNegate = value & 1;
-    value >>>= 1;
-    if (shouldNegate) {
-        value = -0x80000000 | -value;
     }
-    state[j] += value;
-    return pos;
-}
-function hasMoreVlq(mappings, i, length) {
-    if (i >= length)
-        return false;
-    return mappings.charCodeAt(i) !== comma;
-}
-function sort(line) {
-    line.sort(sortComparator);
+    segmentify(line, segment, j);
+    decoded.push(line);
+    return decoded;
 }
-function sortComparator(a, b) {
-    return a[0] - b[0];
+function segmentify(line, segment, j) {
+    // This looks ugly, but we're creating specialized arrays with a specific
+    // length. This is much faster than creating a new array (which v8 expands to
+    // a capacity of 17 after pushing the first item), or slicing out a subarray
+    // (which is slow). Length 4 is assumed to be the most frequent, followed by
+    // length 5 (since not everything will have an associated name), followed by
+    // length 1 (it's probably rare for a source substring to not have an
+    // associated segment data).
+    if (j === 4)
+        line.push([segment[0], segment[1], segment[2], segment[3]]);
+    else if (j === 5)
+        line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);
+    else if (j === 1)
+        line.push([segment[0]]);
 }
 function encode(decoded) {
-    const state = new Int32Array(5);
-    const bufLength = 1024 * 16;
-    const subLength = bufLength - 36;
-    const buf = new Uint8Array(bufLength);
-    const sub = buf.subarray(0, subLength);
-    let pos = 0;
-    let out = '';
-    for (let i = 0; i < decoded.length; i++) {
-        const line = decoded[i];
-        if (i > 0) {
-            if (pos === bufLength) {
-                out += td.decode(buf);
-                pos = 0;
-            }
-            buf[pos++] = semicolon;
-        }
+    var sourceFileIndex = 0; // second field
+    var sourceCodeLine = 0; // third field
+    var sourceCodeColumn = 0; // fourth field
+    var nameIndex = 0; // fifth field
+    var mappings = '';
+    for (var i = 0; i < decoded.length; i++) {
+        var line = decoded[i];
+        if (i > 0)
+            mappings += ';';
         if (line.length === 0)
             continue;
-        state[0] = 0;
-        for (let j = 0; j < line.length; j++) {
-            const segment = line[j];
-            // We can push up to 5 ints, each int can take at most 7 chars, and we
-            // may push a comma.
-            if (pos > subLength) {
-                out += td.decode(sub);
-                buf.copyWithin(0, subLength, pos);
-                pos -= subLength;
-            }
-            if (j > 0)
-                buf[pos++] = comma;
-            pos = encodeInteger(buf, pos, state, segment, 0); // genColumn
-            if (segment.length === 1)
-                continue;
-            pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex
-            pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine
-            pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn
-            if (segment.length === 4)
-                continue;
-            pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex
+        var generatedCodeColumn = 0; // first field
+        var lineMappings = [];
+        for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {
+            var segment = line_1[_i];
+            var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);
+            generatedCodeColumn = segment[0];
+            if (segment.length > 1) {
+                segmentMappings +=
+                    encodeInteger(segment[1] - sourceFileIndex) +
+                        encodeInteger(segment[2] - sourceCodeLine) +
+                        encodeInteger(segment[3] - sourceCodeColumn);
+                sourceFileIndex = segment[1];
+                sourceCodeLine = segment[2];
+                sourceCodeColumn = segment[3];
+            }
+            if (segment.length === 5) {
+                segmentMappings += encodeInteger(segment[4] - nameIndex);
+                nameIndex = segment[4];
+            }
+            lineMappings.push(segmentMappings);
         }
+        mappings += lineMappings.join(',');
     }
-    return out + td.decode(buf.subarray(0, pos));
+    return mappings;
 }
-function encodeInteger(buf, pos, state, segment, j) {
-    const next = segment[j];
-    let num = next - state[j];
-    state[j] = next;
+function encodeInteger(num) {
+    var result = '';
     num = num < 0 ? (-num << 1) | 1 : num << 1;
     do {
-        let clamped = num & 0b011111;
+        var clamped = num & 31;
         num >>>= 5;
-        if (num > 0)
-            clamped |= 0b100000;
-        buf[pos++] = intToChar[clamped];
+        if (num > 0) {
+            clamped |= 32;
+        }
+        result += chars$1[clamped];
     } while (num > 0);
-    return pos;
+    return result;
 }
 
-class BitSet {
-	constructor(arg) {
-		this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
-	}
+var BitSet = function BitSet(arg) {
+	this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
+};
 
-	add(n) {
-		this.bits[n >> 5] |= 1 << (n & 31);
-	}
+BitSet.prototype.add = function add (n) {
+	this.bits[n >> 5] |= 1 << (n & 31);
+};
 
-	has(n) {
-		return !!(this.bits[n >> 5] & (1 << (n & 31)));
-	}
-}
+BitSet.prototype.has = function has (n) {
+	return !!(this.bits[n >> 5] & (1 << (n & 31)));
+};
 
-let Chunk$1 = class Chunk {
-	constructor(start, end, content) {
-		this.start = start;
-		this.end = end;
-		this.original = content;
+var Chunk$1 = function Chunk(start, end, content) {
+	this.start = start;
+	this.end = end;
+	this.original = content;
 
-		this.intro = '';
-		this.outro = '';
+	this.intro = '';
+	this.outro = '';
 
-		this.content = content;
-		this.storeName = false;
-		this.edited = false;
-
-		{
-			this.previous = null;
-			this.next = null;
-		}
-	}
+	this.content = content;
+	this.storeName = false;
+	this.edited = false;
 
-	appendLeft(content) {
-		this.outro += content;
-	}
+	// we make these non-enumerable, for sanity while debugging
+	Object.defineProperties(this, {
+		previous: { writable: true, value: null },
+		next:     { writable: true, value: null }
+	});
+};
 
-	appendRight(content) {
-		this.intro = this.intro + content;
-	}
+Chunk$1.prototype.appendLeft = function appendLeft (content) {
+	this.outro += content;
+};
 
-	clone() {
-		const chunk = new Chunk$1(this.start, this.end, this.original);
+Chunk$1.prototype.appendRight = function appendRight (content) {
+	this.intro = this.intro + content;
+};
 
-		chunk.intro = this.intro;
-		chunk.outro = this.outro;
-		chunk.content = this.content;
-		chunk.storeName = this.storeName;
-		chunk.edited = this.edited;
+Chunk$1.prototype.clone = function clone () {
+	var chunk = new Chunk$1(this.start, this.end, this.original);
 
-		return chunk;
-	}
+	chunk.intro = this.intro;
+	chunk.outro = this.outro;
+	chunk.content = this.content;
+	chunk.storeName = this.storeName;
+	chunk.edited = this.edited;
 
-	contains(index) {
-		return this.start < index && index < this.end;
-	}
+	return chunk;
+};
 
-	eachNext(fn) {
-		let chunk = this;
-		while (chunk) {
-			fn(chunk);
-			chunk = chunk.next;
-		}
-	}
+Chunk$1.prototype.contains = function contains (index) {
+	return this.start < index && index < this.end;
+};
 
-	eachPrevious(fn) {
-		let chunk = this;
-		while (chunk) {
-			fn(chunk);
-			chunk = chunk.previous;
-		}
+Chunk$1.prototype.eachNext = function eachNext (fn) {
+	var chunk = this;
+	while (chunk) {
+		fn(chunk);
+		chunk = chunk.next;
 	}
+};
 
-	edit(content, storeName, contentOnly) {
-		this.content = content;
-		if (!contentOnly) {
-			this.intro = '';
-			this.outro = '';
-		}
-		this.storeName = storeName;
-
-		this.edited = true;
-
-		return this;
+Chunk$1.prototype.eachPrevious = function eachPrevious (fn) {
+	var chunk = this;
+	while (chunk) {
+		fn(chunk);
+		chunk = chunk.previous;
 	}
+};
 
-	prependLeft(content) {
-		this.outro = content + this.outro;
+Chunk$1.prototype.edit = function edit (content, storeName, contentOnly) {
+	this.content = content;
+	if (!contentOnly) {
+		this.intro = '';
+		this.outro = '';
 	}
+	this.storeName = storeName;
 
-	prependRight(content) {
-		this.intro = content + this.intro;
-	}
+	this.edited = true;
 
-	split(index) {
-		const sliceIndex = index - this.start;
+	return this;
+};
 
-		const originalBefore = this.original.slice(0, sliceIndex);
-		const originalAfter = this.original.slice(sliceIndex);
+Chunk$1.prototype.prependLeft = function prependLeft (content) {
+	this.outro = content + this.outro;
+};
 
-		this.original = originalBefore;
+Chunk$1.prototype.prependRight = function prependRight (content) {
+	this.intro = content + this.intro;
+};
 
-		const newChunk = new Chunk$1(index, this.end, originalAfter);
-		newChunk.outro = this.outro;
-		this.outro = '';
+Chunk$1.prototype.split = function split (index) {
+	var sliceIndex = index - this.start;
 
-		this.end = index;
+	var originalBefore = this.original.slice(0, sliceIndex);
+	var originalAfter = this.original.slice(sliceIndex);
 
-		if (this.edited) {
-			// TODO is this block necessary?...
-			newChunk.edit('', false);
-			this.content = '';
-		} else {
-			this.content = originalBefore;
-		}
+	this.original = originalBefore;
 
-		newChunk.next = this.next;
-		if (newChunk.next) newChunk.next.previous = newChunk;
-		newChunk.previous = this;
-		this.next = newChunk;
+	var newChunk = new Chunk$1(index, this.end, originalAfter);
+	newChunk.outro = this.outro;
+	this.outro = '';
 
-		return newChunk;
-	}
+	this.end = index;
 
-	toString() {
-		return this.intro + this.content + this.outro;
+	if (this.edited) {
+		// TODO is this block necessary?...
+		newChunk.edit('', false);
+		this.content = '';
+	} else {
+		this.content = originalBefore;
 	}
 
-	trimEnd(rx) {
-		this.outro = this.outro.replace(rx, '');
-		if (this.outro.length) return true;
+	newChunk.next = this.next;
+	if (newChunk.next) { newChunk.next.previous = newChunk; }
+	newChunk.previous = this;
+	this.next = newChunk;
 
-		const trimmed = this.content.replace(rx, '');
+	return newChunk;
+};
 
-		if (trimmed.length) {
-			if (trimmed !== this.content) {
-				this.split(this.start + trimmed.length).edit('', undefined, true);
-			}
-			return true;
-		} else {
-			this.edit('', undefined, true);
+Chunk$1.prototype.toString = function toString () {
+	return this.intro + this.content + this.outro;
+};
 
-			this.intro = this.intro.replace(rx, '');
-			if (this.intro.length) return true;
+Chunk$1.prototype.trimEnd = function trimEnd (rx) {
+	this.outro = this.outro.replace(rx, '');
+	if (this.outro.length) { return true; }
+
+	var trimmed = this.content.replace(rx, '');
+
+	if (trimmed.length) {
+		if (trimmed !== this.content) {
+			this.split(this.start + trimmed.length).edit('', undefined, true);
 		}
-	}
+		return true;
+
+	} else {
+		this.edit('', undefined, true);
 
-	trimStart(rx) {
 		this.intro = this.intro.replace(rx, '');
-		if (this.intro.length) return true;
+		if (this.intro.length) { return true; }
+	}
+};
 
-		const trimmed = this.content.replace(rx, '');
+Chunk$1.prototype.trimStart = function trimStart (rx) {
+	this.intro = this.intro.replace(rx, '');
+	if (this.intro.length) { return true; }
 
-		if (trimmed.length) {
-			if (trimmed !== this.content) {
-				this.split(this.end - trimmed.length);
-				this.edit('', undefined, true);
-			}
-			return true;
-		} else {
-			this.edit('', undefined, true);
+	var trimmed = this.content.replace(rx, '');
 
-			this.outro = this.outro.replace(rx, '');
-			if (this.outro.length) return true;
+	if (trimmed.length) {
+		if (trimmed !== this.content) {
+			this.split(this.end - trimmed.length);
+			this.edit('', undefined, true);
 		}
-	}
-};
+		return true;
 
-function getBtoa () {
-	if (typeof window !== 'undefined' && typeof window.btoa === 'function') {
-		return (str) => window.btoa(unescape(encodeURIComponent(str)));
-	} else if (typeof Buffer === 'function') {
-		return (str) => Buffer.from(str, 'utf-8').toString('base64');
 	} else {
-		return () => {
-			throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');
-		};
+		this.edit('', undefined, true);
+
+		this.outro = this.outro.replace(rx, '');
+		if (this.outro.length) { return true; }
 	}
-}
+};
 
-const btoa = /*#__PURE__*/ getBtoa();
+var btoa = function () {
+	throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');
+};
+if (typeof window !== 'undefined' && typeof window.btoa === 'function') {
+	btoa = function (str) { return window.btoa(unescape(encodeURIComponent(str))); };
+} else if (typeof Buffer === 'function') {
+	btoa = function (str) { return Buffer.from(str, 'utf-8').toString('base64'); };
+}
 
-class SourceMap {
-	constructor(properties) {
-		this.version = 3;
-		this.file = properties.file;
-		this.sources = properties.sources;
-		this.sourcesContent = properties.sourcesContent;
-		this.names = properties.names;
-		this.mappings = encode(properties.mappings);
-	}
+var SourceMap = function SourceMap(properties) {
+	this.version = 3;
+	this.file = properties.file;
+	this.sources = properties.sources;
+	this.sourcesContent = properties.sourcesContent;
+	this.names = properties.names;
+	this.mappings = encode(properties.mappings);
+};
 
-	toString() {
-		return JSON.stringify(this);
-	}
+SourceMap.prototype.toString = function toString () {
+	return JSON.stringify(this);
+};
 
-	toUrl() {
-		return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());
-	}
-}
+SourceMap.prototype.toUrl = function toUrl () {
+	return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());
+};
 
 function guessIndent(code) {
-	const lines = code.split('\n');
+	var lines = code.split('\n');
 
-	const tabbed = lines.filter((line) => /^\t+/.test(line));
-	const spaced = lines.filter((line) => /^ {2,}/.test(line));
+	var tabbed = lines.filter(function (line) { return /^\t+/.test(line); });
+	var spaced = lines.filter(function (line) { return /^ {2,}/.test(line); });
 
 	if (tabbed.length === 0 && spaced.length === 0) {
 		return null;
@@ -1669,8 +955,8 @@
 	}
 
 	// Otherwise, we need to guess the multiple
-	const min = spaced.reduce((previous, current) => {
-		const numSpaces = /^ +/.exec(current)[0].length;
+	var min = spaced.reduce(function (previous, current) {
+		var numSpaces = /^ +/.exec(current)[0].length;
 		return Math.min(numSpaces, previous);
 	}, Infinity);
 
@@ -1678,8 +964,8 @@
 }
 
 function getRelativePath(from, to) {
-	const fromParts = from.split(/[/\\]/);
-	const toParts = to.split(/[/\\]/);
+	var fromParts = from.split(/[/\\]/);
+	var toParts = to.split(/[/\\]/);
 
 	fromParts.pop(); // get dirname
 
@@ -1689,1270 +975,1115 @@
 	}
 
 	if (fromParts.length) {
-		let i = fromParts.length;
-		while (i--) fromParts[i] = '..';
+		var i = fromParts.length;
+		while (i--) { fromParts[i] = '..'; }
 	}
 
 	return fromParts.concat(toParts).join('/');
 }
 
-const toString$1 = Object.prototype.toString;
+var toString$1 = Object.prototype.toString;
 
 function isObject$1(thing) {
 	return toString$1.call(thing) === '[object Object]';
 }
 
 function getLocator(source) {
-	const originalLines = source.split('\n');
-	const lineOffsets = [];
+	var originalLines = source.split('\n');
+	var lineOffsets = [];
 
-	for (let i = 0, pos = 0; i < originalLines.length; i++) {
+	for (var i = 0, pos = 0; i < originalLines.length; i++) {
 		lineOffsets.push(pos);
 		pos += originalLines[i].length + 1;
 	}
 
 	return function locate(index) {
-		let i = 0;
-		let j = lineOffsets.length;
+		var i = 0;
+		var j = lineOffsets.length;
 		while (i < j) {
-			const m = (i + j) >> 1;
+			var m = (i + j) >> 1;
 			if (index < lineOffsets[m]) {
 				j = m;
 			} else {
 				i = m + 1;
 			}
 		}
-		const line = i - 1;
-		const column = index - lineOffsets[line];
-		return { line, column };
+		var line = i - 1;
+		var column = index - lineOffsets[line];
+		return { line: line, column: column };
 	};
 }
 
-class Mappings {
-	constructor(hires) {
-		this.hires = hires;
-		this.generatedCodeLine = 0;
-		this.generatedCodeColumn = 0;
-		this.raw = [];
-		this.rawSegments = this.raw[this.generatedCodeLine] = [];
-		this.pending = null;
-	}
+var Mappings = function Mappings(hires) {
+	this.hires = hires;
+	this.generatedCodeLine = 0;
+	this.generatedCodeColumn = 0;
+	this.raw = [];
+	this.rawSegments = this.raw[this.generatedCodeLine] = [];
+	this.pending = null;
+};
 
-	addEdit(sourceIndex, content, loc, nameIndex) {
-		if (content.length) {
-			const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
-			if (nameIndex >= 0) {
-				segment.push(nameIndex);
-			}
-			this.rawSegments.push(segment);
-		} else if (this.pending) {
-			this.rawSegments.push(this.pending);
+Mappings.prototype.addEdit = function addEdit (sourceIndex, content, loc, nameIndex) {
+	if (content.length) {
+		var segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
+		if (nameIndex >= 0) {
+			segment.push(nameIndex);
 		}
-
-		this.advance(content);
-		this.pending = null;
+		this.rawSegments.push(segment);
+	} else if (this.pending) {
+		this.rawSegments.push(this.pending);
 	}
 
-	addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
-		let originalCharIndex = chunk.start;
-		let first = true;
-
-		while (originalCharIndex < chunk.end) {
-			if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
-				this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
-			}
+	this.advance(content);
+	this.pending = null;
+};
 
-			if (original[originalCharIndex] === '\n') {
-				loc.line += 1;
-				loc.column = 0;
-				this.generatedCodeLine += 1;
-				this.raw[this.generatedCodeLine] = this.rawSegments = [];
-				this.generatedCodeColumn = 0;
-				first = true;
-			} else {
-				loc.column += 1;
-				this.generatedCodeColumn += 1;
-				first = false;
-			}
+Mappings.prototype.addUneditedChunk = function addUneditedChunk (sourceIndex, chunk, original, loc, sourcemapLocations) {
+	var originalCharIndex = chunk.start;
+	var first = true;
+
+	while (originalCharIndex < chunk.end) {
+		if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
+			this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
+		}
 
-			originalCharIndex += 1;
+		if (original[originalCharIndex] === '\n') {
+			loc.line += 1;
+			loc.column = 0;
+			this.generatedCodeLine += 1;
+			this.raw[this.generatedCodeLine] = this.rawSegments = [];
+			this.generatedCodeColumn = 0;
+			first = true;
+		} else {
+			loc.column += 1;
+			this.generatedCodeColumn += 1;
+			first = false;
 		}
 
-		this.pending = null;
+		originalCharIndex += 1;
 	}
 
-	advance(str) {
-		if (!str) return;
+	this.pending = null;
+};
 
-		const lines = str.split('\n');
+Mappings.prototype.advance = function advance (str) {
+	if (!str) { return; }
 
-		if (lines.length > 1) {
-			for (let i = 0; i < lines.length - 1; i++) {
-				this.generatedCodeLine++;
-				this.raw[this.generatedCodeLine] = this.rawSegments = [];
-			}
-			this.generatedCodeColumn = 0;
-		}
+	var lines = str.split('\n');
 
-		this.generatedCodeColumn += lines[lines.length - 1].length;
+	if (lines.length > 1) {
+		for (var i = 0; i < lines.length - 1; i++) {
+			this.generatedCodeLine++;
+			this.raw[this.generatedCodeLine] = this.rawSegments = [];
+		}
+		this.generatedCodeColumn = 0;
 	}
-}
 
-const n = '\n';
+	this.generatedCodeColumn += lines[lines.length - 1].length;
+};
 
-const warned = {
+var n = '\n';
+
+var warned = {
 	insertLeft: false,
 	insertRight: false,
-	storeName: false,
+	storeName: false
 };
 
-class MagicString {
-	constructor(string, options = {}) {
-		const chunk = new Chunk$1(0, string.length, string);
-
-		Object.defineProperties(this, {
-			original: { writable: true, value: string },
-			outro: { writable: true, value: '' },
-			intro: { writable: true, value: '' },
-			firstChunk: { writable: true, value: chunk },
-			lastChunk: { writable: true, value: chunk },
-			lastSearchedChunk: { writable: true, value: chunk },
-			byStart: { writable: true, value: {} },
-			byEnd: { writable: true, value: {} },
-			filename: { writable: true, value: options.filename },
-			indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
-			sourcemapLocations: { writable: true, value: new BitSet() },
-			storedNames: { writable: true, value: {} },
-			indentStr: { writable: true, value: undefined },
-		});
+var MagicString = function MagicString(string, options) {
+	if ( options === void 0 ) options = {};
 
-		this.byStart[0] = chunk;
-		this.byEnd[string.length] = chunk;
-	}
+	var chunk = new Chunk$1(0, string.length, string);
 
-	addSourcemapLocation(char) {
-		this.sourcemapLocations.add(char);
-	}
-
-	append(content) {
-		if (typeof content !== 'string') throw new TypeError('outro content must be a string');
-
-		this.outro += content;
-		return this;
-	}
+	Object.defineProperties(this, {
+		original:              { writable: true, value: string },
+		outro:                 { writable: true, value: '' },
+		intro:                 { writable: true, value: '' },
+		firstChunk:            { writable: true, value: chunk },
+		lastChunk:             { writable: true, value: chunk },
+		lastSearchedChunk:     { writable: true, value: chunk },
+		byStart:               { writable: true, value: {} },
+		byEnd:                 { writable: true, value: {} },
+		filename:              { writable: true, value: options.filename },
+		indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
+		sourcemapLocations:    { writable: true, value: new BitSet() },
+		storedNames:           { writable: true, value: {} },
+		indentStr:             { writable: true, value: guessIndent(string) }
+	});
 
-	appendLeft(index, content) {
-		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');
+	this.byStart[0] = chunk;
+	this.byEnd[string.length] = chunk;
+};
 
-		this._split(index);
+MagicString.prototype.addSourcemapLocation = function addSourcemapLocation (char) {
+	this.sourcemapLocations.add(char);
+};
 
-		const chunk = this.byEnd[index];
+MagicString.prototype.append = function append (content) {
+	if (typeof content !== 'string') { throw new TypeError('outro content must be a string'); }
 
-		if (chunk) {
-			chunk.appendLeft(content);
-		} else {
-			this.intro += content;
-		}
-		return this;
-	}
+	this.outro += content;
+	return this;
+};
 
-	appendRight(index, content) {
-		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');
+MagicString.prototype.appendLeft = function appendLeft (index, content) {
+	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }
 
-		this._split(index);
+	this._split(index);
 
-		const chunk = this.byStart[index];
+	var chunk = this.byEnd[index];
 
-		if (chunk) {
-			chunk.appendRight(content);
-		} else {
-			this.outro += content;
-		}
-		return this;
+	if (chunk) {
+		chunk.appendLeft(content);
+	} else {
+		this.intro += content;
 	}
+	return this;
+};
+
+MagicString.prototype.appendRight = function appendRight (index, content) {
+	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }
 
-	clone() {
-		const cloned = new MagicString(this.original, { filename: this.filename });
+	this._split(index);
 
-		let originalChunk = this.firstChunk;
-		let clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());
+	var chunk = this.byStart[index];
 
-		while (originalChunk) {
-			cloned.byStart[clonedChunk.start] = clonedChunk;
-			cloned.byEnd[clonedChunk.end] = clonedChunk;
+	if (chunk) {
+		chunk.appendRight(content);
+	} else {
+		this.outro += content;
+	}
+	return this;
+};
 
-			const nextOriginalChunk = originalChunk.next;
-			const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
+MagicString.prototype.clone = function clone () {
+	var cloned = new MagicString(this.original, { filename: this.filename });
 
-			if (nextClonedChunk) {
-				clonedChunk.next = nextClonedChunk;
-				nextClonedChunk.previous = clonedChunk;
+	var originalChunk = this.firstChunk;
+	var clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());
 
-				clonedChunk = nextClonedChunk;
-			}
+	while (originalChunk) {
+		cloned.byStart[clonedChunk.start] = clonedChunk;
+		cloned.byEnd[clonedChunk.end] = clonedChunk;
 
-			originalChunk = nextOriginalChunk;
-		}
+		var nextOriginalChunk = originalChunk.next;
+		var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
 
-		cloned.lastChunk = clonedChunk;
+		if (nextClonedChunk) {
+			clonedChunk.next = nextClonedChunk;
+			nextClonedChunk.previous = clonedChunk;
 
-		if (this.indentExclusionRanges) {
-			cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
+			clonedChunk = nextClonedChunk;
 		}
 
-		cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
+		originalChunk = nextOriginalChunk;
+	}
 
-		cloned.intro = this.intro;
-		cloned.outro = this.outro;
+	cloned.lastChunk = clonedChunk;
 
-		return cloned;
+	if (this.indentExclusionRanges) {
+		cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
 	}
 
-	generateDecodedMap(options) {
-		options = options || {};
-
-		const sourceIndex = 0;
-		const names = Object.keys(this.storedNames);
-		const mappings = new Mappings(options.hires);
+	cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
 
-		const locate = getLocator(this.original);
+	cloned.intro = this.intro;
+	cloned.outro = this.outro;
 
-		if (this.intro) {
-			mappings.advance(this.intro);
-		}
+	return cloned;
+};
 
-		this.firstChunk.eachNext((chunk) => {
-			const loc = locate(chunk.start);
+MagicString.prototype.generateDecodedMap = function generateDecodedMap (options) {
+		var this$1$1 = this;
 
-			if (chunk.intro.length) mappings.advance(chunk.intro);
+	options = options || {};
 
-			if (chunk.edited) {
-				mappings.addEdit(
-					sourceIndex,
-					chunk.content,
-					loc,
-					chunk.storeName ? names.indexOf(chunk.original) : -1
-				);
-			} else {
-				mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
-			}
+	var sourceIndex = 0;
+	var names = Object.keys(this.storedNames);
+	var mappings = new Mappings(options.hires);
 
-			if (chunk.outro.length) mappings.advance(chunk.outro);
-		});
+	var locate = getLocator(this.original);
 
-		return {
-			file: options.file ? options.file.split(/[/\\]/).pop() : null,
-			sources: [options.source ? getRelativePath(options.file || '', options.source) : null],
-			sourcesContent: options.includeContent ? [this.original] : [null],
-			names,
-			mappings: mappings.raw,
-		};
+	if (this.intro) {
+		mappings.advance(this.intro);
 	}
 
-	generateMap(options) {
-		return new SourceMap(this.generateDecodedMap(options));
-	}
+	this.firstChunk.eachNext(function (chunk) {
+		var loc = locate(chunk.start);
 
-	_ensureindentStr() {
-		if (this.indentStr === undefined) {
-			this.indentStr = guessIndent(this.original);
+		if (chunk.intro.length) { mappings.advance(chunk.intro); }
+
+		if (chunk.edited) {
+			mappings.addEdit(
+				sourceIndex,
+				chunk.content,
+				loc,
+				chunk.storeName ? names.indexOf(chunk.original) : -1
+			);
+		} else {
+			mappings.addUneditedChunk(sourceIndex, chunk, this$1$1.original, loc, this$1$1.sourcemapLocations);
 		}
-	}
 
-	_getRawIndentString() {
-		this._ensureindentStr();
-		return this.indentStr;
-	}
+		if (chunk.outro.length) { mappings.advance(chunk.outro); }
+	});
 
-	getIndentString() {
-		this._ensureindentStr();
-		return this.indentStr === null ? '\t' : this.indentStr;
-	}
+	return {
+		file: options.file ? options.file.split(/[/\\]/).pop() : null,
+		sources: [options.source ? getRelativePath(options.file || '', options.source) : null],
+		sourcesContent: options.includeContent ? [this.original] : [null],
+		names: names,
+		mappings: mappings.raw
+	};
+};
 
-	indent(indentStr, options) {
-		const pattern = /^[^\r\n]/gm;
+MagicString.prototype.generateMap = function generateMap (options) {
+	return new SourceMap(this.generateDecodedMap(options));
+};
 
-		if (isObject$1(indentStr)) {
-			options = indentStr;
-			indentStr = undefined;
-		}
+MagicString.prototype.getIndentString = function getIndentString () {
+	return this.indentStr === null ? '\t' : this.indentStr;
+};
 
-		if (indentStr === undefined) {
-			this._ensureindentStr();
-			indentStr = this.indentStr || '\t';
-		}
+MagicString.prototype.indent = function indent (indentStr, options) {
+	var pattern = /^[^\r\n]/gm;
 
-		if (indentStr === '') return this; // noop
+	if (isObject$1(indentStr)) {
+		options = indentStr;
+		indentStr = undefined;
+	}
 
-		options = options || {};
+	indentStr = indentStr !== undefined ? indentStr : this.indentStr || '\t';
 
-		// Process exclusion ranges
-		const isExcluded = {};
+	if (indentStr === '') { return this; } // noop
 
-		if (options.exclude) {
-			const exclusions =
-				typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;
-			exclusions.forEach((exclusion) => {
-				for (let i = exclusion[0]; i < exclusion[1]; i += 1) {
-					isExcluded[i] = true;
-				}
-			});
-		}
+	options = options || {};
 
-		let shouldIndentNextCharacter = options.indentStart !== false;
-		const replacer = (match) => {
-			if (shouldIndentNextCharacter) return `${indentStr}${match}`;
-			shouldIndentNextCharacter = true;
-			return match;
-		};
-
-		this.intro = this.intro.replace(pattern, replacer);
+	// Process exclusion ranges
+	var isExcluded = {};
 
-		let charIndex = 0;
-		let chunk = this.firstChunk;
+	if (options.exclude) {
+		var exclusions =
+			typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;
+		exclusions.forEach(function (exclusion) {
+			for (var i = exclusion[0]; i < exclusion[1]; i += 1) {
+				isExcluded[i] = true;
+			}
+		});
+	}
+
+	var shouldIndentNextCharacter = options.indentStart !== false;
+	var replacer = function (match) {
+		if (shouldIndentNextCharacter) { return ("" + indentStr + match); }
+		shouldIndentNextCharacter = true;
+		return match;
+	};
 
-		while (chunk) {
-			const end = chunk.end;
+	this.intro = this.intro.replace(pattern, replacer);
 
-			if (chunk.edited) {
-				if (!isExcluded[charIndex]) {
-					chunk.content = chunk.content.replace(pattern, replacer);
+	var charIndex = 0;
+	var chunk = this.firstChunk;
 
-					if (chunk.content.length) {
-						shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\n';
-					}
+	while (chunk) {
+		var end = chunk.end;
+
+		if (chunk.edited) {
+			if (!isExcluded[charIndex]) {
+				chunk.content = chunk.content.replace(pattern, replacer);
+
+				if (chunk.content.length) {
+					shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\n';
 				}
-			} else {
-				charIndex = chunk.start;
+			}
+		} else {
+			charIndex = chunk.start;
+
+			while (charIndex < end) {
+				if (!isExcluded[charIndex]) {
+					var char = this.original[charIndex];
 
-				while (charIndex < end) {
-					if (!isExcluded[charIndex]) {
-						const char = this.original[charIndex];
-
-						if (char === '\n') {
-							shouldIndentNextCharacter = true;
-						} else if (char !== '\r' && shouldIndentNextCharacter) {
-							shouldIndentNextCharacter = false;
-
-							if (charIndex === chunk.start) {
-								chunk.prependRight(indentStr);
-							} else {
-								this._splitChunk(chunk, charIndex);
-								chunk = chunk.next;
-								chunk.prependRight(indentStr);
-							}
+					if (char === '\n') {
+						shouldIndentNextCharacter = true;
+					} else if (char !== '\r' && shouldIndentNextCharacter) {
+						shouldIndentNextCharacter = false;
+
+						if (charIndex === chunk.start) {
+							chunk.prependRight(indentStr);
+						} else {
+							this._splitChunk(chunk, charIndex);
+							chunk = chunk.next;
+							chunk.prependRight(indentStr);
 						}
 					}
-
-					charIndex += 1;
 				}
-			}
 
-			charIndex = chunk.end;
-			chunk = chunk.next;
+				charIndex += 1;
+			}
 		}
 
-		this.outro = this.outro.replace(pattern, replacer);
-
-		return this;
+		charIndex = chunk.end;
+		chunk = chunk.next;
 	}
 
-	insert() {
-		throw new Error(
-			'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)'
-		);
-	}
+	this.outro = this.outro.replace(pattern, replacer);
 
-	insertLeft(index, content) {
-		if (!warned.insertLeft) {
-			console.warn(
-				'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'
-			); // eslint-disable-line no-console
-			warned.insertLeft = true;
-		}
+	return this;
+};
 
-		return this.appendLeft(index, content);
+MagicString.prototype.insert = function insert () {
+	throw new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)');
+};
+
+MagicString.prototype.insertLeft = function insertLeft (index, content) {
+	if (!warned.insertLeft) {
+		console.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'); // eslint-disable-line no-console
+		warned.insertLeft = true;
 	}
 
-	insertRight(index, content) {
-		if (!warned.insertRight) {
-			console.warn(
-				'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'
-			); // eslint-disable-line no-console
-			warned.insertRight = true;
-		}
+	return this.appendLeft(index, content);
+};
 
-		return this.prependRight(index, content);
+MagicString.prototype.insertRight = function insertRight (index, content) {
+	if (!warned.insertRight) {
+		console.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'); // eslint-disable-line no-console
+		warned.insertRight = true;
 	}
 
-	move(start, end, index) {
-		if (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');
-
-		this._split(start);
-		this._split(end);
-		this._split(index);
+	return this.prependRight(index, content);
+};
 
-		const first = this.byStart[start];
-		const last = this.byEnd[end];
+MagicString.prototype.move = function move (start, end, index) {
+	if (index >= start && index <= end) { throw new Error('Cannot move a selection inside itself'); }
 
-		const oldLeft = first.previous;
-		const oldRight = last.next;
+	this._split(start);
+	this._split(end);
+	this._split(index);
 
-		const newRight = this.byStart[index];
-		if (!newRight && last === this.lastChunk) return this;
-		const newLeft = newRight ? newRight.previous : this.lastChunk;
+	var first = this.byStart[start];
+	var last = this.byEnd[end];
 
-		if (oldLeft) oldLeft.next = oldRight;
-		if (oldRight) oldRight.previous = oldLeft;
+	var oldLeft = first.previous;
+	var oldRight = last.next;
 
-		if (newLeft) newLeft.next = first;
-		if (newRight) newRight.previous = last;
+	var newRight = this.byStart[index];
+	if (!newRight && last === this.lastChunk) { return this; }
+	var newLeft = newRight ? newRight.previous : this.lastChunk;
 
-		if (!first.previous) this.firstChunk = last.next;
-		if (!last.next) {
-			this.lastChunk = first.previous;
-			this.lastChunk.next = null;
-		}
+	if (oldLeft) { oldLeft.next = oldRight; }
+	if (oldRight) { oldRight.previous = oldLeft; }
 
-		first.previous = newLeft;
-		last.next = newRight || null;
+	if (newLeft) { newLeft.next = first; }
+	if (newRight) { newRight.previous = last; }
 
-		if (!newLeft) this.firstChunk = first;
-		if (!newRight) this.lastChunk = last;
-		return this;
+	if (!first.previous) { this.firstChunk = last.next; }
+	if (!last.next) {
+		this.lastChunk = first.previous;
+		this.lastChunk.next = null;
 	}
 
-	overwrite(start, end, content, options) {
-		options = options || {};
-		return this.update(start, end, content, { ...options, overwrite: !options.contentOnly });
-	}
+	first.previous = newLeft;
+	last.next = newRight || null;
 
-	update(start, end, content, options) {
-		if (typeof content !== 'string') throw new TypeError('replacement content must be a string');
+	if (!newLeft) { this.firstChunk = first; }
+	if (!newRight) { this.lastChunk = last; }
+	return this;
+};
 
-		while (start < 0) start += this.original.length;
-		while (end < 0) end += this.original.length;
+MagicString.prototype.overwrite = function overwrite (start, end, content, options) {
+	if (typeof content !== 'string') { throw new TypeError('replacement content must be a string'); }
 
-		if (end > this.original.length) throw new Error('end is out of bounds');
-		if (start === end)
-			throw new Error(
-				'Cannot overwrite a zero-length range – use appendLeft or prependRight instead'
-			);
+	while (start < 0) { start += this.original.length; }
+	while (end < 0) { end += this.original.length; }
 
-		this._split(start);
-		this._split(end);
+	if (end > this.original.length) { throw new Error('end is out of bounds'); }
+	if (start === end)
+		{ throw new Error('Cannot overwrite a zero-length range – use appendLeft or prependRight instead'); }
 
-		if (options === true) {
-			if (!warned.storeName) {
-				console.warn(
-					'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'
-				); // eslint-disable-line no-console
-				warned.storeName = true;
-			}
+	this._split(start);
+	this._split(end);
 
-			options = { storeName: true };
+	if (options === true) {
+		if (!warned.storeName) {
+			console.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'); // eslint-disable-line no-console
+			warned.storeName = true;
 		}
-		const storeName = options !== undefined ? options.storeName : false;
-		const overwrite = options !== undefined ? options.overwrite : false;
 
-		if (storeName) {
-			const original = this.original.slice(start, end);
-			Object.defineProperty(this.storedNames, original, {
-				writable: true,
-				value: true,
-				enumerable: true,
-			});
+		options = { storeName: true };
+	}
+	var storeName = options !== undefined ? options.storeName : false;
+	var contentOnly = options !== undefined ? options.contentOnly : false;
+
+	if (storeName) {
+		var original = this.original.slice(start, end);
+		this.storedNames[original] = true;
+	}
+
+	var first = this.byStart[start];
+	var last = this.byEnd[end];
+
+	if (first) {
+		if (end > first.end && first.next !== this.byStart[first.end]) {
+			throw new Error('Cannot overwrite across a split point');
 		}
 
-		const first = this.byStart[start];
-		const last = this.byEnd[end];
+		first.edit(content, storeName, contentOnly);
 
-		if (first) {
-			let chunk = first;
+		if (first !== last) {
+			var chunk = first.next;
 			while (chunk !== last) {
-				if (chunk.next !== this.byStart[chunk.end]) {
-					throw new Error('Cannot overwrite across a split point');
-				}
-				chunk = chunk.next;
 				chunk.edit('', false);
+				chunk = chunk.next;
 			}
 
-			first.edit(content, storeName, !overwrite);
-		} else {
-			// must be inserting at the end
-			const newChunk = new Chunk$1(start, end, '').edit(content, storeName);
-
-			// TODO last chunk in the array may not be the last chunk, if it's moved...
-			last.next = newChunk;
-			newChunk.previous = last;
+			chunk.edit('', false);
 		}
-		return this;
-	}
-
-	prepend(content) {
-		if (typeof content !== 'string') throw new TypeError('outro content must be a string');
+	} else {
+		// must be inserting at the end
+		var newChunk = new Chunk$1(start, end, '').edit(content, storeName);
 
-		this.intro = content + this.intro;
-		return this;
+		// TODO last chunk in the array may not be the last chunk, if it's moved...
+		last.next = newChunk;
+		newChunk.previous = last;
 	}
+	return this;
+};
 
-	prependLeft(index, content) {
-		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');
-
-		this._split(index);
-
-		const chunk = this.byEnd[index];
+MagicString.prototype.prepend = function prepend (content) {
+	if (typeof content !== 'string') { throw new TypeError('outro content must be a string'); }
 
-		if (chunk) {
-			chunk.prependLeft(content);
-		} else {
-			this.intro = content + this.intro;
-		}
-		return this;
-	}
+	this.intro = content + this.intro;
+	return this;
+};
 
-	prependRight(index, content) {
-		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');
+MagicString.prototype.prependLeft = function prependLeft (index, content) {
+	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }
 
-		this._split(index);
+	this._split(index);
 
-		const chunk = this.byStart[index];
+	var chunk = this.byEnd[index];
 
-		if (chunk) {
-			chunk.prependRight(content);
-		} else {
-			this.outro = content + this.outro;
-		}
-		return this;
+	if (chunk) {
+		chunk.prependLeft(content);
+	} else {
+		this.intro = content + this.intro;
 	}
+	return this;
+};
 
-	remove(start, end) {
-		while (start < 0) start += this.original.length;
-		while (end < 0) end += this.original.length;
-
-		if (start === end) return this;
-
-		if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');
-		if (start > end) throw new Error('end must be greater than start');
-
-		this._split(start);
-		this._split(end);
+MagicString.prototype.prependRight = function prependRight (index, content) {
+	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }
 
-		let chunk = this.byStart[start];
+	this._split(index);
 
-		while (chunk) {
-			chunk.intro = '';
-			chunk.outro = '';
-			chunk.edit('');
+	var chunk = this.byStart[index];
 
-			chunk = end > chunk.end ? this.byStart[chunk.end] : null;
-		}
-		return this;
+	if (chunk) {
+		chunk.prependRight(content);
+	} else {
+		this.outro = content + this.outro;
 	}
+	return this;
+};
 
-	lastChar() {
-		if (this.outro.length) return this.outro[this.outro.length - 1];
-		let chunk = this.lastChunk;
-		do {
-			if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];
-			if (chunk.content.length) return chunk.content[chunk.content.length - 1];
-			if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];
-		} while ((chunk = chunk.previous));
-		if (this.intro.length) return this.intro[this.intro.length - 1];
-		return '';
-	}
+MagicString.prototype.remove = function remove (start, end) {
+	while (start < 0) { start += this.original.length; }
+	while (end < 0) { end += this.original.length; }
+
+	if (start === end) { return this; }
+
+	if (start < 0 || end > this.original.length) { throw new Error('Character is out of bounds'); }
+	if (start > end) { throw new Error('end must be greater than start'); }
+
+	this._split(start);
+	this._split(end);
+
+	var chunk = this.byStart[start];
+
+	while (chunk) {
+		chunk.intro = '';
+		chunk.outro = '';
+		chunk.edit('');
+
+		chunk = end > chunk.end ? this.byStart[chunk.end] : null;
+	}
+	return this;
+};
+
+MagicString.prototype.lastChar = function lastChar () {
+	if (this.outro.length)
+		{ return this.outro[this.outro.length - 1]; }
+	var chunk = this.lastChunk;
+	do {
+		if (chunk.outro.length)
+			{ return chunk.outro[chunk.outro.length - 1]; }
+		if (chunk.content.length)
+			{ return chunk.content[chunk.content.length - 1]; }
+		if (chunk.intro.length)
+			{ return chunk.intro[chunk.intro.length - 1]; }
+	} while (chunk = chunk.previous);
+	if (this.intro.length)
+		{ return this.intro[this.intro.length - 1]; }
+	return '';
+};
+
+MagicString.prototype.lastLine = function lastLine () {
+	var lineIndex = this.outro.lastIndexOf(n);
+	if (lineIndex !== -1)
+		{ return this.outro.substr(lineIndex + 1); }
+	var lineStr = this.outro;
+	var chunk = this.lastChunk;
+	do {
+		if (chunk.outro.length > 0) {
+			lineIndex = chunk.outro.lastIndexOf(n);
+			if (lineIndex !== -1)
+				{ return chunk.outro.substr(lineIndex + 1) + lineStr; }
+			lineStr = chunk.outro + lineStr;
+		}
 
-	lastLine() {
-		let lineIndex = this.outro.lastIndexOf(n);
-		if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);
-		let lineStr = this.outro;
-		let chunk = this.lastChunk;
-		do {
-			if (chunk.outro.length > 0) {
-				lineIndex = chunk.outro.lastIndexOf(n);
-				if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;
-				lineStr = chunk.outro + lineStr;
-			}
+		if (chunk.content.length > 0) {
+			lineIndex = chunk.content.lastIndexOf(n);
+			if (lineIndex !== -1)
+				{ return chunk.content.substr(lineIndex + 1) + lineStr; }
+			lineStr = chunk.content + lineStr;
+		}
 
-			if (chunk.content.length > 0) {
-				lineIndex = chunk.content.lastIndexOf(n);
-				if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;
-				lineStr = chunk.content + lineStr;
-			}
+		if (chunk.intro.length > 0) {
+			lineIndex = chunk.intro.lastIndexOf(n);
+			if (lineIndex !== -1)
+				{ return chunk.intro.substr(lineIndex + 1) + lineStr; }
+			lineStr = chunk.intro + lineStr;
+		}
+	} while (chunk = chunk.previous);
+	lineIndex = this.intro.lastIndexOf(n);
+	if (lineIndex !== -1)
+		{ return this.intro.substr(lineIndex + 1) + lineStr; }
+	return this.intro + lineStr;
+};
+
+MagicString.prototype.slice = function slice (start, end) {
+		if ( start === void 0 ) start = 0;
+		if ( end === void 0 ) end = this.original.length;
+
+	while (start < 0) { start += this.original.length; }
+	while (end < 0) { end += this.original.length; }
+
+	var result = '';
+
+	// find start chunk
+	var chunk = this.firstChunk;
+	while (chunk && (chunk.start > start || chunk.end <= start)) {
+		// found end chunk before start
+		if (chunk.start < end && chunk.end >= end) {
+			return result;
+		}
 
-			if (chunk.intro.length > 0) {
-				lineIndex = chunk.intro.lastIndexOf(n);
-				if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;
-				lineStr = chunk.intro + lineStr;
-			}
-		} while ((chunk = chunk.previous));
-		lineIndex = this.intro.lastIndexOf(n);
-		if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;
-		return this.intro + lineStr;
+		chunk = chunk.next;
 	}
 
-	slice(start = 0, end = this.original.length) {
-		while (start < 0) start += this.original.length;
-		while (end < 0) end += this.original.length;
-
-		let result = '';
-
-		// find start chunk
-		let chunk = this.firstChunk;
-		while (chunk && (chunk.start > start || chunk.end <= start)) {
-			// found end chunk before start
-			if (chunk.start < end && chunk.end >= end) {
-				return result;
-			}
+	if (chunk && chunk.edited && chunk.start !== start)
+		{ throw new Error(("Cannot use replaced character " + start + " as slice start anchor.")); }
 
-			chunk = chunk.next;
+	var startChunk = chunk;
+	while (chunk) {
+		if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
+			result += chunk.intro;
 		}
 
-		if (chunk && chunk.edited && chunk.start !== start)
-			throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);
-
-		const startChunk = chunk;
-		while (chunk) {
-			if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
-				result += chunk.intro;
-			}
-
-			const containsEnd = chunk.start < end && chunk.end >= end;
-			if (containsEnd && chunk.edited && chunk.end !== end)
-				throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);
+		var containsEnd = chunk.start < end && chunk.end >= end;
+		if (containsEnd && chunk.edited && chunk.end !== end)
+			{ throw new Error(("Cannot use replaced character " + end + " as slice end anchor.")); }
 
-			const sliceStart = startChunk === chunk ? start - chunk.start : 0;
-			const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
+		var sliceStart = startChunk === chunk ? start - chunk.start : 0;
+		var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
 
-			result += chunk.content.slice(sliceStart, sliceEnd);
+		result += chunk.content.slice(sliceStart, sliceEnd);
 
-			if (chunk.outro && (!containsEnd || chunk.end === end)) {
-				result += chunk.outro;
-			}
-
-			if (containsEnd) {
-				break;
-			}
+		if (chunk.outro && (!containsEnd || chunk.end === end)) {
+			result += chunk.outro;
+		}
 
-			chunk = chunk.next;
+		if (containsEnd) {
+			break;
 		}
 
-		return result;
+		chunk = chunk.next;
 	}
 
-	// TODO deprecate this? not really very useful
-	snip(start, end) {
-		const clone = this.clone();
-		clone.remove(0, start);
-		clone.remove(end, clone.original.length);
-
-		return clone;
-	}
+	return result;
+};
 
-	_split(index) {
-		if (this.byStart[index] || this.byEnd[index]) return;
+// TODO deprecate this? not really very useful
+MagicString.prototype.snip = function snip (start, end) {
+	var clone = this.clone();
+	clone.remove(0, start);
+	clone.remove(end, clone.original.length);
 
-		let chunk = this.lastSearchedChunk;
-		const searchForward = index > chunk.end;
+	return clone;
+};
 
-		while (chunk) {
-			if (chunk.contains(index)) return this._splitChunk(chunk, index);
+MagicString.prototype._split = function _split (index) {
+	if (this.byStart[index] || this.byEnd[index]) { return; }
 
-			chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
-		}
-	}
+	var chunk = this.lastSearchedChunk;
+	var searchForward = index > chunk.end;
 
-	_splitChunk(chunk, index) {
-		if (chunk.edited && chunk.content.length) {
-			// zero-length edited chunks are a special case (overlapping replacements)
-			const loc = getLocator(this.original)(index);
-			throw new Error(
-				`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – "${chunk.original}")`
-			);
-		}
+	while (chunk) {
+		if (chunk.contains(index)) { return this._splitChunk(chunk, index); }
 
-		const newChunk = chunk.split(index);
-
-		this.byEnd[index] = chunk;
-		this.byStart[index] = newChunk;
-		this.byEnd[newChunk.end] = newChunk;
-
-		if (chunk === this.lastChunk) this.lastChunk = newChunk;
+		chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
+	}
+};
 
-		this.lastSearchedChunk = chunk;
-		return true;
+MagicString.prototype._splitChunk = function _splitChunk (chunk, index) {
+	if (chunk.edited && chunk.content.length) {
+		// zero-length edited chunks are a special case (overlapping replacements)
+		var loc = getLocator(this.original)(index);
+		throw new Error(
+			("Cannot split a chunk that has already been edited (" + (loc.line) + ":" + (loc.column) + " – \"" + (chunk.original) + "\")")
+		);
 	}
 
-	toString() {
-		let str = this.intro;
+	var newChunk = chunk.split(index);
 
-		let chunk = this.firstChunk;
-		while (chunk) {
-			str += chunk.toString();
-			chunk = chunk.next;
-		}
+	this.byEnd[index] = chunk;
+	this.byStart[index] = newChunk;
+	this.byEnd[newChunk.end] = newChunk;
 
-		return str + this.outro;
-	}
+	if (chunk === this.lastChunk) { this.lastChunk = newChunk; }
 
-	isEmpty() {
-		let chunk = this.firstChunk;
-		do {
-			if (
-				(chunk.intro.length && chunk.intro.trim()) ||
-				(chunk.content.length && chunk.content.trim()) ||
-				(chunk.outro.length && chunk.outro.trim())
-			)
-				return false;
-		} while ((chunk = chunk.next));
-		return true;
-	}
+	this.lastSearchedChunk = chunk;
+	return true;
+};
 
-	length() {
-		let chunk = this.firstChunk;
-		let length = 0;
-		do {
-			length += chunk.intro.length + chunk.content.length + chunk.outro.length;
-		} while ((chunk = chunk.next));
-		return length;
-	}
+MagicString.prototype.toString = function toString () {
+	var str = this.intro;
 
-	trimLines() {
-		return this.trim('[\\r\\n]');
+	var chunk = this.firstChunk;
+	while (chunk) {
+		str += chunk.toString();
+		chunk = chunk.next;
 	}
 
-	trim(charType) {
-		return this.trimStart(charType).trimEnd(charType);
-	}
+	return str + this.outro;
+};
 
-	trimEndAborted(charType) {
-		const rx = new RegExp((charType || '\\s') + '+$');
+MagicString.prototype.isEmpty = function isEmpty () {
+	var chunk = this.firstChunk;
+	do {
+		if (chunk.intro.length && chunk.intro.trim() ||
+				chunk.content.length && chunk.content.trim() ||
+				chunk.outro.length && chunk.outro.trim())
+			{ return false; }
+	} while (chunk = chunk.next);
+	return true;
+};
 
-		this.outro = this.outro.replace(rx, '');
-		if (this.outro.length) return true;
+MagicString.prototype.length = function length () {
+	var chunk = this.firstChunk;
+	var length = 0;
+	do {
+		length += chunk.intro.length + chunk.content.length + chunk.outro.length;
+	} while (chunk = chunk.next);
+	return length;
+};
 
-		let chunk = this.lastChunk;
+MagicString.prototype.trimLines = function trimLines () {
+	return this.trim('[\\r\\n]');
+};
 
-		do {
-			const end = chunk.end;
-			const aborted = chunk.trimEnd(rx);
+MagicString.prototype.trim = function trim (charType) {
+	return this.trimStart(charType).trimEnd(charType);
+};
 
-			// if chunk was trimmed, we have a new lastChunk
-			if (chunk.end !== end) {
-				if (this.lastChunk === chunk) {
-					this.lastChunk = chunk.next;
-				}
+MagicString.prototype.trimEndAborted = function trimEndAborted (charType) {
+	var rx = new RegExp((charType || '\\s') + '+$');
 
-				this.byEnd[chunk.end] = chunk;
-				this.byStart[chunk.next.start] = chunk.next;
-				this.byEnd[chunk.next.end] = chunk.next;
-			}
+	this.outro = this.outro.replace(rx, '');
+	if (this.outro.length) { return true; }
 
-			if (aborted) return true;
-			chunk = chunk.previous;
-		} while (chunk);
+	var chunk = this.lastChunk;
 
-		return false;
-	}
+	do {
+		var end = chunk.end;
+		var aborted = chunk.trimEnd(rx);
 
-	trimEnd(charType) {
-		this.trimEndAborted(charType);
-		return this;
-	}
-	trimStartAborted(charType) {
-		const rx = new RegExp('^' + (charType || '\\s') + '+');
+		// if chunk was trimmed, we have a new lastChunk
+		if (chunk.end !== end) {
+			if (this.lastChunk === chunk) {
+				this.lastChunk = chunk.next;
+			}
 
-		this.intro = this.intro.replace(rx, '');
-		if (this.intro.length) return true;
+			this.byEnd[chunk.end] = chunk;
+			this.byStart[chunk.next.start] = chunk.next;
+			this.byEnd[chunk.next.end] = chunk.next;
+		}
 
-		let chunk = this.firstChunk;
+		if (aborted) { return true; }
+		chunk = chunk.previous;
+	} while (chunk);
 
-		do {
-			const end = chunk.end;
-			const aborted = chunk.trimStart(rx);
+	return false;
+};
 
-			if (chunk.end !== end) {
-				// special case...
-				if (chunk === this.lastChunk) this.lastChunk = chunk.next;
-
-				this.byEnd[chunk.end] = chunk;
-				this.byStart[chunk.next.start] = chunk.next;
-				this.byEnd[chunk.next.end] = chunk.next;
-			}
+MagicString.prototype.trimEnd = function trimEnd (charType) {
+	this.trimEndAborted(charType);
+	return this;
+};
+MagicString.prototype.trimStartAborted = function trimStartAborted (charType) {
+	var rx = new RegExp('^' + (charType || '\\s') + '+');
 
-			if (aborted) return true;
-			chunk = chunk.next;
-		} while (chunk);
+	this.intro = this.intro.replace(rx, '');
+	if (this.intro.length) { return true; }
 
-		return false;
-	}
+	var chunk = this.firstChunk;
 
-	trimStart(charType) {
-		this.trimStartAborted(charType);
-		return this;
-	}
+	do {
+		var end = chunk.end;
+		var aborted = chunk.trimStart(rx);
 
-	hasChanged() {
-		return this.original !== this.toString();
-	}
+		if (chunk.end !== end) {
+			// special case...
+			if (chunk === this.lastChunk) { this.lastChunk = chunk.next; }
 
-	_replaceRegexp(searchValue, replacement) {
-		function getReplacement(match, str) {
-			if (typeof replacement === 'string') {
-				return replacement.replace(/\$(\$|&|\d+)/g, (_, i) => {
-					// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter
-					if (i === '$') return '$';
-					if (i === '&') return match[0];
-					const num = +i;
-					if (num < match.length) return match[+i];
-					return `$${i}`;
-				});
-			} else {
-				return replacement(...match, match.index, str, match.groups);
-			}
-		}
-		function matchAll(re, str) {
-			let match;
-			const matches = [];
-			while ((match = re.exec(str))) {
-				matches.push(match);
-			}
-			return matches;
-		}
-		if (searchValue.global) {
-			const matches = matchAll(searchValue, this.original);
-			matches.forEach((match) => {
-				if (match.index != null)
-					this.overwrite(
-						match.index,
-						match.index + match[0].length,
-						getReplacement(match, this.original)
-					);
-			});
-		} else {
-			const match = this.original.match(searchValue);
-			if (match && match.index != null)
-				this.overwrite(
-					match.index,
-					match.index + match[0].length,
-					getReplacement(match, this.original)
-				);
+			this.byEnd[chunk.end] = chunk;
+			this.byStart[chunk.next.start] = chunk.next;
+			this.byEnd[chunk.next.end] = chunk.next;
 		}
-		return this;
-	}
 
-	_replaceString(string, replacement) {
-		const { original } = this;
-		const index = original.indexOf(string);
+		if (aborted) { return true; }
+		chunk = chunk.next;
+	} while (chunk);
 
-		if (index !== -1) {
-			this.overwrite(index, index + string.length, replacement);
-		}
+	return false;
+};
 
-		return this;
-	}
+MagicString.prototype.trimStart = function trimStart (charType) {
+	this.trimStartAborted(charType);
+	return this;
+};
 
-	replace(searchValue, replacement) {
-		if (typeof searchValue === 'string') {
-			return this._replaceString(searchValue, replacement);
-		}
+var hasOwnProp = Object.prototype.hasOwnProperty;
 
-		return this._replaceRegexp(searchValue, replacement);
-	}
+var Bundle$1 = function Bundle(options) {
+	if ( options === void 0 ) options = {};
 
-	_replaceAllString(string, replacement) {
-		const { original } = this;
-		const stringLength = string.length;
-		for (
-			let index = original.indexOf(string);
-			index !== -1;
-			index = original.indexOf(string, index + stringLength)
-		) {
-			this.overwrite(index, index + stringLength, replacement);
-		}
+	this.intro = options.intro || '';
+	this.separator = options.separator !== undefined ? options.separator : '\n';
+	this.sources = [];
+	this.uniqueSources = [];
+	this.uniqueSourceIndexByFilename = {};
+};
 
-		return this;
+Bundle$1.prototype.addSource = function addSource (source) {
+	if (source instanceof MagicString) {
+		return this.addSource({
+			content: source,
+			filename: source.filename,
+			separator: this.separator
+		});
 	}
 
-	replaceAll(searchValue, replacement) {
-		if (typeof searchValue === 'string') {
-			return this._replaceAllString(searchValue, replacement);
-		}
-
-		if (!searchValue.global) {
-			throw new TypeError(
-				'MagicString.prototype.replaceAll called with a non-global RegExp argument'
-			);
-		}
-
-		return this._replaceRegexp(searchValue, replacement);
+	if (!isObject$1(source) || !source.content) {
+		throw new Error('bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`');
 	}
-}
 
-const hasOwnProp = Object.prototype.hasOwnProperty;
+	['filename', 'indentExclusionRanges', 'separator'].forEach(function (option) {
+		if (!hasOwnProp.call(source, option)) { source[option] = source.content[option]; }
+	});
 
-let Bundle$1 = class Bundle {
-	constructor(options = {}) {
-		this.intro = options.intro || '';
-		this.separator = options.separator !== undefined ? options.separator : '\n';
-		this.sources = [];
-		this.uniqueSources = [];
-		this.uniqueSourceIndexByFilename = {};
+	if (source.separator === undefined) {
+		// TODO there's a bunch of this sort of thing, needs cleaning up
+		source.separator = this.separator;
 	}
 
-	addSource(source) {
-		if (source instanceof MagicString) {
-			return this.addSource({
-				content: source,
-				filename: source.filename,
-				separator: this.separator,
-			});
-		}
-
-		if (!isObject$1(source) || !source.content) {
-			throw new Error(
-				'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`'
-			);
+	if (source.filename) {
+		if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {
+			this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;
+			this.uniqueSources.push({ filename: source.filename, content: source.content.original });
+		} else {
+			var uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];
+			if (source.content.original !== uniqueSource.content) {
+				throw new Error(("Illegal source: same filename (" + (source.filename) + "), different contents"));
+			}
 		}
+	}
 
-		['filename', 'indentExclusionRanges', 'separator'].forEach((option) => {
-			if (!hasOwnProp.call(source, option)) source[option] = source.content[option];
-		});
+	this.sources.push(source);
+	return this;
+};
 
-		if (source.separator === undefined) {
-			// TODO there's a bunch of this sort of thing, needs cleaning up
-			source.separator = this.separator;
-		}
+Bundle$1.prototype.append = function append (str, options) {
+	this.addSource({
+		content: new MagicString(str),
+		separator: (options && options.separator) || ''
+	});
 
-		if (source.filename) {
-			if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {
-				this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;
-				this.uniqueSources.push({ filename: source.filename, content: source.content.original });
-			} else {
-				const uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];
-				if (source.content.original !== uniqueSource.content) {
-					throw new Error(`Illegal source: same filename (${source.filename}), different contents`);
-				}
-			}
-		}
+	return this;
+};
 
-		this.sources.push(source);
-		return this;
-	}
+Bundle$1.prototype.clone = function clone () {
+	var bundle = new Bundle$1({
+		intro: this.intro,
+		separator: this.separator
+	});
 
-	append(str, options) {
-		this.addSource({
-			content: new MagicString(str),
-			separator: (options && options.separator) || '',
+	this.sources.forEach(function (source) {
+		bundle.addSource({
+			filename: source.filename,
+			content: source.content.clone(),
+			separator: source.separator
 		});
+	});
 
-		return this;
-	}
+	return bundle;
+};
 
-	clone() {
-		const bundle = new Bundle$1({
-			intro: this.intro,
-			separator: this.separator,
-		});
+Bundle$1.prototype.generateDecodedMap = function generateDecodedMap (options) {
+		var this$1$1 = this;
+		if ( options === void 0 ) options = {};
 
-		this.sources.forEach((source) => {
-			bundle.addSource({
-				filename: source.filename,
-				content: source.content.clone(),
-				separator: source.separator,
-			});
+	var names = [];
+	this.sources.forEach(function (source) {
+		Object.keys(source.content.storedNames).forEach(function (name) {
+			if (!~names.indexOf(name)) { names.push(name); }
 		});
+	});
 
-		return bundle;
-	}
-
-	generateDecodedMap(options = {}) {
-		const names = [];
-		this.sources.forEach((source) => {
-			Object.keys(source.content.storedNames).forEach((name) => {
-				if (!~names.indexOf(name)) names.push(name);
-			});
-		});
+	var mappings = new Mappings(options.hires);
 
-		const mappings = new Mappings(options.hires);
+	if (this.intro) {
+		mappings.advance(this.intro);
+	}
 
-		if (this.intro) {
-			mappings.advance(this.intro);
+	this.sources.forEach(function (source, i) {
+		if (i > 0) {
+			mappings.advance(this$1$1.separator);
 		}
 
-		this.sources.forEach((source, i) => {
-			if (i > 0) {
-				mappings.advance(this.separator);
-			}
-
-			const sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;
-			const magicString = source.content;
-			const locate = getLocator(magicString.original);
+		var sourceIndex = source.filename ? this$1$1.uniqueSourceIndexByFilename[source.filename] : -1;
+		var magicString = source.content;
+		var locate = getLocator(magicString.original);
 
-			if (magicString.intro) {
-				mappings.advance(magicString.intro);
-			}
+		if (magicString.intro) {
+			mappings.advance(magicString.intro);
+		}
 
-			magicString.firstChunk.eachNext((chunk) => {
-				const loc = locate(chunk.start);
+		magicString.firstChunk.eachNext(function (chunk) {
+			var loc = locate(chunk.start);
 
-				if (chunk.intro.length) mappings.advance(chunk.intro);
+			if (chunk.intro.length) { mappings.advance(chunk.intro); }
 
-				if (source.filename) {
-					if (chunk.edited) {
-						mappings.addEdit(
-							sourceIndex,
-							chunk.content,
-							loc,
-							chunk.storeName ? names.indexOf(chunk.original) : -1
-						);
-					} else {
-						mappings.addUneditedChunk(
-							sourceIndex,
-							chunk,
-							magicString.original,
-							loc,
-							magicString.sourcemapLocations
-						);
-					}
+			if (source.filename) {
+				if (chunk.edited) {
+					mappings.addEdit(
+						sourceIndex,
+						chunk.content,
+						loc,
+						chunk.storeName ? names.indexOf(chunk.original) : -1
+					);
 				} else {
-					mappings.advance(chunk.content);
+					mappings.addUneditedChunk(
+						sourceIndex,
+						chunk,
+						magicString.original,
+						loc,
+						magicString.sourcemapLocations
+					);
 				}
-
-				if (chunk.outro.length) mappings.advance(chunk.outro);
-			});
-
-			if (magicString.outro) {
-				mappings.advance(magicString.outro);
+			} else {
+				mappings.advance(chunk.content);
 			}
+
+			if (chunk.outro.length) { mappings.advance(chunk.outro); }
 		});
 
-		return {
-			file: options.file ? options.file.split(/[/\\]/).pop() : null,
-			sources: this.uniqueSources.map((source) => {
-				return options.file ? getRelativePath(options.file, source.filename) : source.filename;
-			}),
-			sourcesContent: this.uniqueSources.map((source) => {
-				return options.includeContent ? source.content : null;
-			}),
-			names,
-			mappings: mappings.raw,
-		};
-	}
+		if (magicString.outro) {
+			mappings.advance(magicString.outro);
+		}
+	});
 
-	generateMap(options) {
-		return new SourceMap(this.generateDecodedMap(options));
-	}
+	return {
+		file: options.file ? options.file.split(/[/\\]/).pop() : null,
+		sources: this.uniqueSources.map(function (source) {
+			return options.file ? getRelativePath(options.file, source.filename) : source.filename;
+		}),
+		sourcesContent: this.uniqueSources.map(function (source) {
+			return options.includeContent ? source.content : null;
+		}),
+		names: names,
+		mappings: mappings.raw
+	};
+};
 
-	getIndentString() {
-		const indentStringCounts = {};
+Bundle$1.prototype.generateMap = function generateMap (options) {
+	return new SourceMap(this.generateDecodedMap(options));
+};
 
-		this.sources.forEach((source) => {
-			const indentStr = source.content._getRawIndentString();
+Bundle$1.prototype.getIndentString = function getIndentString () {
+	var indentStringCounts = {};
 
-			if (indentStr === null) return;
+	this.sources.forEach(function (source) {
+		var indentStr = source.content.indentStr;
 
-			if (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;
-			indentStringCounts[indentStr] += 1;
-		});
+		if (indentStr === null) { return; }
 
-		return (
-			Object.keys(indentStringCounts).sort((a, b) => {
-				return indentStringCounts[a] - indentStringCounts[b];
-			})[0] || '\t'
-		);
-	}
+		if (!indentStringCounts[indentStr]) { indentStringCounts[indentStr] = 0; }
+		indentStringCounts[indentStr] += 1;
+	});
 
-	indent(indentStr) {
-		if (!arguments.length) {
-			indentStr = this.getIndentString();
-		}
+	return (
+		Object.keys(indentStringCounts).sort(function (a, b) {
+			return indentStringCounts[a] - indentStringCounts[b];
+		})[0] || '\t'
+	);
+};
 
-		if (indentStr === '') return this; // noop
+Bundle$1.prototype.indent = function indent (indentStr) {
+		var this$1$1 = this;
 
-		let trailingNewline = !this.intro || this.intro.slice(-1) === '\n';
+	if (!arguments.length) {
+		indentStr = this.getIndentString();
+	}
 
-		this.sources.forEach((source, i) => {
-			const separator = source.separator !== undefined ? source.separator : this.separator;
-			const indentStart = trailingNewline || (i > 0 && /\r?\n$/.test(separator));
+	if (indentStr === '') { return this; } // noop
 
-			source.content.indent(indentStr, {
-				exclude: source.indentExclusionRanges,
-				indentStart, //: trailingNewline || /\r?\n$/.test( separator )  //true///\r?\n/.test( separator )
-			});
+	var trailingNewline = !this.intro || this.intro.slice(-1) === '\n';
+
+	this.sources.forEach(function (source, i) {
+		var separator = source.separator !== undefined ? source.separator : this$1$1.separator;
+		var indentStart = trailingNewline || (i > 0 && /\r?\n$/.test(separator));
 
-			trailingNewline = source.content.lastChar() === '\n';
+		source.content.indent(indentStr, {
+			exclude: source.indentExclusionRanges,
+			indentStart: indentStart //: trailingNewline || /\r?\n$/.test( separator )  //true///\r?\n/.test( separator )
 		});
 
-		if (this.intro) {
-			this.intro =
-				indentStr +
-				this.intro.replace(/^[^\n]/gm, (match, index) => {
-					return index > 0 ? indentStr + match : match;
-				});
-		}
+		trailingNewline = source.content.lastChar() === '\n';
+	});
 
-		return this;
+	if (this.intro) {
+		this.intro =
+			indentStr +
+			this.intro.replace(/^[^\n]/gm, function (match, index) {
+				return index > 0 ? indentStr + match : match;
+			});
 	}
 
-	prepend(str) {
-		this.intro = str + this.intro;
-		return this;
-	}
+	return this;
+};
 
-	toString() {
-		const body = this.sources
-			.map((source, i) => {
-				const separator = source.separator !== undefined ? source.separator : this.separator;
-				const str = (i > 0 ? separator : '') + source.content.toString();
-
-				return str;
-			})
-			.join('');
+Bundle$1.prototype.prepend = function prepend (str) {
+	this.intro = str + this.intro;
+	return this;
+};
 
-		return this.intro + body;
-	}
+Bundle$1.prototype.toString = function toString () {
+		var this$1$1 = this;
 
-	isEmpty() {
-		if (this.intro.length && this.intro.trim()) return false;
-		if (this.sources.some((source) => !source.content.isEmpty())) return false;
-		return true;
-	}
+	var body = this.sources
+		.map(function (source, i) {
+			var separator = source.separator !== undefined ? source.separator : this$1$1.separator;
+			var str = (i > 0 ? separator : '') + source.content.toString();
 
-	length() {
-		return this.sources.reduce(
-			(length, source) => length + source.content.length(),
-			this.intro.length
-		);
-	}
+			return str;
+		})
+		.join('');
 
-	trimLines() {
-		return this.trim('[\\r\\n]');
-	}
+	return this.intro + body;
+};
 
-	trim(charType) {
-		return this.trimStart(charType).trimEnd(charType);
-	}
+Bundle$1.prototype.isEmpty = function isEmpty () {
+	if (this.intro.length && this.intro.trim())
+		{ return false; }
+	if (this.sources.some(function (source) { return !source.content.isEmpty(); }))
+		{ return false; }
+	return true;
+};
 
-	trimStart(charType) {
-		const rx = new RegExp('^' + (charType || '\\s') + '+');
-		this.intro = this.intro.replace(rx, '');
+Bundle$1.prototype.length = function length () {
+	return this.sources.reduce(function (length, source) { return length + source.content.length(); }, this.intro.length);
+};
 
-		if (!this.intro) {
-			let source;
-			let i = 0;
-
-			do {
-				source = this.sources[i++];
-				if (!source) {
-					break;
-				}
-			} while (!source.content.trimStartAborted(charType));
-		}
+Bundle$1.prototype.trimLines = function trimLines () {
+	return this.trim('[\\r\\n]');
+};
 
-		return this;
-	}
+Bundle$1.prototype.trim = function trim (charType) {
+	return this.trimStart(charType).trimEnd(charType);
+};
 
-	trimEnd(charType) {
-		const rx = new RegExp((charType || '\\s') + '+$');
+Bundle$1.prototype.trimStart = function trimStart (charType) {
+	var rx = new RegExp('^' + (charType || '\\s') + '+');
+	this.intro = this.intro.replace(rx, '');
 
-		let source;
-		let i = this.sources.length - 1;
+	if (!this.intro) {
+		var source;
+		var i = 0;
 
 		do {
-			source = this.sources[i--];
+			source = this.sources[i++];
 			if (!source) {
-				this.intro = this.intro.replace(rx, '');
 				break;
 			}
-		} while (!source.content.trimEndAborted(charType));
-
-		return this;
+		} while (!source.content.trimStartAborted(charType));
 	}
+
+	return this;
 };
 
-const needsEscapeRegEx = /[\n\r'\\\u2028\u2029]/;
-const quoteNewlineRegEx = /([\n\r'\u2028\u2029])/g;
-const backSlashRegEx = /\\/g;
-function escapeId(id) {
-    if (!needsEscapeRegEx.test(id))
-        return id;
-    return id.replace(backSlashRegEx, '\\\\').replace(quoteNewlineRegEx, '\\$1');
-}
+Bundle$1.prototype.trimEnd = function trimEnd (charType) {
+	var rx = new RegExp((charType || '\\s') + '+$');
 
-class ExternalChunk {
-    constructor(module, options, inputBase) {
-        this.options = options;
-        this.inputBase = inputBase;
-        this.defaultVariableName = '';
-        this.namespaceVariableName = '';
-        this.variableName = '';
-        this.fileName = null;
-        this.importAssertions = null;
-        this.id = module.id;
-        this.moduleInfo = module.info;
-        this.renormalizeRenderPath = module.renormalizeRenderPath;
-        this.suggestedVariableName = module.suggestedVariableName;
-    }
-    getFileName() {
-        if (this.fileName) {
-            return this.fileName;
-        }
-        const { paths } = this.options;
-        return (this.fileName =
-            (typeof paths === 'function' ? paths(this.id) : paths[this.id]) ||
-                (this.renormalizeRenderPath ? normalize(node_path.relative(this.inputBase, this.id)) : this.id));
-    }
-    getImportAssertions(snippets) {
-        return (this.importAssertions || (this.importAssertions = formatAssertions(this.options.format === 'es' &&
-            this.options.externalImportAssertions &&
-            this.moduleInfo.assertions, snippets)));
-    }
-    getImportPath(importer) {
-        return escapeId(this.renormalizeRenderPath
-            ? getImportPath(importer, this.getFileName(), this.options.format === 'amd', false)
-            : this.getFileName());
+	var source;
+	var i = this.sources.length - 1;
+
+	do {
+		source = this.sources[i--];
+		if (!source) {
+			this.intro = this.intro.replace(rx, '');
+			break;
+		}
+	} while (!source.content.trimEndAborted(charType));
+
+	return this;
+};
+
+const MagicString$1 = MagicString;
+
+function relative(from, to) {
+    const fromParts = from.split(/[/\\]/).filter(Boolean);
+    const toParts = to.split(/[/\\]/).filter(Boolean);
+    if (fromParts[0] === '.')
+        fromParts.shift();
+    if (toParts[0] === '.')
+        toParts.shift();
+    while (fromParts[0] && toParts[0] && fromParts[0] === toParts[0]) {
+        fromParts.shift();
+        toParts.shift();
     }
-}
-function formatAssertions(assertions, { getObject }) {
-    if (!assertions) {
-        return null;
+    while (toParts[0] === '..' && fromParts.length > 0) {
+        toParts.shift();
+        fromParts.pop();
     }
-    const assertionEntries = Object.entries(assertions).map(([key, value]) => [key, `'${value}'`]);
-    if (assertionEntries.length > 0) {
-        return getObject(assertionEntries, { lineBreakIndent: null });
+    while (fromParts.pop()) {
+        toParts.unshift('..');
     }
-    return null;
+    return toParts.join('/');
 }
 
 function getOrCreate(map, key, init) {
     const existing = map.get(key);
-    if (existing !== undefined) {
+    if (existing) {
         return existing;
     }
     const value = init();
     map.set(key, value);
     return value;
 }
-function getNewSet() {
-    return new Set();
-}
-function getNewArray() {
-    return [];
-}
 
 const UnknownKey = Symbol('Unknown Key');
-const UnknownNonAccessorKey = Symbol('Unknown Non-Accessor Key');
 const UnknownInteger = Symbol('Unknown Integer');
-const SymbolToStringTag = Symbol('Symbol.toStringTag');
 const EMPTY_PATH = [];
 const UNKNOWN_PATH = [UnknownKey];
-// For deoptimizations, this means we are modifying an unknown property but did
-// not lose track of the object or are creating a setter/getter;
-// For assignment effects it means we do not check for setter/getter effects
-// but only if something is mutated that is included, which is relevant for
-// Object.defineProperty
-const UNKNOWN_NON_ACCESSOR_PATH = [UnknownNonAccessorKey];
 const UNKNOWN_INTEGER_PATH = [UnknownInteger];
 const EntitiesKey = Symbol('Entities');
 class PathTracker {
@@ -3001,7 +2132,7 @@
                 currentPaths[pathSegment] ||
                     Object.create(null, { [EntitiesKey]: { value: new Map() } });
         }
-        const trackedEntities = getOrCreate(currentPaths[EntitiesKey], discriminator, getNewSet);
+        const trackedEntities = getOrCreate(currentPaths[EntitiesKey], discriminator, () => new Set());
         if (trackedEntities.has(entity))
             return true;
         trackedEntities.add(entity);
@@ -3010,78 +2141,51 @@
 }
 
 const UnknownValue = Symbol('Unknown Value');
-const UnknownTruthyValue = Symbol('Unknown Truthy Value');
 class ExpressionEntity {
     constructor() {
         this.included = false;
     }
     deoptimizePath(_path) { }
-    deoptimizeThisOnInteractionAtPath({ thisArg }, _path, _recursionTracker) {
-        thisArg.deoptimizePath(UNKNOWN_PATH);
+    deoptimizeThisOnEventAtPath(_event, _path, thisParameter, _recursionTracker) {
+        thisParameter.deoptimizePath(UNKNOWN_PATH);
     }
     /**
      * If possible it returns a stringifyable literal value for this node that can be used
      * for inlining or comparing values.
-     * Otherwise, it should return UnknownValue.
+     * Otherwise it should return UnknownValue.
      */
     getLiteralValueAtPath(_path, _recursionTracker, _origin) {
         return UnknownValue;
     }
-    getReturnExpressionWhenCalledAtPath(_path, _interaction, _recursionTracker, _origin) {
-        return UNKNOWN_RETURN_EXPRESSION;
+    getReturnExpressionWhenCalledAtPath(_path, _callOptions, _recursionTracker, _origin) {
+        return UNKNOWN_EXPRESSION;
     }
-    hasEffectsOnInteractionAtPath(_path, _interaction, _context) {
+    hasEffectsWhenAccessedAtPath(_path, _context) {
         return true;
     }
-    include(_context, _includeChildrenRecursively, _options) {
+    hasEffectsWhenAssignedAtPath(_path, _context) {
+        return true;
+    }
+    hasEffectsWhenCalledAtPath(_path, _callOptions, _context) {
+        return true;
+    }
+    include(_context, _includeChildrenRecursively) {
         this.included = true;
     }
-    includeCallArguments(context, parameters) {
-        for (const argument of parameters) {
-            argument.include(context, false);
+    includeCallArguments(context, args) {
+        for (const arg of args) {
+            arg.include(context, false);
         }
     }
-    shouldBeIncluded(_context) {
-        return true;
-    }
 }
 const UNKNOWN_EXPRESSION = new (class UnknownExpression extends ExpressionEntity {
 })();
-const UNKNOWN_RETURN_EXPRESSION = [
-    UNKNOWN_EXPRESSION,
-    false
-];
-
-const INTERACTION_ACCESSED = 0;
-const INTERACTION_ASSIGNED = 1;
-const INTERACTION_CALLED = 2;
-const NODE_INTERACTION_UNKNOWN_ACCESS = {
-    thisArg: null,
-    type: INTERACTION_ACCESSED
-};
-const UNKNOWN_ARG = [UNKNOWN_EXPRESSION];
-const NODE_INTERACTION_UNKNOWN_ASSIGNMENT = {
-    args: UNKNOWN_ARG,
-    thisArg: null,
-    type: INTERACTION_ASSIGNED
-};
-const NO_ARGS = [];
-// While this is technically a call without arguments, we can compare against
-// this reference in places where precise values or thisArg would make a
-// difference
-const NODE_INTERACTION_UNKNOWN_CALL = {
-    args: NO_ARGS,
-    thisArg: null,
-    type: INTERACTION_CALLED,
-    withNew: false
-};
 
 class Variable extends ExpressionEntity {
     constructor(name) {
         super();
         this.name = name;
         this.alwaysRendered = false;
-        this.forbiddenNames = null;
         this.initReached = false;
         this.isId = false;
         this.isReassigned = false;
@@ -3094,13 +2198,6 @@
      * Necessary to be able to change variable names.
      */
     addReference(_identifier) { }
-    /**
-     * Prevent this variable from being renamed to this name to avoid name
-     * collisions
-     */
-    forbidName(name) {
-        (this.forbiddenNames || (this.forbiddenNames = new Set())).add(name);
-    }
     getBaseVariableName() {
         return this.renderBaseName || this.renderName || this.name;
     }
@@ -3108,8 +2205,8 @@
         const name = this.renderName || this.name;
         return this.renderBaseName ? `${this.renderBaseName}${getPropertyAccess(name)}` : name;
     }
-    hasEffectsOnInteractionAtPath(path, { type }, _context) {
-        return type !== INTERACTION_ACCESSED || path.length > 0;
+    hasEffectsWhenAccessedAtPath(path, _context) {
+        return path.length > 0;
     }
     /**
      * Marks this variable as being part of the bundle, which is usually the case when one of
@@ -3140,8 +2237,8 @@
             this.module.suggestName(identifier.name);
         }
     }
-    hasEffectsOnInteractionAtPath(path, { type }) {
-        return type !== INTERACTION_ACCESSED || path.length > (this.isNamespace ? 1 : 0);
+    hasEffectsWhenAccessedAtPath(path) {
+        return path.length > (this.isNamespace ? 1 : 0);
     }
     include() {
         if (!this.included) {
@@ -3151,206 +2248,126 @@
     }
 }
 
-const RESERVED_NAMES = new Set([
-    'await',
-    'break',
-    'case',
-    'catch',
-    'class',
-    'const',
-    'continue',
-    'debugger',
-    'default',
-    'delete',
-    'do',
-    'else',
-    'enum',
-    'eval',
-    'export',
-    'extends',
-    'false',
-    'finally',
-    'for',
-    'function',
-    'if',
-    'implements',
-    'import',
-    'in',
-    'instanceof',
-    'interface',
-    'let',
-    'NaN',
-    'new',
-    'null',
-    'package',
-    'private',
-    'protected',
-    'public',
-    'return',
-    'static',
-    'super',
-    'switch',
-    'this',
-    'throw',
-    'true',
-    'try',
-    'typeof',
-    'undefined',
-    'var',
-    'void',
-    'while',
-    'with',
-    'yield'
-]);
-const RESERVED_NAMES$1 = RESERVED_NAMES;
-
-const illegalCharacters = /[^\w$]/g;
-const startsWithDigit = (value) => /\d/.test(value[0]);
-const needsEscape = (value) => startsWithDigit(value) || RESERVED_NAMES$1.has(value) || value === 'arguments';
-function isLegal(value) {
-    if (needsEscape(value)) {
+const BLANK = Object.freeze(Object.create(null));
+const EMPTY_OBJECT = Object.freeze({});
+const EMPTY_ARRAY = Object.freeze([]);
+
+const reservedWords$2 = 'break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public'.split(' ');
+const builtins$2 = 'Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl'.split(' ');
+const blacklisted = new Set(reservedWords$2.concat(builtins$2));
+const illegalCharacters = /[^$_a-zA-Z0-9]/g;
+const startsWithDigit = (str) => /\d/.test(str[0]);
+function isLegal(str) {
+    if (startsWithDigit(str) || blacklisted.has(str)) {
         return false;
     }
-    return !illegalCharacters.test(value);
+    return !illegalCharacters.test(str);
 }
-function makeLegal(value) {
-    value = value
-        .replace(/-(\w)/g, (_, letter) => letter.toUpperCase())
-        .replace(illegalCharacters, '_');
-    if (needsEscape(value))
-        value = `_${value}`;
-    return value || '_';
+function makeLegal(str) {
+    str = str.replace(/-(\w)/g, (_, letter) => letter.toUpperCase()).replace(illegalCharacters, '_');
+    if (startsWithDigit(str) || blacklisted.has(str))
+        str = `_${str}`;
+    return str || '_';
 }
 
 class ExternalModule {
-    constructor(options, id, moduleSideEffects, meta, renormalizeRenderPath, assertions) {
+    constructor(options, id, hasModuleSideEffects, meta, renormalizeRenderPath) {
         this.options = options;
         this.id = id;
         this.renormalizeRenderPath = renormalizeRenderPath;
+        this.declarations = Object.create(null);
+        this.defaultVariableName = '';
         this.dynamicImporters = [];
         this.execIndex = Infinity;
         this.exportedVariables = new Map();
         this.importers = [];
+        this.mostCommonSuggestion = 0;
+        this.nameSuggestions = Object.create(null);
+        this.namespaceVariableName = '';
         this.reexported = false;
+        this.renderPath = undefined;
         this.used = false;
-        this.declarations = new Map();
-        this.mostCommonSuggestion = 0;
-        this.nameSuggestions = new Map();
-        this.suggestedVariableName = makeLegal(id.split(/[/\\]/).pop());
+        this.variableName = '';
+        this.suggestedVariableName = makeLegal(id.split(/[\\/]/).pop());
         const { importers, dynamicImporters } = this;
-        const info = (this.info = {
-            assertions,
+        this.info = {
             ast: null,
             code: null,
-            dynamicallyImportedIdResolutions: EMPTY_ARRAY,
             dynamicallyImportedIds: EMPTY_ARRAY,
             get dynamicImporters() {
                 return dynamicImporters.sort();
             },
-            exportedBindings: null,
-            exports: null,
-            hasDefaultExport: null,
-            get hasModuleSideEffects() {
-                warnDeprecation('Accessing ModuleInfo.hasModuleSideEffects from plugins is deprecated. Please use ModuleInfo.moduleSideEffects instead.', URL_THIS_GETMODULEINFO, true, options);
-                return info.moduleSideEffects;
-            },
+            hasModuleSideEffects,
             id,
             implicitlyLoadedAfterOneOf: EMPTY_ARRAY,
             implicitlyLoadedBefore: EMPTY_ARRAY,
-            importedIdResolutions: EMPTY_ARRAY,
             importedIds: EMPTY_ARRAY,
             get importers() {
                 return importers.sort();
             },
             isEntry: false,
             isExternal: true,
-            isIncluded: null,
             meta,
-            moduleSideEffects,
             syntheticNamedExports: false
-        });
-        // Hide the deprecated key so that it only warns when accessed explicitly
-        Object.defineProperty(this.info, 'hasModuleSideEffects', {
-            enumerable: false
-        });
+        };
     }
     getVariableForExportName(name) {
-        const declaration = this.declarations.get(name);
+        let declaration = this.declarations[name];
         if (declaration)
-            return [declaration];
-        const externalVariable = new ExternalVariable(this, name);
-        this.declarations.set(name, externalVariable);
-        this.exportedVariables.set(externalVariable, name);
-        return [externalVariable];
+            return declaration;
+        this.declarations[name] = declaration = new ExternalVariable(this, name);
+        this.exportedVariables.set(declaration, name);
+        return declaration;
+    }
+    setRenderPath(options, inputBase) {
+        this.renderPath =
+            typeof options.paths === 'function' ? options.paths(this.id) : options.paths[this.id];
+        if (!this.renderPath) {
+            this.renderPath = this.renormalizeRenderPath
+                ? normalize(path$2.relative(inputBase, this.id))
+                : this.id;
+        }
+        return this.renderPath;
     }
     suggestName(name) {
-        const value = (this.nameSuggestions.get(name) ?? 0) + 1;
-        this.nameSuggestions.set(name, value);
-        if (value > this.mostCommonSuggestion) {
-            this.mostCommonSuggestion = value;
+        if (!this.nameSuggestions[name])
+            this.nameSuggestions[name] = 0;
+        this.nameSuggestions[name] += 1;
+        if (this.nameSuggestions[name] > this.mostCommonSuggestion) {
+            this.mostCommonSuggestion = this.nameSuggestions[name];
             this.suggestedVariableName = name;
         }
     }
     warnUnusedImports() {
-        const unused = [...this.declarations]
-            .filter(([name, declaration]) => name !== '*' && !declaration.included && !this.reexported && !declaration.referenced)
-            .map(([name]) => name);
+        const unused = Object.keys(this.declarations).filter(name => {
+            if (name === '*')
+                return false;
+            const declaration = this.declarations[name];
+            return !declaration.included && !this.reexported && !declaration.referenced;
+        });
         if (unused.length === 0)
             return;
         const importersSet = new Set();
         for (const name of unused) {
-            for (const importer of this.declarations.get(name).module.importers) {
+            const { importers } = this.declarations[name].module;
+            for (const importer of importers) {
                 importersSet.add(importer);
             }
         }
         const importersArray = [...importersSet];
-        this.options.onwarn(errorUnusedExternalImports(this.id, unused, importersArray));
+        this.options.onwarn({
+            code: 'UNUSED_EXTERNAL_IMPORT',
+            message: `${printQuotedStringList(unused, ['is', 'are'])} imported from external module "${this.id}" but never used in ${printQuotedStringList(importersArray.map(importer => relativeId(importer)))}.`,
+            names: unused,
+            source: this.id,
+            sources: importersArray
+        });
     }
 }
 
-var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
-
-function getDefaultExportFromCjs (x) {
-	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
-}
-
-function getAugmentedNamespace(n) {
-  if (n.__esModule) return n;
-  var f = n.default;
-	if (typeof f == "function") {
-		var a = function a () {
-			if (this instanceof a) {
-				var args = [null];
-				args.push.apply(args, arguments);
-				var Ctor = Function.bind.apply(f, args);
-				return new Ctor();
-			}
-			return f.apply(this, arguments);
-		};
-		a.prototype = f.prototype;
-  } else a = {};
-  Object.defineProperty(a, '__esModule', {value: true});
-	Object.keys(n).forEach(function (k) {
-		var d = Object.getOwnPropertyDescriptor(n, k);
-		Object.defineProperty(a, k, d.get ? d : {
-			enumerable: true,
-			get: function () {
-				return n[k];
-			}
-		});
-	});
-	return a;
-}
-
-exports.picomatchExports = {};
-var picomatch$1 = {
-  get exports(){ return exports.picomatchExports; },
-  set exports(v){ exports.picomatchExports = v; },
-};
-
 var utils$3 = {};
 
-const path$1 = require$$0$1;
+const path$1 = path$2;
 const WIN_SLASH = '\\\\/';
 const WIN_NO_SLASH = `[^${WIN_SLASH}]`;
 
@@ -3530,69 +2547,69 @@
 
 (function (exports) {
 
-	const path = require$$0$1;
-	const win32 = process.platform === 'win32';
-	const {
-	  REGEX_BACKSLASH,
-	  REGEX_REMOVE_BACKSLASH,
-	  REGEX_SPECIAL_CHARS,
-	  REGEX_SPECIAL_CHARS_GLOBAL
-	} = constants$2;
-
-	exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);
-	exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);
-	exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);
-	exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
-	exports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');
-
-	exports.removeBackslashes = str => {
-	  return str.replace(REGEX_REMOVE_BACKSLASH, match => {
-	    return match === '\\' ? '' : match;
-	  });
-	};
+const path = path$2;
+const win32 = process.platform === 'win32';
+const {
+  REGEX_BACKSLASH,
+  REGEX_REMOVE_BACKSLASH,
+  REGEX_SPECIAL_CHARS,
+  REGEX_SPECIAL_CHARS_GLOBAL
+} = constants$2;
 
-	exports.supportsLookbehinds = () => {
-	  const segs = process.version.slice(1).split('.').map(Number);
-	  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {
-	    return true;
-	  }
-	  return false;
-	};
+exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);
+exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);
+exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);
+exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
+exports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');
+
+exports.removeBackslashes = str => {
+  return str.replace(REGEX_REMOVE_BACKSLASH, match => {
+    return match === '\\' ? '' : match;
+  });
+};
 
-	exports.isWindows = options => {
-	  if (options && typeof options.windows === 'boolean') {
-	    return options.windows;
-	  }
-	  return win32 === true || path.sep === '\\';
-	};
+exports.supportsLookbehinds = () => {
+  const segs = process.version.slice(1).split('.').map(Number);
+  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {
+    return true;
+  }
+  return false;
+};
 
-	exports.escapeLast = (input, char, lastIdx) => {
-	  const idx = input.lastIndexOf(char, lastIdx);
-	  if (idx === -1) return input;
-	  if (input[idx - 1] === '\\') return exports.escapeLast(input, char, idx - 1);
-	  return `${input.slice(0, idx)}\\${input.slice(idx)}`;
-	};
+exports.isWindows = options => {
+  if (options && typeof options.windows === 'boolean') {
+    return options.windows;
+  }
+  return win32 === true || path.sep === '\\';
+};
 
-	exports.removePrefix = (input, state = {}) => {
-	  let output = input;
-	  if (output.startsWith('./')) {
-	    output = output.slice(2);
-	    state.prefix = './';
-	  }
-	  return output;
-	};
+exports.escapeLast = (input, char, lastIdx) => {
+  const idx = input.lastIndexOf(char, lastIdx);
+  if (idx === -1) return input;
+  if (input[idx - 1] === '\\') return exports.escapeLast(input, char, idx - 1);
+  return `${input.slice(0, idx)}\\${input.slice(idx)}`;
+};
 
-	exports.wrapOutput = (input, state = {}, options = {}) => {
-	  const prepend = options.contains ? '' : '^';
-	  const append = options.contains ? '' : '$';
-
-	  let output = `${prepend}(?:${input})${append}`;
-	  if (state.negated === true) {
-	    output = `(?:^(?!${output}).*$)`;
-	  }
-	  return output;
-	};
-} (utils$3));
+exports.removePrefix = (input, state = {}) => {
+  let output = input;
+  if (output.startsWith('./')) {
+    output = output.slice(2);
+    state.prefix = './';
+  }
+  return output;
+};
+
+exports.wrapOutput = (input, state = {}, options = {}) => {
+  const prepend = options.contains ? '' : '^';
+  const append = options.contains ? '' : '$';
+
+  let output = `${prepend}(?:${input})${append}`;
+  if (state.negated === true) {
+    output = `(?:^(?!${output}).*$)`;
+  }
+  return output;
+};
+}(utils$3));
 
 const utils$2 = utils$3;
 const {
@@ -4029,7 +3046,7 @@
  * @return {Object}
  */
 
-const parse$2 = (input, options) => {
+const parse$1 = (input, options) => {
   if (typeof input !== 'string') {
     throw new TypeError('Expected a string');
   }
@@ -4227,14 +3244,7 @@
       }
 
       if (token.inner.includes('*') && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
-        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.
-        // In this case, we need to parse the string and use it in the output of the original pattern.
-        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.
-        //
-        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.
-        const expression = parse$2(rest, { ...options, fastpaths: false }).output;
-
-        output = token.close = `)${expression})${extglobStar})`;
+        output = token.close = `)${rest})${extglobStar})`;
       }
 
       if (token.prev.type === 'bos') {
@@ -4978,7 +3988,7 @@
  * impact when none of the fast paths match.
  */
 
-parse$2.fastpaths = (input, options) => {
+parse$1.fastpaths = (input, options) => {
   const opts = { ...options };
   const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
   const len = input.length;
@@ -5065,11 +4075,11 @@
   return source;
 };
 
-var parse_1 = parse$2;
+var parse_1 = parse$1;
 
-const path = require$$0$1;
+const path = path$2;
 const scan = scan_1;
-const parse$1 = parse_1;
+const parse = parse_1;
 const utils = utils$3;
 const constants = constants$2;
 const isObject = val => val && typeof val === 'object' && !Array.isArray(val);
@@ -5096,9 +4106,9 @@
  * @api public
  */
 
-const picomatch = (glob, options, returnState = false) => {
+const picomatch$1 = (glob, options, returnState = false) => {
   if (Array.isArray(glob)) {
-    const fns = glob.map(input => picomatch(input, options, returnState));
+    const fns = glob.map(input => picomatch$1(input, options, returnState));
     const arrayMatcher = str => {
       for (const isMatch of fns) {
         const state = isMatch(str);
@@ -5118,8 +4128,8 @@
   const opts = options || {};
   const posix = utils.isWindows(options);
   const regex = isState
-    ? picomatch.compileRe(glob, options)
-    : picomatch.makeRe(glob, options, false, true);
+    ? picomatch$1.compileRe(glob, options)
+    : picomatch$1.makeRe(glob, options, false, true);
 
   const state = regex.state;
   delete regex.state;
@@ -5127,11 +4137,11 @@
   let isIgnored = () => false;
   if (opts.ignore) {
     const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
-    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
+    isIgnored = picomatch$1(opts.ignore, ignoreOpts, returnState);
   }
 
   const matcher = (input, returnObject = false) => {
-    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
+    const { isMatch, match, output } = picomatch$1.test(input, regex, options, { glob, posix });
     const result = { glob, state, regex, posix, input, output, match, isMatch };
 
     if (typeof opts.onResult === 'function') {
@@ -5181,7 +4191,7 @@
  * @api public
  */
 
-picomatch.test = (input, regex, options, { glob, posix } = {}) => {
+picomatch$1.test = (input, regex, options, { glob, posix } = {}) => {
   if (typeof input !== 'string') {
     throw new TypeError('Expected input to be a string');
   }
@@ -5202,7 +4212,7 @@
 
   if (match === false || opts.capture === true) {
     if (opts.matchBase === true || opts.basename === true) {
-      match = picomatch.matchBase(input, regex, options, posix);
+      match = picomatch$1.matchBase(input, regex, options, posix);
     } else {
       match = regex.exec(output);
     }
@@ -5225,8 +4235,8 @@
  * @api public
  */
 
-picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
-  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
+picomatch$1.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
+  const regex = glob instanceof RegExp ? glob : picomatch$1.makeRe(glob, options);
   return regex.test(path.basename(input));
 };
 
@@ -5247,7 +4257,7 @@
  * @api public
  */
 
-picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
+picomatch$1.isMatch = (str, patterns, options) => picomatch$1(patterns, options)(str);
 
 /**
  * Parse a glob pattern to create the source string for a regular
@@ -5263,9 +4273,9 @@
  * @api public
  */
 
-picomatch.parse = (pattern, options) => {
-  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));
-  return parse$1(pattern, { ...options, fastpaths: false });
+picomatch$1.parse = (pattern, options) => {
+  if (Array.isArray(pattern)) return pattern.map(p => picomatch$1.parse(p, options));
+  return parse(pattern, { ...options, fastpaths: false });
 };
 
 /**
@@ -5295,7 +4305,7 @@
  * @api public
  */
 
-picomatch.scan = (input, options) => scan(input, options);
+picomatch$1.scan = (input, options) => scan(input, options);
 
 /**
  * Compile a regular expression from the `state` object returned by the
@@ -5309,7 +4319,7 @@
  * @api public
  */
 
-picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
+picomatch$1.compileRe = (state, options, returnOutput = false, returnState = false) => {
   if (returnOutput === true) {
     return state.output;
   }
@@ -5323,7 +4333,7 @@
     source = `^(?!${source}).*$`;
   }
 
-  const regex = picomatch.toRegex(source, options);
+  const regex = picomatch$1.toRegex(source, options);
   if (returnState === true) {
     regex.state = state;
   }
@@ -5350,7 +4360,7 @@
  * @api public
  */
 
-picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
+picomatch$1.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
   if (!input || typeof input !== 'string') {
     throw new TypeError('Expected a non-empty string');
   }
@@ -5358,14 +4368,14 @@
   let parsed = { negated: false, fastpaths: true };
 
   if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
-    parsed.output = parse$1.fastpaths(input, options);
+    parsed.output = parse.fastpaths(input, options);
   }
 
   if (!parsed.output) {
-    parsed = parse$1(input, options);
+    parsed = parse(input, options);
   }
 
-  return picomatch.compileRe(parsed, options, returnOutput, returnState);
+  return picomatch$1.compileRe(parsed, options, returnOutput, returnState);
 };
 
 /**
@@ -5385,7 +4395,7 @@
  * @api public
  */
 
-picomatch.toRegex = (source, options) => {
+picomatch$1.toRegex = (source, options) => {
   try {
     const opts = options || {};
     return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
@@ -5400,20 +4410,17 @@
  * @return {Object}
  */
 
-picomatch.constants = constants;
+picomatch$1.constants = constants;
 
 /**
  * Expose "picomatch"
  */
 
-var picomatch_1 = picomatch;
+var picomatch_1 = picomatch$1;
 
-(function (module) {
+var picomatch = picomatch_1;
 
-	module.exports = picomatch_1;
-} (picomatch$1));
-
-const pm = /*@__PURE__*/getDefaultExportFromCjs(exports.picomatchExports);
+const pm = picomatch;
 
 const extractors = {
     ArrayPattern(names, param) {
@@ -5463,22 +4470,22 @@
 }
 
 const normalizePath = function normalizePath(filename) {
-    return filename.split(require$$0$1.win32.sep).join(require$$0$1.posix.sep);
+    return filename.split(path$2.win32.sep).join(path$2.posix.sep);
 };
 
 function getMatcherString(id, resolutionBase) {
-    if (resolutionBase === false || require$$0$1.isAbsolute(id) || id.startsWith('*')) {
-        return normalizePath(id);
+    if (resolutionBase === false || path$2.isAbsolute(id) || id.startsWith('*')) {
+        return id;
     }
     // resolve('') is valid and will default to process.cwd()
-    const basePath = normalizePath(require$$0$1.resolve(resolutionBase || ''))
+    const basePath = normalizePath(path$2.resolve(resolutionBase || ''))
         // escape all possible (posix + win) path characters that might interfere with regex
         .replace(/[-^$*+?.()|[\]{}]/g, '\\$&');
     // Note that we use posix.join because:
     // 1. the basePath has been normalized to use /
     // 2. the incoming glob (id) matcher, also uses /
     // otherwise Node will force backslash (\) on windows
-    return require$$0$1.posix.join(basePath, normalizePath(id));
+    return path$2.posix.join(basePath, id);
 }
 const createFilter = function createFilter(include, exclude, options) {
     const resolutionBase = options && options.resolve;
@@ -5516,8 +4523,8 @@
 };
 
 const reservedWords$1 = 'break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public';
-const builtins = 'arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl';
-const forbiddenIdentifiers = new Set(`${reservedWords$1} ${builtins}`.split(' '));
+const builtins$1 = 'arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl';
+const forbiddenIdentifiers = new Set(`${reservedWords$1} ${builtins$1}`.split(' '));
 forbiddenIdentifiers.add('');
 
 const BROKEN_FLOW_NONE = 0;
@@ -5548,208 +4555,6 @@
     };
 }
 
-function assembleMemberDescriptions(memberDescriptions, inheritedDescriptions = null) {
-    return Object.create(inheritedDescriptions, memberDescriptions);
-}
-const UNDEFINED_EXPRESSION = new (class UndefinedExpression extends ExpressionEntity {
-    getLiteralValueAtPath() {
-        return undefined;
-    }
-})();
-const returnsUnknown = {
-    value: {
-        hasEffectsWhenCalled: null,
-        returns: UNKNOWN_EXPRESSION
-    }
-};
-const UNKNOWN_LITERAL_BOOLEAN = new (class UnknownBoolean extends ExpressionEntity {
-    getReturnExpressionWhenCalledAtPath(path) {
-        if (path.length === 1) {
-            return getMemberReturnExpressionWhenCalled(literalBooleanMembers, path[0]);
-        }
-        return UNKNOWN_RETURN_EXPRESSION;
-    }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        if (interaction.type === INTERACTION_ACCESSED) {
-            return path.length > 1;
-        }
-        if (interaction.type === INTERACTION_CALLED && path.length === 1) {
-            return hasMemberEffectWhenCalled(literalBooleanMembers, path[0], interaction, context);
-        }
-        return true;
-    }
-})();
-const returnsBoolean = {
-    value: {
-        hasEffectsWhenCalled: null,
-        returns: UNKNOWN_LITERAL_BOOLEAN
-    }
-};
-const UNKNOWN_LITERAL_NUMBER = new (class UnknownNumber extends ExpressionEntity {
-    getReturnExpressionWhenCalledAtPath(path) {
-        if (path.length === 1) {
-            return getMemberReturnExpressionWhenCalled(literalNumberMembers, path[0]);
-        }
-        return UNKNOWN_RETURN_EXPRESSION;
-    }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        if (interaction.type === INTERACTION_ACCESSED) {
-            return path.length > 1;
-        }
-        if (interaction.type === INTERACTION_CALLED && path.length === 1) {
-            return hasMemberEffectWhenCalled(literalNumberMembers, path[0], interaction, context);
-        }
-        return true;
-    }
-})();
-const returnsNumber = {
-    value: {
-        hasEffectsWhenCalled: null,
-        returns: UNKNOWN_LITERAL_NUMBER
-    }
-};
-const UNKNOWN_LITERAL_STRING = new (class UnknownString extends ExpressionEntity {
-    getReturnExpressionWhenCalledAtPath(path) {
-        if (path.length === 1) {
-            return getMemberReturnExpressionWhenCalled(literalStringMembers, path[0]);
-        }
-        return UNKNOWN_RETURN_EXPRESSION;
-    }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        if (interaction.type === INTERACTION_ACCESSED) {
-            return path.length > 1;
-        }
-        if (interaction.type === INTERACTION_CALLED && path.length === 1) {
-            return hasMemberEffectWhenCalled(literalStringMembers, path[0], interaction, context);
-        }
-        return true;
-    }
-})();
-const returnsString = {
-    value: {
-        hasEffectsWhenCalled: null,
-        returns: UNKNOWN_LITERAL_STRING
-    }
-};
-const stringReplace = {
-    value: {
-        hasEffectsWhenCalled({ args }, context) {
-            const argument1 = args[1];
-            return (args.length < 2 ||
-                (typeof argument1.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, {
-                    deoptimizeCache() { }
-                }) === 'symbol' &&
-                    argument1.hasEffectsOnInteractionAtPath(EMPTY_PATH, NODE_INTERACTION_UNKNOWN_CALL, context)));
-        },
-        returns: UNKNOWN_LITERAL_STRING
-    }
-};
-const objectMembers = assembleMemberDescriptions({
-    hasOwnProperty: returnsBoolean,
-    isPrototypeOf: returnsBoolean,
-    propertyIsEnumerable: returnsBoolean,
-    toLocaleString: returnsString,
-    toString: returnsString,
-    valueOf: returnsUnknown
-});
-const literalBooleanMembers = assembleMemberDescriptions({
-    valueOf: returnsBoolean
-}, objectMembers);
-const literalNumberMembers = assembleMemberDescriptions({
-    toExponential: returnsString,
-    toFixed: returnsString,
-    toLocaleString: returnsString,
-    toPrecision: returnsString,
-    valueOf: returnsNumber
-}, objectMembers);
-/**
- * RegExp are stateful when they have the global or sticky flags set.
- * But if we actually don't use them, the side effect does not matter.
- * the check logic in `hasEffectsOnInteractionAtPath`.
- */
-const literalRegExpMembers = assembleMemberDescriptions({
-    exec: returnsUnknown,
-    test: returnsBoolean
-}, objectMembers);
-const literalStringMembers = assembleMemberDescriptions({
-    anchor: returnsString,
-    at: returnsUnknown,
-    big: returnsString,
-    blink: returnsString,
-    bold: returnsString,
-    charAt: returnsString,
-    charCodeAt: returnsNumber,
-    codePointAt: returnsUnknown,
-    concat: returnsString,
-    endsWith: returnsBoolean,
-    fixed: returnsString,
-    fontcolor: returnsString,
-    fontsize: returnsString,
-    includes: returnsBoolean,
-    indexOf: returnsNumber,
-    italics: returnsString,
-    lastIndexOf: returnsNumber,
-    link: returnsString,
-    localeCompare: returnsNumber,
-    match: returnsUnknown,
-    matchAll: returnsUnknown,
-    normalize: returnsString,
-    padEnd: returnsString,
-    padStart: returnsString,
-    repeat: returnsString,
-    replace: stringReplace,
-    replaceAll: stringReplace,
-    search: returnsNumber,
-    slice: returnsString,
-    small: returnsString,
-    split: returnsUnknown,
-    startsWith: returnsBoolean,
-    strike: returnsString,
-    sub: returnsString,
-    substr: returnsString,
-    substring: returnsString,
-    sup: returnsString,
-    toLocaleLowerCase: returnsString,
-    toLocaleUpperCase: returnsString,
-    toLowerCase: returnsString,
-    toString: returnsString,
-    toUpperCase: returnsString,
-    trim: returnsString,
-    trimEnd: returnsString,
-    trimLeft: returnsString,
-    trimRight: returnsString,
-    trimStart: returnsString,
-    valueOf: returnsString
-}, objectMembers);
-function getLiteralMembersForValue(value) {
-    if (value instanceof RegExp) {
-        return literalRegExpMembers;
-    }
-    switch (typeof value) {
-        case 'boolean': {
-            return literalBooleanMembers;
-        }
-        case 'number': {
-            return literalNumberMembers;
-        }
-        case 'string': {
-            return literalStringMembers;
-        }
-    }
-    return Object.create(null);
-}
-function hasMemberEffectWhenCalled(members, memberName, interaction, context) {
-    if (typeof memberName !== 'string' || !members[memberName]) {
-        return true;
-    }
-    return members[memberName].hasEffectsWhenCalled?.(interaction, context) || false;
-}
-function getMemberReturnExpressionWhenCalled(members, memberName) {
-    if (typeof memberName !== 'string' || !members[memberName])
-        return UNKNOWN_RETURN_EXPRESSION;
-    return [members[memberName].returns, false];
-}
-
 // AST walker module for Mozilla Parser API compatible trees
 
 function skipThrough(node, st, c) { c(node, st); }
@@ -6023,6 +4828,8 @@
 const ConditionalExpression$1 = 'ConditionalExpression';
 const ExpressionStatement$1 = 'ExpressionStatement';
 const Identifier$1 = 'Identifier';
+const ImportDefaultSpecifier$1 = 'ImportDefaultSpecifier';
+const ImportNamespaceSpecifier$1 = 'ImportNamespaceSpecifier';
 const LogicalExpression$1 = 'LogicalExpression';
 const NewExpression$1 = 'NewExpression';
 const Program$1 = 'Program';
@@ -6037,19 +4844,26 @@
 const whiteSpaceNoNewline = '[ \\f\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]';
 const SOURCEMAPPING_URL_RE = new RegExp(`^#${whiteSpaceNoNewline}+${SOURCEMAPPING_URL}=.+`);
 
+// patch up acorn-walk until class-fields are officially supported
+base$1.PropertyDefinition = function (node, st, c) {
+    if (node.computed) {
+        c(node.key, st, 'Expression');
+    }
+    if (node.value) {
+        c(node.value, st, 'Expression');
+    }
+};
 const ANNOTATION_KEY = '_rollupAnnotations';
 const INVALID_COMMENT_KEY = '_rollupRemoved';
 function handlePureAnnotationsOfNode(node, state, type = node.type) {
-    const { annotations, code } = state;
-    // eslint-disable-next-line unicorn/consistent-destructuring
+    const { annotations } = state;
     let comment = annotations[state.annotationIndex];
     while (comment && node.start >= comment.end) {
-        markPureNode(node, comment, code);
+        markPureNode(node, comment, state.code);
         comment = annotations[++state.annotationIndex];
     }
     if (comment && comment.end <= node.end) {
         base$1[type](node, state, handlePureAnnotationsOfNode);
-        // eslint-disable-next-line unicorn/consistent-destructuring
         while ((comment = annotations[state.annotationIndex]) && comment.end <= node.end) {
             ++state.annotationIndex;
             annotateNode(node, comment, false);
@@ -6068,11 +4882,10 @@
             annotatedNodes.push(node);
             switch (node.type) {
                 case ExpressionStatement$1:
-                case ChainExpression$1: {
+                case ChainExpression$1:
                     node = node.expression;
                     continue;
-                }
-                case SequenceExpression$1: {
+                case SequenceExpression$1:
                     // if there are parentheses, the annotation would apply to the entire expression
                     if (doesNotMatchOutsideComment(code.slice(parentStart, node.start), noWhitespace)) {
                         node = node.expressions[0];
@@ -6080,8 +4893,7 @@
                     }
                     invalidAnnotation = true;
                     break;
-                }
-                case ConditionalExpression$1: {
+                case ConditionalExpression$1:
                     // if there are parentheses, the annotation would apply to the entire expression
                     if (doesNotMatchOutsideComment(code.slice(parentStart, node.start), noWhitespace)) {
                         node = node.test;
@@ -6089,9 +4901,8 @@
                     }
                     invalidAnnotation = true;
                     break;
-                }
                 case LogicalExpression$1:
-                case BinaryExpression$1: {
+                case BinaryExpression$1:
                     // if there are parentheses, the annotation would apply to the entire expression
                     if (doesNotMatchOutsideComment(code.slice(parentStart, node.start), noWhitespace)) {
                         node = node.left;
@@ -6099,14 +4910,11 @@
                     }
                     invalidAnnotation = true;
                     break;
-                }
                 case CallExpression$1:
-                case NewExpression$1: {
+                case NewExpression$1:
                     break;
-                }
-                default: {
+                default:
                     invalidAnnotation = true;
-                }
             }
             break;
         }
@@ -6142,7 +4950,7 @@
     }
     return true;
 }
-const pureCommentRegex = /[#@]__PURE__/;
+const pureCommentRegex = /[@#]__PURE__/;
 function addAnnotations(comments, esTreeAst, code) {
     const annotations = [];
     const sourceMappingComments = [];
@@ -6175,9 +4983,6 @@
 }
 
 const keys = {
-    // TODO this should be removed once ImportExpression follows official ESTree
-    //  specs with "null" as default
-    ImportExpression: ['arguments'],
     Literal: [],
     Program: ['body']
 };
@@ -6188,18 +4993,9 @@
 
 const INCLUDE_PARAMETERS = 'variables';
 class NodeBase extends ExpressionEntity {
-    constructor(esTreeNode, parent, parentScope, keepEsTreeNode = false) {
+    constructor(esTreeNode, parent, parentScope) {
         super();
-        /**
-         * Nodes can apply custom deoptimizations once they become part of the
-         * executed code. To do this, they must initialize this as false, implement
-         * applyDeoptimizations and call this from include and hasEffects if they have
-         * custom handlers
-         */
-        this.deoptimized = false;
-        // Nodes can opt-in to keep the AST if needed during the build pipeline.
-        // Avoid true when possible as large AST takes up memory.
-        this.esTreeNode = keepEsTreeNode ? esTreeNode : null;
+        this.esTreeNode = esTreeNode;
         this.keys = keys[esTreeNode.type] || getAndCreateKeys(esTreeNode);
         this.parent = parent;
         this.context = parent.context;
@@ -6217,12 +5013,15 @@
     bind() {
         for (const key of this.keys) {
             const value = this[key];
+            if (value === null)
+                continue;
             if (Array.isArray(value)) {
                 for (const child of value) {
-                    child?.bind();
+                    if (child !== null)
+                        child.bind();
                 }
             }
-            else if (value) {
+            else {
                 value.bind();
             }
         }
@@ -6234,7 +5033,7 @@
         this.scope = parentScope;
     }
     hasEffects(context) {
-        if (!this.deoptimized)
+        if (this.deoptimized === false)
             this.applyDeoptimizations();
         for (const key of this.keys) {
             const value = this[key];
@@ -6242,7 +5041,7 @@
                 continue;
             if (Array.isArray(value)) {
                 for (const child of value) {
-                    if (child?.hasEffects(context))
+                    if (child !== null && child.hasEffects(context))
                         return true;
                 }
             }
@@ -6251,12 +5050,8 @@
         }
         return false;
     }
-    hasEffectsAsAssignmentTarget(context, _checkAccess) {
-        return (this.hasEffects(context) ||
-            this.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.assignmentInteraction, context));
-    }
-    include(context, includeChildrenRecursively, _options) {
-        if (!this.deoptimized)
+    include(context, includeChildrenRecursively) {
+        if (this.deoptimized === false)
             this.applyDeoptimizations();
         this.included = true;
         for (const key of this.keys) {
@@ -6265,7 +5060,8 @@
                 continue;
             if (Array.isArray(value)) {
                 for (const child of value) {
-                    child?.include(context, includeChildrenRecursively);
+                    if (child !== null)
+                        child.include(context, includeChildrenRecursively);
                 }
             }
             else {
@@ -6273,7 +5069,7 @@
             }
         }
     }
-    includeAsAssignmentTarget(context, includeChildrenRecursively, _deoptimizeAccess) {
+    includeAsSingleStatement(context, includeChildrenRecursively) {
         this.include(context, includeChildrenRecursively);
     }
     /**
@@ -6285,7 +5081,7 @@
             code.appendLeft(this.end, ';');
         }
     }
-    parseNode(esTreeNode, keepEsTreeNodeKeys) {
+    parseNode(esTreeNode) {
         for (const [key, value] of Object.entries(esTreeNode)) {
             // That way, we can override this function to add custom initialisation and then call super.parseNode
             if (this.hasOwnProperty(key))
@@ -6307,11 +5103,13 @@
                 for (const child of value) {
                     this[key].push(child === null
                         ? null
-                        : new (this.context.getNodeConstructor(child.type))(child, this, this.scope, keepEsTreeNodeKeys?.includes(key)));
+                        : new (this.context.nodeConstructors[child.type] ||
+                            this.context.nodeConstructors.UnknownNode)(child, this, this.scope));
                 }
             }
             else {
-                this[key] = new (this.context.getNodeConstructor(value.type))(value, this, this.scope, keepEsTreeNodeKeys?.includes(key));
+                this[key] = new (this.context.nodeConstructors[value.type] ||
+                    this.context.nodeConstructors.UnknownNode)(value, this, this.scope);
             }
         }
     }
@@ -6322,7 +5120,8 @@
                 continue;
             if (Array.isArray(value)) {
                 for (const child of value) {
-                    child?.render(code, options);
+                    if (child !== null)
+                        child.render(code, options);
                 }
             }
             else {
@@ -6330,739 +5129,468 @@
             }
         }
     }
-    setAssignedValue(value) {
-        this.assignmentInteraction = { args: [value], thisArg: null, type: INTERACTION_ASSIGNED };
-    }
     shouldBeIncluded(context) {
         return this.included || (!context.brokenFlow && this.hasEffects(createHasEffectsContext()));
     }
-    /**
-     * Just deoptimize everything by default so that when e.g. we do not track
-     * something properly, it is deoptimized.
-     * @protected
-     */
-    applyDeoptimizations() {
-        this.deoptimized = true;
-        for (const key of this.keys) {
-            const value = this[key];
-            if (value === null)
-                continue;
-            if (Array.isArray(value)) {
-                for (const child of value) {
-                    child?.deoptimizePath(UNKNOWN_PATH);
-                }
-            }
-            else {
-                value.deoptimizePath(UNKNOWN_PATH);
-            }
-        }
-        this.context.requestTreeshakingPass();
-    }
+    applyDeoptimizations() { }
 }
 
-class SpreadElement extends NodeBase {
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        if (path.length > 0) {
-            this.argument.deoptimizeThisOnInteractionAtPath(interaction, [UnknownKey, ...path], recursionTracker);
-        }
+class ExportAllDeclaration extends NodeBase {
+    hasEffects() {
+        return false;
     }
-    hasEffects(context) {
-        if (!this.deoptimized)
-            this.applyDeoptimizations();
-        const { propertyReadSideEffects } = this.context.options
-            .treeshake;
-        return (this.argument.hasEffects(context) ||
-            (propertyReadSideEffects &&
-                (propertyReadSideEffects === 'always' ||
-                    this.argument.hasEffectsOnInteractionAtPath(UNKNOWN_PATH, NODE_INTERACTION_UNKNOWN_ACCESS, context))));
+    initialise() {
+        this.context.addExport(this);
     }
-    applyDeoptimizations() {
-        this.deoptimized = true;
-        // Only properties of properties of the argument could become subject to reassignment
-        // This will also reassign the return values of iterators
-        this.argument.deoptimizePath([UnknownKey, UnknownKey]);
-        this.context.requestTreeshakingPass();
+    render(code, _options, nodeRenderOptions) {
+        code.remove(nodeRenderOptions.start, nodeRenderOptions.end);
     }
 }
+ExportAllDeclaration.prototype.needsBoundaries = true;
 
-class Method extends ExpressionEntity {
-    constructor(description) {
-        super();
-        this.description = description;
-    }
-    deoptimizeThisOnInteractionAtPath({ type, thisArg }, path) {
-        if (type === INTERACTION_CALLED && path.length === 0 && this.description.mutatesSelfAsArray) {
-            thisArg.deoptimizePath(UNKNOWN_INTEGER_PATH);
-        }
-    }
-    getReturnExpressionWhenCalledAtPath(path, { thisArg }) {
-        if (path.length > 0) {
-            return UNKNOWN_RETURN_EXPRESSION;
-        }
-        return [
-            this.description.returnsPrimitive ||
-                (this.description.returns === 'self'
-                    ? thisArg || UNKNOWN_EXPRESSION
-                    : this.description.returns()),
-            false
-        ];
-    }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        const { type } = interaction;
-        if (path.length > (type === INTERACTION_ACCESSED ? 1 : 0)) {
-            return true;
-        }
-        if (type === INTERACTION_CALLED) {
-            const { args, thisArg } = interaction;
-            if (this.description.mutatesSelfAsArray === true &&
-                thisArg?.hasEffectsOnInteractionAtPath(UNKNOWN_INTEGER_PATH, NODE_INTERACTION_UNKNOWN_ASSIGNMENT, context)) {
-                return true;
+function treeshakeNode(node, code, start, end) {
+    code.remove(start, end);
+    if (node.annotations) {
+        for (const annotation of node.annotations) {
+            if (annotation.start < start) {
+                code.remove(annotation.start, annotation.end);
             }
-            if (this.description.callsArgs) {
-                for (const argumentIndex of this.description.callsArgs) {
-                    if (args[argumentIndex]?.hasEffectsOnInteractionAtPath(EMPTY_PATH, NODE_INTERACTION_UNKNOWN_CALL, context)) {
-                        return true;
-                    }
-                }
+            else {
+                return;
             }
         }
-        return false;
     }
 }
-const METHOD_RETURNS_BOOLEAN = [
-    new Method({
-        callsArgs: null,
-        mutatesSelfAsArray: false,
-        returns: null,
-        returnsPrimitive: UNKNOWN_LITERAL_BOOLEAN
-    })
-];
-const METHOD_RETURNS_STRING = [
-    new Method({
-        callsArgs: null,
-        mutatesSelfAsArray: false,
-        returns: null,
-        returnsPrimitive: UNKNOWN_LITERAL_STRING
-    })
-];
-const METHOD_RETURNS_NUMBER = [
-    new Method({
-        callsArgs: null,
-        mutatesSelfAsArray: false,
-        returns: null,
-        returnsPrimitive: UNKNOWN_LITERAL_NUMBER
-    })
-];
-const METHOD_RETURNS_UNKNOWN = [
-    new Method({
-        callsArgs: null,
-        mutatesSelfAsArray: false,
-        returns: null,
-        returnsPrimitive: UNKNOWN_EXPRESSION
-    })
-];
-
-const INTEGER_REG_EXP = /^\d+$/;
-class ObjectEntity extends ExpressionEntity {
-    // If a PropertyMap is used, this will be taken as propertiesAndGettersByKey
-    // and we assume there are no setters or getters
-    constructor(properties, prototypeExpression, immutable = false) {
-        super();
-        this.prototypeExpression = prototypeExpression;
-        this.immutable = immutable;
-        this.allProperties = [];
-        this.deoptimizedPaths = Object.create(null);
-        this.expressionsToBeDeoptimizedByKey = Object.create(null);
-        this.gettersByKey = Object.create(null);
-        this.hasLostTrack = false;
-        this.hasUnknownDeoptimizedInteger = false;
-        this.hasUnknownDeoptimizedProperty = false;
-        this.propertiesAndGettersByKey = Object.create(null);
-        this.propertiesAndSettersByKey = Object.create(null);
-        this.settersByKey = Object.create(null);
-        this.thisParametersToBeDeoptimized = new Set();
-        this.unknownIntegerProps = [];
-        this.unmatchableGetters = [];
-        this.unmatchablePropertiesAndGetters = [];
-        this.unmatchableSetters = [];
-        if (Array.isArray(properties)) {
-            this.buildPropertyMaps(properties);
-        }
-        else {
-            this.propertiesAndGettersByKey = this.propertiesAndSettersByKey = properties;
-            for (const propertiesForKey of Object.values(properties)) {
-                this.allProperties.push(...propertiesForKey);
-            }
-        }
+function removeAnnotations(node, code) {
+    if (!node.annotations && node.parent.type === ExpressionStatement$1) {
+        node = node.parent;
     }
-    deoptimizeAllProperties(noAccessors) {
-        const isDeoptimized = this.hasLostTrack || this.hasUnknownDeoptimizedProperty;
-        if (noAccessors) {
-            this.hasUnknownDeoptimizedProperty = true;
-        }
-        else {
-            this.hasLostTrack = true;
-        }
-        if (isDeoptimized) {
-            return;
-        }
-        for (const properties of [
-            ...Object.values(this.propertiesAndGettersByKey),
-            ...Object.values(this.settersByKey)
-        ]) {
-            for (const property of properties) {
-                property.deoptimizePath(UNKNOWN_PATH);
-            }
+    if (node.annotations) {
+        for (const annotation of node.annotations) {
+            code.remove(annotation.start, annotation.end);
         }
-        // While the prototype itself cannot be mutated, each property can
-        this.prototypeExpression?.deoptimizePath([UnknownKey, UnknownKey]);
-        this.deoptimizeCachedEntities();
     }
-    deoptimizeIntegerProperties() {
-        if (this.hasLostTrack ||
-            this.hasUnknownDeoptimizedProperty ||
-            this.hasUnknownDeoptimizedInteger) {
-            return;
-        }
-        this.hasUnknownDeoptimizedInteger = true;
-        for (const [key, propertiesAndGetters] of Object.entries(this.propertiesAndGettersByKey)) {
-            if (INTEGER_REG_EXP.test(key)) {
-                for (const property of propertiesAndGetters) {
-                    property.deoptimizePath(UNKNOWN_PATH);
-                }
-            }
+}
+
+const NO_SEMICOLON = { isNoStatement: true };
+// This assumes there are only white-space and comments between start and the string we are looking for
+function findFirstOccurrenceOutsideComment(code, searchString, start = 0) {
+    let searchPos, charCodeAfterSlash;
+    searchPos = code.indexOf(searchString, start);
+    while (true) {
+        start = code.indexOf('/', start);
+        if (start === -1 || start >= searchPos)
+            return searchPos;
+        charCodeAfterSlash = code.charCodeAt(++start);
+        ++start;
+        // With our assumption, '/' always starts a comment. Determine comment type:
+        start =
+            charCodeAfterSlash === 47 /*"/"*/
+                ? code.indexOf('\n', start) + 1
+                : code.indexOf('*/', start) + 2;
+        if (start > searchPos) {
+            searchPos = code.indexOf(searchString, start);
         }
-        this.deoptimizeCachedIntegerEntities();
     }
-    // Assumption: If only a specific path is deoptimized, no accessors are created
-    deoptimizePath(path) {
-        if (this.hasLostTrack || this.immutable) {
-            return;
-        }
-        const key = path[0];
-        if (path.length === 1) {
-            if (typeof key !== 'string') {
-                if (key === UnknownInteger) {
-                    return this.deoptimizeIntegerProperties();
-                }
-                return this.deoptimizeAllProperties(key === UnknownNonAccessorKey);
-            }
-            if (!this.deoptimizedPaths[key]) {
-                this.deoptimizedPaths[key] = true;
-                // we only deoptimizeCache exact matches as in all other cases,
-                // we do not return a literal value or return expression
-                const expressionsToBeDeoptimized = this.expressionsToBeDeoptimizedByKey[key];
-                if (expressionsToBeDeoptimized) {
-                    for (const expression of expressionsToBeDeoptimized) {
-                        expression.deoptimizeCache();
-                    }
-                }
-            }
-        }
-        const subPath = path.length === 1 ? UNKNOWN_PATH : path.slice(1);
-        for (const property of typeof key === 'string'
-            ? [
-                ...(this.propertiesAndGettersByKey[key] || this.unmatchablePropertiesAndGetters),
-                ...(this.settersByKey[key] || this.unmatchableSetters)
-            ]
-            : this.allProperties) {
-            property.deoptimizePath(subPath);
+}
+const NON_WHITESPACE = /\S/g;
+function findNonWhiteSpace(code, index) {
+    NON_WHITESPACE.lastIndex = index;
+    const result = NON_WHITESPACE.exec(code);
+    return result.index;
+}
+// This assumes "code" only contains white-space and comments
+// Returns position of line-comment if applicable
+function findFirstLineBreakOutsideComment(code) {
+    let lineBreakPos, charCodeAfterSlash, start = 0;
+    lineBreakPos = code.indexOf('\n', start);
+    while (true) {
+        start = code.indexOf('/', start);
+        if (start === -1 || start > lineBreakPos)
+            return [lineBreakPos, lineBreakPos + 1];
+        // With our assumption, '/' always starts a comment. Determine comment type:
+        charCodeAfterSlash = code.charCodeAt(start + 1);
+        if (charCodeAfterSlash === 47 /*"/"*/)
+            return [start, lineBreakPos + 1];
+        start = code.indexOf('*/', start + 3) + 2;
+        if (start > lineBreakPos) {
+            lineBreakPos = code.indexOf('\n', start);
         }
-        this.prototypeExpression?.deoptimizePath(path.length === 1 ? [...path, UnknownKey] : path);
     }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        const [key, ...subPath] = path;
-        if (this.hasLostTrack ||
-            // single paths that are deoptimized will not become getters or setters
-            ((interaction.type === INTERACTION_CALLED || path.length > 1) &&
-                (this.hasUnknownDeoptimizedProperty ||
-                    (typeof key === 'string' && this.deoptimizedPaths[key])))) {
-            interaction.thisArg.deoptimizePath(UNKNOWN_PATH);
-            return;
-        }
-        const [propertiesForExactMatchByKey, relevantPropertiesByKey, relevantUnmatchableProperties] = interaction.type === INTERACTION_CALLED || path.length > 1
-            ? [
-                this.propertiesAndGettersByKey,
-                this.propertiesAndGettersByKey,
-                this.unmatchablePropertiesAndGetters
-            ]
-            : interaction.type === INTERACTION_ACCESSED
-                ? [this.propertiesAndGettersByKey, this.gettersByKey, this.unmatchableGetters]
-                : [this.propertiesAndSettersByKey, this.settersByKey, this.unmatchableSetters];
-        if (typeof key === 'string') {
-            if (propertiesForExactMatchByKey[key]) {
-                const properties = relevantPropertiesByKey[key];
-                if (properties) {
-                    for (const property of properties) {
-                        property.deoptimizeThisOnInteractionAtPath(interaction, subPath, recursionTracker);
-                    }
-                }
-                if (!this.immutable) {
-                    this.thisParametersToBeDeoptimized.add(interaction.thisArg);
-                }
-                return;
-            }
-            for (const property of relevantUnmatchableProperties) {
-                property.deoptimizeThisOnInteractionAtPath(interaction, subPath, recursionTracker);
+}
+function renderStatementList(statements, code, start, end, options) {
+    let currentNode, currentNodeStart, currentNodeNeedsBoundaries, nextNodeStart;
+    let nextNode = statements[0];
+    let nextNodeNeedsBoundaries = !nextNode.included || nextNode.needsBoundaries;
+    if (nextNodeNeedsBoundaries) {
+        nextNodeStart =
+            start + findFirstLineBreakOutsideComment(code.original.slice(start, nextNode.start))[1];
+    }
+    for (let nextIndex = 1; nextIndex <= statements.length; nextIndex++) {
+        currentNode = nextNode;
+        currentNodeStart = nextNodeStart;
+        currentNodeNeedsBoundaries = nextNodeNeedsBoundaries;
+        nextNode = statements[nextIndex];
+        nextNodeNeedsBoundaries =
+            nextNode === undefined ? false : !nextNode.included || nextNode.needsBoundaries;
+        if (currentNodeNeedsBoundaries || nextNodeNeedsBoundaries) {
+            nextNodeStart =
+                currentNode.end +
+                    findFirstLineBreakOutsideComment(code.original.slice(currentNode.end, nextNode === undefined ? end : nextNode.start))[1];
+            if (currentNode.included) {
+                currentNodeNeedsBoundaries
+                    ? currentNode.render(code, options, {
+                        end: nextNodeStart,
+                        start: currentNodeStart
+                    })
+                    : currentNode.render(code, options);
             }
-            if (INTEGER_REG_EXP.test(key)) {
-                for (const property of this.unknownIntegerProps) {
-                    property.deoptimizeThisOnInteractionAtPath(interaction, subPath, recursionTracker);
-                }
+            else {
+                treeshakeNode(currentNode, code, currentNodeStart, nextNodeStart);
             }
         }
         else {
-            for (const properties of [
-                ...Object.values(relevantPropertiesByKey),
-                relevantUnmatchableProperties
-            ]) {
-                for (const property of properties) {
-                    property.deoptimizeThisOnInteractionAtPath(interaction, subPath, recursionTracker);
-                }
-            }
-            for (const property of this.unknownIntegerProps) {
-                property.deoptimizeThisOnInteractionAtPath(interaction, subPath, recursionTracker);
-            }
-        }
-        if (!this.immutable) {
-            this.thisParametersToBeDeoptimized.add(interaction.thisArg);
-        }
-        this.prototypeExpression?.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
-    }
-    getLiteralValueAtPath(path, recursionTracker, origin) {
-        if (path.length === 0) {
-            return UnknownTruthyValue;
-        }
-        const key = path[0];
-        const expressionAtPath = this.getMemberExpressionAndTrackDeopt(key, origin);
-        if (expressionAtPath) {
-            return expressionAtPath.getLiteralValueAtPath(path.slice(1), recursionTracker, origin);
-        }
-        if (this.prototypeExpression) {
-            return this.prototypeExpression.getLiteralValueAtPath(path, recursionTracker, origin);
-        }
-        if (path.length === 1) {
-            return undefined;
+            currentNode.render(code, options);
         }
-        return UnknownValue;
     }
-    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
-        if (path.length === 0) {
-            return UNKNOWN_RETURN_EXPRESSION;
-        }
-        const [key, ...subPath] = path;
-        const expressionAtPath = this.getMemberExpressionAndTrackDeopt(key, origin);
-        if (expressionAtPath) {
-            return expressionAtPath.getReturnExpressionWhenCalledAtPath(subPath, interaction, recursionTracker, origin);
+}
+// This assumes that the first character is not part of the first node
+function getCommaSeparatedNodesWithBoundaries(nodes, code, start, end) {
+    const splitUpNodes = [];
+    let node, nextNode, nextNodeStart, contentEnd, char;
+    let separator = start - 1;
+    for (let nextIndex = 0; nextIndex < nodes.length; nextIndex++) {
+        nextNode = nodes[nextIndex];
+        if (node !== undefined) {
+            separator =
+                node.end +
+                    findFirstOccurrenceOutsideComment(code.original.slice(node.end, nextNode.start), ',');
         }
-        if (this.prototypeExpression) {
-            return this.prototypeExpression.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
+        nextNodeStart = contentEnd =
+            separator +
+                1 +
+                findFirstLineBreakOutsideComment(code.original.slice(separator + 1, nextNode.start))[1];
+        while (((char = code.original.charCodeAt(nextNodeStart)),
+            char === 32 /*" "*/ || char === 9 /*"\t"*/ || char === 10 /*"\n"*/ || char === 13) /*"\r"*/)
+            nextNodeStart++;
+        if (node !== undefined) {
+            splitUpNodes.push({
+                contentEnd,
+                end: nextNodeStart,
+                node,
+                separator,
+                start
+            });
         }
-        return UNKNOWN_RETURN_EXPRESSION;
+        node = nextNode;
+        start = nextNodeStart;
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        const [key, ...subPath] = path;
-        if (subPath.length > 0 || interaction.type === INTERACTION_CALLED) {
-            const expressionAtPath = this.getMemberExpression(key);
-            if (expressionAtPath) {
-                return expressionAtPath.hasEffectsOnInteractionAtPath(subPath, interaction, context);
-            }
-            if (this.prototypeExpression) {
-                return this.prototypeExpression.hasEffectsOnInteractionAtPath(path, interaction, context);
-            }
-            return true;
-        }
-        if (key === UnknownNonAccessorKey)
-            return false;
-        if (this.hasLostTrack)
-            return true;
-        const [propertiesAndAccessorsByKey, accessorsByKey, unmatchableAccessors] = interaction.type === INTERACTION_ACCESSED
-            ? [this.propertiesAndGettersByKey, this.gettersByKey, this.unmatchableGetters]
-            : [this.propertiesAndSettersByKey, this.settersByKey, this.unmatchableSetters];
-        if (typeof key === 'string') {
-            if (propertiesAndAccessorsByKey[key]) {
-                const accessors = accessorsByKey[key];
-                if (accessors) {
-                    for (const accessor of accessors) {
-                        if (accessor.hasEffectsOnInteractionAtPath(subPath, interaction, context))
-                            return true;
-                    }
-                }
-                return false;
-            }
-            for (const accessor of unmatchableAccessors) {
-                if (accessor.hasEffectsOnInteractionAtPath(subPath, interaction, context)) {
-                    return true;
-                }
-            }
-        }
-        else {
-            for (const accessors of [...Object.values(accessorsByKey), unmatchableAccessors]) {
-                for (const accessor of accessors) {
-                    if (accessor.hasEffectsOnInteractionAtPath(subPath, interaction, context))
-                        return true;
-                }
-            }
-        }
-        if (this.prototypeExpression) {
-            return this.prototypeExpression.hasEffectsOnInteractionAtPath(path, interaction, context);
+    splitUpNodes.push({
+        contentEnd: end,
+        end,
+        node: node,
+        separator: null,
+        start
+    });
+    return splitUpNodes;
+}
+// This assumes there are only white-space and comments between start and end
+function removeLineBreaks(code, start, end) {
+    while (true) {
+        const [removeStart, removeEnd] = findFirstLineBreakOutsideComment(code.original.slice(start, end));
+        if (removeStart === -1) {
+            break;
         }
-        return false;
+        code.remove(start + removeStart, (start += removeEnd));
     }
-    buildPropertyMaps(properties) {
-        const { allProperties, propertiesAndGettersByKey, propertiesAndSettersByKey, settersByKey, gettersByKey, unknownIntegerProps, unmatchablePropertiesAndGetters, unmatchableGetters, unmatchableSetters } = this;
-        const unmatchablePropertiesAndSetters = [];
-        for (let index = properties.length - 1; index >= 0; index--) {
-            const { key, kind, property } = properties[index];
-            allProperties.push(property);
-            if (typeof key === 'string') {
-                if (kind === 'set') {
-                    if (!propertiesAndSettersByKey[key]) {
-                        propertiesAndSettersByKey[key] = [property, ...unmatchablePropertiesAndSetters];
-                        settersByKey[key] = [property, ...unmatchableSetters];
-                    }
-                }
-                else if (kind === 'get') {
-                    if (!propertiesAndGettersByKey[key]) {
-                        propertiesAndGettersByKey[key] = [property, ...unmatchablePropertiesAndGetters];
-                        gettersByKey[key] = [property, ...unmatchableGetters];
-                    }
-                }
-                else {
-                    if (!propertiesAndSettersByKey[key]) {
-                        propertiesAndSettersByKey[key] = [property, ...unmatchablePropertiesAndSetters];
-                    }
-                    if (!propertiesAndGettersByKey[key]) {
-                        propertiesAndGettersByKey[key] = [property, ...unmatchablePropertiesAndGetters];
-                    }
-                }
-            }
-            else {
-                if (key === UnknownInteger) {
-                    unknownIntegerProps.push(property);
-                    continue;
-                }
-                if (kind === 'set')
-                    unmatchableSetters.push(property);
-                if (kind === 'get')
-                    unmatchableGetters.push(property);
-                if (kind !== 'get')
-                    unmatchablePropertiesAndSetters.push(property);
-                if (kind !== 'set')
-                    unmatchablePropertiesAndGetters.push(property);
-            }
-        }
+}
+
+function getSystemExportStatement(exportedVariables, { exportNamesByVariable, snippets: { _, getObject, getPropertyAccess } }, modifier = '') {
+    if (exportedVariables.length === 1 &&
+        exportNamesByVariable.get(exportedVariables[0]).length === 1) {
+        const variable = exportedVariables[0];
+        return `exports('${exportNamesByVariable.get(variable)}',${_}${variable.getName(getPropertyAccess)}${modifier})`;
     }
-    deoptimizeCachedEntities() {
-        for (const expressionsToBeDeoptimized of Object.values(this.expressionsToBeDeoptimizedByKey)) {
-            for (const expression of expressionsToBeDeoptimized) {
-                expression.deoptimizeCache();
+    else {
+        const fields = [];
+        for (const variable of exportedVariables) {
+            for (const exportName of exportNamesByVariable.get(variable)) {
+                fields.push([exportName, variable.getName(getPropertyAccess) + modifier]);
             }
         }
-        for (const expression of this.thisParametersToBeDeoptimized) {
-            expression.deoptimizePath(UNKNOWN_PATH);
-        }
+        return `exports(${getObject(fields, { lineBreakIndent: null })})`;
     }
-    deoptimizeCachedIntegerEntities() {
-        for (const [key, expressionsToBeDeoptimized] of Object.entries(this.expressionsToBeDeoptimizedByKey)) {
-            if (INTEGER_REG_EXP.test(key)) {
-                for (const expression of expressionsToBeDeoptimized) {
-                    expression.deoptimizeCache();
-                }
-            }
-        }
-        for (const expression of this.thisParametersToBeDeoptimized) {
-            expression.deoptimizePath(UNKNOWN_INTEGER_PATH);
-        }
+}
+function renderSystemExportExpression(exportedVariable, expressionStart, expressionEnd, code, { exportNamesByVariable, snippets: { _ } }) {
+    code.prependRight(expressionStart, `exports('${exportNamesByVariable.get(exportedVariable)}',${_}`);
+    code.appendLeft(expressionEnd, ')');
+}
+function renderSystemExportFunction(exportedVariables, expressionStart, expressionEnd, needsParens, code, options) {
+    const { _, getDirectReturnIifeLeft } = options.snippets;
+    code.prependRight(expressionStart, getDirectReturnIifeLeft(['v'], `${getSystemExportStatement(exportedVariables, options)},${_}v`, { needsArrowReturnParens: true, needsWrappedFunction: needsParens }));
+    code.appendLeft(expressionEnd, ')');
+}
+function renderSystemExportSequenceAfterExpression(exportedVariable, expressionStart, expressionEnd, needsParens, code, options) {
+    const { _, getPropertyAccess } = options.snippets;
+    code.appendLeft(expressionEnd, `,${_}${getSystemExportStatement([exportedVariable], options)},${_}${exportedVariable.getName(getPropertyAccess)}`);
+    if (needsParens) {
+        code.prependRight(expressionStart, '(');
+        code.appendLeft(expressionEnd, ')');
     }
-    getMemberExpression(key) {
-        if (this.hasLostTrack ||
-            this.hasUnknownDeoptimizedProperty ||
-            typeof key !== 'string' ||
-            (this.hasUnknownDeoptimizedInteger && INTEGER_REG_EXP.test(key)) ||
-            this.deoptimizedPaths[key]) {
-            return UNKNOWN_EXPRESSION;
-        }
-        const properties = this.propertiesAndGettersByKey[key];
-        if (properties?.length === 1) {
-            return properties[0];
-        }
-        if (properties ||
-            this.unmatchablePropertiesAndGetters.length > 0 ||
-            (this.unknownIntegerProps.length > 0 && INTEGER_REG_EXP.test(key))) {
-            return UNKNOWN_EXPRESSION;
-        }
-        return null;
+}
+function renderSystemExportSequenceBeforeExpression(exportedVariable, expressionStart, expressionEnd, needsParens, code, options, modifier) {
+    const { _ } = options.snippets;
+    code.prependRight(expressionStart, `${getSystemExportStatement([exportedVariable], options, modifier)},${_}`);
+    if (needsParens) {
+        code.prependRight(expressionStart, '(');
+        code.appendLeft(expressionEnd, ')');
     }
-    getMemberExpressionAndTrackDeopt(key, origin) {
-        if (typeof key !== 'string') {
-            return UNKNOWN_EXPRESSION;
-        }
-        const expression = this.getMemberExpression(key);
-        if (!(expression === UNKNOWN_EXPRESSION || this.immutable)) {
-            const expressionsToBeDeoptimized = (this.expressionsToBeDeoptimizedByKey[key] =
-                this.expressionsToBeDeoptimizedByKey[key] || []);
-            expressionsToBeDeoptimized.push(origin);
-        }
-        return expression;
+}
+
+const chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$';
+const base = 64;
+function toBase64(num) {
+    let outStr = '';
+    do {
+        const curDigit = num % base;
+        num = Math.floor(num / base);
+        outStr = chars[curDigit] + outStr;
+    } while (num !== 0);
+    return outStr;
+}
+
+const RESERVED_NAMES = {
+    __proto__: null,
+    await: true,
+    break: true,
+    case: true,
+    catch: true,
+    class: true,
+    const: true,
+    continue: true,
+    debugger: true,
+    default: true,
+    delete: true,
+    do: true,
+    else: true,
+    enum: true,
+    eval: true,
+    export: true,
+    extends: true,
+    false: true,
+    finally: true,
+    for: true,
+    function: true,
+    if: true,
+    implements: true,
+    import: true,
+    in: true,
+    instanceof: true,
+    interface: true,
+    let: true,
+    new: true,
+    null: true,
+    package: true,
+    private: true,
+    protected: true,
+    public: true,
+    return: true,
+    static: true,
+    super: true,
+    switch: true,
+    this: true,
+    throw: true,
+    true: true,
+    try: true,
+    typeof: true,
+    undefined: true,
+    var: true,
+    void: true,
+    while: true,
+    with: true,
+    yield: true
+};
+
+function getSafeName(baseName, usedNames) {
+    let safeName = baseName;
+    let count = 1;
+    while (usedNames.has(safeName) || RESERVED_NAMES[safeName]) {
+        safeName = `${baseName}$${toBase64(count++)}`;
     }
+    usedNames.add(safeName);
+    return safeName;
 }
 
-const isInteger = (property) => typeof property === 'string' && /^\d+$/.test(property);
-// This makes sure unknown properties are not handled as "undefined" but as
-// "unknown" but without access side effects. An exception is done for numeric
-// properties as we do not expect new builtin properties to be numbers, this
-// will improve tree-shaking for out-of-bounds array properties
-const OBJECT_PROTOTYPE_FALLBACK = new (class ObjectPrototypeFallbackExpression extends ExpressionEntity {
-    deoptimizeThisOnInteractionAtPath({ type, thisArg }, path) {
-        if (type === INTERACTION_CALLED && path.length === 1 && !isInteger(path[0])) {
-            thisArg.deoptimizePath(UNKNOWN_PATH);
+const NO_ARGS = [];
+
+function assembleMemberDescriptions(memberDescriptions, inheritedDescriptions = null) {
+    return Object.create(inheritedDescriptions, memberDescriptions);
+}
+const UNDEFINED_EXPRESSION = new (class UndefinedExpression extends ExpressionEntity {
+    getLiteralValueAtPath() {
+        return undefined;
+    }
+})();
+const returnsUnknown = {
+    value: {
+        callsArgs: null,
+        returns: UNKNOWN_EXPRESSION
+    }
+};
+const UNKNOWN_LITERAL_BOOLEAN = new (class UnknownBoolean extends ExpressionEntity {
+    getReturnExpressionWhenCalledAtPath(path) {
+        if (path.length === 1) {
+            return getMemberReturnExpressionWhenCalled(literalBooleanMembers, path[0]);
         }
+        return UNKNOWN_EXPRESSION;
     }
-    getLiteralValueAtPath(path) {
-        // We ignore number properties as we do not expect new properties to be
-        // numbers and also want to keep handling out-of-bound array elements as
-        // "undefined"
-        return path.length === 1 && isInteger(path[0]) ? undefined : UnknownValue;
+    hasEffectsWhenAccessedAtPath(path) {
+        return path.length > 1;
     }
-    hasEffectsOnInteractionAtPath(path, { type }) {
-        return path.length > 1 || type === INTERACTION_CALLED;
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        if (path.length === 1) {
+            return hasMemberEffectWhenCalled(literalBooleanMembers, path[0], callOptions, context);
+        }
+        return true;
     }
 })();
-const OBJECT_PROTOTYPE = new ObjectEntity({
-    __proto__: null,
-    hasOwnProperty: METHOD_RETURNS_BOOLEAN,
-    isPrototypeOf: METHOD_RETURNS_BOOLEAN,
-    propertyIsEnumerable: METHOD_RETURNS_BOOLEAN,
-    toLocaleString: METHOD_RETURNS_STRING,
-    toString: METHOD_RETURNS_STRING,
-    valueOf: METHOD_RETURNS_UNKNOWN
-}, OBJECT_PROTOTYPE_FALLBACK, true);
-
-const NEW_ARRAY_PROPERTIES = [
-    { key: UnknownInteger, kind: 'init', property: UNKNOWN_EXPRESSION },
-    { key: 'length', kind: 'init', property: UNKNOWN_LITERAL_NUMBER }
-];
-const METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_BOOLEAN = [
-    new Method({
-        callsArgs: [0],
-        mutatesSelfAsArray: 'deopt-only',
-        returns: null,
-        returnsPrimitive: UNKNOWN_LITERAL_BOOLEAN
-    })
-];
-const METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NUMBER = [
-    new Method({
-        callsArgs: [0],
-        mutatesSelfAsArray: 'deopt-only',
-        returns: null,
-        returnsPrimitive: UNKNOWN_LITERAL_NUMBER
-    })
-];
-const METHOD_MUTATES_SELF_RETURNS_NEW_ARRAY = [
-    new Method({
-        callsArgs: null,
-        mutatesSelfAsArray: true,
-        returns: () => new ObjectEntity(NEW_ARRAY_PROPERTIES, ARRAY_PROTOTYPE),
-        returnsPrimitive: null
-    })
-];
-const METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY = [
-    new Method({
-        callsArgs: null,
-        mutatesSelfAsArray: 'deopt-only',
-        returns: () => new ObjectEntity(NEW_ARRAY_PROPERTIES, ARRAY_PROTOTYPE),
-        returnsPrimitive: null
-    })
-];
-const METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY = [
-    new Method({
-        callsArgs: [0],
-        mutatesSelfAsArray: 'deopt-only',
-        returns: () => new ObjectEntity(NEW_ARRAY_PROPERTIES, ARRAY_PROTOTYPE),
-        returnsPrimitive: null
-    })
-];
-const METHOD_MUTATES_SELF_RETURNS_NUMBER = [
-    new Method({
-        callsArgs: null,
-        mutatesSelfAsArray: true,
-        returns: null,
-        returnsPrimitive: UNKNOWN_LITERAL_NUMBER
-    })
-];
-const METHOD_MUTATES_SELF_RETURNS_UNKNOWN = [
-    new Method({
-        callsArgs: null,
-        mutatesSelfAsArray: true,
-        returns: null,
-        returnsPrimitive: UNKNOWN_EXPRESSION
-    })
-];
-const METHOD_DEOPTS_SELF_RETURNS_UNKNOWN = [
-    new Method({
-        callsArgs: null,
-        mutatesSelfAsArray: 'deopt-only',
-        returns: null,
-        returnsPrimitive: UNKNOWN_EXPRESSION
-    })
-];
-const METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN = [
-    new Method({
-        callsArgs: [0],
-        mutatesSelfAsArray: 'deopt-only',
-        returns: null,
-        returnsPrimitive: UNKNOWN_EXPRESSION
-    })
-];
-const METHOD_MUTATES_SELF_RETURNS_SELF = [
-    new Method({
+const returnsBoolean = {
+    value: {
         callsArgs: null,
-        mutatesSelfAsArray: true,
-        returns: 'self',
-        returnsPrimitive: null
-    })
-];
-const METHOD_CALLS_ARG_MUTATES_SELF_RETURNS_SELF = [
-    new Method({
-        callsArgs: [0],
-        mutatesSelfAsArray: true,
-        returns: 'self',
-        returnsPrimitive: null
-    })
-];
-const ARRAY_PROTOTYPE = new ObjectEntity({
-    __proto__: null,
-    // We assume that accessors have effects as we do not track the accessed value afterwards
-    at: METHOD_DEOPTS_SELF_RETURNS_UNKNOWN,
-    concat: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY,
-    copyWithin: METHOD_MUTATES_SELF_RETURNS_SELF,
-    entries: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY,
-    every: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_BOOLEAN,
-    fill: METHOD_MUTATES_SELF_RETURNS_SELF,
-    filter: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY,
-    find: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
-    findIndex: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NUMBER,
-    findLast: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
-    findLastIndex: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NUMBER,
-    flat: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY,
-    flatMap: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY,
-    forEach: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
-    includes: METHOD_RETURNS_BOOLEAN,
-    indexOf: METHOD_RETURNS_NUMBER,
-    join: METHOD_RETURNS_STRING,
-    keys: METHOD_RETURNS_UNKNOWN,
-    lastIndexOf: METHOD_RETURNS_NUMBER,
-    map: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY,
-    pop: METHOD_MUTATES_SELF_RETURNS_UNKNOWN,
-    push: METHOD_MUTATES_SELF_RETURNS_NUMBER,
-    reduce: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
-    reduceRight: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
-    reverse: METHOD_MUTATES_SELF_RETURNS_SELF,
-    shift: METHOD_MUTATES_SELF_RETURNS_UNKNOWN,
-    slice: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY,
-    some: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_BOOLEAN,
-    sort: METHOD_CALLS_ARG_MUTATES_SELF_RETURNS_SELF,
-    splice: METHOD_MUTATES_SELF_RETURNS_NEW_ARRAY,
-    toLocaleString: METHOD_RETURNS_STRING,
-    toString: METHOD_RETURNS_STRING,
-    unshift: METHOD_MUTATES_SELF_RETURNS_NUMBER,
-    values: METHOD_DEOPTS_SELF_RETURNS_UNKNOWN
-}, OBJECT_PROTOTYPE, true);
-
-class ArrayExpression extends NodeBase {
-    constructor() {
-        super(...arguments);
-        this.objectEntity = null;
-    }
-    deoptimizePath(path) {
-        this.getObjectEntity().deoptimizePath(path);
+        returns: UNKNOWN_LITERAL_BOOLEAN
     }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        this.getObjectEntity().deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
+};
+const UNKNOWN_LITERAL_NUMBER = new (class UnknownNumber extends ExpressionEntity {
+    getReturnExpressionWhenCalledAtPath(path) {
+        if (path.length === 1) {
+            return getMemberReturnExpressionWhenCalled(literalNumberMembers, path[0]);
+        }
+        return UNKNOWN_EXPRESSION;
     }
-    getLiteralValueAtPath(path, recursionTracker, origin) {
-        return this.getObjectEntity().getLiteralValueAtPath(path, recursionTracker, origin);
+    hasEffectsWhenAccessedAtPath(path) {
+        return path.length > 1;
     }
-    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
-        return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        if (path.length === 1) {
+            return hasMemberEffectWhenCalled(literalNumberMembers, path[0], callOptions, context);
+        }
+        return true;
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        return this.getObjectEntity().hasEffectsOnInteractionAtPath(path, interaction, context);
+})();
+const returnsNumber = {
+    value: {
+        callsArgs: null,
+        returns: UNKNOWN_LITERAL_NUMBER
     }
-    applyDeoptimizations() {
-        this.deoptimized = true;
-        let hasSpread = false;
-        for (let index = 0; index < this.elements.length; index++) {
-            const element = this.elements[index];
-            if (element && (hasSpread || element instanceof SpreadElement)) {
-                hasSpread = true;
-                element.deoptimizePath(UNKNOWN_PATH);
-            }
+};
+const UNKNOWN_LITERAL_STRING = new (class UnknownString extends ExpressionEntity {
+    getReturnExpressionWhenCalledAtPath(path) {
+        if (path.length === 1) {
+            return getMemberReturnExpressionWhenCalled(literalStringMembers, path[0]);
         }
-        this.context.requestTreeshakingPass();
+        return UNKNOWN_EXPRESSION;
     }
-    getObjectEntity() {
-        if (this.objectEntity !== null) {
-            return this.objectEntity;
-        }
-        const properties = [
-            { key: 'length', kind: 'init', property: UNKNOWN_LITERAL_NUMBER }
-        ];
-        let hasSpread = false;
-        for (let index = 0; index < this.elements.length; index++) {
-            const element = this.elements[index];
-            if (hasSpread || element instanceof SpreadElement) {
-                if (element) {
-                    hasSpread = true;
-                    properties.unshift({ key: UnknownInteger, kind: 'init', property: element });
-                }
-            }
-            else if (element) {
-                properties.push({ key: String(index), kind: 'init', property: element });
-            }
-            else {
-                properties.push({ key: String(index), kind: 'init', property: UNDEFINED_EXPRESSION });
-            }
-        }
-        return (this.objectEntity = new ObjectEntity(properties, ARRAY_PROTOTYPE));
+    hasEffectsWhenAccessedAtPath(path) {
+        return path.length > 1;
     }
-}
-
-class ArrayPattern extends NodeBase {
-    addExportedVariables(variables, exportNamesByVariable) {
-        for (const element of this.elements) {
-            element?.addExportedVariables(variables, exportNamesByVariable);
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        if (path.length === 1) {
+            return hasMemberEffectWhenCalled(literalStringMembers, path[0], callOptions, context);
         }
+        return true;
     }
-    declare(kind) {
-        const variables = [];
-        for (const element of this.elements) {
-            if (element !== null) {
-                variables.push(...element.declare(kind, UNKNOWN_EXPRESSION));
-            }
-        }
-        return variables;
+})();
+const returnsString = {
+    value: {
+        callsArgs: null,
+        returns: UNKNOWN_LITERAL_STRING
     }
-    // Patterns can only be deoptimized at the empty path at the moment
-    deoptimizePath() {
-        for (const element of this.elements) {
-            element?.deoptimizePath(EMPTY_PATH);
+};
+const objectMembers = assembleMemberDescriptions({
+    hasOwnProperty: returnsBoolean,
+    isPrototypeOf: returnsBoolean,
+    propertyIsEnumerable: returnsBoolean,
+    toLocaleString: returnsString,
+    toString: returnsString,
+    valueOf: returnsUnknown
+});
+const literalBooleanMembers = assembleMemberDescriptions({
+    valueOf: returnsBoolean
+}, objectMembers);
+const literalNumberMembers = assembleMemberDescriptions({
+    toExponential: returnsString,
+    toFixed: returnsString,
+    toLocaleString: returnsString,
+    toPrecision: returnsString,
+    valueOf: returnsNumber
+}, objectMembers);
+const literalStringMembers = assembleMemberDescriptions({
+    charAt: returnsString,
+    charCodeAt: returnsNumber,
+    codePointAt: returnsNumber,
+    concat: returnsString,
+    endsWith: returnsBoolean,
+    includes: returnsBoolean,
+    indexOf: returnsNumber,
+    lastIndexOf: returnsNumber,
+    localeCompare: returnsNumber,
+    match: returnsBoolean,
+    normalize: returnsString,
+    padEnd: returnsString,
+    padStart: returnsString,
+    repeat: returnsString,
+    replace: {
+        value: {
+            callsArgs: [1],
+            returns: UNKNOWN_LITERAL_STRING
         }
+    },
+    search: returnsNumber,
+    slice: returnsString,
+    split: returnsUnknown,
+    startsWith: returnsBoolean,
+    substr: returnsString,
+    substring: returnsString,
+    toLocaleLowerCase: returnsString,
+    toLocaleUpperCase: returnsString,
+    toLowerCase: returnsString,
+    toUpperCase: returnsString,
+    trim: returnsString,
+    valueOf: returnsString
+}, objectMembers);
+function getLiteralMembersForValue(value) {
+    switch (typeof value) {
+        case 'boolean':
+            return literalBooleanMembers;
+        case 'number':
+            return literalNumberMembers;
+        case 'string':
+            return literalStringMembers;
+        default:
+            return Object.create(null);
     }
-    // Patterns are only checked at the emtpy path at the moment
-    hasEffectsOnInteractionAtPath(_path, interaction, context) {
-        for (const element of this.elements) {
-            if (element?.hasEffectsOnInteractionAtPath(EMPTY_PATH, interaction, context))
-                return true;
-        }
-        return false;
+}
+function hasMemberEffectWhenCalled(members, memberName, callOptions, context) {
+    if (typeof memberName !== 'string' || !members[memberName]) {
+        return true;
     }
-    markDeclarationReached() {
-        for (const element of this.elements) {
-            element?.markDeclarationReached();
-        }
+    if (!members[memberName].callsArgs)
+        return false;
+    for (const argIndex of members[memberName].callsArgs) {
+        if (callOptions.args[argIndex] &&
+            callOptions.args[argIndex].hasEffectsWhenCalledAtPath(EMPTY_PATH, {
+                args: NO_ARGS,
+                thisParam: null,
+                withNew: false
+            }, context))
+            return true;
     }
+    return false;
+}
+function getMemberReturnExpressionWhenCalled(members, memberName) {
+    if (typeof memberName !== 'string' || !members[memberName])
+        return UNKNOWN_EXPRESSION;
+    return members[memberName].returns;
 }
 
 class LocalVariable extends Variable {
@@ -7092,6 +5620,7 @@
         }
     }
     deoptimizePath(path) {
+        var _a, _b;
         if (this.isReassigned ||
             this.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(path, this)) {
             return;
@@ -7104,18 +5633,18 @@
                 for (const expression of expressionsToBeDeoptimized) {
                     expression.deoptimizeCache();
                 }
-                this.init?.deoptimizePath(UNKNOWN_PATH);
+                (_a = this.init) === null || _a === void 0 ? void 0 : _a.deoptimizePath(UNKNOWN_PATH);
             }
         }
         else {
-            this.init?.deoptimizePath(path);
+            (_b = this.init) === null || _b === void 0 ? void 0 : _b.deoptimizePath(path);
         }
     }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
         if (this.isReassigned || !this.init) {
-            return interaction.thisArg.deoptimizePath(UNKNOWN_PATH);
+            return thisParameter.deoptimizePath(UNKNOWN_PATH);
         }
-        recursionTracker.withTrackedEntityAtPath(path, this.init, () => this.init.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker), undefined);
+        recursionTracker.withTrackedEntityAtPath(path, this.init, () => this.init.deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker), undefined);
     }
     getLiteralValueAtPath(path, recursionTracker, origin) {
         if (this.isReassigned || !this.init) {
@@ -7126,43 +5655,39 @@
             return this.init.getLiteralValueAtPath(path, recursionTracker, origin);
         }, UnknownValue);
     }
-    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
+    getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin) {
         if (this.isReassigned || !this.init) {
-            return UNKNOWN_RETURN_EXPRESSION;
+            return UNKNOWN_EXPRESSION;
         }
         return recursionTracker.withTrackedEntityAtPath(path, this.init, () => {
             this.expressionsToBeDeoptimized.push(origin);
-            return this.init.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
-        }, UNKNOWN_RETURN_EXPRESSION);
+            return this.init.getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin);
+        }, UNKNOWN_EXPRESSION);
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        switch (interaction.type) {
-            case INTERACTION_ACCESSED: {
-                if (this.isReassigned)
-                    return true;
-                return (this.init &&
-                    !context.accessed.trackEntityAtPathAndGetIfTracked(path, this) &&
-                    this.init.hasEffectsOnInteractionAtPath(path, interaction, context));
-            }
-            case INTERACTION_ASSIGNED: {
-                if (this.included)
-                    return true;
-                if (path.length === 0)
-                    return false;
-                if (this.isReassigned)
-                    return true;
-                return (this.init &&
-                    !context.assigned.trackEntityAtPathAndGetIfTracked(path, this) &&
-                    this.init.hasEffectsOnInteractionAtPath(path, interaction, context));
-            }
-            case INTERACTION_CALLED: {
-                if (this.isReassigned)
-                    return true;
-                return (this.init &&
-                    !(interaction.withNew ? context.instantiated : context.called).trackEntityAtPathAndGetIfTracked(path, interaction.args, this) &&
-                    this.init.hasEffectsOnInteractionAtPath(path, interaction, context));
-            }
-        }
+    hasEffectsWhenAccessedAtPath(path, context) {
+        if (this.isReassigned)
+            return true;
+        return (this.init &&
+            !context.accessed.trackEntityAtPathAndGetIfTracked(path, this) &&
+            this.init.hasEffectsWhenAccessedAtPath(path, context));
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        if (this.included)
+            return true;
+        if (path.length === 0)
+            return false;
+        if (this.isReassigned)
+            return true;
+        return (this.init &&
+            !context.accessed.trackEntityAtPathAndGetIfTracked(path, this) &&
+            this.init.hasEffectsWhenAssignedAtPath(path, context));
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        if (this.isReassigned)
+            return true;
+        return (this.init &&
+            !(callOptions.withNew ? context.instantiated : context.called).trackEntityAtPathAndGetIfTracked(path, callOptions, this) &&
+            this.init.hasEffectsWhenCalledAtPath(path, callOptions, context));
     }
     include() {
         if (!this.included) {
@@ -7183,15 +5708,15 @@
             }
         }
     }
-    includeCallArguments(context, parameters) {
+    includeCallArguments(context, args) {
         if (this.isReassigned || (this.init && context.includedCallArguments.has(this.init))) {
-            for (const argument of parameters) {
-                argument.include(context, false);
+            for (const arg of args) {
+                arg.include(context, false);
             }
         }
         else if (this.init) {
             context.includedCallArguments.add(this.init);
-            this.init.includeCallArguments(context, parameters);
+            this.init.includeCallArguments(context, args);
             context.includedCallArguments.delete(this.init);
         }
     }
@@ -7208,29 +5733,7 @@
     }
 }
 
-const chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$';
-const base = 64;
-function toBase64(value) {
-    let outString = '';
-    do {
-        const currentDigit = value % base;
-        value = (value / base) | 0;
-        outString = chars[currentDigit] + outString;
-    } while (value !== 0);
-    return outString;
-}
-
-function getSafeName(baseName, usedNames, forbiddenNames) {
-    let safeName = baseName;
-    let count = 1;
-    while (usedNames.has(safeName) || RESERVED_NAMES$1.has(safeName) || forbiddenNames?.has(safeName)) {
-        safeName = `${baseName}$${toBase64(count++)}`;
-    }
-    usedNames.add(safeName);
-    return safeName;
-}
-
-let Scope$1 = class Scope {
+class Scope$1 {
     constructor() {
         this.children = [];
         this.variables = new Map();
@@ -7253,7 +5756,7 @@
     findVariable(_name) {
         throw new Error('Internal Error: findVariable needs to be implemented by a subclass');
     }
-};
+}
 
 class ChildScope extends Scope$1 {
     constructor(parent) {
@@ -7316,7 +5819,7 @@
         }
         for (const [name, variable] of this.variables) {
             if (variable.included || variable.alwaysRendered) {
-                variable.setRenderNames(null, getSafeName(name, usedNames, variable.forbiddenNames));
+                variable.setRenderNames(null, getSafeName(name, usedNames));
             }
         }
         for (const scope of this.children) {
@@ -7337,108 +5840,7 @@
     }
 }
 
-class ParameterScope extends ChildScope {
-    constructor(parent, context) {
-        super(parent);
-        this.parameters = [];
-        this.hasRest = false;
-        this.context = context;
-        this.hoistedBodyVarScope = new ChildScope(this);
-    }
-    /**
-     * Adds a parameter to this scope. Parameters must be added in the correct
-     * order, e.g. from left to right.
-     */
-    addParameterDeclaration(identifier) {
-        const name = identifier.name;
-        let variable = this.hoistedBodyVarScope.variables.get(name);
-        if (variable) {
-            variable.addDeclaration(identifier, null);
-        }
-        else {
-            variable = new LocalVariable(name, identifier, UNKNOWN_EXPRESSION, this.context);
-        }
-        this.variables.set(name, variable);
-        return variable;
-    }
-    addParameterVariables(parameters, hasRest) {
-        this.parameters = parameters;
-        for (const parameterList of parameters) {
-            for (const parameter of parameterList) {
-                parameter.alwaysRendered = true;
-            }
-        }
-        this.hasRest = hasRest;
-    }
-    includeCallArguments(context, parameters) {
-        let calledFromTryStatement = false;
-        let argumentIncluded = false;
-        const restParameter = this.hasRest && this.parameters[this.parameters.length - 1];
-        for (const checkedArgument of parameters) {
-            if (checkedArgument instanceof SpreadElement) {
-                for (const argument of parameters) {
-                    argument.include(context, false);
-                }
-                break;
-            }
-        }
-        for (let index = parameters.length - 1; index >= 0; index--) {
-            const parameterVariables = this.parameters[index] || restParameter;
-            const argument = parameters[index];
-            if (parameterVariables) {
-                calledFromTryStatement = false;
-                if (parameterVariables.length === 0) {
-                    // handle empty destructuring
-                    argumentIncluded = true;
-                }
-                else {
-                    for (const variable of parameterVariables) {
-                        if (variable.included) {
-                            argumentIncluded = true;
-                        }
-                        if (variable.calledFromTryStatement) {
-                            calledFromTryStatement = true;
-                        }
-                    }
-                }
-            }
-            if (!argumentIncluded && argument.shouldBeIncluded(context)) {
-                argumentIncluded = true;
-            }
-            if (argumentIncluded) {
-                argument.include(context, calledFromTryStatement);
-            }
-        }
-    }
-}
-
-class ReturnValueScope extends ParameterScope {
-    constructor() {
-        super(...arguments);
-        this.returnExpression = null;
-        this.returnExpressions = [];
-    }
-    addReturnExpression(expression) {
-        this.returnExpressions.push(expression);
-    }
-    getReturnExpression() {
-        if (this.returnExpression === null)
-            this.updateReturnExpression();
-        return this.returnExpression;
-    }
-    updateReturnExpression() {
-        if (this.returnExpressions.length === 1) {
-            this.returnExpression = this.returnExpressions[0];
-        }
-        else {
-            this.returnExpression = UNKNOWN_EXPRESSION;
-            for (const expression of this.returnExpressions) {
-                expression.deoptimizePath(UNKNOWN_PATH);
-            }
-        }
-    }
-}
-
+//@ts-check
 /** @typedef { import('estree').Node} Node */
 /** @typedef {Node | {
  *   type: 'PropertyDefinition';
@@ -7450,7 +5852,7 @@
  *
  * @param {NodeWithPropertyDefinition} node
  * @param {NodeWithPropertyDefinition} parent
- * @returns {boolean}
+ * @returns boolean
  */
 function is_reference (node, parent) {
 	if (node.type === 'MemberExpression') {
@@ -7489,32 +5891,10 @@
 	return false;
 }
 
-const PureFunctionKey = Symbol('PureFunction');
-const getPureFunctions = ({ treeshake }) => {
-    const pureFunctions = Object.create(null);
-    for (const functionName of treeshake ? treeshake.manualPureFunctions : []) {
-        let currentFunctions = pureFunctions;
-        for (const pathSegment of functionName.split('.')) {
-            currentFunctions = currentFunctions[pathSegment] || (currentFunctions[pathSegment] = Object.create(null));
-        }
-        currentFunctions[PureFunctionKey] = true;
-    }
-    return pureFunctions;
-};
-
 /* eslint sort-keys: "off" */
 const ValueProperties = Symbol('Value Properties');
-const getTruthyLiteralValue = () => UnknownTruthyValue;
-const returnFalse = () => false;
-const returnTrue = () => true;
-const PURE = {
-    getLiteralValue: getTruthyLiteralValue,
-    hasEffectsWhenCalled: returnFalse
-};
-const IMPURE = {
-    getLiteralValue: getTruthyLiteralValue,
-    hasEffectsWhenCalled: returnTrue
-};
+const PURE = { pure: true };
+const IMPURE = { pure: false };
 // We use shortened variables to reduce file size here
 /* OBJECT */
 const O = {
@@ -7526,17 +5906,6 @@
     __proto__: null,
     [ValueProperties]: PURE
 };
-/* FUNCTION THAT MUTATES FIRST ARG WITHOUT TRIGGERING ACCESSORS */
-const MUTATES_ARG_WITHOUT_ACCESSOR = {
-    __proto__: null,
-    [ValueProperties]: {
-        getLiteralValue: getTruthyLiteralValue,
-        hasEffectsWhenCalled({ args }, context) {
-            return (args.length === 0 ||
-                args[0].hasEffectsOnInteractionAtPath(UNKNOWN_NON_ACCESSOR_PATH, NODE_INTERACTION_UNKNOWN_ASSIGNMENT, context));
-        }
-    }
-};
 /* CONSTRUCTOR */
 const C = {
     __proto__: null,
@@ -7675,24 +6044,17 @@
         __proto__: null,
         [ValueProperties]: PURE,
         create: PF,
-        // Technically those can throw in certain situations, but we ignore this as
-        // code that relies on this will hopefully wrap this in a try-catch, which
-        // deoptimizes everything anyway
-        defineProperty: MUTATES_ARG_WITHOUT_ACCESSOR,
-        defineProperties: MUTATES_ARG_WITHOUT_ACCESSOR,
-        freeze: MUTATES_ARG_WITHOUT_ACCESSOR,
+        getNotifier: PF,
+        getOwn: PF,
         getOwnPropertyDescriptor: PF,
         getOwnPropertyNames: PF,
         getOwnPropertySymbols: PF,
         getPrototypeOf: PF,
-        hasOwn: PF,
         is: PF,
         isExtensible: PF,
         isFrozen: PF,
         isSealed: PF,
         keys: PF,
-        fromEntries: PF,
-        entries: PF,
         prototype: O
     },
     parseFloat: PF,
@@ -7727,16 +6089,7 @@
         [ValueProperties]: PURE,
         for: PF,
         keyFor: PF,
-        prototype: O,
-        toStringTag: {
-            __proto__: null,
-            [ValueProperties]: {
-                getLiteralValue() {
-                    return SymbolToStringTag;
-                },
-                hasEffectsWhenCalled: returnTrue
-            }
-        }
+        prototype: O
     },
     SyntaxError: PC,
     toLocaleString: O,
@@ -8373,35 +6726,27 @@
     }
     return currentGlobal[ValueProperties];
 }
+function isPureGlobal(path) {
+    const globalAtPath = getGlobalAtPath(path);
+    return globalAtPath !== null && globalAtPath.pure;
+}
+function isGlobalMember(path) {
+    if (path.length === 1) {
+        return path[0] === 'undefined' || getGlobalAtPath(path) !== null;
+    }
+    return getGlobalAtPath(path.slice(0, -1)) !== null;
+}
 
 class GlobalVariable extends Variable {
     constructor() {
         super(...arguments);
-        // Ensure we use live-bindings for globals as we do not know if they have
-        // been reassigned
         this.isReassigned = true;
     }
-    getLiteralValueAtPath(path, _recursionTracker, _origin) {
-        const globalAtPath = getGlobalAtPath([this.name, ...path]);
-        return globalAtPath ? globalAtPath.getLiteralValue() : UnknownValue;
-    }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        switch (interaction.type) {
-            case INTERACTION_ACCESSED: {
-                if (path.length === 0) {
-                    // Technically, "undefined" is a global variable of sorts
-                    return this.name !== 'undefined' && !getGlobalAtPath([this.name]);
-                }
-                return !getGlobalAtPath([this.name, ...path].slice(0, -1));
-            }
-            case INTERACTION_ASSIGNED: {
-                return true;
-            }
-            case INTERACTION_CALLED: {
-                const globalAtPath = getGlobalAtPath([this.name, ...path]);
-                return !globalAtPath || globalAtPath.hasEffectsWhenCalled(interaction, context);
-            }
-        }
+    hasEffectsWhenAccessedAtPath(path) {
+        return !isGlobalMember([this.name, ...path]);
+    }
+    hasEffectsWhenCalledAtPath(path) {
+        return !isPureGlobal([this.name, ...path]);
     }
 }
 
@@ -8416,15 +6761,16 @@
     constructor() {
         super(...arguments);
         this.variable = null;
+        this.deoptimized = false;
         this.isTDZAccess = null;
     }
     addExportedVariables(variables, exportNamesByVariable) {
-        if (exportNamesByVariable.has(this.variable)) {
+        if (this.variable !== null && exportNamesByVariable.has(this.variable)) {
             variables.push(this.variable);
         }
     }
     bind() {
-        if (!this.variable && is_reference(this, this.parent)) {
+        if (this.variable === null && is_reference(this, this.parent)) {
             this.variable = this.scope.findVariable(this.name);
             this.variable.addReference(this);
         }
@@ -8433,34 +6779,29 @@
         let variable;
         const { treeshake } = this.context.options;
         switch (kind) {
-            case 'var': {
+            case 'var':
                 variable = this.scope.addDeclaration(this, this.context, init, true);
                 if (treeshake && treeshake.correctVarValueBeforeDeclaration) {
                     // Necessary to make sure the init is deoptimized. We cannot call deoptimizePath here.
                     variable.markInitializersForDeoptimization();
                 }
                 break;
-            }
-            case 'function': {
+            case 'function':
                 // in strict mode, functions are only hoisted within a scope but not across block scopes
                 variable = this.scope.addDeclaration(this, this.context, init, false);
                 break;
-            }
             case 'let':
             case 'const':
-            case 'class': {
+            case 'class':
                 variable = this.scope.addDeclaration(this, this.context, init, false);
                 break;
-            }
-            case 'parameter': {
+            case 'parameter':
                 variable = this.scope.addParameterDeclaration(this);
                 break;
-            }
             /* istanbul ignore next */
-            default: {
+            default:
                 /* istanbul ignore next */
                 throw new Error(`Internal Error: Unexpected identifier kind ${kind}.`);
-            }
         }
         variable.kind = kind;
         return [(this.variable = variable)];
@@ -8469,21 +6810,18 @@
         if (path.length === 0 && !this.scope.contains(this.name)) {
             this.disallowImportReassignment();
         }
-        // We keep conditional chaining because an unknown Node could have an
-        // Identifier as property that might be deoptimized by default
-        this.variable?.deoptimizePath(path);
+        this.variable.deoptimizePath(path);
     }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        this.variable.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
+        this.variable.deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker);
     }
     getLiteralValueAtPath(path, recursionTracker, origin) {
         return this.getVariableRespectingTDZ().getLiteralValueAtPath(path, recursionTracker, origin);
     }
-    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
-        const [expression, isPure] = this.getVariableRespectingTDZ().getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
-        return [expression, isPure || this.isPureFunction(path)];
+    getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin) {
+        return this.getVariableRespectingTDZ().getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin);
     }
-    hasEffects(context) {
+    hasEffects() {
         if (!this.deoptimized)
             this.applyDeoptimizations();
         if (this.isPossibleTDZ() && this.variable.kind !== 'var') {
@@ -8491,24 +6829,21 @@
         }
         return (this.context.options.treeshake.unknownGlobalSideEffects &&
             this.variable instanceof GlobalVariable &&
-            !this.isPureFunction(EMPTY_PATH) &&
-            this.variable.hasEffectsOnInteractionAtPath(EMPTY_PATH, NODE_INTERACTION_UNKNOWN_ACCESS, context));
+            this.variable.hasEffectsWhenAccessedAtPath(EMPTY_PATH));
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        switch (interaction.type) {
-            case INTERACTION_ACCESSED: {
-                return (this.variable !== null &&
-                    !this.isPureFunction(path) &&
-                    this.getVariableRespectingTDZ().hasEffectsOnInteractionAtPath(path, interaction, context));
-            }
-            case INTERACTION_ASSIGNED: {
-                return (path.length > 0 ? this.getVariableRespectingTDZ() : this.variable).hasEffectsOnInteractionAtPath(path, interaction, context);
-            }
-            case INTERACTION_CALLED: {
-                return (!this.isPureFunction(path) &&
-                    this.getVariableRespectingTDZ().hasEffectsOnInteractionAtPath(path, interaction, context));
-            }
-        }
+    hasEffectsWhenAccessedAtPath(path, context) {
+        return (this.variable !== null &&
+            this.getVariableRespectingTDZ().hasEffectsWhenAccessedAtPath(path, context));
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        return (!this.variable ||
+            (path.length > 0
+                ? this.getVariableRespectingTDZ()
+                : this.variable).hasEffectsWhenAssignedAtPath(path, context));
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        return (!this.variable ||
+            this.getVariableRespectingTDZ().hasEffectsWhenCalledAtPath(path, callOptions, context));
     }
     include() {
         if (!this.deoptimized)
@@ -8520,8 +6855,8 @@
             }
         }
     }
-    includeCallArguments(context, parameters) {
-        this.variable.includeCallArguments(context, parameters);
+    includeCallArguments(context, args) {
+        this.getVariableRespectingTDZ().includeCallArguments(context, args);
     }
     isPossibleTDZ() {
         // return cached value to avoid issues with the next tree-shaking pass
@@ -8574,13 +6909,16 @@
     }
     applyDeoptimizations() {
         this.deoptimized = true;
-        if (this.variable instanceof LocalVariable) {
+        if (this.variable !== null && this.variable instanceof LocalVariable) {
             this.variable.consolidateInitializers();
             this.context.requestTreeshakingPass();
         }
     }
     disallowImportReassignment() {
-        return this.context.error(errorIllegalImportReassignment(this.name, this.context.module.id), this.start);
+        return this.context.error({
+            code: 'ILLEGAL_REASSIGNMENT',
+            message: `Illegal reassignment to import '${this.name}'`
+        }, this.start);
     }
     getVariableRespectingTDZ() {
         if (this.isPossibleTDZ()) {
@@ -8588,183 +6926,1706 @@
         }
         return this.variable;
     }
-    isPureFunction(path) {
-        let currentPureFunction = this.context.manualPureFunctions[this.name];
-        for (const segment of path) {
-            if (currentPureFunction) {
-                if (currentPureFunction[PureFunctionKey]) {
+}
+function closestParentFunctionOrProgram(node) {
+    while (node && !/^Program|Function/.test(node.type)) {
+        node = node.parent;
+    }
+    // one of: ArrowFunctionExpression, FunctionDeclaration, FunctionExpression or Program
+    return node;
+}
+
+const EVENT_ACCESSED = 0;
+const EVENT_ASSIGNED = 1;
+const EVENT_CALLED = 2;
+
+class MethodBase extends NodeBase {
+    constructor() {
+        super(...arguments);
+        this.accessedValue = null;
+        this.accessorCallOptions = {
+            args: NO_ARGS,
+            thisParam: null,
+            withNew: false
+        };
+    }
+    // As getter properties directly receive their values from fixed function
+    // expressions, there is no known situation where a getter is deoptimized.
+    deoptimizeCache() { }
+    deoptimizePath(path) {
+        this.getAccessedValue().deoptimizePath(path);
+    }
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
+        if (event === EVENT_ACCESSED && this.kind === 'get' && path.length === 0) {
+            return this.value.deoptimizeThisOnEventAtPath(EVENT_CALLED, EMPTY_PATH, thisParameter, recursionTracker);
+        }
+        if (event === EVENT_ASSIGNED && this.kind === 'set' && path.length === 0) {
+            return this.value.deoptimizeThisOnEventAtPath(EVENT_CALLED, EMPTY_PATH, thisParameter, recursionTracker);
+        }
+        this.getAccessedValue().deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker);
+    }
+    getLiteralValueAtPath(path, recursionTracker, origin) {
+        return this.getAccessedValue().getLiteralValueAtPath(path, recursionTracker, origin);
+    }
+    getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin) {
+        return this.getAccessedValue().getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin);
+    }
+    hasEffects(context) {
+        return this.key.hasEffects(context);
+    }
+    hasEffectsWhenAccessedAtPath(path, context) {
+        if (this.kind === 'get' && path.length === 0) {
+            return this.value.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.accessorCallOptions, context);
+        }
+        return this.getAccessedValue().hasEffectsWhenAccessedAtPath(path, context);
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        if (this.kind === 'set') {
+            return this.value.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.accessorCallOptions, context);
+        }
+        return this.getAccessedValue().hasEffectsWhenAssignedAtPath(path, context);
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        return this.getAccessedValue().hasEffectsWhenCalledAtPath(path, callOptions, context);
+    }
+    getAccessedValue() {
+        if (this.accessedValue === null) {
+            if (this.kind === 'get') {
+                this.accessedValue = UNKNOWN_EXPRESSION;
+                return (this.accessedValue = this.value.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, this.accessorCallOptions, SHARED_RECURSION_TRACKER, this));
+            }
+            else {
+                return (this.accessedValue = this.value);
+            }
+        }
+        return this.accessedValue;
+    }
+}
+
+class MethodDefinition extends MethodBase {
+}
+
+const INTEGER_REG_EXP = /^\d+$/;
+class ObjectEntity extends ExpressionEntity {
+    // If a PropertyMap is used, this will be taken as propertiesAndGettersByKey
+    // and we assume there are no setters or getters
+    constructor(properties, prototypeExpression, immutable = false) {
+        super();
+        this.prototypeExpression = prototypeExpression;
+        this.immutable = immutable;
+        this.allProperties = [];
+        this.deoptimizedPaths = Object.create(null);
+        this.expressionsToBeDeoptimizedByKey = Object.create(null);
+        this.gettersByKey = Object.create(null);
+        this.hasUnknownDeoptimizedInteger = false;
+        this.hasUnknownDeoptimizedProperty = false;
+        this.propertiesAndGettersByKey = Object.create(null);
+        this.propertiesAndSettersByKey = Object.create(null);
+        this.settersByKey = Object.create(null);
+        this.thisParametersToBeDeoptimized = new Set();
+        this.unknownIntegerProps = [];
+        this.unmatchableGetters = [];
+        this.unmatchablePropertiesAndGetters = [];
+        this.unmatchableSetters = [];
+        if (Array.isArray(properties)) {
+            this.buildPropertyMaps(properties);
+        }
+        else {
+            this.propertiesAndGettersByKey = this.propertiesAndSettersByKey = properties;
+            for (const propertiesForKey of Object.values(properties)) {
+                this.allProperties.push(...propertiesForKey);
+            }
+        }
+    }
+    deoptimizeAllProperties() {
+        var _a;
+        if (this.hasUnknownDeoptimizedProperty) {
+            return;
+        }
+        this.hasUnknownDeoptimizedProperty = true;
+        for (const properties of Object.values(this.propertiesAndGettersByKey).concat(Object.values(this.settersByKey))) {
+            for (const property of properties) {
+                property.deoptimizePath(UNKNOWN_PATH);
+            }
+        }
+        // While the prototype itself cannot be mutated, each property can
+        (_a = this.prototypeExpression) === null || _a === void 0 ? void 0 : _a.deoptimizePath([UnknownKey, UnknownKey]);
+        this.deoptimizeCachedEntities();
+    }
+    deoptimizeIntegerProperties() {
+        if (this.hasUnknownDeoptimizedProperty || this.hasUnknownDeoptimizedInteger) {
+            return;
+        }
+        this.hasUnknownDeoptimizedInteger = true;
+        for (const [key, propertiesAndGetters] of Object.entries(this.propertiesAndGettersByKey)) {
+            if (INTEGER_REG_EXP.test(key)) {
+                for (const property of propertiesAndGetters) {
+                    property.deoptimizePath(UNKNOWN_PATH);
+                }
+            }
+        }
+        this.deoptimizeCachedIntegerEntities();
+    }
+    deoptimizePath(path) {
+        var _a;
+        if (this.hasUnknownDeoptimizedProperty || this.immutable)
+            return;
+        const key = path[0];
+        if (path.length === 1) {
+            if (typeof key !== 'string') {
+                if (key === UnknownInteger) {
+                    return this.deoptimizeIntegerProperties();
+                }
+                return this.deoptimizeAllProperties();
+            }
+            if (!this.deoptimizedPaths[key]) {
+                this.deoptimizedPaths[key] = true;
+                // we only deoptimizeCache exact matches as in all other cases,
+                // we do not return a literal value or return expression
+                const expressionsToBeDeoptimized = this.expressionsToBeDeoptimizedByKey[key];
+                if (expressionsToBeDeoptimized) {
+                    for (const expression of expressionsToBeDeoptimized) {
+                        expression.deoptimizeCache();
+                    }
+                }
+            }
+        }
+        const subPath = path.length === 1 ? UNKNOWN_PATH : path.slice(1);
+        for (const property of typeof key === 'string'
+            ? (this.propertiesAndGettersByKey[key] || this.unmatchablePropertiesAndGetters).concat(this.settersByKey[key] || this.unmatchableSetters)
+            : this.allProperties) {
+            property.deoptimizePath(subPath);
+        }
+        (_a = this.prototypeExpression) === null || _a === void 0 ? void 0 : _a.deoptimizePath(path.length === 1 ? [UnknownKey, UnknownKey] : path);
+    }
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
+        var _a;
+        const [key, ...subPath] = path;
+        if (this.hasUnknownDeoptimizedProperty ||
+            // single paths that are deoptimized will not become getters or setters
+            ((event === EVENT_CALLED || path.length > 1) &&
+                typeof key === 'string' &&
+                this.deoptimizedPaths[key])) {
+            thisParameter.deoptimizePath(UNKNOWN_PATH);
+            return;
+        }
+        const [propertiesForExactMatchByKey, relevantPropertiesByKey, relevantUnmatchableProperties] = event === EVENT_CALLED || path.length > 1
+            ? [
+                this.propertiesAndGettersByKey,
+                this.propertiesAndGettersByKey,
+                this.unmatchablePropertiesAndGetters
+            ]
+            : event === EVENT_ACCESSED
+                ? [this.propertiesAndGettersByKey, this.gettersByKey, this.unmatchableGetters]
+                : [this.propertiesAndSettersByKey, this.settersByKey, this.unmatchableSetters];
+        if (typeof key === 'string') {
+            if (propertiesForExactMatchByKey[key]) {
+                const properties = relevantPropertiesByKey[key];
+                if (properties) {
+                    for (const property of properties) {
+                        property.deoptimizeThisOnEventAtPath(event, subPath, thisParameter, recursionTracker);
+                    }
+                }
+                if (!this.immutable) {
+                    this.thisParametersToBeDeoptimized.add(thisParameter);
+                }
+                return;
+            }
+            for (const property of relevantUnmatchableProperties) {
+                property.deoptimizeThisOnEventAtPath(event, subPath, thisParameter, recursionTracker);
+            }
+            if (INTEGER_REG_EXP.test(key)) {
+                for (const property of this.unknownIntegerProps) {
+                    property.deoptimizeThisOnEventAtPath(event, subPath, thisParameter, recursionTracker);
+                }
+            }
+        }
+        else {
+            for (const properties of Object.values(relevantPropertiesByKey).concat([
+                relevantUnmatchableProperties
+            ])) {
+                for (const property of properties) {
+                    property.deoptimizeThisOnEventAtPath(event, subPath, thisParameter, recursionTracker);
+                }
+            }
+            for (const property of this.unknownIntegerProps) {
+                property.deoptimizeThisOnEventAtPath(event, subPath, thisParameter, recursionTracker);
+            }
+        }
+        if (!this.immutable) {
+            this.thisParametersToBeDeoptimized.add(thisParameter);
+        }
+        (_a = this.prototypeExpression) === null || _a === void 0 ? void 0 : _a.deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker);
+    }
+    getLiteralValueAtPath(path, recursionTracker, origin) {
+        if (path.length === 0) {
+            return UnknownValue;
+        }
+        const key = path[0];
+        const expressionAtPath = this.getMemberExpressionAndTrackDeopt(key, origin);
+        if (expressionAtPath) {
+            return expressionAtPath.getLiteralValueAtPath(path.slice(1), recursionTracker, origin);
+        }
+        if (this.prototypeExpression) {
+            return this.prototypeExpression.getLiteralValueAtPath(path, recursionTracker, origin);
+        }
+        if (path.length === 1) {
+            return undefined;
+        }
+        return UnknownValue;
+    }
+    getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin) {
+        if (path.length === 0) {
+            return UNKNOWN_EXPRESSION;
+        }
+        const key = path[0];
+        const expressionAtPath = this.getMemberExpressionAndTrackDeopt(key, origin);
+        if (expressionAtPath) {
+            return expressionAtPath.getReturnExpressionWhenCalledAtPath(path.slice(1), callOptions, recursionTracker, origin);
+        }
+        if (this.prototypeExpression) {
+            return this.prototypeExpression.getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin);
+        }
+        return UNKNOWN_EXPRESSION;
+    }
+    hasEffectsWhenAccessedAtPath(path, context) {
+        const [key, ...subPath] = path;
+        if (path.length > 1) {
+            if (typeof key !== 'string') {
+                return true;
+            }
+            const expressionAtPath = this.getMemberExpression(key);
+            if (expressionAtPath) {
+                return expressionAtPath.hasEffectsWhenAccessedAtPath(subPath, context);
+            }
+            if (this.prototypeExpression) {
+                return this.prototypeExpression.hasEffectsWhenAccessedAtPath(path, context);
+            }
+            return true;
+        }
+        if (this.hasUnknownDeoptimizedProperty)
+            return true;
+        if (typeof key === 'string') {
+            if (this.propertiesAndGettersByKey[key]) {
+                const getters = this.gettersByKey[key];
+                if (getters) {
+                    for (const getter of getters) {
+                        if (getter.hasEffectsWhenAccessedAtPath(subPath, context))
+                            return true;
+                    }
+                }
+                return false;
+            }
+            for (const getter of this.unmatchableGetters) {
+                if (getter.hasEffectsWhenAccessedAtPath(subPath, context)) {
                     return true;
                 }
-                currentPureFunction = currentPureFunction[segment];
             }
-            else {
+        }
+        else {
+            for (const getters of Object.values(this.gettersByKey).concat([this.unmatchableGetters])) {
+                for (const getter of getters) {
+                    if (getter.hasEffectsWhenAccessedAtPath(subPath, context))
+                        return true;
+                }
+            }
+        }
+        if (this.prototypeExpression) {
+            return this.prototypeExpression.hasEffectsWhenAccessedAtPath(path, context);
+        }
+        return false;
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        const [key, ...subPath] = path;
+        if (path.length > 1) {
+            if (typeof key !== 'string') {
+                return true;
+            }
+            const expressionAtPath = this.getMemberExpression(key);
+            if (expressionAtPath) {
+                return expressionAtPath.hasEffectsWhenAssignedAtPath(subPath, context);
+            }
+            if (this.prototypeExpression) {
+                return this.prototypeExpression.hasEffectsWhenAssignedAtPath(path, context);
+            }
+            return true;
+        }
+        if (this.hasUnknownDeoptimizedProperty)
+            return true;
+        // We do not need to test for unknown properties as in that case, hasUnknownDeoptimizedProperty is true
+        if (typeof key === 'string') {
+            if (this.propertiesAndSettersByKey[key]) {
+                const setters = this.settersByKey[key];
+                if (setters) {
+                    for (const setter of setters) {
+                        if (setter.hasEffectsWhenAssignedAtPath(subPath, context))
+                            return true;
+                    }
+                }
                 return false;
             }
+            for (const property of this.unmatchableSetters) {
+                if (property.hasEffectsWhenAssignedAtPath(subPath, context)) {
+                    return true;
+                }
+            }
+        }
+        if (this.prototypeExpression) {
+            return this.prototypeExpression.hasEffectsWhenAssignedAtPath(path, context);
         }
-        return currentPureFunction?.[PureFunctionKey];
+        return false;
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        const key = path[0];
+        const expressionAtPath = this.getMemberExpression(key);
+        if (expressionAtPath) {
+            return expressionAtPath.hasEffectsWhenCalledAtPath(path.slice(1), callOptions, context);
+        }
+        if (this.prototypeExpression) {
+            return this.prototypeExpression.hasEffectsWhenCalledAtPath(path, callOptions, context);
+        }
+        return true;
+    }
+    buildPropertyMaps(properties) {
+        const { allProperties, propertiesAndGettersByKey, propertiesAndSettersByKey, settersByKey, gettersByKey, unknownIntegerProps, unmatchablePropertiesAndGetters, unmatchableGetters, unmatchableSetters } = this;
+        const unmatchablePropertiesAndSetters = [];
+        for (let index = properties.length - 1; index >= 0; index--) {
+            const { key, kind, property } = properties[index];
+            allProperties.push(property);
+            if (typeof key !== 'string') {
+                if (key === UnknownInteger) {
+                    unknownIntegerProps.push(property);
+                    continue;
+                }
+                if (kind === 'set')
+                    unmatchableSetters.push(property);
+                if (kind === 'get')
+                    unmatchableGetters.push(property);
+                if (kind !== 'get')
+                    unmatchablePropertiesAndSetters.push(property);
+                if (kind !== 'set')
+                    unmatchablePropertiesAndGetters.push(property);
+            }
+            else {
+                if (kind === 'set') {
+                    if (!propertiesAndSettersByKey[key]) {
+                        propertiesAndSettersByKey[key] = [property, ...unmatchablePropertiesAndSetters];
+                        settersByKey[key] = [property, ...unmatchableSetters];
+                    }
+                }
+                else if (kind === 'get') {
+                    if (!propertiesAndGettersByKey[key]) {
+                        propertiesAndGettersByKey[key] = [property, ...unmatchablePropertiesAndGetters];
+                        gettersByKey[key] = [property, ...unmatchableGetters];
+                    }
+                }
+                else {
+                    if (!propertiesAndSettersByKey[key]) {
+                        propertiesAndSettersByKey[key] = [property, ...unmatchablePropertiesAndSetters];
+                    }
+                    if (!propertiesAndGettersByKey[key]) {
+                        propertiesAndGettersByKey[key] = [property, ...unmatchablePropertiesAndGetters];
+                    }
+                }
+            }
+        }
+    }
+    deoptimizeCachedEntities() {
+        for (const expressionsToBeDeoptimized of Object.values(this.expressionsToBeDeoptimizedByKey)) {
+            for (const expression of expressionsToBeDeoptimized) {
+                expression.deoptimizeCache();
+            }
+        }
+        for (const expression of this.thisParametersToBeDeoptimized) {
+            expression.deoptimizePath(UNKNOWN_PATH);
+        }
+    }
+    deoptimizeCachedIntegerEntities() {
+        for (const [key, expressionsToBeDeoptimized] of Object.entries(this.expressionsToBeDeoptimizedByKey)) {
+            if (INTEGER_REG_EXP.test(key)) {
+                for (const expression of expressionsToBeDeoptimized) {
+                    expression.deoptimizeCache();
+                }
+            }
+        }
+        for (const expression of this.thisParametersToBeDeoptimized) {
+            expression.deoptimizePath(UNKNOWN_INTEGER_PATH);
+        }
+    }
+    getMemberExpression(key) {
+        if (this.hasUnknownDeoptimizedProperty ||
+            typeof key !== 'string' ||
+            (this.hasUnknownDeoptimizedInteger && INTEGER_REG_EXP.test(key)) ||
+            this.deoptimizedPaths[key]) {
+            return UNKNOWN_EXPRESSION;
+        }
+        const properties = this.propertiesAndGettersByKey[key];
+        if ((properties === null || properties === void 0 ? void 0 : properties.length) === 1) {
+            return properties[0];
+        }
+        if (properties ||
+            this.unmatchablePropertiesAndGetters.length > 0 ||
+            (this.unknownIntegerProps.length && INTEGER_REG_EXP.test(key))) {
+            return UNKNOWN_EXPRESSION;
+        }
+        return null;
+    }
+    getMemberExpressionAndTrackDeopt(key, origin) {
+        if (typeof key !== 'string') {
+            return UNKNOWN_EXPRESSION;
+        }
+        const expression = this.getMemberExpression(key);
+        if (!(expression === UNKNOWN_EXPRESSION || this.immutable)) {
+            const expressionsToBeDeoptimized = (this.expressionsToBeDeoptimizedByKey[key] =
+                this.expressionsToBeDeoptimizedByKey[key] || []);
+            expressionsToBeDeoptimized.push(origin);
+        }
+        return expression;
     }
 }
-function closestParentFunctionOrProgram(node) {
-    while (node && !/^Program|Function/.test(node.type)) {
-        node = node.parent;
+
+class ObjectMember extends ExpressionEntity {
+    constructor(object, key) {
+        super();
+        this.object = object;
+        this.key = key;
+    }
+    deoptimizePath(path) {
+        this.object.deoptimizePath([this.key, ...path]);
+    }
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
+        this.object.deoptimizeThisOnEventAtPath(event, [this.key, ...path], thisParameter, recursionTracker);
+    }
+    getLiteralValueAtPath(path, recursionTracker, origin) {
+        return this.object.getLiteralValueAtPath([this.key, ...path], recursionTracker, origin);
+    }
+    getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin) {
+        return this.object.getReturnExpressionWhenCalledAtPath([this.key, ...path], callOptions, recursionTracker, origin);
+    }
+    hasEffectsWhenAccessedAtPath(path, context) {
+        if (path.length === 0)
+            return false;
+        return this.object.hasEffectsWhenAccessedAtPath([this.key, ...path], context);
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        return this.object.hasEffectsWhenAssignedAtPath([this.key, ...path], context);
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        return this.object.hasEffectsWhenCalledAtPath([this.key, ...path], callOptions, context);
     }
-    // one of: ArrowFunctionExpression, FunctionDeclaration, FunctionExpression or Program
-    return node;
 }
 
-function treeshakeNode(node, code, start, end) {
-    code.remove(start, end);
-    if (node.annotations) {
-        for (const annotation of node.annotations) {
-            if (annotation.start < start) {
-                code.remove(annotation.start, annotation.end);
+class Method extends ExpressionEntity {
+    constructor(description) {
+        super();
+        this.description = description;
+    }
+    deoptimizeThisOnEventAtPath(event, path, thisParameter) {
+        if (event === EVENT_CALLED && path.length === 0 && this.description.mutatesSelfAsArray) {
+            thisParameter.deoptimizePath(UNKNOWN_INTEGER_PATH);
+        }
+    }
+    getReturnExpressionWhenCalledAtPath(path, callOptions) {
+        if (path.length > 0) {
+            return UNKNOWN_EXPRESSION;
+        }
+        return (this.description.returnsPrimitive ||
+            (this.description.returns === 'self'
+                ? callOptions.thisParam || UNKNOWN_EXPRESSION
+                : this.description.returns()));
+    }
+    hasEffectsWhenAccessedAtPath(path) {
+        return path.length > 1;
+    }
+    hasEffectsWhenAssignedAtPath(path) {
+        return path.length > 0;
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        var _a, _b;
+        if (path.length > 0 ||
+            (this.description.mutatesSelfAsArray === true &&
+                ((_a = callOptions.thisParam) === null || _a === void 0 ? void 0 : _a.hasEffectsWhenAssignedAtPath(UNKNOWN_INTEGER_PATH, context)))) {
+            return true;
+        }
+        if (!this.description.callsArgs) {
+            return false;
+        }
+        for (const argIndex of this.description.callsArgs) {
+            if ((_b = callOptions.args[argIndex]) === null || _b === void 0 ? void 0 : _b.hasEffectsWhenCalledAtPath(EMPTY_PATH, {
+                args: NO_ARGS,
+                thisParam: null,
+                withNew: false
+            }, context)) {
+                return true;
             }
-            else {
+        }
+        return false;
+    }
+    includeCallArguments(context, args) {
+        for (const arg of args) {
+            arg.include(context, false);
+        }
+    }
+}
+const METHOD_RETURNS_BOOLEAN = [
+    new Method({
+        callsArgs: null,
+        mutatesSelfAsArray: false,
+        returns: null,
+        returnsPrimitive: UNKNOWN_LITERAL_BOOLEAN
+    })
+];
+const METHOD_RETURNS_STRING = [
+    new Method({
+        callsArgs: null,
+        mutatesSelfAsArray: false,
+        returns: null,
+        returnsPrimitive: UNKNOWN_LITERAL_STRING
+    })
+];
+const METHOD_RETURNS_NUMBER = [
+    new Method({
+        callsArgs: null,
+        mutatesSelfAsArray: false,
+        returns: null,
+        returnsPrimitive: UNKNOWN_LITERAL_NUMBER
+    })
+];
+const METHOD_RETURNS_UNKNOWN = [
+    new Method({
+        callsArgs: null,
+        mutatesSelfAsArray: false,
+        returns: null,
+        returnsPrimitive: UNKNOWN_EXPRESSION
+    })
+];
+
+const OBJECT_PROTOTYPE = new ObjectEntity({
+    __proto__: null,
+    hasOwnProperty: METHOD_RETURNS_BOOLEAN,
+    isPrototypeOf: METHOD_RETURNS_BOOLEAN,
+    propertyIsEnumerable: METHOD_RETURNS_BOOLEAN,
+    toLocaleString: METHOD_RETURNS_STRING,
+    toString: METHOD_RETURNS_STRING,
+    valueOf: METHOD_RETURNS_UNKNOWN
+}, null, true);
+
+class ClassNode extends NodeBase {
+    constructor() {
+        super(...arguments);
+        this.objectEntity = null;
+    }
+    createScope(parentScope) {
+        this.scope = new ChildScope(parentScope);
+    }
+    deoptimizeCache() {
+        this.getObjectEntity().deoptimizeAllProperties();
+    }
+    deoptimizePath(path) {
+        this.getObjectEntity().deoptimizePath(path);
+    }
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
+        this.getObjectEntity().deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker);
+    }
+    getLiteralValueAtPath(path, recursionTracker, origin) {
+        return this.getObjectEntity().getLiteralValueAtPath(path, recursionTracker, origin);
+    }
+    getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin) {
+        return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin);
+    }
+    hasEffects(context) {
+        var _a, _b;
+        const initEffect = ((_a = this.superClass) === null || _a === void 0 ? void 0 : _a.hasEffects(context)) || this.body.hasEffects(context);
+        (_b = this.id) === null || _b === void 0 ? void 0 : _b.markDeclarationReached();
+        return initEffect || super.hasEffects(context);
+    }
+    hasEffectsWhenAccessedAtPath(path, context) {
+        return this.getObjectEntity().hasEffectsWhenAccessedAtPath(path, context);
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        return this.getObjectEntity().hasEffectsWhenAssignedAtPath(path, context);
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        if (path.length === 0) {
+            return (!callOptions.withNew ||
+                (this.classConstructor !== null
+                    ? this.classConstructor.hasEffectsWhenCalledAtPath(EMPTY_PATH, callOptions, context)
+                    : this.superClass !== null &&
+                        this.superClass.hasEffectsWhenCalledAtPath(path, callOptions, context)));
+        }
+        else {
+            return this.getObjectEntity().hasEffectsWhenCalledAtPath(path, callOptions, context);
+        }
+    }
+    include(context, includeChildrenRecursively) {
+        var _a;
+        this.included = true;
+        (_a = this.superClass) === null || _a === void 0 ? void 0 : _a.include(context, includeChildrenRecursively);
+        this.body.include(context, includeChildrenRecursively);
+        if (this.id) {
+            this.id.markDeclarationReached();
+            this.id.include();
+        }
+    }
+    initialise() {
+        var _a;
+        (_a = this.id) === null || _a === void 0 ? void 0 : _a.declare('class', this);
+        for (const method of this.body.body) {
+            if (method instanceof MethodDefinition && method.kind === 'constructor') {
+                this.classConstructor = method;
                 return;
             }
         }
+        this.classConstructor = null;
+    }
+    getObjectEntity() {
+        if (this.objectEntity !== null) {
+            return this.objectEntity;
+        }
+        const staticProperties = [];
+        const dynamicMethods = [];
+        for (const definition of this.body.body) {
+            const properties = definition.static ? staticProperties : dynamicMethods;
+            const definitionKind = definition.kind;
+            // Note that class fields do not end up on the prototype
+            if (properties === dynamicMethods && !definitionKind)
+                continue;
+            const kind = definitionKind === 'set' || definitionKind === 'get' ? definitionKind : 'init';
+            let key;
+            if (definition.computed) {
+                const keyValue = definition.key.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
+                if (keyValue === UnknownValue) {
+                    properties.push({ key: UnknownKey, kind, property: definition });
+                    continue;
+                }
+                else {
+                    key = String(keyValue);
+                }
+            }
+            else {
+                key =
+                    definition.key instanceof Identifier
+                        ? definition.key.name
+                        : String(definition.key.value);
+            }
+            properties.push({ key, kind, property: definition });
+        }
+        staticProperties.unshift({
+            key: 'prototype',
+            kind: 'init',
+            property: new ObjectEntity(dynamicMethods, this.superClass ? new ObjectMember(this.superClass, 'prototype') : OBJECT_PROTOTYPE)
+        });
+        return (this.objectEntity = new ObjectEntity(staticProperties, this.superClass || OBJECT_PROTOTYPE));
     }
 }
-function removeAnnotations(node, code) {
-    if (!node.annotations && node.parent.type === ExpressionStatement$1) {
-        node = node.parent;
+
+class ClassDeclaration extends ClassNode {
+    initialise() {
+        super.initialise();
+        if (this.id !== null) {
+            this.id.variable.isId = true;
+        }
     }
-    if (node.annotations) {
-        for (const annotation of node.annotations) {
-            code.remove(annotation.start, annotation.end);
+    parseNode(esTreeNode) {
+        if (esTreeNode.id !== null) {
+            this.id = new this.context.nodeConstructors.Identifier(esTreeNode.id, this, this.scope.parent);
         }
+        super.parseNode(esTreeNode);
+    }
+    render(code, options) {
+        const { exportNamesByVariable, format, snippets: { _ } } = options;
+        if (format === 'system' && this.id && exportNamesByVariable.has(this.id.variable)) {
+            code.appendLeft(this.end, `${_}${getSystemExportStatement([this.id.variable], options)};`);
+        }
+        super.render(code, options);
     }
 }
 
-const NO_SEMICOLON = { isNoStatement: true };
-// This assumes there are only white-space and comments between start and the string we are looking for
-function findFirstOccurrenceOutsideComment(code, searchString, start = 0) {
-    let searchPos, charCodeAfterSlash;
-    searchPos = code.indexOf(searchString, start);
-    while (true) {
-        start = code.indexOf('/', start);
-        if (start === -1 || start >= searchPos)
-            return searchPos;
-        charCodeAfterSlash = code.charCodeAt(++start);
-        ++start;
-        // With our assumption, '/' always starts a comment. Determine comment type:
-        start =
-            charCodeAfterSlash === 47 /*"/"*/
-                ? code.indexOf('\n', start) + 1
-                : code.indexOf('*/', start) + 2;
-        if (start > searchPos) {
-            searchPos = code.indexOf(searchString, start);
+class ArgumentsVariable extends LocalVariable {
+    constructor(context) {
+        super('arguments', null, UNKNOWN_EXPRESSION, context);
+    }
+    hasEffectsWhenAccessedAtPath(path) {
+        return path.length > 1;
+    }
+    hasEffectsWhenAssignedAtPath() {
+        return true;
+    }
+    hasEffectsWhenCalledAtPath() {
+        return true;
+    }
+}
+
+class ThisVariable extends LocalVariable {
+    constructor(context) {
+        super('this', null, null, context);
+        this.deoptimizedPaths = [];
+        this.entitiesToBeDeoptimized = new Set();
+        this.thisDeoptimizationList = [];
+        this.thisDeoptimizations = new DiscriminatedPathTracker();
+    }
+    addEntityToBeDeoptimized(entity) {
+        for (const path of this.deoptimizedPaths) {
+            entity.deoptimizePath(path);
         }
+        for (const thisDeoptimization of this.thisDeoptimizationList) {
+            this.applyThisDeoptimizationEvent(entity, thisDeoptimization);
+        }
+        this.entitiesToBeDeoptimized.add(entity);
+    }
+    deoptimizePath(path) {
+        if (path.length === 0 ||
+            this.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(path, this)) {
+            return;
+        }
+        this.deoptimizedPaths.push(path);
+        for (const entity of this.entitiesToBeDeoptimized) {
+            entity.deoptimizePath(path);
+        }
+    }
+    deoptimizeThisOnEventAtPath(event, path, thisParameter) {
+        const thisDeoptimization = {
+            event,
+            path,
+            thisParameter
+        };
+        if (!this.thisDeoptimizations.trackEntityAtPathAndGetIfTracked(path, event, thisParameter)) {
+            for (const entity of this.entitiesToBeDeoptimized) {
+                this.applyThisDeoptimizationEvent(entity, thisDeoptimization);
+            }
+            this.thisDeoptimizationList.push(thisDeoptimization);
+        }
+    }
+    hasEffectsWhenAccessedAtPath(path, context) {
+        return (this.getInit(context).hasEffectsWhenAccessedAtPath(path, context) ||
+            super.hasEffectsWhenAccessedAtPath(path, context));
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        return (this.getInit(context).hasEffectsWhenAssignedAtPath(path, context) ||
+            super.hasEffectsWhenAssignedAtPath(path, context));
+    }
+    applyThisDeoptimizationEvent(entity, { event, path, thisParameter }) {
+        entity.deoptimizeThisOnEventAtPath(event, path, thisParameter === this ? entity : thisParameter, SHARED_RECURSION_TRACKER);
+    }
+    getInit(context) {
+        return context.replacedVariableInits.get(this) || UNKNOWN_EXPRESSION;
     }
 }
-const NON_WHITESPACE = /\S/g;
-function findNonWhiteSpace(code, index) {
-    NON_WHITESPACE.lastIndex = index;
-    const result = NON_WHITESPACE.exec(code);
-    return result.index;
+
+class SpreadElement extends NodeBase {
+    constructor() {
+        super(...arguments);
+        this.deoptimized = false;
+    }
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
+        if (path.length > 0) {
+            this.argument.deoptimizeThisOnEventAtPath(event, [UnknownKey, ...path], thisParameter, recursionTracker);
+        }
+    }
+    hasEffects(context) {
+        if (!this.deoptimized)
+            this.applyDeoptimizations();
+        const { propertyReadSideEffects } = this.context.options
+            .treeshake;
+        return (this.argument.hasEffects(context) ||
+            (propertyReadSideEffects &&
+                (propertyReadSideEffects === 'always' ||
+                    this.argument.hasEffectsWhenAccessedAtPath(UNKNOWN_PATH, context))));
+    }
+    applyDeoptimizations() {
+        this.deoptimized = true;
+        // Only properties of properties of the argument could become subject to reassignment
+        // This will also reassign the return values of iterators
+        this.argument.deoptimizePath([UnknownKey, UnknownKey]);
+        this.context.requestTreeshakingPass();
+    }
 }
-// This assumes "code" only contains white-space and comments
-// Returns position of line-comment if applicable
-function findFirstLineBreakOutsideComment(code) {
-    let lineBreakPos, charCodeAfterSlash, start = 0;
-    lineBreakPos = code.indexOf('\n', start);
-    while (true) {
-        start = code.indexOf('/', start);
-        if (start === -1 || start > lineBreakPos)
-            return [lineBreakPos, lineBreakPos + 1];
-        // With our assumption, '/' always starts a comment. Determine comment type:
-        charCodeAfterSlash = code.charCodeAt(start + 1);
-        if (charCodeAfterSlash === 47 /*"/"*/)
-            return [start, lineBreakPos + 1];
-        start = code.indexOf('*/', start + 3) + 2;
-        if (start > lineBreakPos) {
-            lineBreakPos = code.indexOf('\n', start);
+
+class ParameterScope extends ChildScope {
+    constructor(parent, context) {
+        super(parent);
+        this.parameters = [];
+        this.hasRest = false;
+        this.context = context;
+        this.hoistedBodyVarScope = new ChildScope(this);
+    }
+    /**
+     * Adds a parameter to this scope. Parameters must be added in the correct
+     * order, e.g. from left to right.
+     */
+    addParameterDeclaration(identifier) {
+        const name = identifier.name;
+        let variable = this.hoistedBodyVarScope.variables.get(name);
+        if (variable) {
+            variable.addDeclaration(identifier, null);
+        }
+        else {
+            variable = new LocalVariable(name, identifier, UNKNOWN_EXPRESSION, this.context);
+        }
+        this.variables.set(name, variable);
+        return variable;
+    }
+    addParameterVariables(parameters, hasRest) {
+        this.parameters = parameters;
+        for (const parameterList of parameters) {
+            for (const parameter of parameterList) {
+                parameter.alwaysRendered = true;
+            }
+        }
+        this.hasRest = hasRest;
+    }
+    includeCallArguments(context, args) {
+        let calledFromTryStatement = false;
+        let argIncluded = false;
+        const restParam = this.hasRest && this.parameters[this.parameters.length - 1];
+        for (const checkedArg of args) {
+            if (checkedArg instanceof SpreadElement) {
+                for (const arg of args) {
+                    arg.include(context, false);
+                }
+                break;
+            }
+        }
+        for (let index = args.length - 1; index >= 0; index--) {
+            const paramVars = this.parameters[index] || restParam;
+            const arg = args[index];
+            if (paramVars) {
+                calledFromTryStatement = false;
+                if (paramVars.length === 0) {
+                    // handle empty destructuring
+                    argIncluded = true;
+                }
+                else {
+                    for (const variable of paramVars) {
+                        if (variable.included) {
+                            argIncluded = true;
+                        }
+                        if (variable.calledFromTryStatement) {
+                            calledFromTryStatement = true;
+                        }
+                    }
+                }
+            }
+            if (!argIncluded && arg.shouldBeIncluded(context)) {
+                argIncluded = true;
+            }
+            if (argIncluded) {
+                arg.include(context, calledFromTryStatement);
+            }
         }
     }
 }
-function renderStatementList(statements, code, start, end, options) {
-    let currentNode, currentNodeStart, currentNodeNeedsBoundaries, nextNodeStart;
-    let nextNode = statements[0];
-    let nextNodeNeedsBoundaries = !nextNode.included || nextNode.needsBoundaries;
-    if (nextNodeNeedsBoundaries) {
-        nextNodeStart =
-            start + findFirstLineBreakOutsideComment(code.original.slice(start, nextNode.start))[1];
+
+class ReturnValueScope extends ParameterScope {
+    constructor() {
+        super(...arguments);
+        this.returnExpression = null;
+        this.returnExpressions = [];
     }
-    for (let nextIndex = 1; nextIndex <= statements.length; nextIndex++) {
-        currentNode = nextNode;
-        currentNodeStart = nextNodeStart;
-        currentNodeNeedsBoundaries = nextNodeNeedsBoundaries;
-        nextNode = statements[nextIndex];
-        nextNodeNeedsBoundaries =
-            nextNode === undefined ? false : !nextNode.included || nextNode.needsBoundaries;
-        if (currentNodeNeedsBoundaries || nextNodeNeedsBoundaries) {
-            nextNodeStart =
-                currentNode.end +
-                    findFirstLineBreakOutsideComment(code.original.slice(currentNode.end, nextNode === undefined ? end : nextNode.start))[1];
-            if (currentNode.included) {
-                currentNodeNeedsBoundaries
-                    ? currentNode.render(code, options, {
-                        end: nextNodeStart,
-                        start: currentNodeStart
-                    })
-                    : currentNode.render(code, options);
+    addReturnExpression(expression) {
+        this.returnExpressions.push(expression);
+    }
+    getReturnExpression() {
+        if (this.returnExpression === null)
+            this.updateReturnExpression();
+        return this.returnExpression;
+    }
+    updateReturnExpression() {
+        if (this.returnExpressions.length === 1) {
+            this.returnExpression = this.returnExpressions[0];
+        }
+        else {
+            this.returnExpression = UNKNOWN_EXPRESSION;
+            for (const expression of this.returnExpressions) {
+                expression.deoptimizePath(UNKNOWN_PATH);
+            }
+        }
+    }
+}
+
+class FunctionScope extends ReturnValueScope {
+    constructor(parent, context) {
+        super(parent, context);
+        this.variables.set('arguments', (this.argumentsVariable = new ArgumentsVariable(context)));
+        this.variables.set('this', (this.thisVariable = new ThisVariable(context)));
+    }
+    findLexicalBoundary() {
+        return this;
+    }
+    includeCallArguments(context, args) {
+        super.includeCallArguments(context, args);
+        if (this.argumentsVariable.included) {
+            for (const arg of args) {
+                if (!arg.included) {
+                    arg.include(context, false);
+                }
+            }
+        }
+    }
+}
+
+class RestElement extends NodeBase {
+    constructor() {
+        super(...arguments);
+        this.deoptimized = false;
+        this.declarationInit = null;
+    }
+    addExportedVariables(variables, exportNamesByVariable) {
+        this.argument.addExportedVariables(variables, exportNamesByVariable);
+    }
+    declare(kind, init) {
+        this.declarationInit = init;
+        return this.argument.declare(kind, UNKNOWN_EXPRESSION);
+    }
+    deoptimizePath(path) {
+        path.length === 0 && this.argument.deoptimizePath(EMPTY_PATH);
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        return path.length > 0 || this.argument.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context);
+    }
+    markDeclarationReached() {
+        this.argument.markDeclarationReached();
+    }
+    applyDeoptimizations() {
+        this.deoptimized = true;
+        if (this.declarationInit !== null) {
+            this.declarationInit.deoptimizePath([UnknownKey, UnknownKey]);
+            this.context.requestTreeshakingPass();
+        }
+    }
+}
+
+class FunctionNode extends NodeBase {
+    constructor() {
+        super(...arguments);
+        this.deoptimizedReturn = false;
+        this.isPrototypeDeoptimized = false;
+    }
+    createScope(parentScope) {
+        this.scope = new FunctionScope(parentScope, this.context);
+    }
+    deoptimizePath(path) {
+        if (path.length === 1) {
+            if (path[0] === 'prototype') {
+                this.isPrototypeDeoptimized = true;
+            }
+            else if (path[0] === UnknownKey) {
+                this.isPrototypeDeoptimized = true;
+                // A reassignment of UNKNOWN_PATH is considered equivalent to having lost track
+                // which means the return expression needs to be reassigned as well
+                this.scope.getReturnExpression().deoptimizePath(UNKNOWN_PATH);
+            }
+        }
+    }
+    // TODO for completeness, we should also track other events here
+    deoptimizeThisOnEventAtPath(event, path, thisParameter) {
+        if (event === EVENT_CALLED) {
+            if (path.length > 0) {
+                thisParameter.deoptimizePath(UNKNOWN_PATH);
             }
             else {
-                treeshakeNode(currentNode, code, currentNodeStart, nextNodeStart);
+                this.scope.thisVariable.addEntityToBeDeoptimized(thisParameter);
+            }
+        }
+    }
+    getReturnExpressionWhenCalledAtPath(path) {
+        if (path.length !== 0) {
+            return UNKNOWN_EXPRESSION;
+        }
+        if (this.async) {
+            if (!this.deoptimizedReturn) {
+                this.deoptimizedReturn = true;
+                this.scope.getReturnExpression().deoptimizePath(UNKNOWN_PATH);
+                this.context.requestTreeshakingPass();
+            }
+            return UNKNOWN_EXPRESSION;
+        }
+        return this.scope.getReturnExpression();
+    }
+    hasEffects() {
+        return this.id !== null && this.id.hasEffects();
+    }
+    hasEffectsWhenAccessedAtPath(path) {
+        if (path.length <= 1)
+            return false;
+        return path.length > 2 || path[0] !== 'prototype' || this.isPrototypeDeoptimized;
+    }
+    hasEffectsWhenAssignedAtPath(path) {
+        if (path.length <= 1) {
+            return false;
+        }
+        return path.length > 2 || path[0] !== 'prototype' || this.isPrototypeDeoptimized;
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        if (path.length > 0)
+            return true;
+        if (this.async) {
+            const { propertyReadSideEffects } = this.context.options
+                .treeshake;
+            const returnExpression = this.scope.getReturnExpression();
+            if (returnExpression.hasEffectsWhenCalledAtPath(['then'], { args: NO_ARGS, thisParam: null, withNew: false }, context) ||
+                (propertyReadSideEffects &&
+                    (propertyReadSideEffects === 'always' ||
+                        returnExpression.hasEffectsWhenAccessedAtPath(['then'], context)))) {
+                return true;
             }
         }
+        for (const param of this.params) {
+            if (param.hasEffects(context))
+                return true;
+        }
+        const thisInit = context.replacedVariableInits.get(this.scope.thisVariable);
+        context.replacedVariableInits.set(this.scope.thisVariable, callOptions.withNew
+            ? new ObjectEntity(Object.create(null), OBJECT_PROTOTYPE)
+            : UNKNOWN_EXPRESSION);
+        const { brokenFlow, ignore } = context;
+        context.ignore = {
+            breaks: false,
+            continues: false,
+            labels: new Set(),
+            returnYield: true
+        };
+        if (this.body.hasEffects(context))
+            return true;
+        context.brokenFlow = brokenFlow;
+        if (thisInit) {
+            context.replacedVariableInits.set(this.scope.thisVariable, thisInit);
+        }
         else {
-            currentNode.render(code, options);
+            context.replacedVariableInits.delete(this.scope.thisVariable);
+        }
+        context.ignore = ignore;
+        return false;
+    }
+    include(context, includeChildrenRecursively) {
+        this.included = true;
+        if (this.id)
+            this.id.include();
+        const hasArguments = this.scope.argumentsVariable.included;
+        for (const param of this.params) {
+            if (!(param instanceof Identifier) || hasArguments) {
+                param.include(context, includeChildrenRecursively);
+            }
         }
+        const { brokenFlow } = context;
+        context.brokenFlow = BROKEN_FLOW_NONE;
+        this.body.include(context, includeChildrenRecursively);
+        context.brokenFlow = brokenFlow;
+    }
+    includeCallArguments(context, args) {
+        this.scope.includeCallArguments(context, args);
+    }
+    initialise() {
+        if (this.id !== null) {
+            this.id.declare('function', this);
+        }
+        this.scope.addParameterVariables(this.params.map(param => param.declare('parameter', UNKNOWN_EXPRESSION)), this.params[this.params.length - 1] instanceof RestElement);
+        this.body.addImplicitReturnExpressionToScope();
+    }
+    parseNode(esTreeNode) {
+        this.body = new this.context.nodeConstructors.BlockStatement(esTreeNode.body, this, this.scope.hoistedBodyVarScope);
+        super.parseNode(esTreeNode);
     }
 }
-// This assumes that the first character is not part of the first node
-function getCommaSeparatedNodesWithBoundaries(nodes, code, start, end) {
-    const splitUpNodes = [];
-    let node, nextNodeStart, contentEnd, char;
-    let separator = start - 1;
-    for (const nextNode of nodes) {
-        if (node !== undefined) {
-            separator =
-                node.end +
-                    findFirstOccurrenceOutsideComment(code.original.slice(node.end, nextNode.start), ',');
+FunctionNode.prototype.preventChildBlockScope = true;
+
+class FunctionDeclaration extends FunctionNode {
+    initialise() {
+        super.initialise();
+        if (this.id !== null) {
+            this.id.variable.isId = true;
         }
-        nextNodeStart = contentEnd =
-            separator +
-                1 +
-                findFirstLineBreakOutsideComment(code.original.slice(separator + 1, nextNode.start))[1];
-        while (((char = code.original.charCodeAt(nextNodeStart)),
-            char === 32 /*" "*/ || char === 9 /*"\t"*/ || char === 10 /*"\n"*/ || char === 13) /*"\r"*/)
-            nextNodeStart++;
-        if (node !== undefined) {
-            splitUpNodes.push({
-                contentEnd,
-                end: nextNodeStart,
-                node,
-                separator,
-                start
+    }
+    parseNode(esTreeNode) {
+        if (esTreeNode.id !== null) {
+            this.id = new this.context.nodeConstructors.Identifier(esTreeNode.id, this, this.scope.parent);
+        }
+        super.parseNode(esTreeNode);
+    }
+}
+
+// The header ends at the first non-white-space after "default"
+function getDeclarationStart(code, start) {
+    return findNonWhiteSpace(code, findFirstOccurrenceOutsideComment(code, 'default', start) + 7);
+}
+function getIdInsertPosition(code, declarationKeyword, endMarker, start) {
+    const declarationEnd = findFirstOccurrenceOutsideComment(code, declarationKeyword, start) + declarationKeyword.length;
+    code = code.slice(declarationEnd, findFirstOccurrenceOutsideComment(code, endMarker, declarationEnd));
+    const generatorStarPos = findFirstOccurrenceOutsideComment(code, '*');
+    if (generatorStarPos === -1) {
+        return declarationEnd;
+    }
+    return declarationEnd + generatorStarPos + 1;
+}
+class ExportDefaultDeclaration extends NodeBase {
+    include(context, includeChildrenRecursively) {
+        super.include(context, includeChildrenRecursively);
+        if (includeChildrenRecursively) {
+            this.context.includeVariableInModule(this.variable);
+        }
+    }
+    initialise() {
+        const declaration = this.declaration;
+        this.declarationName =
+            (declaration.id && declaration.id.name) || this.declaration.name;
+        this.variable = this.scope.addExportDefaultDeclaration(this.declarationName || this.context.getModuleName(), this, this.context);
+        this.context.addExport(this);
+    }
+    render(code, options, nodeRenderOptions) {
+        const { start, end } = nodeRenderOptions;
+        const declarationStart = getDeclarationStart(code.original, this.start);
+        if (this.declaration instanceof FunctionDeclaration) {
+            this.renderNamedDeclaration(code, declarationStart, 'function', '(', this.declaration.id === null, options);
+        }
+        else if (this.declaration instanceof ClassDeclaration) {
+            this.renderNamedDeclaration(code, declarationStart, 'class', '{', this.declaration.id === null, options);
+        }
+        else if (this.variable.getOriginalVariable() !== this.variable) {
+            // Remove altogether to prevent re-declaring the same variable
+            treeshakeNode(this, code, start, end);
+            return;
+        }
+        else if (this.variable.included) {
+            this.renderVariableDeclaration(code, declarationStart, options);
+        }
+        else {
+            code.remove(this.start, declarationStart);
+            this.declaration.render(code, options, {
+                renderedSurroundingElement: ExpressionStatement$1
             });
+            if (code.original[this.end - 1] !== ';') {
+                code.appendLeft(this.end, ';');
+            }
+            return;
+        }
+        this.declaration.render(code, options);
+    }
+    renderNamedDeclaration(code, declarationStart, declarationKeyword, endMarker, needsId, options) {
+        const { exportNamesByVariable, format, snippets: { getPropertyAccess } } = options;
+        const name = this.variable.getName(getPropertyAccess);
+        // Remove `export default`
+        code.remove(this.start, declarationStart);
+        if (needsId) {
+            code.appendLeft(getIdInsertPosition(code.original, declarationKeyword, endMarker, declarationStart), ` ${name}`);
+        }
+        if (format === 'system' &&
+            this.declaration instanceof ClassDeclaration &&
+            exportNamesByVariable.has(this.variable)) {
+            code.appendLeft(this.end, ` ${getSystemExportStatement([this.variable], options)};`);
+        }
+    }
+    renderVariableDeclaration(code, declarationStart, { format, exportNamesByVariable, snippets: { cnst, getPropertyAccess } }) {
+        const hasTrailingSemicolon = code.original.charCodeAt(this.end - 1) === 59; /*";"*/
+        const systemExportNames = format === 'system' && exportNamesByVariable.get(this.variable);
+        if (systemExportNames) {
+            code.overwrite(this.start, declarationStart, `${cnst} ${this.variable.getName(getPropertyAccess)} = exports('${systemExportNames[0]}', `);
+            code.appendRight(hasTrailingSemicolon ? this.end - 1 : this.end, ')' + (hasTrailingSemicolon ? '' : ';'));
+        }
+        else {
+            code.overwrite(this.start, declarationStart, `${cnst} ${this.variable.getName(getPropertyAccess)} = `);
+            if (!hasTrailingSemicolon) {
+                code.appendLeft(this.end, ';');
+            }
         }
-        node = nextNode;
-        start = nextNodeStart;
     }
-    splitUpNodes.push({
-        contentEnd: end,
-        end,
-        node: node,
-        separator: null,
-        start
-    });
-    return splitUpNodes;
 }
-// This assumes there are only white-space and comments between start and end
-function removeLineBreaks(code, start, end) {
-    while (true) {
-        const [removeStart, removeEnd] = findFirstLineBreakOutsideComment(code.original.slice(start, end));
-        if (removeStart === -1) {
-            break;
+ExportDefaultDeclaration.prototype.needsBoundaries = true;
+
+class Literal extends NodeBase {
+    deoptimizeThisOnEventAtPath() { }
+    getLiteralValueAtPath(path) {
+        if (path.length > 0 ||
+            // unknown literals can also be null but do not start with an "n"
+            (this.value === null && this.context.code.charCodeAt(this.start) !== 110) ||
+            typeof this.value === 'bigint' ||
+            // to support shims for regular expressions
+            this.context.code.charCodeAt(this.start) === 47) {
+            return UnknownValue;
+        }
+        return this.value;
+    }
+    getReturnExpressionWhenCalledAtPath(path) {
+        if (path.length !== 1)
+            return UNKNOWN_EXPRESSION;
+        return getMemberReturnExpressionWhenCalled(this.members, path[0]);
+    }
+    hasEffectsWhenAccessedAtPath(path) {
+        if (this.value === null) {
+            return path.length > 0;
+        }
+        return path.length > 1;
+    }
+    hasEffectsWhenAssignedAtPath(path) {
+        return path.length > 0;
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        if (path.length === 1) {
+            return hasMemberEffectWhenCalled(this.members, path[0], callOptions, context);
+        }
+        return true;
+    }
+    initialise() {
+        this.members = getLiteralMembersForValue(this.value);
+    }
+    parseNode(esTreeNode) {
+        this.value = esTreeNode.value;
+        this.regex = esTreeNode.regex;
+        super.parseNode(esTreeNode);
+    }
+    render(code) {
+        if (typeof this.value === 'string') {
+            code.indentExclusionRanges.push([this.start + 1, this.end - 1]);
+        }
+    }
+}
+
+class Program extends NodeBase {
+    constructor() {
+        super(...arguments);
+        this.hasCachedEffect = false;
+    }
+    hasEffects(context) {
+        // We are caching here to later more efficiently identify side-effect-free modules
+        if (this.hasCachedEffect)
+            return true;
+        for (const node of this.body) {
+            if (node.hasEffects(context)) {
+                return (this.hasCachedEffect = true);
+            }
+        }
+        return false;
+    }
+    include(context, includeChildrenRecursively) {
+        this.included = true;
+        for (const node of this.body) {
+            if (includeChildrenRecursively || node.shouldBeIncluded(context)) {
+                node.include(context, includeChildrenRecursively);
+            }
+        }
+    }
+    render(code, options) {
+        if (this.body.length) {
+            renderStatementList(this.body, code, this.start, this.end, options);
+        }
+        else {
+            super.render(code, options);
+        }
+    }
+}
+
+class TemplateLiteral extends NodeBase {
+    getLiteralValueAtPath(path) {
+        if (path.length > 0 || this.quasis.length !== 1) {
+            return UnknownValue;
+        }
+        return this.quasis[0].value.cooked;
+    }
+    render(code, options) {
+        code.indentExclusionRanges.push([this.start, this.end]);
+        super.render(code, options);
+    }
+}
+
+function isReassignedExportsMember(variable, exportNamesByVariable) {
+    return (variable.renderBaseName !== null && exportNamesByVariable.has(variable) && variable.isReassigned);
+}
+
+function areAllDeclarationsIncludedAndNotExported(declarations, exportNamesByVariable) {
+    for (const declarator of declarations) {
+        if (!declarator.id.included)
+            return false;
+        if (declarator.id.type === Identifier$1) {
+            if (exportNamesByVariable.has(declarator.id.variable))
+                return false;
+        }
+        else {
+            const exportedVariables = [];
+            declarator.id.addExportedVariables(exportedVariables, exportNamesByVariable);
+            if (exportedVariables.length > 0)
+                return false;
+        }
+    }
+    return true;
+}
+class VariableDeclaration extends NodeBase {
+    deoptimizePath() {
+        for (const declarator of this.declarations) {
+            declarator.deoptimizePath(EMPTY_PATH);
+        }
+    }
+    hasEffectsWhenAssignedAtPath() {
+        return false;
+    }
+    include(context, includeChildrenRecursively) {
+        this.included = true;
+        for (const declarator of this.declarations) {
+            if (includeChildrenRecursively || declarator.shouldBeIncluded(context))
+                declarator.include(context, includeChildrenRecursively);
+        }
+    }
+    includeAsSingleStatement(context, includeChildrenRecursively) {
+        this.included = true;
+        for (const declarator of this.declarations) {
+            if (includeChildrenRecursively || declarator.shouldBeIncluded(context)) {
+                declarator.include(context, includeChildrenRecursively);
+                declarator.id.include(context, includeChildrenRecursively);
+            }
+        }
+    }
+    initialise() {
+        for (const declarator of this.declarations) {
+            declarator.declareDeclarator(this.kind);
+        }
+    }
+    render(code, options, nodeRenderOptions = BLANK) {
+        if (areAllDeclarationsIncludedAndNotExported(this.declarations, options.exportNamesByVariable)) {
+            for (const declarator of this.declarations) {
+                declarator.render(code, options);
+            }
+            if (!nodeRenderOptions.isNoStatement &&
+                code.original.charCodeAt(this.end - 1) !== 59 /*";"*/) {
+                code.appendLeft(this.end, ';');
+            }
+        }
+        else {
+            this.renderReplacedDeclarations(code, options, nodeRenderOptions);
+        }
+    }
+    renderDeclarationEnd(code, separatorString, lastSeparatorPos, actualContentEnd, renderedContentEnd, systemPatternExports, options, isNoStatement) {
+        if (code.original.charCodeAt(this.end - 1) === 59 /*";"*/) {
+            code.remove(this.end - 1, this.end);
+        }
+        if (!isNoStatement) {
+            separatorString += ';';
+        }
+        if (lastSeparatorPos !== null) {
+            if (code.original.charCodeAt(actualContentEnd - 1) === 10 /*"\n"*/ &&
+                (code.original.charCodeAt(this.end) === 10 /*"\n"*/ ||
+                    code.original.charCodeAt(this.end) === 13) /*"\r"*/) {
+                actualContentEnd--;
+                if (code.original.charCodeAt(actualContentEnd) === 13 /*"\r"*/) {
+                    actualContentEnd--;
+                }
+            }
+            if (actualContentEnd === lastSeparatorPos + 1) {
+                code.overwrite(lastSeparatorPos, renderedContentEnd, separatorString);
+            }
+            else {
+                code.overwrite(lastSeparatorPos, lastSeparatorPos + 1, separatorString);
+                code.remove(actualContentEnd, renderedContentEnd);
+            }
+        }
+        else {
+            code.appendLeft(renderedContentEnd, separatorString);
+        }
+        if (systemPatternExports.length > 0) {
+            code.appendLeft(renderedContentEnd, ` ${getSystemExportStatement(systemPatternExports, options)};`);
+        }
+    }
+    renderReplacedDeclarations(code, options, { isNoStatement }) {
+        const separatedNodes = getCommaSeparatedNodesWithBoundaries(this.declarations, code, this.start + this.kind.length, this.end - (code.original.charCodeAt(this.end - 1) === 59 /*";"*/ ? 1 : 0));
+        let actualContentEnd, renderedContentEnd;
+        renderedContentEnd = findNonWhiteSpace(code.original, this.start + this.kind.length);
+        let lastSeparatorPos = renderedContentEnd - 1;
+        code.remove(this.start, lastSeparatorPos);
+        let isInDeclaration = false;
+        let hasRenderedContent = false;
+        let separatorString = '', leadingString, nextSeparatorString;
+        const aggregatedSystemExports = [];
+        const singleSystemExport = gatherSystemExportsAndGetSingleExport(separatedNodes, options, aggregatedSystemExports);
+        for (const { node, start, separator, contentEnd, end } of separatedNodes) {
+            if (!node.included) {
+                code.remove(start, end);
+                continue;
+            }
+            node.render(code, options);
+            leadingString = '';
+            nextSeparatorString = '';
+            if (!node.id.included ||
+                (node.id instanceof Identifier &&
+                    isReassignedExportsMember(node.id.variable, options.exportNamesByVariable))) {
+                if (hasRenderedContent) {
+                    separatorString += ';';
+                }
+                isInDeclaration = false;
+            }
+            else {
+                if (singleSystemExport && singleSystemExport === node.id.variable) {
+                    const operatorPos = findFirstOccurrenceOutsideComment(code.original, '=', node.id.end);
+                    renderSystemExportExpression(singleSystemExport, findNonWhiteSpace(code.original, operatorPos + 1), separator === null ? contentEnd : separator, code, options);
+                }
+                if (isInDeclaration) {
+                    separatorString += ',';
+                }
+                else {
+                    if (hasRenderedContent) {
+                        separatorString += ';';
+                    }
+                    leadingString += `${this.kind} `;
+                    isInDeclaration = true;
+                }
+            }
+            if (renderedContentEnd === lastSeparatorPos + 1) {
+                code.overwrite(lastSeparatorPos, renderedContentEnd, separatorString + leadingString);
+            }
+            else {
+                code.overwrite(lastSeparatorPos, lastSeparatorPos + 1, separatorString);
+                code.appendLeft(renderedContentEnd, leadingString);
+            }
+            actualContentEnd = contentEnd;
+            renderedContentEnd = end;
+            hasRenderedContent = true;
+            lastSeparatorPos = separator;
+            separatorString = nextSeparatorString;
+        }
+        this.renderDeclarationEnd(code, separatorString, lastSeparatorPos, actualContentEnd, renderedContentEnd, aggregatedSystemExports, options, isNoStatement);
+    }
+}
+function gatherSystemExportsAndGetSingleExport(separatedNodes, options, aggregatedSystemExports) {
+    var _a;
+    let singleSystemExport = null;
+    if (options.format === 'system') {
+        for (const { node } of separatedNodes) {
+            if (node.id instanceof Identifier &&
+                node.init &&
+                aggregatedSystemExports.length === 0 &&
+                ((_a = options.exportNamesByVariable.get(node.id.variable)) === null || _a === void 0 ? void 0 : _a.length) === 1) {
+                singleSystemExport = node.id.variable;
+                aggregatedSystemExports.push(singleSystemExport);
+            }
+            else {
+                node.id.addExportedVariables(aggregatedSystemExports, options.exportNamesByVariable);
+            }
+        }
+        if (aggregatedSystemExports.length > 1) {
+            singleSystemExport = null;
+        }
+        else if (singleSystemExport) {
+            aggregatedSystemExports.length = 0;
+        }
+    }
+    return singleSystemExport;
+}
+
+const NEW_ARRAY_PROPERTIES = [
+    { key: UnknownInteger, kind: 'init', property: UNKNOWN_EXPRESSION },
+    { key: 'length', kind: 'init', property: UNKNOWN_LITERAL_NUMBER }
+];
+const METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_BOOLEAN = [
+    new Method({
+        callsArgs: [0],
+        mutatesSelfAsArray: 'deopt-only',
+        returns: null,
+        returnsPrimitive: UNKNOWN_LITERAL_BOOLEAN
+    })
+];
+const METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NUMBER = [
+    new Method({
+        callsArgs: [0],
+        mutatesSelfAsArray: 'deopt-only',
+        returns: null,
+        returnsPrimitive: UNKNOWN_LITERAL_NUMBER
+    })
+];
+const METHOD_MUTATES_SELF_RETURNS_NEW_ARRAY = [
+    new Method({
+        callsArgs: null,
+        mutatesSelfAsArray: true,
+        returns: () => new ObjectEntity(NEW_ARRAY_PROPERTIES, ARRAY_PROTOTYPE),
+        returnsPrimitive: null
+    })
+];
+const METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY = [
+    new Method({
+        callsArgs: null,
+        mutatesSelfAsArray: 'deopt-only',
+        returns: () => new ObjectEntity(NEW_ARRAY_PROPERTIES, ARRAY_PROTOTYPE),
+        returnsPrimitive: null
+    })
+];
+const METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY = [
+    new Method({
+        callsArgs: [0],
+        mutatesSelfAsArray: 'deopt-only',
+        returns: () => new ObjectEntity(NEW_ARRAY_PROPERTIES, ARRAY_PROTOTYPE),
+        returnsPrimitive: null
+    })
+];
+const METHOD_MUTATES_SELF_RETURNS_NUMBER = [
+    new Method({
+        callsArgs: null,
+        mutatesSelfAsArray: true,
+        returns: null,
+        returnsPrimitive: UNKNOWN_LITERAL_NUMBER
+    })
+];
+const METHOD_MUTATES_SELF_RETURNS_UNKNOWN = [
+    new Method({
+        callsArgs: null,
+        mutatesSelfAsArray: true,
+        returns: null,
+        returnsPrimitive: UNKNOWN_EXPRESSION
+    })
+];
+const METHOD_DEOPTS_SELF_RETURNS_UNKNOWN = [
+    new Method({
+        callsArgs: null,
+        mutatesSelfAsArray: 'deopt-only',
+        returns: null,
+        returnsPrimitive: UNKNOWN_EXPRESSION
+    })
+];
+const METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN = [
+    new Method({
+        callsArgs: [0],
+        mutatesSelfAsArray: 'deopt-only',
+        returns: null,
+        returnsPrimitive: UNKNOWN_EXPRESSION
+    })
+];
+const METHOD_MUTATES_SELF_RETURNS_SELF = [
+    new Method({
+        callsArgs: null,
+        mutatesSelfAsArray: true,
+        returns: 'self',
+        returnsPrimitive: null
+    })
+];
+const METHOD_CALLS_ARG_MUTATES_SELF_RETURNS_SELF = [
+    new Method({
+        callsArgs: [0],
+        mutatesSelfAsArray: true,
+        returns: 'self',
+        returnsPrimitive: null
+    })
+];
+const ARRAY_PROTOTYPE = new ObjectEntity({
+    __proto__: null,
+    // We assume that accessors have effects as we do not track the accessed value afterwards
+    at: METHOD_DEOPTS_SELF_RETURNS_UNKNOWN,
+    concat: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY,
+    copyWithin: METHOD_MUTATES_SELF_RETURNS_SELF,
+    entries: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY,
+    every: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_BOOLEAN,
+    fill: METHOD_MUTATES_SELF_RETURNS_SELF,
+    filter: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY,
+    find: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
+    findIndex: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NUMBER,
+    forEach: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
+    includes: METHOD_RETURNS_BOOLEAN,
+    indexOf: METHOD_RETURNS_NUMBER,
+    join: METHOD_RETURNS_STRING,
+    keys: METHOD_RETURNS_UNKNOWN,
+    lastIndexOf: METHOD_RETURNS_NUMBER,
+    map: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY,
+    pop: METHOD_MUTATES_SELF_RETURNS_UNKNOWN,
+    push: METHOD_MUTATES_SELF_RETURNS_NUMBER,
+    reduce: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
+    reduceRight: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
+    reverse: METHOD_MUTATES_SELF_RETURNS_SELF,
+    shift: METHOD_MUTATES_SELF_RETURNS_UNKNOWN,
+    slice: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY,
+    some: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_BOOLEAN,
+    sort: METHOD_CALLS_ARG_MUTATES_SELF_RETURNS_SELF,
+    splice: METHOD_MUTATES_SELF_RETURNS_NEW_ARRAY,
+    unshift: METHOD_MUTATES_SELF_RETURNS_NUMBER,
+    values: METHOD_DEOPTS_SELF_RETURNS_UNKNOWN
+}, OBJECT_PROTOTYPE, true);
+
+class ArrayExpression extends NodeBase {
+    constructor() {
+        super(...arguments);
+        this.objectEntity = null;
+    }
+    deoptimizePath(path) {
+        this.getObjectEntity().deoptimizePath(path);
+    }
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
+        this.getObjectEntity().deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker);
+    }
+    getLiteralValueAtPath(path, recursionTracker, origin) {
+        return this.getObjectEntity().getLiteralValueAtPath(path, recursionTracker, origin);
+    }
+    getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin) {
+        return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin);
+    }
+    hasEffectsWhenAccessedAtPath(path, context) {
+        return this.getObjectEntity().hasEffectsWhenAccessedAtPath(path, context);
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        return this.getObjectEntity().hasEffectsWhenAssignedAtPath(path, context);
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        return this.getObjectEntity().hasEffectsWhenCalledAtPath(path, callOptions, context);
+    }
+    getObjectEntity() {
+        if (this.objectEntity !== null) {
+            return this.objectEntity;
+        }
+        const properties = [
+            { key: 'length', kind: 'init', property: UNKNOWN_LITERAL_NUMBER }
+        ];
+        let hasSpread = false;
+        for (let index = 0; index < this.elements.length; index++) {
+            const element = this.elements[index];
+            if (element instanceof SpreadElement || hasSpread) {
+                if (element) {
+                    hasSpread = true;
+                    properties.unshift({ key: UnknownInteger, kind: 'init', property: element });
+                }
+            }
+            else if (!element) {
+                properties.push({ key: String(index), kind: 'init', property: UNDEFINED_EXPRESSION });
+            }
+            else {
+                properties.push({ key: String(index), kind: 'init', property: element });
+            }
+        }
+        return (this.objectEntity = new ObjectEntity(properties, ARRAY_PROTOTYPE));
+    }
+}
+
+class ArrayPattern extends NodeBase {
+    addExportedVariables(variables, exportNamesByVariable) {
+        for (const element of this.elements) {
+            if (element !== null) {
+                element.addExportedVariables(variables, exportNamesByVariable);
+            }
+        }
+    }
+    declare(kind) {
+        const variables = [];
+        for (const element of this.elements) {
+            if (element !== null) {
+                variables.push(...element.declare(kind, UNKNOWN_EXPRESSION));
+            }
+        }
+        return variables;
+    }
+    deoptimizePath(path) {
+        if (path.length === 0) {
+            for (const element of this.elements) {
+                if (element !== null) {
+                    element.deoptimizePath(path);
+                }
+            }
+        }
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        if (path.length > 0)
+            return true;
+        for (const element of this.elements) {
+            if (element !== null && element.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context))
+                return true;
+        }
+        return false;
+    }
+    markDeclarationReached() {
+        for (const element of this.elements) {
+            if (element !== null) {
+                element.markDeclarationReached();
+            }
         }
-        code.remove(start + removeStart, (start += removeEnd));
     }
 }
 
@@ -8790,7 +8651,10 @@
             this.parent.type === Program$1) {
             this.context.warn(
             // This is necessary, because either way (deleting or not) can lead to errors.
-            errorModuleLevelDirective(this.directive, this.context.module.id), this.start);
+            {
+                code: 'MODULE_LEVEL_DIRECTIVE',
+                message: `Module level directives cause errors when bundled, '${this.directive}' was ignored.`
+            }, this.start);
         }
     }
     render(code, options) {
@@ -8803,7 +8667,6 @@
             return this.parent.type !== Program$1;
         return super.shouldBeIncluded(context);
     }
-    applyDeoptimizations() { }
 }
 
 class BlockStatement extends NodeBase {
@@ -8826,15 +8689,15 @@
         if (this.deoptimizeBody)
             return true;
         for (const node of this.body) {
-            if (context.brokenFlow)
-                break;
             if (node.hasEffects(context))
                 return true;
+            if (context.brokenFlow)
+                break;
         }
         return false;
     }
     include(context, includeChildrenRecursively) {
-        if (!(this.deoptimizeBody && this.directlyIncluded)) {
+        if (!this.deoptimizeBody || !this.directlyIncluded) {
             this.included = true;
             this.directlyIncluded = true;
             if (this.deoptimizeBody)
@@ -8852,7 +8715,7 @@
                 firstBodyStatement.directive === 'use asm';
     }
     render(code, options) {
-        if (this.body.length > 0) {
+        if (this.body.length) {
             renderStatementList(this.body, code, this.start + 1, this.end - 1, options);
         }
         else {
@@ -8861,62 +8724,26 @@
     }
 }
 
-class RestElement extends NodeBase {
-    constructor() {
-        super(...arguments);
-        this.declarationInit = null;
-    }
-    addExportedVariables(variables, exportNamesByVariable) {
-        this.argument.addExportedVariables(variables, exportNamesByVariable);
-    }
-    declare(kind, init) {
-        this.declarationInit = init;
-        return this.argument.declare(kind, UNKNOWN_EXPRESSION);
-    }
-    deoptimizePath(path) {
-        path.length === 0 && this.argument.deoptimizePath(EMPTY_PATH);
-    }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        return (path.length > 0 ||
-            this.argument.hasEffectsOnInteractionAtPath(EMPTY_PATH, interaction, context));
-    }
-    markDeclarationReached() {
-        this.argument.markDeclarationReached();
-    }
-    applyDeoptimizations() {
-        this.deoptimized = true;
-        if (this.declarationInit !== null) {
-            this.declarationInit.deoptimizePath([UnknownKey, UnknownKey]);
-            this.context.requestTreeshakingPass();
-        }
-    }
-}
-
-class FunctionBase extends NodeBase {
+class ArrowFunctionExpression extends NodeBase {
     constructor() {
         super(...arguments);
-        this.objectEntity = null;
         this.deoptimizedReturn = false;
     }
+    createScope(parentScope) {
+        this.scope = new ReturnValueScope(parentScope, this.context);
+    }
     deoptimizePath(path) {
-        this.getObjectEntity().deoptimizePath(path);
+        // A reassignment of UNKNOWN_PATH is considered equivalent to having lost track
+        // which means the return expression needs to be reassigned
         if (path.length === 1 && path[0] === UnknownKey) {
-            // A reassignment of UNKNOWN_PATH is considered equivalent to having lost track
-            // which means the return expression needs to be reassigned
             this.scope.getReturnExpression().deoptimizePath(UNKNOWN_PATH);
         }
     }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        if (path.length > 0) {
-            this.getObjectEntity().deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
-        }
-    }
-    getLiteralValueAtPath(path, recursionTracker, origin) {
-        return this.getObjectEntity().getLiteralValueAtPath(path, recursionTracker, origin);
-    }
-    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
-        if (path.length > 0) {
-            return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
+    // Arrow functions do not mutate their context
+    deoptimizeThisOnEventAtPath() { }
+    getReturnExpressionWhenCalledAtPath(path) {
+        if (path.length !== 0) {
+            return UNKNOWN_EXPRESSION;
         }
         if (this.async) {
             if (!this.deoptimizedReturn) {
@@ -8924,45 +8751,67 @@
                 this.scope.getReturnExpression().deoptimizePath(UNKNOWN_PATH);
                 this.context.requestTreeshakingPass();
             }
-            return UNKNOWN_RETURN_EXPRESSION;
+            return UNKNOWN_EXPRESSION;
         }
-        return [this.scope.getReturnExpression(), false];
+        return this.scope.getReturnExpression();
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        if (path.length > 0 || interaction.type !== INTERACTION_CALLED) {
-            return this.getObjectEntity().hasEffectsOnInteractionAtPath(path, interaction, context);
-        }
+    hasEffects() {
+        return false;
+    }
+    hasEffectsWhenAccessedAtPath(path) {
+        return path.length > 1;
+    }
+    hasEffectsWhenAssignedAtPath(path) {
+        return path.length > 1;
+    }
+    hasEffectsWhenCalledAtPath(path, _callOptions, context) {
+        if (path.length > 0)
+            return true;
         if (this.async) {
             const { propertyReadSideEffects } = this.context.options
                 .treeshake;
             const returnExpression = this.scope.getReturnExpression();
-            if (returnExpression.hasEffectsOnInteractionAtPath(['then'], NODE_INTERACTION_UNKNOWN_CALL, context) ||
+            if (returnExpression.hasEffectsWhenCalledAtPath(['then'], { args: NO_ARGS, thisParam: null, withNew: false }, context) ||
                 (propertyReadSideEffects &&
                     (propertyReadSideEffects === 'always' ||
-                        returnExpression.hasEffectsOnInteractionAtPath(['then'], NODE_INTERACTION_UNKNOWN_ACCESS, context)))) {
+                        returnExpression.hasEffectsWhenAccessedAtPath(['then'], context)))) {
                 return true;
             }
         }
-        for (const parameter of this.params) {
-            if (parameter.hasEffects(context))
+        for (const param of this.params) {
+            if (param.hasEffects(context))
                 return true;
         }
+        const { ignore, brokenFlow } = context;
+        context.ignore = {
+            breaks: false,
+            continues: false,
+            labels: new Set(),
+            returnYield: true
+        };
+        if (this.body.hasEffects(context))
+            return true;
+        context.ignore = ignore;
+        context.brokenFlow = brokenFlow;
         return false;
     }
     include(context, includeChildrenRecursively) {
-        if (!this.deoptimized)
-            this.applyDeoptimizations();
         this.included = true;
+        for (const param of this.params) {
+            if (!(param instanceof Identifier)) {
+                param.include(context, includeChildrenRecursively);
+            }
+        }
         const { brokenFlow } = context;
         context.brokenFlow = BROKEN_FLOW_NONE;
         this.body.include(context, includeChildrenRecursively);
         context.brokenFlow = brokenFlow;
     }
-    includeCallArguments(context, parameters) {
-        this.scope.includeCallArguments(context, parameters);
+    includeCallArguments(context, args) {
+        this.scope.includeCallArguments(context, args);
     }
     initialise() {
-        this.scope.addParameterVariables(this.params.map(parameter => parameter.declare('parameter', UNKNOWN_EXPRESSION)), this.params[this.params.length - 1] instanceof RestElement);
+        this.scope.addParameterVariables(this.params.map(param => param.declare('parameter', UNKNOWN_EXPRESSION)), this.params[this.params.length - 1] instanceof RestElement);
         if (this.body instanceof BlockStatement) {
             this.body.addImplicitReturnExpressionToScope();
         }
@@ -8972,102 +8821,12 @@
     }
     parseNode(esTreeNode) {
         if (esTreeNode.body.type === BlockStatement$1) {
-            this.body = new BlockStatement(esTreeNode.body, this, this.scope.hoistedBodyVarScope);
+            this.body = new this.context.nodeConstructors.BlockStatement(esTreeNode.body, this, this.scope.hoistedBodyVarScope);
         }
         super.parseNode(esTreeNode);
     }
-    applyDeoptimizations() { }
-}
-FunctionBase.prototype.preventChildBlockScope = true;
-
-class ArrowFunctionExpression extends FunctionBase {
-    constructor() {
-        super(...arguments);
-        this.objectEntity = null;
-    }
-    createScope(parentScope) {
-        this.scope = new ReturnValueScope(parentScope, this.context);
-    }
-    hasEffects() {
-        if (!this.deoptimized)
-            this.applyDeoptimizations();
-        return false;
-    }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        if (super.hasEffectsOnInteractionAtPath(path, interaction, context))
-            return true;
-        if (interaction.type === INTERACTION_CALLED) {
-            const { ignore, brokenFlow } = context;
-            context.ignore = {
-                breaks: false,
-                continues: false,
-                labels: new Set(),
-                returnYield: true
-            };
-            if (this.body.hasEffects(context))
-                return true;
-            context.ignore = ignore;
-            context.brokenFlow = brokenFlow;
-        }
-        return false;
-    }
-    include(context, includeChildrenRecursively) {
-        super.include(context, includeChildrenRecursively);
-        for (const parameter of this.params) {
-            if (!(parameter instanceof Identifier)) {
-                parameter.include(context, includeChildrenRecursively);
-            }
-        }
-    }
-    getObjectEntity() {
-        if (this.objectEntity !== null) {
-            return this.objectEntity;
-        }
-        return (this.objectEntity = new ObjectEntity([], OBJECT_PROTOTYPE));
-    }
-}
-
-function getSystemExportStatement(exportedVariables, { exportNamesByVariable, snippets: { _, getObject, getPropertyAccess } }, modifier = '') {
-    if (exportedVariables.length === 1 &&
-        exportNamesByVariable.get(exportedVariables[0]).length === 1) {
-        const variable = exportedVariables[0];
-        return `exports('${exportNamesByVariable.get(variable)}',${_}${variable.getName(getPropertyAccess)}${modifier})`;
-    }
-    else {
-        const fields = [];
-        for (const variable of exportedVariables) {
-            for (const exportName of exportNamesByVariable.get(variable)) {
-                fields.push([exportName, variable.getName(getPropertyAccess) + modifier]);
-            }
-        }
-        return `exports(${getObject(fields, { lineBreakIndent: null })})`;
-    }
-}
-function renderSystemExportExpression(exportedVariable, expressionStart, expressionEnd, code, { exportNamesByVariable, snippets: { _ } }) {
-    code.prependRight(expressionStart, `exports('${exportNamesByVariable.get(exportedVariable)}',${_}`);
-    code.appendLeft(expressionEnd, ')');
-}
-function renderSystemExportFunction(exportedVariables, expressionStart, expressionEnd, needsParens, code, options) {
-    const { _, getDirectReturnIifeLeft } = options.snippets;
-    code.prependRight(expressionStart, getDirectReturnIifeLeft(['v'], `${getSystemExportStatement(exportedVariables, options)},${_}v`, { needsArrowReturnParens: true, needsWrappedFunction: needsParens }));
-    code.appendLeft(expressionEnd, ')');
-}
-function renderSystemExportSequenceAfterExpression(exportedVariable, expressionStart, expressionEnd, needsParens, code, options) {
-    const { _, getPropertyAccess } = options.snippets;
-    code.appendLeft(expressionEnd, `,${_}${getSystemExportStatement([exportedVariable], options)},${_}${exportedVariable.getName(getPropertyAccess)}`);
-    if (needsParens) {
-        code.prependRight(expressionStart, '(');
-        code.appendLeft(expressionEnd, ')');
-    }
-}
-function renderSystemExportSequenceBeforeExpression(exportedVariable, expressionStart, expressionEnd, needsParens, code, options, modifier) {
-    const { _ } = options.snippets;
-    code.prependRight(expressionStart, `${getSystemExportStatement([exportedVariable], options, modifier)},${_}`);
-    if (needsParens) {
-        code.prependRight(expressionStart, '(');
-        code.appendLeft(expressionEnd, ')');
-    }
 }
+ArrowFunctionExpression.prototype.preventChildBlockScope = true;
 
 class ObjectPattern extends NodeBase {
     addExportedVariables(variables, exportNamesByVariable) {
@@ -9094,12 +8853,11 @@
             }
         }
     }
-    hasEffectsOnInteractionAtPath(
-    // At the moment, this is only triggered for assignment left-hand sides,
-    // where the path is empty
-    _path, interaction, context) {
+    hasEffectsWhenAssignedAtPath(path, context) {
+        if (path.length > 0)
+            return true;
         for (const property of this.properties) {
-            if (property.hasEffectsOnInteractionAtPath(EMPTY_PATH, interaction, context))
+            if (property.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context))
                 return true;
         }
         return false;
@@ -9112,79 +8870,80 @@
 }
 
 class AssignmentExpression extends NodeBase {
+    constructor() {
+        super(...arguments);
+        this.deoptimized = false;
+    }
     hasEffects(context) {
-        const { deoptimized, left, operator, right } = this;
-        if (!deoptimized)
+        if (!this.deoptimized)
             this.applyDeoptimizations();
-        // MemberExpressions do not access the property before assignments if the
-        // operator is '='.
-        return (right.hasEffects(context) || left.hasEffectsAsAssignmentTarget(context, operator !== '='));
+        return (this.right.hasEffects(context) ||
+            this.left.hasEffects(context) ||
+            this.left.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context));
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        return this.right.hasEffectsOnInteractionAtPath(path, interaction, context);
+    hasEffectsWhenAccessedAtPath(path, context) {
+        return path.length > 0 && this.right.hasEffectsWhenAccessedAtPath(path, context);
     }
     include(context, includeChildrenRecursively) {
-        const { deoptimized, left, right, operator } = this;
-        if (!deoptimized)
+        if (!this.deoptimized)
             this.applyDeoptimizations();
         this.included = true;
+        let hasEffectsContext;
         if (includeChildrenRecursively ||
-            operator !== '=' ||
-            left.included ||
-            left.hasEffectsAsAssignmentTarget(createHasEffectsContext(), false)) {
-            left.includeAsAssignmentTarget(context, includeChildrenRecursively, operator !== '=');
+            this.operator !== '=' ||
+            this.left.included ||
+            ((hasEffectsContext = createHasEffectsContext()),
+                this.left.hasEffects(hasEffectsContext) ||
+                    this.left.hasEffectsWhenAssignedAtPath(EMPTY_PATH, hasEffectsContext))) {
+            this.left.include(context, includeChildrenRecursively);
         }
-        right.include(context, includeChildrenRecursively);
-    }
-    initialise() {
-        this.left.setAssignedValue(this.right);
+        this.right.include(context, includeChildrenRecursively);
     }
     render(code, options, { preventASI, renderedParentType, renderedSurroundingElement } = BLANK) {
-        const { left, right, start, end, parent } = this;
-        if (left.included) {
-            left.render(code, options);
-            right.render(code, options);
+        if (this.left.included) {
+            this.left.render(code, options);
+            this.right.render(code, options);
         }
         else {
-            const inclusionStart = findNonWhiteSpace(code.original, findFirstOccurrenceOutsideComment(code.original, '=', left.end) + 1);
-            code.remove(start, inclusionStart);
+            const inclusionStart = findNonWhiteSpace(code.original, findFirstOccurrenceOutsideComment(code.original, '=', this.left.end) + 1);
+            code.remove(this.start, inclusionStart);
             if (preventASI) {
-                removeLineBreaks(code, inclusionStart, right.start);
+                removeLineBreaks(code, inclusionStart, this.right.start);
             }
-            right.render(code, options, {
-                renderedParentType: renderedParentType || parent.type,
-                renderedSurroundingElement: renderedSurroundingElement || parent.type
+            this.right.render(code, options, {
+                renderedParentType: renderedParentType || this.parent.type,
+                renderedSurroundingElement: renderedSurroundingElement || this.parent.type
             });
         }
         if (options.format === 'system') {
-            if (left instanceof Identifier) {
-                const variable = left.variable;
+            if (this.left instanceof Identifier) {
+                const variable = this.left.variable;
                 const exportNames = options.exportNamesByVariable.get(variable);
                 if (exportNames) {
                     if (exportNames.length === 1) {
-                        renderSystemExportExpression(variable, start, end, code, options);
+                        renderSystemExportExpression(variable, this.start, this.end, code, options);
                     }
                     else {
-                        renderSystemExportSequenceAfterExpression(variable, start, end, parent.type !== ExpressionStatement$1, code, options);
+                        renderSystemExportSequenceAfterExpression(variable, this.start, this.end, this.parent.type !== ExpressionStatement$1, code, options);
                     }
                     return;
                 }
             }
             else {
                 const systemPatternExports = [];
-                left.addExportedVariables(systemPatternExports, options.exportNamesByVariable);
+                this.left.addExportedVariables(systemPatternExports, options.exportNamesByVariable);
                 if (systemPatternExports.length > 0) {
-                    renderSystemExportFunction(systemPatternExports, start, end, renderedSurroundingElement === ExpressionStatement$1, code, options);
+                    renderSystemExportFunction(systemPatternExports, this.start, this.end, renderedSurroundingElement === ExpressionStatement$1, code, options);
                     return;
                 }
             }
         }
-        if (left.included &&
-            left instanceof ObjectPattern &&
+        if (this.left.included &&
+            this.left instanceof ObjectPattern &&
             (renderedSurroundingElement === ExpressionStatement$1 ||
                 renderedSurroundingElement === ArrowFunctionExpression$1)) {
-            code.appendRight(start, '(');
-            code.prependLeft(end, ')');
+            code.appendRight(this.start, '(');
+            code.prependLeft(this.end, ')');
         }
     }
     applyDeoptimizations() {
@@ -9196,6 +8955,10 @@
 }
 
 class AssignmentPattern extends NodeBase {
+    constructor() {
+        super(...arguments);
+        this.deoptimized = false;
+    }
     addExportedVariables(variables, exportNamesByVariable) {
         this.left.addExportedVariables(variables, exportNamesByVariable);
     }
@@ -9205,8 +8968,8 @@
     deoptimizePath(path) {
         path.length === 0 && this.left.deoptimizePath(path);
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        return (path.length > 0 || this.left.hasEffectsOnInteractionAtPath(EMPTY_PATH, interaction, context));
+    hasEffectsWhenAssignedAtPath(path, context) {
+        return path.length > 0 || this.left.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context);
     }
     markDeclarationReached() {
         this.left.markDeclarationReached();
@@ -9223,160 +8986,11 @@
     }
 }
 
-class ArgumentsVariable extends LocalVariable {
-    constructor(context) {
-        super('arguments', null, UNKNOWN_EXPRESSION, context);
-    }
-    hasEffectsOnInteractionAtPath(path, { type }) {
-        return type !== INTERACTION_ACCESSED || path.length > 1;
-    }
-}
-
-class ThisVariable extends LocalVariable {
-    constructor(context) {
-        super('this', null, null, context);
-        this.deoptimizedPaths = [];
-        this.entitiesToBeDeoptimized = new Set();
-        this.thisDeoptimizationList = [];
-        this.thisDeoptimizations = new DiscriminatedPathTracker();
-    }
-    addEntityToBeDeoptimized(entity) {
-        for (const path of this.deoptimizedPaths) {
-            entity.deoptimizePath(path);
-        }
-        for (const { interaction, path } of this.thisDeoptimizationList) {
-            entity.deoptimizeThisOnInteractionAtPath(interaction, path, SHARED_RECURSION_TRACKER);
-        }
-        this.entitiesToBeDeoptimized.add(entity);
-    }
-    deoptimizePath(path) {
-        if (path.length === 0 ||
-            this.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(path, this)) {
-            return;
-        }
-        this.deoptimizedPaths.push(path);
-        for (const entity of this.entitiesToBeDeoptimized) {
-            entity.deoptimizePath(path);
-        }
-    }
-    deoptimizeThisOnInteractionAtPath(interaction, path) {
-        const thisDeoptimization = {
-            interaction,
-            path
-        };
-        if (!this.thisDeoptimizations.trackEntityAtPathAndGetIfTracked(path, interaction.type, interaction.thisArg)) {
-            for (const entity of this.entitiesToBeDeoptimized) {
-                entity.deoptimizeThisOnInteractionAtPath(interaction, path, SHARED_RECURSION_TRACKER);
-            }
-            this.thisDeoptimizationList.push(thisDeoptimization);
-        }
-    }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        return (this.getInit(context).hasEffectsOnInteractionAtPath(path, interaction, context) ||
-            super.hasEffectsOnInteractionAtPath(path, interaction, context));
-    }
-    getInit(context) {
-        return context.replacedVariableInits.get(this) || UNKNOWN_EXPRESSION;
-    }
-}
-
-class FunctionScope extends ReturnValueScope {
-    constructor(parent, context) {
-        super(parent, context);
-        this.variables.set('arguments', (this.argumentsVariable = new ArgumentsVariable(context)));
-        this.variables.set('this', (this.thisVariable = new ThisVariable(context)));
-    }
-    findLexicalBoundary() {
-        return this;
-    }
-    includeCallArguments(context, parameters) {
-        super.includeCallArguments(context, parameters);
-        if (this.argumentsVariable.included) {
-            for (const argument of parameters) {
-                if (!argument.included) {
-                    argument.include(context, false);
-                }
-            }
-        }
-    }
-}
-
-class FunctionNode extends FunctionBase {
+class AwaitExpression extends NodeBase {
     constructor() {
         super(...arguments);
-        this.objectEntity = null;
-    }
-    createScope(parentScope) {
-        this.scope = new FunctionScope(parentScope, this.context);
-    }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        super.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
-        if (interaction.type === INTERACTION_CALLED && path.length === 0) {
-            this.scope.thisVariable.addEntityToBeDeoptimized(interaction.thisArg);
-        }
-    }
-    hasEffects(context) {
-        if (!this.deoptimized)
-            this.applyDeoptimizations();
-        return !!this.id?.hasEffects(context);
-    }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        if (super.hasEffectsOnInteractionAtPath(path, interaction, context))
-            return true;
-        if (interaction.type === INTERACTION_CALLED) {
-            const thisInit = context.replacedVariableInits.get(this.scope.thisVariable);
-            context.replacedVariableInits.set(this.scope.thisVariable, interaction.withNew
-                ? new ObjectEntity(Object.create(null), OBJECT_PROTOTYPE)
-                : UNKNOWN_EXPRESSION);
-            const { brokenFlow, ignore, replacedVariableInits } = context;
-            context.ignore = {
-                breaks: false,
-                continues: false,
-                labels: new Set(),
-                returnYield: true
-            };
-            if (this.body.hasEffects(context))
-                return true;
-            context.brokenFlow = brokenFlow;
-            if (thisInit) {
-                replacedVariableInits.set(this.scope.thisVariable, thisInit);
-            }
-            else {
-                replacedVariableInits.delete(this.scope.thisVariable);
-            }
-            context.ignore = ignore;
-        }
-        return false;
-    }
-    include(context, includeChildrenRecursively) {
-        super.include(context, includeChildrenRecursively);
-        this.id?.include();
-        const hasArguments = this.scope.argumentsVariable.included;
-        for (const parameter of this.params) {
-            if (!(parameter instanceof Identifier) || hasArguments) {
-                parameter.include(context, includeChildrenRecursively);
-            }
-        }
-    }
-    initialise() {
-        super.initialise();
-        this.id?.declare('function', this);
-    }
-    getObjectEntity() {
-        if (this.objectEntity !== null) {
-            return this.objectEntity;
-        }
-        return (this.objectEntity = new ObjectEntity([
-            {
-                key: 'prototype',
-                kind: 'init',
-                property: new ObjectEntity([], OBJECT_PROTOTYPE)
-            }
-        ], OBJECT_PROTOTYPE));
+        this.deoptimized = false;
     }
-}
-
-class AwaitExpression extends NodeBase {
     hasEffects() {
         if (!this.deoptimized)
             this.applyDeoptimizations();
@@ -9398,6 +9012,11 @@
         }
         this.argument.include(context, includeChildrenRecursively);
     }
+    applyDeoptimizations() {
+        this.deoptimized = true;
+        this.argument.deoptimizePath(UNKNOWN_PATH);
+        this.context.requestTreeshakingPass();
+    }
 }
 
 const binaryOperators = {
@@ -9421,10 +9040,9 @@
     '>>': (left, right) => left >> right,
     '>>>': (left, right) => left >>> right,
     '^': (left, right) => left ^ right,
+    in: () => UnknownValue,
+    instanceof: () => UnknownValue,
     '|': (left, right) => left | right
-    // We use the fallback for cases where we return something unknown
-    // in: () => UnknownValue,
-    // instanceof: () => UnknownValue,
 };
 class BinaryExpression extends NodeBase {
     deoptimizeCache() { }
@@ -9432,27 +9050,26 @@
         if (path.length > 0)
             return UnknownValue;
         const leftValue = this.left.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);
-        if (typeof leftValue === 'symbol')
+        if (leftValue === UnknownValue)
             return UnknownValue;
         const rightValue = this.right.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);
-        if (typeof rightValue === 'symbol')
+        if (rightValue === UnknownValue)
             return UnknownValue;
-        const operatorFunction = binaryOperators[this.operator];
-        if (!operatorFunction)
+        const operatorFn = binaryOperators[this.operator];
+        if (!operatorFn)
             return UnknownValue;
-        return operatorFunction(leftValue, rightValue);
+        return operatorFn(leftValue, rightValue);
     }
     hasEffects(context) {
         // support some implicit type coercion runtime errors
         if (this.operator === '+' &&
             this.parent instanceof ExpressionStatement &&
-            this.left.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this) === '') {
+            this.left.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this) === '')
             return true;
-        }
         return super.hasEffects(context);
     }
-    hasEffectsOnInteractionAtPath(path, { type }) {
-        return type !== INTERACTION_ACCESSED || path.length > 1;
+    hasEffectsWhenAccessedAtPath(path) {
+        return path.length > 1;
     }
     render(code, options, { renderedSurroundingElement } = BLANK) {
         this.left.render(code, options, { renderedSurroundingElement });
@@ -9485,83 +9102,6 @@
     }
 }
 
-function renderCallArguments(code, options, node) {
-    if (node.arguments.length > 0) {
-        if (node.arguments[node.arguments.length - 1].included) {
-            for (const argument of node.arguments) {
-                argument.render(code, options);
-            }
-        }
-        else {
-            let lastIncludedIndex = node.arguments.length - 2;
-            while (lastIncludedIndex >= 0 && !node.arguments[lastIncludedIndex].included) {
-                lastIncludedIndex--;
-            }
-            if (lastIncludedIndex >= 0) {
-                for (let index = 0; index <= lastIncludedIndex; index++) {
-                    node.arguments[index].render(code, options);
-                }
-                code.remove(findFirstOccurrenceOutsideComment(code.original, ',', node.arguments[lastIncludedIndex].end), node.end - 1);
-            }
-            else {
-                code.remove(findFirstOccurrenceOutsideComment(code.original, '(', node.callee.end) + 1, node.end - 1);
-            }
-        }
-    }
-}
-
-class Literal extends NodeBase {
-    deoptimizeThisOnInteractionAtPath() { }
-    getLiteralValueAtPath(path) {
-        if (path.length > 0 ||
-            // unknown literals can also be null but do not start with an "n"
-            (this.value === null && this.context.code.charCodeAt(this.start) !== 110) ||
-            typeof this.value === 'bigint' ||
-            // to support shims for regular expressions
-            this.context.code.charCodeAt(this.start) === 47) {
-            return UnknownValue;
-        }
-        return this.value;
-    }
-    getReturnExpressionWhenCalledAtPath(path) {
-        if (path.length !== 1)
-            return UNKNOWN_RETURN_EXPRESSION;
-        return getMemberReturnExpressionWhenCalled(this.members, path[0]);
-    }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        switch (interaction.type) {
-            case INTERACTION_ACCESSED: {
-                return path.length > (this.value === null ? 0 : 1);
-            }
-            case INTERACTION_ASSIGNED: {
-                return true;
-            }
-            case INTERACTION_CALLED: {
-                if (this.included &&
-                    this.value instanceof RegExp &&
-                    (this.value.global || this.value.sticky)) {
-                    return true;
-                }
-                return (path.length !== 1 ||
-                    hasMemberEffectWhenCalled(this.members, path[0], interaction, context));
-            }
-        }
-    }
-    initialise() {
-        this.members = getLiteralMembersForValue(this.value);
-    }
-    parseNode(esTreeNode) {
-        this.value = esTreeNode.value;
-        this.regex = esTreeNode.regex;
-        super.parseNode(esTreeNode);
-    }
-    render(code) {
-        if (typeof this.value === 'string') {
-            code.indentExclusionRanges.push([this.start + 1, this.end - 1]);
-        }
-    }
-}
-
 // To avoid infinite recursions
 const MAX_PATH_DEPTH = 7;
 function getResolvablePropertyKey(memberExpression) {
@@ -9603,22 +9143,22 @@
     constructor() {
         super(...arguments);
         this.variable = null;
-        this.assignmentDeoptimized = false;
+        this.deoptimized = false;
         this.bound = false;
         this.expressionsToBeDeoptimized = [];
-        this.isUndefined = false;
+        this.replacement = null;
     }
     bind() {
         this.bound = true;
         const path = getPathIfNotComputed(this);
         const baseVariable = path && this.scope.findVariable(path[0].key);
-        if (baseVariable?.isNamespace) {
-            const resolvedVariable = resolveNamespaceVariables(baseVariable, path.slice(1), this.context);
+        if (baseVariable && baseVariable.isNamespace) {
+            const resolvedVariable = this.resolveNamespaceVariables(baseVariable, path.slice(1));
             if (!resolvedVariable) {
                 super.bind();
             }
-            else if (resolvedVariable === 'undefined') {
-                this.isUndefined = true;
+            else if (typeof resolvedVariable === 'string') {
+                this.replacement = resolvedVariable;
             }
             else {
                 this.variable = resolvedVariable;
@@ -9644,33 +9184,31 @@
         if (this.variable) {
             this.variable.deoptimizePath(path);
         }
-        else if (!this.isUndefined && path.length < MAX_PATH_DEPTH) {
-            const propertyKey = this.getPropertyKey();
-            this.object.deoptimizePath([
-                propertyKey === UnknownKey ? UnknownNonAccessorKey : propertyKey,
-                ...path
-            ]);
+        else if (!this.replacement) {
+            if (path.length < MAX_PATH_DEPTH) {
+                this.object.deoptimizePath([this.getPropertyKey(), ...path]);
+            }
         }
     }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
         if (this.variable) {
-            this.variable.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
+            this.variable.deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker);
         }
-        else if (!this.isUndefined) {
+        else if (!this.replacement) {
             if (path.length < MAX_PATH_DEPTH) {
-                this.object.deoptimizeThisOnInteractionAtPath(interaction, [this.getPropertyKey(), ...path], recursionTracker);
+                this.object.deoptimizeThisOnEventAtPath(event, [this.getPropertyKey(), ...path], thisParameter, recursionTracker);
             }
             else {
-                interaction.thisArg.deoptimizePath(UNKNOWN_PATH);
+                thisParameter.deoptimizePath(UNKNOWN_PATH);
             }
         }
     }
     getLiteralValueAtPath(path, recursionTracker, origin) {
-        if (this.variable) {
+        if (this.variable !== null) {
             return this.variable.getLiteralValueAtPath(path, recursionTracker, origin);
         }
-        if (this.isUndefined) {
-            return undefined;
+        if (this.replacement) {
+            return UnknownValue;
         }
         this.expressionsToBeDeoptimized.push(origin);
         if (path.length < MAX_PATH_DEPTH) {
@@ -9678,86 +9216,97 @@
         }
         return UnknownValue;
     }
-    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
-        if (this.variable) {
-            return this.variable.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
+    getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin) {
+        if (this.variable !== null) {
+            return this.variable.getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin);
         }
-        if (this.isUndefined) {
-            return [UNDEFINED_EXPRESSION, false];
+        if (this.replacement) {
+            return UNKNOWN_EXPRESSION;
         }
         this.expressionsToBeDeoptimized.push(origin);
         if (path.length < MAX_PATH_DEPTH) {
-            return this.object.getReturnExpressionWhenCalledAtPath([this.getPropertyKey(), ...path], interaction, recursionTracker, origin);
+            return this.object.getReturnExpressionWhenCalledAtPath([this.getPropertyKey(), ...path], callOptions, recursionTracker, origin);
         }
-        return UNKNOWN_RETURN_EXPRESSION;
+        return UNKNOWN_EXPRESSION;
     }
     hasEffects(context) {
         if (!this.deoptimized)
             this.applyDeoptimizations();
+        const { propertyReadSideEffects } = this.context.options
+            .treeshake;
         return (this.property.hasEffects(context) ||
             this.object.hasEffects(context) ||
-            this.hasAccessEffect(context));
+            // Assignments do not access the property before assigning
+            (!(this.variable ||
+                this.replacement ||
+                (this.parent instanceof AssignmentExpression && this.parent.operator === '=')) &&
+                propertyReadSideEffects &&
+                (propertyReadSideEffects === 'always' ||
+                    this.object.hasEffectsWhenAccessedAtPath([this.getPropertyKey()], context))));
     }
-    hasEffectsAsAssignmentTarget(context, checkAccess) {
-        if (checkAccess && !this.deoptimized)
-            this.applyDeoptimizations();
-        if (!this.assignmentDeoptimized)
-            this.applyAssignmentDeoptimization();
-        return (this.property.hasEffects(context) ||
-            this.object.hasEffects(context) ||
-            (checkAccess && this.hasAccessEffect(context)) ||
-            this.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.assignmentInteraction, context));
+    hasEffectsWhenAccessedAtPath(path, context) {
+        if (this.variable !== null) {
+            return this.variable.hasEffectsWhenAccessedAtPath(path, context);
+        }
+        if (this.replacement) {
+            return true;
+        }
+        if (path.length < MAX_PATH_DEPTH) {
+            return this.object.hasEffectsWhenAccessedAtPath([this.getPropertyKey(), ...path], context);
+        }
+        return true;
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        if (this.variable) {
-            return this.variable.hasEffectsOnInteractionAtPath(path, interaction, context);
+    hasEffectsWhenAssignedAtPath(path, context) {
+        if (this.variable !== null) {
+            return this.variable.hasEffectsWhenAssignedAtPath(path, context);
+        }
+        if (this.replacement) {
+            return true;
+        }
+        if (path.length < MAX_PATH_DEPTH) {
+            return this.object.hasEffectsWhenAssignedAtPath([this.getPropertyKey(), ...path], context);
+        }
+        return true;
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        if (this.variable !== null) {
+            return this.variable.hasEffectsWhenCalledAtPath(path, callOptions, context);
         }
-        if (this.isUndefined) {
+        if (this.replacement) {
             return true;
         }
         if (path.length < MAX_PATH_DEPTH) {
-            return this.object.hasEffectsOnInteractionAtPath([this.getPropertyKey(), ...path], interaction, context);
+            return this.object.hasEffectsWhenCalledAtPath([this.getPropertyKey(), ...path], callOptions, context);
         }
         return true;
     }
     include(context, includeChildrenRecursively) {
         if (!this.deoptimized)
             this.applyDeoptimizations();
-        this.includeProperties(context, includeChildrenRecursively);
-    }
-    includeAsAssignmentTarget(context, includeChildrenRecursively, deoptimizeAccess) {
-        if (!this.assignmentDeoptimized)
-            this.applyAssignmentDeoptimization();
-        if (deoptimizeAccess) {
-            this.include(context, includeChildrenRecursively);
-        }
-        else {
-            this.includeProperties(context, includeChildrenRecursively);
+        if (!this.included) {
+            this.included = true;
+            if (this.variable !== null) {
+                this.context.includeVariableInModule(this.variable);
+            }
         }
+        this.object.include(context, includeChildrenRecursively);
+        this.property.include(context, includeChildrenRecursively);
     }
-    includeCallArguments(context, parameters) {
+    includeCallArguments(context, args) {
         if (this.variable) {
-            this.variable.includeCallArguments(context, parameters);
+            this.variable.includeCallArguments(context, args);
         }
         else {
-            super.includeCallArguments(context, parameters);
+            super.includeCallArguments(context, args);
         }
     }
     initialise() {
         this.propertyKey = getResolvablePropertyKey(this);
-        this.accessInteraction = { thisArg: this.object, type: INTERACTION_ACCESSED };
-    }
-    isSkippedAsOptional(origin) {
-        return (!this.variable &&
-            !this.isUndefined &&
-            (this.object.isSkippedAsOptional?.(origin) ||
-                (this.optional &&
-                    this.object.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, origin) == null)));
     }
     render(code, options, { renderedParentType, isCalleeOfRenderedParent, renderedSurroundingElement } = BLANK) {
-        if (this.variable || this.isUndefined) {
+        if (this.variable || this.replacement) {
             const { snippets: { getPropertyAccess } } = options;
-            let replacement = this.variable ? this.variable.getName(getPropertyAccess) : 'undefined';
+            let replacement = this.variable ? this.variable.getName(getPropertyAccess) : this.replacement;
             if (renderedParentType && isCalleeOfRenderedParent)
                 replacement = '0, ' + replacement;
             code.overwrite(this.start, this.end, replacement, {
@@ -9773,13 +9322,6 @@
             this.property.render(code, options);
         }
     }
-    setAssignedValue(value) {
-        this.assignmentInteraction = {
-            args: [value],
-            thisArg: this.object,
-            type: INTERACTION_ASSIGNED
-        };
-    }
     applyDeoptimizations() {
         this.deoptimized = true;
         const { propertyReadSideEffects } = this.context.options
@@ -9788,22 +9330,14 @@
         // Namespaces are not bound and should not be deoptimized
         this.bound &&
             propertyReadSideEffects &&
-            !(this.variable || this.isUndefined)) {
-            const propertyKey = this.getPropertyKey();
-            this.object.deoptimizeThisOnInteractionAtPath(this.accessInteraction, [propertyKey], SHARED_RECURSION_TRACKER);
-            this.context.requestTreeshakingPass();
-        }
-    }
-    applyAssignmentDeoptimization() {
-        this.assignmentDeoptimized = true;
-        const { propertyReadSideEffects } = this.context.options
-            .treeshake;
-        if (
-        // Namespaces are not bound and should not be deoptimized
-        this.bound &&
-            propertyReadSideEffects &&
-            !(this.variable || this.isUndefined)) {
-            this.object.deoptimizeThisOnInteractionAtPath(this.assignmentInteraction, [this.getPropertyKey()], SHARED_RECURSION_TRACKER);
+            !(this.variable || this.replacement)) {
+            // Regular Assignments do not access the property before assigning
+            if (!(this.parent instanceof AssignmentExpression && this.parent.operator === '=')) {
+                this.object.deoptimizeThisOnEventAtPath(EVENT_ACCESSED, [this.propertyKey], this.object, SHARED_RECURSION_TRACKER);
+            }
+            if (this.parent instanceof AssignmentExpression) {
+                this.object.deoptimizeThisOnEventAtPath(EVENT_ASSIGNED, [this.propertyKey], this.object, SHARED_RECURSION_TRACKER);
+            }
             this.context.requestTreeshakingPass();
         }
     }
@@ -9814,7 +9348,10 @@
                 if (this.variable) {
                     this.context.includeVariableInModule(this.variable);
                 }
-                this.context.warn(errorIllegalImportReassignment(this.object.name, this.context.module.id), this.start);
+                this.context.warn({
+                    code: 'ILLEGAL_NAMESPACE_REASSIGNMENT',
+                    message: `Illegal reassignment to import '${this.object.name}'`
+                }, this.start);
             }
         }
     }
@@ -9822,62 +9359,70 @@
         if (this.propertyKey === null) {
             this.propertyKey = UnknownKey;
             const value = this.property.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
-            return (this.propertyKey =
-                value === SymbolToStringTag
-                    ? value
-                    : typeof value === 'symbol'
-                        ? UnknownKey
-                        : String(value));
+            return (this.propertyKey = value === UnknownValue ? UnknownKey : String(value));
         }
         return this.propertyKey;
     }
-    hasAccessEffect(context) {
-        const { propertyReadSideEffects } = this.context.options
-            .treeshake;
-        return (!(this.variable || this.isUndefined) &&
-            propertyReadSideEffects &&
-            (propertyReadSideEffects === 'always' ||
-                this.object.hasEffectsOnInteractionAtPath([this.getPropertyKey()], this.accessInteraction, context)));
-    }
-    includeProperties(context, includeChildrenRecursively) {
-        if (!this.included) {
-            this.included = true;
-            if (this.variable) {
-                this.context.includeVariableInModule(this.variable);
-            }
-        }
-        this.object.include(context, includeChildrenRecursively);
-        this.property.include(context, includeChildrenRecursively);
-    }
-}
-function resolveNamespaceVariables(baseVariable, path, astContext) {
-    if (path.length === 0)
-        return baseVariable;
-    if (!baseVariable.isNamespace || baseVariable instanceof ExternalVariable)
-        return null;
-    const exportName = path[0].key;
-    const variable = baseVariable.context.traceExport(exportName);
-    if (!variable) {
-        if (path.length === 1) {
+    resolveNamespaceVariables(baseVariable, path) {
+        if (path.length === 0)
+            return baseVariable;
+        if (!baseVariable.isNamespace || baseVariable instanceof ExternalVariable)
+            return null;
+        const exportName = path[0].key;
+        const variable = baseVariable.context.traceExport(exportName);
+        if (!variable) {
             const fileName = baseVariable.context.fileName;
-            astContext.warn(errorMissingExport(exportName, astContext.module.id, fileName), path[0].pos);
+            this.context.warn({
+                code: 'MISSING_EXPORT',
+                exporter: relativeId(fileName),
+                importer: relativeId(this.context.fileName),
+                message: `'${exportName}' is not exported by '${relativeId(fileName)}'`,
+                missing: exportName,
+                url: `https://rollupjs.org/guide/en/#error-name-is-not-exported-by-module`
+            }, path[0].pos);
             return 'undefined';
         }
-        return null;
+        return this.resolveNamespaceVariables(variable, path.slice(1));
     }
-    return resolveNamespaceVariables(variable, path.slice(1), astContext);
 }
 
-class CallExpressionBase extends NodeBase {
+class CallExpression extends NodeBase {
     constructor() {
         super(...arguments);
-        this.returnExpression = null;
+        this.deoptimized = false;
         this.deoptimizableDependentExpressions = [];
         this.expressionsToBeDeoptimized = new Set();
+        this.returnExpression = null;
+    }
+    bind() {
+        super.bind();
+        if (this.callee instanceof Identifier) {
+            const variable = this.scope.findVariable(this.callee.name);
+            if (variable.isNamespace) {
+                this.context.warn({
+                    code: 'CANNOT_CALL_NAMESPACE',
+                    message: `Cannot call a namespace ('${this.callee.name}')`
+                }, this.start);
+            }
+            if (this.callee.name === 'eval') {
+                this.context.warn({
+                    code: 'EVAL',
+                    message: `Use of eval is strongly discouraged, as it poses security risks and may cause issues with minification`,
+                    url: 'https://rollupjs.org/guide/en/#avoiding-eval'
+                }, this.start);
+            }
+        }
+        this.callOptions = {
+            args: this.arguments,
+            thisParam: this.callee instanceof MemberExpression && !this.callee.variable
+                ? this.callee.object
+                : null,
+            withNew: false
+        };
     }
     deoptimizeCache() {
-        if (this.returnExpression?.[0] !== UNKNOWN_EXPRESSION) {
-            this.returnExpression = UNKNOWN_RETURN_EXPRESSION;
+        if (this.returnExpression !== UNKNOWN_EXPRESSION) {
+            this.returnExpression = UNKNOWN_EXPRESSION;
             for (const expression of this.deoptimizableDependentExpressions) {
                 expression.deoptimizeCache();
             }
@@ -9891,27 +9436,25 @@
             this.context.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(path, this)) {
             return;
         }
-        const [returnExpression] = this.getReturnExpression();
+        const returnExpression = this.getReturnExpression();
         if (returnExpression !== UNKNOWN_EXPRESSION) {
             returnExpression.deoptimizePath(path);
         }
     }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        const [returnExpression, isPure] = this.getReturnExpression(recursionTracker);
-        if (isPure)
-            return;
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
+        const returnExpression = this.getReturnExpression(recursionTracker);
         if (returnExpression === UNKNOWN_EXPRESSION) {
-            interaction.thisArg.deoptimizePath(UNKNOWN_PATH);
+            thisParameter.deoptimizePath(UNKNOWN_PATH);
         }
         else {
             recursionTracker.withTrackedEntityAtPath(path, returnExpression, () => {
-                this.expressionsToBeDeoptimized.add(interaction.thisArg);
-                returnExpression.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
-            }, null);
+                this.expressionsToBeDeoptimized.add(thisParameter);
+                returnExpression.deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker);
+            }, undefined);
         }
     }
     getLiteralValueAtPath(path, recursionTracker, origin) {
-        const [returnExpression] = this.getReturnExpression(recursionTracker);
+        const returnExpression = this.getReturnExpression(recursionTracker);
         if (returnExpression === UNKNOWN_EXPRESSION) {
             return UnknownValue;
         }
@@ -9920,56 +9463,15 @@
             return returnExpression.getLiteralValueAtPath(path, recursionTracker, origin);
         }, UnknownValue);
     }
-    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
+    getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin) {
         const returnExpression = this.getReturnExpression(recursionTracker);
-        if (returnExpression[0] === UNKNOWN_EXPRESSION) {
-            return returnExpression;
+        if (this.returnExpression === UNKNOWN_EXPRESSION) {
+            return UNKNOWN_EXPRESSION;
         }
         return recursionTracker.withTrackedEntityAtPath(path, returnExpression, () => {
             this.deoptimizableDependentExpressions.push(origin);
-            const [expression, isPure] = returnExpression[0].getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
-            return [expression, isPure || returnExpression[1]];
-        }, UNKNOWN_RETURN_EXPRESSION);
-    }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        const { type } = interaction;
-        if (type === INTERACTION_CALLED) {
-            const { args, withNew } = interaction;
-            if ((withNew ? context.instantiated : context.called).trackEntityAtPathAndGetIfTracked(path, args, this)) {
-                return false;
-            }
-        }
-        else if ((type === INTERACTION_ASSIGNED
-            ? context.assigned
-            : context.accessed).trackEntityAtPathAndGetIfTracked(path, this)) {
-            return false;
-        }
-        const [returnExpression, isPure] = this.getReturnExpression();
-        return ((type === INTERACTION_ASSIGNED || !isPure) &&
-            returnExpression.hasEffectsOnInteractionAtPath(path, interaction, context));
-    }
-}
-
-class CallExpression extends CallExpressionBase {
-    bind() {
-        super.bind();
-        if (this.callee instanceof Identifier) {
-            const variable = this.scope.findVariable(this.callee.name);
-            if (variable.isNamespace) {
-                this.context.warn(errorCannotCallNamespace(this.callee.name), this.start);
-            }
-            if (this.callee.name === 'eval') {
-                this.context.warn(errorEval(this.context.module.id), this.start);
-            }
-        }
-        this.interaction = {
-            args: this.arguments,
-            thisArg: this.callee instanceof MemberExpression && !this.callee.variable
-                ? this.callee.object
-                : null,
-            type: INTERACTION_CALLED,
-            withNew: false
-        };
+            return returnExpression.getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin);
+        }, UNKNOWN_EXPRESSION);
     }
     hasEffects(context) {
         try {
@@ -9981,13 +9483,25 @@
                 this.annotations)
                 return false;
             return (this.callee.hasEffects(context) ||
-                this.callee.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.interaction, context));
+                this.callee.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.callOptions, context));
         }
         finally {
             if (!this.deoptimized)
                 this.applyDeoptimizations();
         }
     }
+    hasEffectsWhenAccessedAtPath(path, context) {
+        return (!context.accessed.trackEntityAtPathAndGetIfTracked(path, this) &&
+            this.getReturnExpression().hasEffectsWhenAccessedAtPath(path, context));
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        return (!context.assigned.trackEntityAtPathAndGetIfTracked(path, this) &&
+            this.getReturnExpression().hasEffectsWhenAssignedAtPath(path, context));
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        return (!(callOptions.withNew ? context.instantiated : context.called).trackEntityAtPathAndGetIfTracked(path, callOptions, this) &&
+            this.getReturnExpression().hasEffectsWhenCalledAtPath(path, callOptions, context));
+    }
     include(context, includeChildrenRecursively) {
         if (!this.deoptimized)
             this.applyDeoptimizations();
@@ -10004,23 +9518,44 @@
             this.callee.include(context, false);
         }
         this.callee.includeCallArguments(context, this.arguments);
-    }
-    isSkippedAsOptional(origin) {
-        return (this.callee.isSkippedAsOptional?.(origin) ||
-            (this.optional &&
-                this.callee.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, origin) == null));
+        const returnExpression = this.getReturnExpression();
+        if (!returnExpression.included) {
+            returnExpression.include(context, false);
+        }
     }
     render(code, options, { renderedSurroundingElement } = BLANK) {
         this.callee.render(code, options, {
             isCalleeOfRenderedParent: true,
             renderedSurroundingElement
         });
-        renderCallArguments(code, options, this);
+        if (this.arguments.length > 0) {
+            if (this.arguments[this.arguments.length - 1].included) {
+                for (const arg of this.arguments) {
+                    arg.render(code, options);
+                }
+            }
+            else {
+                let lastIncludedIndex = this.arguments.length - 2;
+                while (lastIncludedIndex >= 0 && !this.arguments[lastIncludedIndex].included) {
+                    lastIncludedIndex--;
+                }
+                if (lastIncludedIndex >= 0) {
+                    for (let index = 0; index <= lastIncludedIndex; index++) {
+                        this.arguments[index].render(code, options);
+                    }
+                    code.remove(findFirstOccurrenceOutsideComment(code.original, ',', this.arguments[lastIncludedIndex].end), this.end - 1);
+                }
+                else {
+                    code.remove(findFirstOccurrenceOutsideComment(code.original, '(', this.callee.end) + 1, this.end - 1);
+                }
+            }
+        }
     }
     applyDeoptimizations() {
         this.deoptimized = true;
-        if (this.interaction.thisArg) {
-            this.callee.deoptimizeThisOnInteractionAtPath(this.interaction, EMPTY_PATH, SHARED_RECURSION_TRACKER);
+        const { thisParam } = this.callOptions;
+        if (thisParam) {
+            this.callee.deoptimizeThisOnEventAtPath(EVENT_CALLED, EMPTY_PATH, thisParam, SHARED_RECURSION_TRACKER);
         }
         for (const argument of this.arguments) {
             // This will make sure all properties of parameters behave as "unknown"
@@ -10030,8 +9565,8 @@
     }
     getReturnExpression(recursionTracker = SHARED_RECURSION_TRACKER) {
         if (this.returnExpression === null) {
-            this.returnExpression = UNKNOWN_RETURN_EXPRESSION;
-            return (this.returnExpression = this.callee.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, this.interaction, recursionTracker, this));
+            this.returnExpression = UNKNOWN_EXPRESSION;
+            return (this.returnExpression = this.callee.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, this.callOptions, recursionTracker, this));
         }
         return this.returnExpression;
     }
@@ -10062,7 +9597,8 @@
         // name instead of the variable
         const { param } = esTreeNode;
         if (param) {
-            this.param = new (this.context.getNodeConstructor(param.type))(param, this, this.scope);
+            this.param = new (this.context.nodeConstructors[param.type] ||
+                this.context.nodeConstructors.UnknownNode)(param, this, this.scope);
             this.param.declare('parameter', UNKNOWN_EXPRESSION);
         }
         super.parseNode(esTreeNode);
@@ -10070,18 +9606,6 @@
 }
 
 class ChainExpression extends NodeBase {
-    // deoptimizations are not relevant as we are not caching values
-    deoptimizeCache() { }
-    getLiteralValueAtPath(path, recursionTracker, origin) {
-        if (this.expression.isSkippedAsOptional(origin))
-            return undefined;
-        return this.expression.getLiteralValueAtPath(path, recursionTracker, origin);
-    }
-    hasEffects(context) {
-        if (this.expression.isSkippedAsOptional(this))
-            return false;
-        return this.expression.hasEffects(context);
-    }
 }
 
 class ClassBodyScope extends ChildScope {
@@ -10110,269 +9634,10 @@
     parseNode(esTreeNode) {
         const body = (this.body = []);
         for (const definition of esTreeNode.body) {
-            body.push(new (this.context.getNodeConstructor(definition.type))(definition, this, definition.static ? this.scope : this.scope.instanceScope));
+            body.push(new this.context.nodeConstructors[definition.type](definition, this, definition.static ? this.scope : this.scope.instanceScope));
         }
         super.parseNode(esTreeNode);
     }
-    applyDeoptimizations() { }
-}
-
-class MethodBase extends NodeBase {
-    constructor() {
-        super(...arguments);
-        this.accessedValue = null;
-    }
-    // As getter properties directly receive their values from fixed function
-    // expressions, there is no known situation where a getter is deoptimized.
-    deoptimizeCache() { }
-    deoptimizePath(path) {
-        this.getAccessedValue()[0].deoptimizePath(path);
-    }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        if (interaction.type === INTERACTION_ACCESSED && this.kind === 'get' && path.length === 0) {
-            return this.value.deoptimizeThisOnInteractionAtPath({
-                args: NO_ARGS,
-                thisArg: interaction.thisArg,
-                type: INTERACTION_CALLED,
-                withNew: false
-            }, EMPTY_PATH, recursionTracker);
-        }
-        if (interaction.type === INTERACTION_ASSIGNED && this.kind === 'set' && path.length === 0) {
-            return this.value.deoptimizeThisOnInteractionAtPath({
-                args: interaction.args,
-                thisArg: interaction.thisArg,
-                type: INTERACTION_CALLED,
-                withNew: false
-            }, EMPTY_PATH, recursionTracker);
-        }
-        this.getAccessedValue()[0].deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
-    }
-    getLiteralValueAtPath(path, recursionTracker, origin) {
-        return this.getAccessedValue()[0].getLiteralValueAtPath(path, recursionTracker, origin);
-    }
-    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
-        return this.getAccessedValue()[0].getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
-    }
-    hasEffects(context) {
-        return this.key.hasEffects(context);
-    }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        if (this.kind === 'get' && interaction.type === INTERACTION_ACCESSED && path.length === 0) {
-            return this.value.hasEffectsOnInteractionAtPath(EMPTY_PATH, {
-                args: NO_ARGS,
-                thisArg: interaction.thisArg,
-                type: INTERACTION_CALLED,
-                withNew: false
-            }, context);
-        }
-        // setters are only called for empty paths
-        if (this.kind === 'set' && interaction.type === INTERACTION_ASSIGNED) {
-            return this.value.hasEffectsOnInteractionAtPath(EMPTY_PATH, {
-                args: interaction.args,
-                thisArg: interaction.thisArg,
-                type: INTERACTION_CALLED,
-                withNew: false
-            }, context);
-        }
-        return this.getAccessedValue()[0].hasEffectsOnInteractionAtPath(path, interaction, context);
-    }
-    applyDeoptimizations() { }
-    getAccessedValue() {
-        if (this.accessedValue === null) {
-            if (this.kind === 'get') {
-                this.accessedValue = UNKNOWN_RETURN_EXPRESSION;
-                return (this.accessedValue = this.value.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, NODE_INTERACTION_UNKNOWN_CALL, SHARED_RECURSION_TRACKER, this));
-            }
-            else {
-                return (this.accessedValue = [this.value, false]);
-            }
-        }
-        return this.accessedValue;
-    }
-}
-
-class MethodDefinition extends MethodBase {
-    applyDeoptimizations() { }
-}
-
-class ObjectMember extends ExpressionEntity {
-    constructor(object, key) {
-        super();
-        this.object = object;
-        this.key = key;
-    }
-    deoptimizePath(path) {
-        this.object.deoptimizePath([this.key, ...path]);
-    }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        this.object.deoptimizeThisOnInteractionAtPath(interaction, [this.key, ...path], recursionTracker);
-    }
-    getLiteralValueAtPath(path, recursionTracker, origin) {
-        return this.object.getLiteralValueAtPath([this.key, ...path], recursionTracker, origin);
-    }
-    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
-        return this.object.getReturnExpressionWhenCalledAtPath([this.key, ...path], interaction, recursionTracker, origin);
-    }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        return this.object.hasEffectsOnInteractionAtPath([this.key, ...path], interaction, context);
-    }
-}
-
-class ClassNode extends NodeBase {
-    constructor() {
-        super(...arguments);
-        this.objectEntity = null;
-    }
-    createScope(parentScope) {
-        this.scope = new ChildScope(parentScope);
-    }
-    deoptimizeCache() {
-        this.getObjectEntity().deoptimizeAllProperties();
-    }
-    deoptimizePath(path) {
-        this.getObjectEntity().deoptimizePath(path);
-    }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        this.getObjectEntity().deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
-    }
-    getLiteralValueAtPath(path, recursionTracker, origin) {
-        return this.getObjectEntity().getLiteralValueAtPath(path, recursionTracker, origin);
-    }
-    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
-        return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
-    }
-    hasEffects(context) {
-        if (!this.deoptimized)
-            this.applyDeoptimizations();
-        const initEffect = this.superClass?.hasEffects(context) || this.body.hasEffects(context);
-        this.id?.markDeclarationReached();
-        return initEffect || super.hasEffects(context);
-    }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        return interaction.type === INTERACTION_CALLED && path.length === 0
-            ? !interaction.withNew ||
-                (this.classConstructor === null
-                    ? this.superClass?.hasEffectsOnInteractionAtPath(path, interaction, context)
-                    : this.classConstructor.hasEffectsOnInteractionAtPath(path, interaction, context)) ||
-                false
-            : this.getObjectEntity().hasEffectsOnInteractionAtPath(path, interaction, context);
-    }
-    include(context, includeChildrenRecursively) {
-        if (!this.deoptimized)
-            this.applyDeoptimizations();
-        this.included = true;
-        this.superClass?.include(context, includeChildrenRecursively);
-        this.body.include(context, includeChildrenRecursively);
-        if (this.id) {
-            this.id.markDeclarationReached();
-            this.id.include();
-        }
-    }
-    initialise() {
-        this.id?.declare('class', this);
-        for (const method of this.body.body) {
-            if (method instanceof MethodDefinition && method.kind === 'constructor') {
-                this.classConstructor = method;
-                return;
-            }
-        }
-        this.classConstructor = null;
-    }
-    applyDeoptimizations() {
-        this.deoptimized = true;
-        for (const definition of this.body.body) {
-            if (!(definition.static ||
-                (definition instanceof MethodDefinition && definition.kind === 'constructor'))) {
-                // Calls to methods are not tracked, ensure that the return value is deoptimized
-                definition.deoptimizePath(UNKNOWN_PATH);
-            }
-        }
-        this.context.requestTreeshakingPass();
-    }
-    getObjectEntity() {
-        if (this.objectEntity !== null) {
-            return this.objectEntity;
-        }
-        const staticProperties = [];
-        const dynamicMethods = [];
-        for (const definition of this.body.body) {
-            const properties = definition.static ? staticProperties : dynamicMethods;
-            const definitionKind = definition.kind;
-            // Note that class fields do not end up on the prototype
-            if (properties === dynamicMethods && !definitionKind)
-                continue;
-            const kind = definitionKind === 'set' || definitionKind === 'get' ? definitionKind : 'init';
-            let key;
-            if (definition.computed) {
-                const keyValue = definition.key.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
-                if (typeof keyValue === 'symbol') {
-                    properties.push({ key: UnknownKey, kind, property: definition });
-                    continue;
-                }
-                else {
-                    key = String(keyValue);
-                }
-            }
-            else {
-                key =
-                    definition.key instanceof Identifier
-                        ? definition.key.name
-                        : String(definition.key.value);
-            }
-            properties.push({ key, kind, property: definition });
-        }
-        staticProperties.unshift({
-            key: 'prototype',
-            kind: 'init',
-            property: new ObjectEntity(dynamicMethods, this.superClass ? new ObjectMember(this.superClass, 'prototype') : OBJECT_PROTOTYPE)
-        });
-        return (this.objectEntity = new ObjectEntity(staticProperties, this.superClass || OBJECT_PROTOTYPE));
-    }
-}
-
-class ClassDeclaration extends ClassNode {
-    initialise() {
-        super.initialise();
-        if (this.id !== null) {
-            this.id.variable.isId = true;
-        }
-    }
-    parseNode(esTreeNode) {
-        if (esTreeNode.id !== null) {
-            this.id = new Identifier(esTreeNode.id, this, this.scope.parent);
-        }
-        super.parseNode(esTreeNode);
-    }
-    render(code, options) {
-        const { exportNamesByVariable, format, snippets: { _, getPropertyAccess } } = options;
-        if (this.id) {
-            const { variable, name } = this.id;
-            if (format === 'system' && exportNamesByVariable.has(variable)) {
-                code.appendLeft(this.end, `${_}${getSystemExportStatement([variable], options)};`);
-            }
-            const renderedVariable = variable.getName(getPropertyAccess);
-            if (renderedVariable !== name) {
-                this.superClass?.render(code, options);
-                this.body.render(code, options);
-                code.prependRight(this.start, `let ${renderedVariable}${_}=${_}`);
-                code.prependLeft(this.end, ';');
-                return;
-            }
-        }
-        super.render(code, options);
-    }
-    applyDeoptimizations() {
-        super.applyDeoptimizations();
-        const { id, scope } = this;
-        if (id) {
-            const { name, variable } = id;
-            for (const accessedVariable of scope.accessedOutsideVariables.values()) {
-                if (accessedVariable !== variable) {
-                    accessedVariable.forbidName(name);
-                }
-            }
-        }
-    }
 }
 
 class ClassExpression extends ClassNode {
@@ -10396,19 +9661,39 @@
             expression.deoptimizePath(path);
         }
     }
-    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
-        return [
-            new MultiExpression(this.expressions.map(expression => expression.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin)[0])),
-            false
-        ];
+    getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin) {
+        return new MultiExpression(this.expressions.map(expression => expression.getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin)));
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
+    hasEffectsWhenAccessedAtPath(path, context) {
         for (const expression of this.expressions) {
-            if (expression.hasEffectsOnInteractionAtPath(path, interaction, context))
+            if (expression.hasEffectsWhenAccessedAtPath(path, context))
                 return true;
         }
         return false;
     }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        for (const expression of this.expressions) {
+            if (expression.hasEffectsWhenAssignedAtPath(path, context))
+                return true;
+        }
+        return false;
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        for (const expression of this.expressions) {
+            if (expression.hasEffectsWhenCalledAtPath(path, callOptions, context))
+                return true;
+        }
+        return false;
+    }
+    include(context, includeChildrenRecursively) {
+        // This is only relevant to include values that do not have an AST representation,
+        // such as UnknownArrayExpression. Thus we only need to include them once.
+        for (const expression of this.expressions) {
+            if (!expression.included) {
+                expression.include(context, includeChildrenRecursively);
+            }
+        }
+    }
 }
 
 class ConditionalExpression extends NodeBase {
@@ -10430,54 +9715,67 @@
     }
     deoptimizePath(path) {
         const usedBranch = this.getUsedBranch();
-        if (usedBranch) {
-            usedBranch.deoptimizePath(path);
-        }
-        else {
+        if (usedBranch === null) {
             this.consequent.deoptimizePath(path);
             this.alternate.deoptimizePath(path);
         }
+        else {
+            usedBranch.deoptimizePath(path);
+        }
     }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        this.consequent.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
-        this.alternate.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
+        this.consequent.deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker);
+        this.alternate.deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker);
     }
     getLiteralValueAtPath(path, recursionTracker, origin) {
         const usedBranch = this.getUsedBranch();
-        if (!usedBranch)
+        if (usedBranch === null)
             return UnknownValue;
         this.expressionsToBeDeoptimized.push(origin);
         return usedBranch.getLiteralValueAtPath(path, recursionTracker, origin);
     }
-    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
+    getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin) {
         const usedBranch = this.getUsedBranch();
-        if (!usedBranch)
-            return [
-                new MultiExpression([
-                    this.consequent.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin)[0],
-                    this.alternate.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin)[0]
-                ]),
-                false
-            ];
+        if (usedBranch === null)
+            return new MultiExpression([
+                this.consequent.getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin),
+                this.alternate.getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin)
+            ]);
         this.expressionsToBeDeoptimized.push(origin);
-        return usedBranch.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
+        return usedBranch.getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin);
     }
     hasEffects(context) {
         if (this.test.hasEffects(context))
             return true;
         const usedBranch = this.getUsedBranch();
-        if (!usedBranch) {
+        if (usedBranch === null) {
             return this.consequent.hasEffects(context) || this.alternate.hasEffects(context);
         }
         return usedBranch.hasEffects(context);
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
+    hasEffectsWhenAccessedAtPath(path, context) {
         const usedBranch = this.getUsedBranch();
-        if (!usedBranch) {
-            return (this.consequent.hasEffectsOnInteractionAtPath(path, interaction, context) ||
-                this.alternate.hasEffectsOnInteractionAtPath(path, interaction, context));
+        if (usedBranch === null) {
+            return (this.consequent.hasEffectsWhenAccessedAtPath(path, context) ||
+                this.alternate.hasEffectsWhenAccessedAtPath(path, context));
         }
-        return usedBranch.hasEffectsOnInteractionAtPath(path, interaction, context);
+        return usedBranch.hasEffectsWhenAccessedAtPath(path, context);
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        const usedBranch = this.getUsedBranch();
+        if (usedBranch === null) {
+            return (this.consequent.hasEffectsWhenAssignedAtPath(path, context) ||
+                this.alternate.hasEffectsWhenAssignedAtPath(path, context));
+        }
+        return usedBranch.hasEffectsWhenAssignedAtPath(path, context);
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        const usedBranch = this.getUsedBranch();
+        if (usedBranch === null) {
+            return (this.consequent.hasEffectsWhenCalledAtPath(path, callOptions, context) ||
+                this.alternate.hasEffectsWhenCalledAtPath(path, callOptions, context));
+        }
+        return usedBranch.hasEffectsWhenCalledAtPath(path, callOptions, context);
     }
     include(context, includeChildrenRecursively) {
         this.included = true;
@@ -10491,24 +9789,19 @@
             usedBranch.include(context, includeChildrenRecursively);
         }
     }
-    includeCallArguments(context, parameters) {
+    includeCallArguments(context, args) {
         const usedBranch = this.getUsedBranch();
-        if (usedBranch) {
-            usedBranch.includeCallArguments(context, parameters);
+        if (usedBranch === null) {
+            this.consequent.includeCallArguments(context, args);
+            this.alternate.includeCallArguments(context, args);
         }
         else {
-            this.consequent.includeCallArguments(context, parameters);
-            this.alternate.includeCallArguments(context, parameters);
+            usedBranch.includeCallArguments(context, args);
         }
     }
     render(code, options, { isCalleeOfRenderedParent, preventASI, renderedParentType, renderedSurroundingElement } = BLANK) {
         const usedBranch = this.getUsedBranch();
-        if (this.test.included) {
-            this.test.render(code, options, { renderedSurroundingElement });
-            this.consequent.render(code, options);
-            this.alternate.render(code, options);
-        }
-        else {
+        if (!this.test.included) {
             const colonPos = findFirstOccurrenceOutsideComment(code.original, ':', this.consequent.end);
             const inclusionStart = findNonWhiteSpace(code.original, (this.consequent.included
                 ? findFirstOccurrenceOutsideComment(code.original, '?', this.test.end)
@@ -10528,6 +9821,11 @@
                 renderedSurroundingElement: renderedSurroundingElement || this.parent.type
             });
         }
+        else {
+            this.test.render(code, options, { renderedSurroundingElement });
+            this.consequent.render(code, options);
+            this.alternate.render(code, options);
+        }
     }
     getUsedBranch() {
         if (this.isBranchResolutionAnalysed) {
@@ -10535,7 +9833,7 @@
         }
         this.isBranchResolutionAnalysed = true;
         const testValue = this.test.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
-        return typeof testValue === 'symbol'
+        return testValue === UnknownValue
             ? null
             : (this.usedBranch = testValue ? this.consequent : this.alternate);
     }
@@ -10570,14 +9868,13 @@
     hasEffects(context) {
         if (this.test.hasEffects(context))
             return true;
-        const { brokenFlow, ignore } = context;
-        const { breaks, continues } = ignore;
-        ignore.breaks = true;
-        ignore.continues = true;
+        const { brokenFlow, ignore: { breaks, continues } } = context;
+        context.ignore.breaks = true;
+        context.ignore.continues = true;
         if (this.body.hasEffects(context))
             return true;
-        ignore.breaks = breaks;
-        ignore.continues = continues;
+        context.ignore.breaks = breaks;
+        context.ignore.continues = continues;
         context.brokenFlow = brokenFlow;
         return false;
     }
@@ -10585,7 +9882,7 @@
         this.included = true;
         this.test.include(context, includeChildrenRecursively);
         const { brokenFlow } = context;
-        this.body.include(context, includeChildrenRecursively, { asSingleStatement: true });
+        this.body.includeAsSingleStatement(context, includeChildrenRecursively);
         context.brokenFlow = brokenFlow;
     }
 }
@@ -10596,130 +9893,14 @@
     }
 }
 
-class ExportAllDeclaration extends NodeBase {
-    hasEffects() {
-        return false;
-    }
-    initialise() {
-        this.context.addExport(this);
-    }
-    render(code, _options, nodeRenderOptions) {
-        code.remove(nodeRenderOptions.start, nodeRenderOptions.end);
-    }
-    applyDeoptimizations() { }
-}
-ExportAllDeclaration.prototype.needsBoundaries = true;
-
-class FunctionDeclaration extends FunctionNode {
-    initialise() {
-        super.initialise();
-        if (this.id !== null) {
-            this.id.variable.isId = true;
-        }
-    }
-    parseNode(esTreeNode) {
-        if (esTreeNode.id !== null) {
-            this.id = new Identifier(esTreeNode.id, this, this.scope.parent);
-        }
-        super.parseNode(esTreeNode);
-    }
-}
-
-// The header ends at the first non-white-space after "default"
-function getDeclarationStart(code, start) {
-    return findNonWhiteSpace(code, findFirstOccurrenceOutsideComment(code, 'default', start) + 7);
-}
-function getIdInsertPosition(code, declarationKeyword, endMarker, start) {
-    const declarationEnd = findFirstOccurrenceOutsideComment(code, declarationKeyword, start) + declarationKeyword.length;
-    code = code.slice(declarationEnd, findFirstOccurrenceOutsideComment(code, endMarker, declarationEnd));
-    const generatorStarPos = findFirstOccurrenceOutsideComment(code, '*');
-    if (generatorStarPos === -1) {
-        return declarationEnd;
-    }
-    return declarationEnd + generatorStarPos + 1;
-}
-class ExportDefaultDeclaration extends NodeBase {
-    include(context, includeChildrenRecursively) {
-        super.include(context, includeChildrenRecursively);
-        if (includeChildrenRecursively) {
-            this.context.includeVariableInModule(this.variable);
-        }
-    }
-    initialise() {
-        const declaration = this.declaration;
-        this.declarationName =
-            (declaration.id && declaration.id.name) || this.declaration.name;
-        this.variable = this.scope.addExportDefaultDeclaration(this.declarationName || this.context.getModuleName(), this, this.context);
-        this.context.addExport(this);
-    }
-    render(code, options, nodeRenderOptions) {
-        const { start, end } = nodeRenderOptions;
-        const declarationStart = getDeclarationStart(code.original, this.start);
-        if (this.declaration instanceof FunctionDeclaration) {
-            this.renderNamedDeclaration(code, declarationStart, 'function', '(', this.declaration.id === null, options);
-        }
-        else if (this.declaration instanceof ClassDeclaration) {
-            this.renderNamedDeclaration(code, declarationStart, 'class', '{', this.declaration.id === null, options);
-        }
-        else if (this.variable.getOriginalVariable() !== this.variable) {
-            // Remove altogether to prevent re-declaring the same variable
-            treeshakeNode(this, code, start, end);
-            return;
-        }
-        else if (this.variable.included) {
-            this.renderVariableDeclaration(code, declarationStart, options);
-        }
-        else {
-            code.remove(this.start, declarationStart);
-            this.declaration.render(code, options, {
-                renderedSurroundingElement: ExpressionStatement$1
-            });
-            if (code.original[this.end - 1] !== ';') {
-                code.appendLeft(this.end, ';');
-            }
-            return;
-        }
-        this.declaration.render(code, options);
-    }
-    applyDeoptimizations() { }
-    renderNamedDeclaration(code, declarationStart, declarationKeyword, endMarker, needsId, options) {
-        const { exportNamesByVariable, format, snippets: { getPropertyAccess } } = options;
-        const name = this.variable.getName(getPropertyAccess);
-        // Remove `export default`
-        code.remove(this.start, declarationStart);
-        if (needsId) {
-            code.appendLeft(getIdInsertPosition(code.original, declarationKeyword, endMarker, declarationStart), ` ${name}`);
-        }
-        if (format === 'system' &&
-            this.declaration instanceof ClassDeclaration &&
-            exportNamesByVariable.has(this.variable)) {
-            code.appendLeft(this.end, ` ${getSystemExportStatement([this.variable], options)};`);
-        }
-    }
-    renderVariableDeclaration(code, declarationStart, { format, exportNamesByVariable, snippets: { cnst, getPropertyAccess } }) {
-        const hasTrailingSemicolon = code.original.charCodeAt(this.end - 1) === 59; /*";"*/
-        const systemExportNames = format === 'system' && exportNamesByVariable.get(this.variable);
-        if (systemExportNames) {
-            code.overwrite(this.start, declarationStart, `${cnst} ${this.variable.getName(getPropertyAccess)} = exports('${systemExportNames[0]}', `);
-            code.appendRight(hasTrailingSemicolon ? this.end - 1 : this.end, ')' + (hasTrailingSemicolon ? '' : ';'));
-        }
-        else {
-            code.overwrite(this.start, declarationStart, `${cnst} ${this.variable.getName(getPropertyAccess)} = `);
-            if (!hasTrailingSemicolon) {
-                code.appendLeft(this.end, ';');
-            }
-        }
-    }
-}
-ExportDefaultDeclaration.prototype.needsBoundaries = true;
-
 class ExportNamedDeclaration extends NodeBase {
     bind() {
         // Do not bind specifiers
-        this.declaration?.bind();
+        if (this.declaration !== null)
+            this.declaration.bind();
     }
     hasEffects(context) {
-        return !!this.declaration?.hasEffects(context);
+        return this.declaration !== null && this.declaration.hasEffects(context);
     }
     initialise() {
         this.context.addExport(this);
@@ -10734,49 +9915,48 @@
             this.declaration.render(code, options, { end, start });
         }
     }
-    applyDeoptimizations() { }
 }
 ExportNamedDeclaration.prototype.needsBoundaries = true;
 
 class ExportSpecifier extends NodeBase {
-    applyDeoptimizations() { }
 }
 
 class ForInStatement extends NodeBase {
+    constructor() {
+        super(...arguments);
+        this.deoptimized = false;
+    }
     createScope(parentScope) {
         this.scope = new BlockScope(parentScope);
     }
     hasEffects(context) {
-        const { body, deoptimized, left, right } = this;
-        if (!deoptimized)
+        if (!this.deoptimized)
             this.applyDeoptimizations();
-        if (left.hasEffectsAsAssignmentTarget(context, false) || right.hasEffects(context))
+        if ((this.left &&
+            (this.left.hasEffects(context) ||
+                this.left.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context))) ||
+            (this.right && this.right.hasEffects(context)))
             return true;
-        const { brokenFlow, ignore } = context;
-        const { breaks, continues } = ignore;
-        ignore.breaks = true;
-        ignore.continues = true;
-        if (body.hasEffects(context))
+        const { brokenFlow, ignore: { breaks, continues } } = context;
+        context.ignore.breaks = true;
+        context.ignore.continues = true;
+        if (this.body.hasEffects(context))
             return true;
-        ignore.breaks = breaks;
-        ignore.continues = continues;
+        context.ignore.breaks = breaks;
+        context.ignore.continues = continues;
         context.brokenFlow = brokenFlow;
         return false;
     }
     include(context, includeChildrenRecursively) {
-        const { body, deoptimized, left, right } = this;
-        if (!deoptimized)
+        if (!this.deoptimized)
             this.applyDeoptimizations();
         this.included = true;
-        left.includeAsAssignmentTarget(context, includeChildrenRecursively || true, false);
-        right.include(context, includeChildrenRecursively);
+        this.left.include(context, includeChildrenRecursively || true);
+        this.right.include(context, includeChildrenRecursively);
         const { brokenFlow } = context;
-        body.include(context, includeChildrenRecursively, { asSingleStatement: true });
+        this.body.includeAsSingleStatement(context, includeChildrenRecursively);
         context.brokenFlow = brokenFlow;
     }
-    initialise() {
-        this.left.setAssignedValue(UNKNOWN_EXPRESSION);
-    }
     render(code, options) {
         this.left.render(code, options, NO_SEMICOLON);
         this.right.render(code, options, NO_SEMICOLON);
@@ -10794,6 +9974,10 @@
 }
 
 class ForOfStatement extends NodeBase {
+    constructor() {
+        super(...arguments);
+        this.deoptimized = false;
+    }
     createScope(parentScope) {
         this.scope = new BlockScope(parentScope);
     }
@@ -10804,19 +9988,15 @@
         return true;
     }
     include(context, includeChildrenRecursively) {
-        const { body, deoptimized, left, right } = this;
-        if (!deoptimized)
+        if (!this.deoptimized)
             this.applyDeoptimizations();
         this.included = true;
-        left.includeAsAssignmentTarget(context, includeChildrenRecursively || true, false);
-        right.include(context, includeChildrenRecursively);
+        this.left.include(context, includeChildrenRecursively || true);
+        this.right.include(context, includeChildrenRecursively);
         const { brokenFlow } = context;
-        body.include(context, includeChildrenRecursively, { asSingleStatement: true });
+        this.body.includeAsSingleStatement(context, includeChildrenRecursively);
         context.brokenFlow = brokenFlow;
     }
-    initialise() {
-        this.left.setAssignedValue(UNKNOWN_EXPRESSION);
-    }
     render(code, options) {
         this.left.render(code, options, NO_SEMICOLON);
         this.right.render(code, options, NO_SEMICOLON);
@@ -10838,34 +10018,39 @@
         this.scope = new BlockScope(parentScope);
     }
     hasEffects(context) {
-        if (this.init?.hasEffects(context) ||
-            this.test?.hasEffects(context) ||
-            this.update?.hasEffects(context))
+        if ((this.init && this.init.hasEffects(context)) ||
+            (this.test && this.test.hasEffects(context)) ||
+            (this.update && this.update.hasEffects(context)))
             return true;
-        const { brokenFlow, ignore } = context;
-        const { breaks, continues } = ignore;
-        ignore.breaks = true;
-        ignore.continues = true;
+        const { brokenFlow, ignore: { breaks, continues } } = context;
+        context.ignore.breaks = true;
+        context.ignore.continues = true;
         if (this.body.hasEffects(context))
             return true;
-        ignore.breaks = breaks;
-        ignore.continues = continues;
+        context.ignore.breaks = breaks;
+        context.ignore.continues = continues;
         context.brokenFlow = brokenFlow;
         return false;
     }
     include(context, includeChildrenRecursively) {
         this.included = true;
-        this.init?.include(context, includeChildrenRecursively, { asSingleStatement: true });
-        this.test?.include(context, includeChildrenRecursively);
+        if (this.init)
+            this.init.includeAsSingleStatement(context, includeChildrenRecursively);
+        if (this.test)
+            this.test.include(context, includeChildrenRecursively);
         const { brokenFlow } = context;
-        this.update?.include(context, includeChildrenRecursively);
-        this.body.include(context, includeChildrenRecursively, { asSingleStatement: true });
+        if (this.update)
+            this.update.include(context, includeChildrenRecursively);
+        this.body.includeAsSingleStatement(context, includeChildrenRecursively);
         context.brokenFlow = brokenFlow;
     }
     render(code, options) {
-        this.init?.render(code, options, NO_SEMICOLON);
-        this.test?.render(code, options, NO_SEMICOLON);
-        this.update?.render(code, options, NO_SEMICOLON);
+        if (this.init)
+            this.init.render(code, options, NO_SEMICOLON);
+        if (this.test)
+            this.test.render(code, options, NO_SEMICOLON);
+        if (this.update)
+            this.update.render(code, options, NO_SEMICOLON);
         this.body.render(code, options);
     }
 }
@@ -10905,11 +10090,10 @@
             return true;
         }
         const testValue = this.getTestValue();
-        if (typeof testValue === 'symbol') {
+        if (testValue === UnknownValue) {
             const { brokenFlow } = context;
             if (this.consequent.hasEffects(context))
                 return true;
-            // eslint-disable-next-line unicorn/consistent-destructuring
             const consequentBrokenFlow = context.brokenFlow;
             context.brokenFlow = brokenFlow;
             if (this.alternate === null)
@@ -10917,11 +10101,12 @@
             if (this.alternate.hasEffects(context))
                 return true;
             context.brokenFlow =
-                // eslint-disable-next-line unicorn/consistent-destructuring
                 context.brokenFlow < consequentBrokenFlow ? context.brokenFlow : consequentBrokenFlow;
             return false;
         }
-        return testValue ? this.consequent.hasEffects(context) : !!this.alternate?.hasEffects(context);
+        return testValue
+            ? this.consequent.hasEffects(context)
+            : this.alternate !== null && this.alternate.hasEffects(context);
     }
     include(context, includeChildrenRecursively) {
         this.included = true;
@@ -10930,7 +10115,7 @@
         }
         else {
             const testValue = this.getTestValue();
-            if (typeof testValue === 'symbol') {
+            if (testValue === UnknownValue) {
                 this.includeUnknownTest(context);
             }
             else {
@@ -10940,10 +10125,12 @@
     }
     parseNode(esTreeNode) {
         this.consequentScope = new TrackingScope(this.scope);
-        this.consequent = new (this.context.getNodeConstructor(esTreeNode.consequent.type))(esTreeNode.consequent, this, this.consequentScope);
+        this.consequent = new (this.context.nodeConstructors[esTreeNode.consequent.type] ||
+            this.context.nodeConstructors.UnknownNode)(esTreeNode.consequent, this, this.consequentScope);
         if (esTreeNode.alternate) {
             this.alternateScope = new TrackingScope(this.scope);
-            this.alternate = new (this.context.getNodeConstructor(esTreeNode.alternate.type))(esTreeNode.alternate, this, this.alternateScope);
+            this.alternate = new (this.context.nodeConstructors[esTreeNode.alternate.type] ||
+                this.context.nodeConstructors.UnknownNode)(esTreeNode.alternate, this, this.alternateScope);
         }
         super.parseNode(esTreeNode);
     }
@@ -10960,7 +10147,7 @@
         else {
             code.remove(this.start, this.consequent.start);
         }
-        if (this.consequent.included && (noTreeshake || typeof testValue === 'symbol' || testValue)) {
+        if (this.consequent.included && (noTreeshake || testValue === UnknownValue || testValue)) {
             this.consequent.render(code, options);
         }
         else {
@@ -10968,7 +10155,7 @@
             hoistedDeclarations.push(...this.consequentScope.hoistedDeclarations);
         }
         if (this.alternate) {
-            if (this.alternate.included && (noTreeshake || typeof testValue === 'symbol' || !testValue)) {
+            if (this.alternate.included && (noTreeshake || testValue === UnknownValue || !testValue)) {
                 if (includesIfElse) {
                     if (code.original.charCodeAt(this.alternate.start - 1) === 101) {
                         code.prependLeft(this.alternate.start, ' ');
@@ -10991,7 +10178,6 @@
         }
         this.renderHoistedDeclarations(hoistedDeclarations, code, getPropertyAccess);
     }
-    applyDeoptimizations() { }
     getTestValue() {
         if (this.testValue === unset) {
             return (this.testValue = this.test.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this));
@@ -11003,36 +10189,36 @@
             this.test.include(context, false);
         }
         if (testValue && this.consequent.shouldBeIncluded(context)) {
-            this.consequent.include(context, false, { asSingleStatement: true });
+            this.consequent.includeAsSingleStatement(context, false);
         }
-        if (!testValue && this.alternate?.shouldBeIncluded(context)) {
-            this.alternate.include(context, false, { asSingleStatement: true });
+        if (this.alternate !== null && !testValue && this.alternate.shouldBeIncluded(context)) {
+            this.alternate.includeAsSingleStatement(context, false);
         }
     }
     includeRecursively(includeChildrenRecursively, context) {
         this.test.include(context, includeChildrenRecursively);
         this.consequent.include(context, includeChildrenRecursively);
-        this.alternate?.include(context, includeChildrenRecursively);
+        if (this.alternate !== null) {
+            this.alternate.include(context, includeChildrenRecursively);
+        }
     }
     includeUnknownTest(context) {
         this.test.include(context, false);
         const { brokenFlow } = context;
         let consequentBrokenFlow = BROKEN_FLOW_NONE;
         if (this.consequent.shouldBeIncluded(context)) {
-            this.consequent.include(context, false, { asSingleStatement: true });
-            // eslint-disable-next-line unicorn/consistent-destructuring
+            this.consequent.includeAsSingleStatement(context, false);
             consequentBrokenFlow = context.brokenFlow;
             context.brokenFlow = brokenFlow;
         }
-        if (this.alternate?.shouldBeIncluded(context)) {
-            this.alternate.include(context, false, { asSingleStatement: true });
+        if (this.alternate !== null && this.alternate.shouldBeIncluded(context)) {
+            this.alternate.includeAsSingleStatement(context, false);
             context.brokenFlow =
-                // eslint-disable-next-line unicorn/consistent-destructuring
                 context.brokenFlow < consequentBrokenFlow ? context.brokenFlow : consequentBrokenFlow;
         }
     }
     renderHoistedDeclarations(hoistedDeclarations, code, getPropertyAccess) {
-        const hoistedVariables = [
+        const hoistedVars = [
             ...new Set(hoistedDeclarations.map(identifier => {
                 const variable = identifier.variable;
                 return variable.included ? variable.getName(getPropertyAccess) : '';
@@ -11040,10 +10226,10 @@
         ]
             .filter(Boolean)
             .join(', ');
-        if (hoistedVariables) {
+        if (hoistedVars) {
             const parentType = this.parent.type;
             const needsBraces = parentType !== Program$1 && parentType !== BlockStatement$1;
-            code.prependRight(this.start, `${needsBraces ? '{ ' : ''}var ${hoistedVariables}; `);
+            code.prependRight(this.start, `${needsBraces ? '{ ' : ''}var ${hoistedVars}; `);
             if (needsBraces) {
                 code.appendLeft(this.end, ` }`);
             }
@@ -11064,11 +10250,8 @@
     }
 }
 
-class ImportAttribute extends NodeBase {
-}
-
 class ImportDeclaration extends NodeBase {
-    // Do not bind specifiers or assertions
+    // Do not bind specifiers
     bind() { }
     hasEffects() {
         return false;
@@ -11079,38 +10262,38 @@
     render(code, _options, nodeRenderOptions) {
         code.remove(nodeRenderOptions.start, nodeRenderOptions.end);
     }
-    applyDeoptimizations() { }
 }
 ImportDeclaration.prototype.needsBoundaries = true;
 
 class ImportDefaultSpecifier extends NodeBase {
-    applyDeoptimizations() { }
 }
 
 const INTEROP_DEFAULT_VARIABLE = '_interopDefault';
-const INTEROP_DEFAULT_COMPAT_VARIABLE = '_interopDefaultCompat';
+const INTEROP_DEFAULT_LEGACY_VARIABLE = '_interopDefaultLegacy';
 const INTEROP_NAMESPACE_VARIABLE = '_interopNamespace';
-const INTEROP_NAMESPACE_COMPAT_VARIABLE = '_interopNamespaceCompat';
 const INTEROP_NAMESPACE_DEFAULT_VARIABLE = '_interopNamespaceDefault';
 const INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE = '_interopNamespaceDefaultOnly';
 const MERGE_NAMESPACES_VARIABLE = '_mergeNamespaces';
 const defaultInteropHelpersByInteropType = {
     auto: INTEROP_DEFAULT_VARIABLE,
-    compat: INTEROP_DEFAULT_COMPAT_VARIABLE,
     default: null,
     defaultOnly: null,
-    esModule: null
+    esModule: null,
+    false: null,
+    true: INTEROP_DEFAULT_LEGACY_VARIABLE
 };
 const isDefaultAProperty = (interopType, externalLiveBindings) => interopType === 'esModule' ||
-    (externalLiveBindings && (interopType === 'auto' || interopType === 'compat'));
+    (externalLiveBindings && (interopType === 'auto' || interopType === 'true'));
 const namespaceInteropHelpersByInteropType = {
     auto: INTEROP_NAMESPACE_VARIABLE,
-    compat: INTEROP_NAMESPACE_COMPAT_VARIABLE,
     default: INTEROP_NAMESPACE_DEFAULT_VARIABLE,
     defaultOnly: INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE,
-    esModule: null
+    esModule: null,
+    false: null,
+    true: INTEROP_NAMESPACE_VARIABLE
 };
-const canDefaultBeTakenFromNamespace = (interopType, externalLiveBindings) => interopType !== 'esModule' && isDefaultAProperty(interopType, externalLiveBindings);
+const canDefaultBeTakenFromNamespace = (interopType, externalLiveBindings) => isDefaultAProperty(interopType, externalLiveBindings) &&
+    defaultInteropHelpersByInteropType[interopType] === INTEROP_DEFAULT_VARIABLE;
 const getHelpersBlock = (additionalHelpers, accessedGlobals, indent, snippets, liveBindings, freeze, namespaceToStringTag) => {
     const usedHelpers = new Set(additionalHelpers);
     for (const variable of HELPER_NAMES) {
@@ -11123,14 +10306,14 @@
         : '').join('');
 };
 const HELPER_GENERATORS = {
-    [INTEROP_DEFAULT_COMPAT_VARIABLE](_t, snippets, liveBindings) {
+    [INTEROP_DEFAULT_LEGACY_VARIABLE](_t, snippets, liveBindings) {
         const { _, getDirectReturnFunction, n } = snippets;
         const [left, right] = getDirectReturnFunction(['e'], {
             functionReturn: true,
             lineBreakIndent: null,
-            name: INTEROP_DEFAULT_COMPAT_VARIABLE
+            name: INTEROP_DEFAULT_LEGACY_VARIABLE
         });
-        return (`${left}${getIsCompatNamespace(snippets)}${_}?${_}` +
+        return (`${left}e${_}&&${_}typeof e${_}===${_}'object'${_}&&${_}'default'${_}in e${_}?${_}` +
             `${liveBindings ? getDefaultLiveBinding(snippets) : getDefaultStatic(snippets)}${right}${n}${n}`);
     },
     [INTEROP_DEFAULT_VARIABLE](_t, snippets, liveBindings) {
@@ -11143,32 +10326,19 @@
         return (`${left}e${_}&&${_}e.__esModule${_}?${_}` +
             `${liveBindings ? getDefaultLiveBinding(snippets) : getDefaultStatic(snippets)}${right}${n}${n}`);
     },
-    [INTEROP_NAMESPACE_COMPAT_VARIABLE](t, snippets, liveBindings, freeze, namespaceToStringTag, usedHelpers) {
-        const { _, getDirectReturnFunction, n } = snippets;
-        if (usedHelpers.has(INTEROP_NAMESPACE_DEFAULT_VARIABLE)) {
-            const [left, right] = getDirectReturnFunction(['e'], {
-                functionReturn: true,
-                lineBreakIndent: null,
-                name: INTEROP_NAMESPACE_COMPAT_VARIABLE
-            });
-            return `${left}${getIsCompatNamespace(snippets)}${_}?${_}e${_}:${_}${INTEROP_NAMESPACE_DEFAULT_VARIABLE}(e)${right}${n}${n}`;
-        }
-        return (`function ${INTEROP_NAMESPACE_COMPAT_VARIABLE}(e)${_}{${n}` +
-            `${t}if${_}(${getIsCompatNamespace(snippets)})${_}return e;${n}` +
-            createNamespaceObject(t, t, snippets, liveBindings, freeze, namespaceToStringTag) +
-            `}${n}${n}`);
-    },
-    [INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE](_t, snippets, _liveBindings, freeze, namespaceToStringTag) {
-        const { getDirectReturnFunction, getObject, n } = snippets;
+    [INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE](_t, { _, getDirectReturnFunction, getObject, n }, _liveBindings, freeze, namespaceToStringTag) {
         const [left, right] = getDirectReturnFunction(['e'], {
             functionReturn: true,
             lineBreakIndent: null,
             name: INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE
         });
-        return `${left}${getFrozen(freeze, getWithToStringTag(namespaceToStringTag, getObject([
+        return `${left}${getFrozen(getObject([
             ['__proto__', 'null'],
+            ...(namespaceToStringTag
+                ? [[null, `[Symbol.toStringTag]:${_}'Module'`]]
+                : []),
             ['default', 'e']
-        ], { lineBreakIndent: null }), snippets))}${right}${n}${n}`;
+        ], { lineBreakIndent: null }), freeze)}${right}${n}${n}`;
     },
     [INTEROP_NAMESPACE_DEFAULT_VARIABLE](t, snippets, liveBindings, freeze, namespaceToStringTag) {
         const { _, n } = snippets;
@@ -11191,122 +10361,85 @@
             createNamespaceObject(t, t, snippets, liveBindings, freeze, namespaceToStringTag) +
             `}${n}${n}`);
     },
-    [MERGE_NAMESPACES_VARIABLE](t, snippets, liveBindings, freeze, namespaceToStringTag) {
-        const { _, cnst, n } = snippets;
-        const useForEach = cnst === 'var' && liveBindings;
+    [MERGE_NAMESPACES_VARIABLE](t, snippets, liveBindings, freeze) {
+        const { _, n } = snippets;
         return (`function ${MERGE_NAMESPACES_VARIABLE}(n, m)${_}{${n}` +
             `${t}${loopOverNamespaces(`{${n}` +
                 `${t}${t}${t}if${_}(k${_}!==${_}'default'${_}&&${_}!(k in n))${_}{${n}` +
-                (liveBindings
-                    ? useForEach
-                        ? copyOwnPropertyLiveBinding
-                        : copyPropertyLiveBinding
-                    : copyPropertyStatic)(t, t + t + t + t, snippets) +
+                (liveBindings ? copyPropertyLiveBinding : copyPropertyStatic)(t, t + t + t + t, snippets) +
                 `${t}${t}${t}}${n}` +
-                `${t}${t}}`, useForEach, t, snippets)}${n}` +
-            `${t}return ${getFrozen(freeze, getWithToStringTag(namespaceToStringTag, 'n', snippets))};${n}` +
+                `${t}${t}}`, !liveBindings, t, snippets)}${n}` +
+            `${t}return ${getFrozen('n', freeze)};${n}` +
             `}${n}${n}`);
     }
 };
 const getDefaultLiveBinding = ({ _, getObject }) => `e${_}:${_}${getObject([['default', 'e']], { lineBreakIndent: null })}`;
 const getDefaultStatic = ({ _, getPropertyAccess }) => `e${getPropertyAccess('default')}${_}:${_}e`;
-const getIsCompatNamespace = ({ _ }) => `e${_}&&${_}typeof e${_}===${_}'object'${_}&&${_}'default'${_}in e`;
-const createNamespaceObject = (t, index, snippets, liveBindings, freeze, namespaceToStringTag) => {
-    const { _, cnst, getObject, getPropertyAccess, n, s } = snippets;
+const createNamespaceObject = (t, i, snippets, liveBindings, freeze, namespaceToStringTag) => {
+    const { _, cnst, getPropertyAccess, n, s } = snippets;
     const copyProperty = `{${n}` +
-        (liveBindings ? copyNonDefaultOwnPropertyLiveBinding : copyPropertyStatic)(t, index + t + t, snippets) +
-        `${index}${t}}`;
-    return (`${index}${cnst} n${_}=${_}Object.create(null${namespaceToStringTag
-        ? `,${_}{${_}[Symbol.toStringTag]:${_}${getToStringTagValue(getObject)}${_}}`
-        : ''});${n}` +
-        `${index}if${_}(e)${_}{${n}` +
-        `${index}${t}${loopOverKeys(copyProperty, !liveBindings, snippets)}${n}` +
-        `${index}}${n}` +
-        `${index}n${getPropertyAccess('default')}${_}=${_}e;${n}` +
-        `${index}return ${getFrozen(freeze, 'n')}${s}${n}`);
+        (liveBindings ? copyNonDefaultPropertyLiveBinding : copyPropertyStatic)(t, i + t + t, snippets) +
+        `${i}${t}}`;
+    return (`${i}${cnst} n${_}=${_}${namespaceToStringTag
+        ? `{__proto__:${_}null,${_}[Symbol.toStringTag]:${_}'Module'}`
+        : 'Object.create(null)'};${n}` +
+        `${i}if${_}(e)${_}{${n}` +
+        `${i}${t}${loopOverKeys(copyProperty, !liveBindings, snippets)}${n}` +
+        `${i}}${n}` +
+        `${i}n${getPropertyAccess('default')}${_}=${_}e;${n}` +
+        `${i}return ${getFrozen('n', freeze)}${s}${n}`);
 };
-const loopOverKeys = (body, allowVariableLoopVariable, { _, cnst, getFunctionIntro, s }) => cnst !== 'var' || allowVariableLoopVariable
+const loopOverKeys = (body, allowVarLoopVariable, { _, cnst, getFunctionIntro, s }) => cnst !== 'var' || allowVarLoopVariable
     ? `for${_}(${cnst} k in e)${_}${body}`
     : `Object.keys(e).forEach(${getFunctionIntro(['k'], {
         isAsync: false,
         name: null
     })}${body})${s}`;
-const loopOverNamespaces = (body, useForEach, t, { _, cnst, getDirectReturnFunction, getFunctionIntro, n }) => {
-    if (useForEach) {
-        const [left, right] = getDirectReturnFunction(['e'], {
-            functionReturn: false,
-            lineBreakIndent: { base: t, t },
+const loopOverNamespaces = (body, allowVarLoopVariable, t, { _, cnst, getDirectReturnFunction, getFunctionIntro, n }) => {
+    if (cnst !== 'var' || allowVarLoopVariable) {
+        return (`for${_}(var i${_}=${_}0;${_}i${_}<${_}m.length;${_}i++)${_}{${n}` +
+            `${t}${t}${cnst} e${_}=${_}m[i];${n}` +
+            `${t}${t}for${_}(${cnst} k in e)${_}${body}${n}${t}}`);
+    }
+    const [left, right] = getDirectReturnFunction(['e'], {
+        functionReturn: false,
+        lineBreakIndent: { base: t, t },
+        name: null
+    });
+    return (`m.forEach(${left}` +
+        `Object.keys(e).forEach(${getFunctionIntro(['k'], {
+            isAsync: false,
             name: null
-        });
-        return (`m.forEach(${left}` +
-            `e${_}&&${_}typeof e${_}!==${_}'string'${_}&&${_}!Array.isArray(e)${_}&&${_}Object.keys(e).forEach(${getFunctionIntro(['k'], {
-                isAsync: false,
-                name: null
-            })}${body})${right});`);
-    }
-    return (`for${_}(var i${_}=${_}0;${_}i${_}<${_}m.length;${_}i++)${_}{${n}` +
-        `${t}${t}${cnst} e${_}=${_}m[i];${n}` +
-        `${t}${t}if${_}(typeof e${_}!==${_}'string'${_}&&${_}!Array.isArray(e))${_}{${_}for${_}(${cnst} k in e)${_}${body}${_}}${n}${t}}`);
+        })}${body})${right});`);
 };
-const copyNonDefaultOwnPropertyLiveBinding = (t, index, snippets) => {
+const copyNonDefaultPropertyLiveBinding = (t, i, snippets) => {
     const { _, n } = snippets;
-    return (`${index}if${_}(k${_}!==${_}'default')${_}{${n}` +
-        copyOwnPropertyLiveBinding(t, index + t, snippets) +
-        `${index}}${n}`);
+    return (`${i}if${_}(k${_}!==${_}'default')${_}{${n}` +
+        copyPropertyLiveBinding(t, i + t, snippets) +
+        `${i}}${n}`);
 };
-const copyOwnPropertyLiveBinding = (t, index, { _, cnst, getDirectReturnFunction, n }) => {
+const copyPropertyLiveBinding = (t, i, { _, cnst, getDirectReturnFunction, n }) => {
     const [left, right] = getDirectReturnFunction([], {
         functionReturn: true,
         lineBreakIndent: null,
         name: null
     });
-    return (`${index}${cnst} d${_}=${_}Object.getOwnPropertyDescriptor(e,${_}k);${n}` +
-        `${index}Object.defineProperty(n,${_}k,${_}d.get${_}?${_}d${_}:${_}{${n}` +
-        `${index}${t}enumerable:${_}true,${n}` +
-        `${index}${t}get:${_}${left}e[k]${right}${n}` +
-        `${index}});${n}`);
+    return (`${i}${cnst} d${_}=${_}Object.getOwnPropertyDescriptor(e,${_}k);${n}` +
+        `${i}Object.defineProperty(n,${_}k,${_}d.get${_}?${_}d${_}:${_}{${n}` +
+        `${i}${t}enumerable:${_}true,${n}` +
+        `${i}${t}get:${_}${left}e[k]${right}${n}` +
+        `${i}});${n}`);
 };
-const copyPropertyLiveBinding = (t, index, { _, cnst, getDirectReturnFunction, n }) => {
-    const [left, right] = getDirectReturnFunction([], {
-        functionReturn: true,
-        lineBreakIndent: null,
-        name: null
-    });
-    return (`${index}${cnst} d${_}=${_}Object.getOwnPropertyDescriptor(e,${_}k);${n}` +
-        `${index}if${_}(d)${_}{${n}` +
-        `${index}${t}Object.defineProperty(n,${_}k,${_}d.get${_}?${_}d${_}:${_}{${n}` +
-        `${index}${t}${t}enumerable:${_}true,${n}` +
-        `${index}${t}${t}get:${_}${left}e[k]${right}${n}` +
-        `${index}${t}});${n}` +
-        `${index}}${n}`);
-};
-const copyPropertyStatic = (_t, index, { _, n }) => `${index}n[k]${_}=${_}e[k];${n}`;
-const getFrozen = (freeze, fragment) => freeze ? `Object.freeze(${fragment})` : fragment;
-const getWithToStringTag = (namespaceToStringTag, fragment, { _, getObject }) => namespaceToStringTag
-    ? `Object.defineProperty(${fragment},${_}Symbol.toStringTag,${_}${getToStringTagValue(getObject)})`
-    : fragment;
+const copyPropertyStatic = (_t, i, { _, n }) => `${i}n[k]${_}=${_}e[k];${n}`;
+const getFrozen = (fragment, freeze) => freeze ? `Object.freeze(${fragment})` : fragment;
 const HELPER_NAMES = Object.keys(HELPER_GENERATORS);
-function getToStringTagValue(getObject) {
-    return getObject([['value', "'Module'"]], {
-        lineBreakIndent: null
-    });
-}
 
-// TODO once ImportExpression follows official ESTree specs with "null" as
-//  default, keys.ts should be updated
 class ImportExpression extends NodeBase {
     constructor() {
         super(...arguments);
         this.inlineNamespace = null;
-        this.assertions = null;
         this.mechanism = null;
-        this.namespaceExportName = undefined;
         this.resolution = null;
-        this.resolutionString = null;
-    }
-    // Do not bind assertions
-    bind() {
-        this.source.bind();
     }
     hasEffects() {
         return true;
@@ -11322,57 +10455,37 @@
     initialise() {
         this.context.addDynamicImport(this);
     }
-    parseNode(esTreeNode) {
-        // Keep the source AST to be used by renderDynamicImport
-        super.parseNode(esTreeNode, ['source']);
-    }
     render(code, options) {
-        const { snippets: { _, getDirectReturnFunction, getObject, getPropertyAccess } } = options;
         if (this.inlineNamespace) {
+            const { snippets: { getDirectReturnFunction, getPropertyAccess } } = options;
             const [left, right] = getDirectReturnFunction([], {
                 functionReturn: true,
                 lineBreakIndent: null,
                 name: null
             });
-            code.overwrite(this.start, this.end, `Promise.resolve().then(${left}${this.inlineNamespace.getName(getPropertyAccess)}${right})`);
+            code.overwrite(this.start, this.end, `Promise.resolve().then(${left}${this.inlineNamespace.getName(getPropertyAccess)}${right})`, { contentOnly: true });
             return;
         }
         if (this.mechanism) {
-            code.overwrite(this.start, findFirstOccurrenceOutsideComment(code.original, '(', this.start + 6) + 1, this.mechanism.left);
-            code.overwrite(this.end - 1, this.end, this.mechanism.right);
+            code.overwrite(this.start, findFirstOccurrenceOutsideComment(code.original, '(', this.start + 6) + 1, this.mechanism.left, { contentOnly: true });
+            code.overwrite(this.end - 1, this.end, this.mechanism.right, { contentOnly: true });
         }
-        if (this.resolutionString) {
-            code.overwrite(this.source.start, this.source.end, this.resolutionString);
-            if (this.namespaceExportName) {
-                const [left, right] = getDirectReturnFunction(['n'], {
-                    functionReturn: true,
-                    lineBreakIndent: null,
-                    name: null
-                });
-                code.prependLeft(this.end, `.then(${left}n.${this.namespaceExportName}${right})`);
-            }
-        }
-        else {
-            this.source.render(code, options);
-        }
-        if (this.assertions !== true) {
-            if (this.arguments) {
-                code.overwrite(this.source.end, this.end - 1, '', { contentOnly: true });
-            }
-            if (this.assertions) {
-                code.appendLeft(this.end - 1, `,${_}${getObject([['assert', this.assertions]], {
-                    lineBreakIndent: null
-                })}`);
-            }
+        this.source.render(code, options);
+    }
+    renderFinalResolution(code, resolution, namespaceExportName, { getDirectReturnFunction }) {
+        code.overwrite(this.source.start, this.source.end, resolution);
+        if (namespaceExportName) {
+            const [left, right] = getDirectReturnFunction(['n'], {
+                functionReturn: true,
+                lineBreakIndent: null,
+                name: null
+            });
+            code.prependLeft(this.end, `.then(${left}n.${namespaceExportName}${right})`);
         }
     }
-    setExternalResolution(exportMode, resolution, options, snippets, pluginDriver, accessedGlobalsByScope, resolutionString, namespaceExportName, assertions) {
+    setExternalResolution(exportMode, resolution, options, snippets, pluginDriver, accessedGlobalsByScope) {
         const { format } = options;
-        this.inlineNamespace = null;
         this.resolution = resolution;
-        this.resolutionString = resolutionString;
-        this.namespaceExportName = namespaceExportName;
-        this.assertions = assertions;
         const accessedGlobals = [...(accessedImportGlobals[format] || [])];
         let helper;
         ({ helper, mechanism: this.mechanism } = this.getDynamicImportMechanismAndHelper(resolution, exportMode, options, snippets, pluginDriver));
@@ -11386,8 +10499,7 @@
     setInternalResolution(inlineNamespace) {
         this.inlineNamespace = inlineNamespace;
     }
-    applyDeoptimizations() { }
-    getDynamicImportMechanismAndHelper(resolution, exportMode, { compact, dynamicImportFunction, dynamicImportInCjs, format, generatedCode: { arrowFunctions }, interop }, { _, getDirectReturnFunction, getDirectReturnIifeLeft }, pluginDriver) {
+    getDynamicImportMechanismAndHelper(resolution, exportMode, { compact, dynamicImportFunction, format, generatedCode: { arrowFunctions }, interop }, { _, getDirectReturnFunction, getDirectReturnIifeLeft }, pluginDriver) {
         const mechanism = pluginDriver.hookFirstSync('renderDynamicImport', [
             {
                 customResolution: typeof this.resolution === 'string' ? this.resolution : null,
@@ -11402,10 +10514,6 @@
         const hasDynamicTarget = !this.resolution || typeof this.resolution === 'string';
         switch (format) {
             case 'cjs': {
-                if (dynamicImportInCjs &&
-                    (!resolution || typeof resolution === 'string' || resolution instanceof ExternalModule)) {
-                    return { helper: null, mechanism: null };
-                }
                 const helper = getInteropHelper(resolution, exportMode, interop);
                 let left = `require(`;
                 let right = `)`;
@@ -11463,7 +10571,7 @@
                     mechanism: { left, right }
                 };
             }
-            case 'system': {
+            case 'system':
                 return {
                     helper: null,
                     mechanism: {
@@ -11471,8 +10579,7 @@
                         right: ')'
                     }
                 };
-            }
-            case 'es': {
+            case 'es':
                 if (dynamicImportFunction) {
                     return {
                         helper: null,
@@ -11482,14 +10589,13 @@
                         }
                     };
                 }
-            }
         }
         return { helper: null, mechanism: null };
     }
 }
 function getInteropHelper(resolution, exportMode, interop) {
     return exportMode === 'external'
-        ? namespaceInteropHelpersByInteropType[interop(resolution instanceof ExternalModule ? resolution.id : null)]
+        ? namespaceInteropHelpersByInteropType[String(interop(resolution instanceof ExternalModule ? resolution.id : null))]
         : exportMode === 'default'
             ? INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE
             : null;
@@ -11501,11 +10607,9 @@
 };
 
 class ImportNamespaceSpecifier extends NodeBase {
-    applyDeoptimizations() { }
 }
 
 class ImportSpecifier extends NodeBase {
-    applyDeoptimizations() { }
 }
 
 class LabeledStatement extends NodeBase {
@@ -11551,51 +10655,45 @@
         this.usedBranch = null;
     }
     deoptimizeCache() {
-        if (this.usedBranch) {
+        if (this.usedBranch !== null) {
             const unusedBranch = this.usedBranch === this.left ? this.right : this.left;
             this.usedBranch = null;
             unusedBranch.deoptimizePath(UNKNOWN_PATH);
             for (const expression of this.expressionsToBeDeoptimized) {
                 expression.deoptimizeCache();
             }
-            // Request another pass because we need to ensure "include" runs again if
-            // it is rendered
-            this.context.requestTreeshakingPass();
         }
     }
     deoptimizePath(path) {
         const usedBranch = this.getUsedBranch();
-        if (usedBranch) {
-            usedBranch.deoptimizePath(path);
-        }
-        else {
+        if (usedBranch === null) {
             this.left.deoptimizePath(path);
             this.right.deoptimizePath(path);
         }
+        else {
+            usedBranch.deoptimizePath(path);
+        }
     }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        this.left.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
-        this.right.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
+        this.left.deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker);
+        this.right.deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker);
     }
     getLiteralValueAtPath(path, recursionTracker, origin) {
         const usedBranch = this.getUsedBranch();
-        if (!usedBranch)
+        if (usedBranch === null)
             return UnknownValue;
         this.expressionsToBeDeoptimized.push(origin);
         return usedBranch.getLiteralValueAtPath(path, recursionTracker, origin);
     }
-    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
+    getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin) {
         const usedBranch = this.getUsedBranch();
-        if (!usedBranch)
-            return [
-                new MultiExpression([
-                    this.left.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin)[0],
-                    this.right.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin)[0]
-                ]),
-                false
-            ];
+        if (usedBranch === null)
+            return new MultiExpression([
+                this.left.getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin),
+                this.right.getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin)
+            ]);
         this.expressionsToBeDeoptimized.push(origin);
-        return usedBranch.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
+        return usedBranch.getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin);
     }
     hasEffects(context) {
         if (this.left.hasEffects(context)) {
@@ -11606,20 +10704,36 @@
         }
         return false;
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
+    hasEffectsWhenAccessedAtPath(path, context) {
+        const usedBranch = this.getUsedBranch();
+        if (usedBranch === null) {
+            return (this.left.hasEffectsWhenAccessedAtPath(path, context) ||
+                this.right.hasEffectsWhenAccessedAtPath(path, context));
+        }
+        return usedBranch.hasEffectsWhenAccessedAtPath(path, context);
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
         const usedBranch = this.getUsedBranch();
-        if (!usedBranch) {
-            return (this.left.hasEffectsOnInteractionAtPath(path, interaction, context) ||
-                this.right.hasEffectsOnInteractionAtPath(path, interaction, context));
+        if (usedBranch === null) {
+            return (this.left.hasEffectsWhenAssignedAtPath(path, context) ||
+                this.right.hasEffectsWhenAssignedAtPath(path, context));
         }
-        return usedBranch.hasEffectsOnInteractionAtPath(path, interaction, context);
+        return usedBranch.hasEffectsWhenAssignedAtPath(path, context);
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        const usedBranch = this.getUsedBranch();
+        if (usedBranch === null) {
+            return (this.left.hasEffectsWhenCalledAtPath(path, callOptions, context) ||
+                this.right.hasEffectsWhenCalledAtPath(path, callOptions, context));
+        }
+        return usedBranch.hasEffectsWhenCalledAtPath(path, callOptions, context);
     }
     include(context, includeChildrenRecursively) {
         this.included = true;
         const usedBranch = this.getUsedBranch();
         if (includeChildrenRecursively ||
             (usedBranch === this.right && this.left.shouldBeIncluded(context)) ||
-            !usedBranch) {
+            usedBranch === null) {
             this.left.include(context, includeChildrenRecursively);
             this.right.include(context, includeChildrenRecursively);
         }
@@ -11660,7 +10774,7 @@
         if (!this.isBranchResolutionAnalysed) {
             this.isBranchResolutionAnalysed = true;
             const leftValue = this.left.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
-            if (typeof leftValue === 'symbol') {
+            if (leftValue === UnknownValue) {
                 return null;
             }
             else {
@@ -11676,78 +10790,122 @@
     }
 }
 
+const ASSET_PREFIX = 'ROLLUP_ASSET_URL_';
+const CHUNK_PREFIX = 'ROLLUP_CHUNK_URL_';
 const FILE_PREFIX = 'ROLLUP_FILE_URL_';
-const IMPORT = 'import';
 class MetaProperty extends NodeBase {
-    constructor() {
-        super(...arguments);
-        this.metaProperty = null;
-        this.preliminaryChunkId = null;
-        this.referenceId = null;
+    addAccessedGlobals(format, accessedGlobalsByScope) {
+        const metaProperty = this.metaProperty;
+        const accessedGlobals = (metaProperty &&
+            (metaProperty.startsWith(FILE_PREFIX) ||
+                metaProperty.startsWith(ASSET_PREFIX) ||
+                metaProperty.startsWith(CHUNK_PREFIX))
+            ? accessedFileUrlGlobals
+            : accessedMetaUrlGlobals)[format];
+        if (accessedGlobals.length > 0) {
+            this.scope.addAccessedGlobals(accessedGlobals, accessedGlobalsByScope);
+        }
     }
     getReferencedFileName(outputPluginDriver) {
-        const { meta: { name }, metaProperty } = this;
-        if (name === IMPORT && metaProperty?.startsWith(FILE_PREFIX)) {
-            return outputPluginDriver.getFileName(metaProperty.slice(FILE_PREFIX.length));
+        const metaProperty = this.metaProperty;
+        if (metaProperty && metaProperty.startsWith(FILE_PREFIX)) {
+            return outputPluginDriver.getFileName(metaProperty.substr(FILE_PREFIX.length));
         }
         return null;
     }
     hasEffects() {
         return false;
     }
-    hasEffectsOnInteractionAtPath(path, { type }) {
-        return path.length > 1 || type !== INTERACTION_ACCESSED;
+    hasEffectsWhenAccessedAtPath(path) {
+        return path.length > 1;
     }
     include() {
         if (!this.included) {
             this.included = true;
-            if (this.meta.name === IMPORT) {
+            if (this.meta.name === 'import') {
                 this.context.addImportMeta(this);
                 const parent = this.parent;
-                const metaProperty = (this.metaProperty =
+                this.metaProperty =
                     parent instanceof MemberExpression && typeof parent.propertyKey === 'string'
                         ? parent.propertyKey
-                        : null);
-                if (metaProperty?.startsWith(FILE_PREFIX)) {
-                    this.referenceId = metaProperty.slice(FILE_PREFIX.length);
-                }
+                        : null;
             }
         }
     }
-    render(code, { format, pluginDriver, snippets }) {
-        const { context: { module: { id: moduleId } }, meta: { name }, metaProperty, parent, preliminaryChunkId, referenceId, start, end } = this;
-        if (name !== IMPORT)
-            return;
-        const chunkId = preliminaryChunkId;
-        if (referenceId) {
-            const fileName = pluginDriver.getFileName(referenceId);
-            const relativePath = normalize(node_path.relative(node_path.dirname(chunkId), fileName));
-            const replacement = pluginDriver.hookFirstSync('resolveFileUrl', [
-                { chunkId, fileName, format, moduleId, referenceId, relativePath }
-            ]) || relativeUrlMechanisms[format](relativePath);
+    renderFinalMechanism(code, chunkId, format, snippets, outputPluginDriver) {
+        var _a;
+        const parent = this.parent;
+        const metaProperty = this.metaProperty;
+        if (metaProperty &&
+            (metaProperty.startsWith(FILE_PREFIX) ||
+                metaProperty.startsWith(ASSET_PREFIX) ||
+                metaProperty.startsWith(CHUNK_PREFIX))) {
+            let referenceId = null;
+            let assetReferenceId = null;
+            let chunkReferenceId = null;
+            let fileName;
+            if (metaProperty.startsWith(FILE_PREFIX)) {
+                referenceId = metaProperty.substr(FILE_PREFIX.length);
+                fileName = outputPluginDriver.getFileName(referenceId);
+            }
+            else if (metaProperty.startsWith(ASSET_PREFIX)) {
+                warnDeprecation(`Using the "${ASSET_PREFIX}" prefix to reference files is deprecated. Use the "${FILE_PREFIX}" prefix instead.`, true, this.context.options);
+                assetReferenceId = metaProperty.substr(ASSET_PREFIX.length);
+                fileName = outputPluginDriver.getFileName(assetReferenceId);
+            }
+            else {
+                warnDeprecation(`Using the "${CHUNK_PREFIX}" prefix to reference files is deprecated. Use the "${FILE_PREFIX}" prefix instead.`, true, this.context.options);
+                chunkReferenceId = metaProperty.substr(CHUNK_PREFIX.length);
+                fileName = outputPluginDriver.getFileName(chunkReferenceId);
+            }
+            const relativePath = normalize(path$2.relative(path$2.dirname(chunkId), fileName));
+            let replacement;
+            if (assetReferenceId !== null) {
+                replacement = outputPluginDriver.hookFirstSync('resolveAssetUrl', [
+                    {
+                        assetFileName: fileName,
+                        chunkId,
+                        format,
+                        moduleId: this.context.module.id,
+                        relativeAssetPath: relativePath
+                    }
+                ]);
+            }
+            if (!replacement) {
+                replacement =
+                    outputPluginDriver.hookFirstSync('resolveFileUrl', [
+                        {
+                            assetReferenceId,
+                            chunkId,
+                            chunkReferenceId,
+                            fileName,
+                            format,
+                            moduleId: this.context.module.id,
+                            referenceId: referenceId || assetReferenceId || chunkReferenceId,
+                            relativePath
+                        }
+                    ]) || relativeUrlMechanisms[format](relativePath);
+            }
             code.overwrite(parent.start, parent.end, replacement, { contentOnly: true });
             return;
         }
-        const replacement = pluginDriver.hookFirstSync('resolveImportMeta', [
+        const replacement = outputPluginDriver.hookFirstSync('resolveImportMeta', [
             metaProperty,
-            { chunkId, format, moduleId }
-        ]) || importMetaMechanisms[format]?.(metaProperty, { chunkId, snippets });
+            {
+                chunkId,
+                format,
+                moduleId: this.context.module.id
+            }
+        ]) || ((_a = importMetaMechanisms[format]) === null || _a === void 0 ? void 0 : _a.call(importMetaMechanisms, metaProperty, { chunkId, snippets }));
         if (typeof replacement === 'string') {
             if (parent instanceof MemberExpression) {
                 code.overwrite(parent.start, parent.end, replacement, { contentOnly: true });
             }
             else {
-                code.overwrite(start, end, replacement, { contentOnly: true });
+                code.overwrite(this.start, this.end, replacement, { contentOnly: true });
             }
         }
     }
-    setResolution(format, accessedGlobalsByScope, preliminaryChunkId) {
-        this.preliminaryChunkId = preliminaryChunkId;
-        const accessedGlobals = (this.metaProperty?.startsWith(FILE_PREFIX) ? accessedFileUrlGlobals : accessedMetaUrlGlobals)[format];
-        if (accessedGlobals.length > 0) {
-            this.scope.addAccessedGlobals(accessedGlobals, accessedGlobalsByScope);
-        }
-    }
 }
 const accessedMetaUrlGlobals = {
     amd: ['document', 'module', 'URL'],
@@ -11766,16 +10924,16 @@
     umd: ['document', 'require', 'URL']
 };
 const getResolveUrl = (path, URL = 'URL') => `new ${URL}(${path}).href`;
-const getRelativeUrlFromDocument = (relativePath, umd = false) => getResolveUrl(`'${escapeId(relativePath)}', ${umd ? `typeof document === 'undefined' ? location.href : ` : ''}document.currentScript && document.currentScript.src || document.baseURI`);
-const getGenericImportMetaMechanism = (getUrl) => (property, { chunkId }) => {
+const getRelativeUrlFromDocument = (relativePath, umd = false) => getResolveUrl(`'${relativePath}', ${umd ? `typeof document === 'undefined' ? location.href : ` : ''}document.currentScript && document.currentScript.src || document.baseURI`);
+const getGenericImportMetaMechanism = (getUrl) => (prop, { chunkId }) => {
     const urlMechanism = getUrl(chunkId);
-    return property === null
+    return prop === null
         ? `({ url: ${urlMechanism} })`
-        : property === 'url'
+        : prop === 'url'
             ? urlMechanism
             : 'undefined';
 };
-const getUrlFromDocument = (chunkId, umd = false) => `${umd ? `typeof document === 'undefined' ? location.href : ` : ''}(document.currentScript && document.currentScript.src || new URL('${escapeId(chunkId)}', document.baseURI).href)`;
+const getUrlFromDocument = (chunkId, umd = false) => `${umd ? `typeof document === 'undefined' ? location.href : ` : ''}(document.currentScript && document.currentScript.src || new URL('${chunkId}', document.baseURI).href)`;
 const relativeUrlMechanisms = {
     amd: relativePath => {
         if (relativePath[0] !== '.')
@@ -11792,56 +10950,38 @@
     amd: getGenericImportMetaMechanism(() => getResolveUrl(`module.uri, document.baseURI`)),
     cjs: getGenericImportMetaMechanism(chunkId => `(typeof document === 'undefined' ? ${getResolveUrl(`'file:' + __filename`, `(require('u' + 'rl').URL)`)} : ${getUrlFromDocument(chunkId)})`),
     iife: getGenericImportMetaMechanism(chunkId => getUrlFromDocument(chunkId)),
-    system: (property, { snippets: { getPropertyAccess } }) => property === null ? `module.meta` : `module.meta${getPropertyAccess(property)}`,
+    system: (prop, { snippets: { getPropertyAccess } }) => prop === null ? `module.meta` : `module.meta${getPropertyAccess(prop)}`,
     umd: getGenericImportMetaMechanism(chunkId => `(typeof document === 'undefined' && typeof location === 'undefined' ? ${getResolveUrl(`'file:' + __filename`, `(require('u' + 'rl').URL)`)} : ${getUrlFromDocument(chunkId, true)})`)
 };
 
 class NewExpression extends NodeBase {
-    hasEffects(context) {
-        try {
-            for (const argument of this.arguments) {
-                if (argument.hasEffects(context))
-                    return true;
-            }
-            if (this.context.options.treeshake.annotations &&
-                this.annotations) {
-                return false;
-            }
-            return (this.callee.hasEffects(context) ||
-                this.callee.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.interaction, context));
-        }
-        finally {
-            if (!this.deoptimized)
-                this.applyDeoptimizations();
-        }
-    }
-    hasEffectsOnInteractionAtPath(path, { type }) {
-        return path.length > 0 || type !== INTERACTION_ACCESSED;
+    constructor() {
+        super(...arguments);
+        this.deoptimized = false;
     }
-    include(context, includeChildrenRecursively) {
+    hasEffects(context) {
         if (!this.deoptimized)
             this.applyDeoptimizations();
-        if (includeChildrenRecursively) {
-            super.include(context, includeChildrenRecursively);
-        }
-        else {
-            this.included = true;
-            this.callee.include(context, false);
+        for (const argument of this.arguments) {
+            if (argument.hasEffects(context))
+                return true;
         }
-        this.callee.includeCallArguments(context, this.arguments);
+        if (this.context.options.treeshake.annotations &&
+            this.annotations)
+            return false;
+        return (this.callee.hasEffects(context) ||
+            this.callee.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.callOptions, context));
+    }
+    hasEffectsWhenAccessedAtPath(path) {
+        return path.length > 0;
     }
     initialise() {
-        this.interaction = {
+        this.callOptions = {
             args: this.arguments,
-            thisArg: null,
-            type: INTERACTION_CALLED,
+            thisParam: null,
             withNew: true
         };
     }
-    render(code, options) {
-        this.callee.render(code, options);
-        renderCallArguments(code, options, this);
-    }
     applyDeoptimizations() {
         this.deoptimized = true;
         for (const argument of this.arguments) {
@@ -11863,17 +11003,23 @@
     deoptimizePath(path) {
         this.getObjectEntity().deoptimizePath(path);
     }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        this.getObjectEntity().deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
+        this.getObjectEntity().deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker);
     }
     getLiteralValueAtPath(path, recursionTracker, origin) {
         return this.getObjectEntity().getLiteralValueAtPath(path, recursionTracker, origin);
     }
-    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
-        return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
+    getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin) {
+        return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin);
+    }
+    hasEffectsWhenAccessedAtPath(path, context) {
+        return this.getObjectEntity().hasEffectsWhenAccessedAtPath(path, context);
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        return this.getObjectEntity().hasEffectsWhenAssignedAtPath(path, context);
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        return this.getObjectEntity().hasEffectsOnInteractionAtPath(path, interaction, context);
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        return this.getObjectEntity().hasEffectsWhenCalledAtPath(path, callOptions, context);
     }
     render(code, options, { renderedSurroundingElement } = BLANK) {
         super.render(code, options);
@@ -11883,7 +11029,6 @@
             code.prependLeft(this.end, ')');
         }
     }
-    applyDeoptimizations() { }
     getObjectEntity() {
         if (this.objectEntity !== null) {
             return this.objectEntity;
@@ -11898,7 +11043,7 @@
             let key;
             if (property.computed) {
                 const keyValue = property.key.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
-                if (typeof keyValue === 'symbol') {
+                if (keyValue === UnknownValue) {
                     properties.push({ key: UnknownKey, kind: property.kind, property });
                     continue;
                 }
@@ -11928,49 +11073,10 @@
 class PrivateIdentifier extends NodeBase {
 }
 
-class Program extends NodeBase {
-    constructor() {
-        super(...arguments);
-        this.hasCachedEffect = false;
-    }
-    hasEffects(context) {
-        // We are caching here to later more efficiently identify side-effect-free modules
-        if (this.hasCachedEffect)
-            return true;
-        for (const node of this.body) {
-            if (node.hasEffects(context)) {
-                return (this.hasCachedEffect = true);
-            }
-        }
-        return false;
-    }
-    include(context, includeChildrenRecursively) {
-        this.included = true;
-        for (const node of this.body) {
-            if (includeChildrenRecursively || node.shouldBeIncluded(context)) {
-                node.include(context, includeChildrenRecursively);
-            }
-        }
-    }
-    render(code, options) {
-        let start = this.start;
-        if (code.original.startsWith('#!')) {
-            start = Math.min(code.original.indexOf('\n') + 1, this.end);
-            code.remove(0, start);
-        }
-        if (this.body.length > 0) {
-            renderStatementList(this.body, code, start, this.end, options);
-        }
-        else {
-            super.render(code, options);
-        }
-    }
-    applyDeoptimizations() { }
-}
-
 class Property extends MethodBase {
     constructor() {
         super(...arguments);
+        this.deoptimized = false;
         this.declarationInit = null;
     }
     declare(kind, init) {
@@ -12006,40 +11112,51 @@
 
 class PropertyDefinition extends NodeBase {
     deoptimizePath(path) {
-        this.value?.deoptimizePath(path);
+        var _a;
+        (_a = this.value) === null || _a === void 0 ? void 0 : _a.deoptimizePath(path);
     }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        this.value?.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
+        var _a;
+        (_a = this.value) === null || _a === void 0 ? void 0 : _a.deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker);
     }
     getLiteralValueAtPath(path, recursionTracker, origin) {
         return this.value
             ? this.value.getLiteralValueAtPath(path, recursionTracker, origin)
             : UnknownValue;
     }
-    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
+    getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin) {
         return this.value
-            ? this.value.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin)
-            : UNKNOWN_RETURN_EXPRESSION;
+            ? this.value.getReturnExpressionWhenCalledAtPath(path, callOptions, recursionTracker, origin)
+            : UNKNOWN_EXPRESSION;
     }
     hasEffects(context) {
-        return this.key.hasEffects(context) || (this.static && !!this.value?.hasEffects(context));
+        return (this.key.hasEffects(context) ||
+            (this.static && this.value !== null && this.value.hasEffects(context)));
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        return !this.value || this.value.hasEffectsOnInteractionAtPath(path, interaction, context);
+    hasEffectsWhenAccessedAtPath(path, context) {
+        return !this.value || this.value.hasEffectsWhenAccessedAtPath(path, context);
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        return !this.value || this.value.hasEffectsWhenAssignedAtPath(path, context);
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        return !this.value || this.value.hasEffectsWhenCalledAtPath(path, callOptions, context);
     }
-    applyDeoptimizations() { }
 }
 
 class ReturnStatement extends NodeBase {
     hasEffects(context) {
-        if (!context.ignore.returnYield || this.argument?.hasEffects(context))
+        if (!context.ignore.returnYield ||
+            (this.argument !== null && this.argument.hasEffects(context)))
             return true;
         context.brokenFlow = BROKEN_FLOW_ERROR_RETURN_LABEL;
         return false;
     }
     include(context, includeChildrenRecursively) {
         this.included = true;
-        this.argument?.include(context, includeChildrenRecursively);
+        if (this.argument) {
+            this.argument.include(context, includeChildrenRecursively);
+        }
         context.brokenFlow = BROKEN_FLOW_ERROR_RETURN_LABEL;
     }
     initialise() {
@@ -12059,8 +11176,8 @@
     deoptimizePath(path) {
         this.expressions[this.expressions.length - 1].deoptimizePath(path);
     }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        this.expressions[this.expressions.length - 1].deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
+        this.expressions[this.expressions.length - 1].deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker);
     }
     getLiteralValueAtPath(path, recursionTracker, origin) {
         return this.expressions[this.expressions.length - 1].getLiteralValueAtPath(path, recursionTracker, origin);
@@ -12072,8 +11189,15 @@
         }
         return false;
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        return this.expressions[this.expressions.length - 1].hasEffectsOnInteractionAtPath(path, interaction, context);
+    hasEffectsWhenAccessedAtPath(path, context) {
+        return (path.length > 0 &&
+            this.expressions[this.expressions.length - 1].hasEffectsWhenAccessedAtPath(path, context));
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        return this.expressions[this.expressions.length - 1].hasEffectsWhenAssignedAtPath(path, context);
+    }
+    hasEffectsWhenCalledAtPath(path, callOptions, context) {
+        return this.expressions[this.expressions.length - 1].hasEffectsWhenCalledAtPath(path, callOptions, context);
     }
     include(context, includeChildrenRecursively) {
         this.included = true;
@@ -12117,34 +11241,6 @@
     }
 }
 
-class StaticBlock extends NodeBase {
-    createScope(parentScope) {
-        this.scope = new BlockScope(parentScope);
-    }
-    hasEffects(context) {
-        for (const node of this.body) {
-            if (node.hasEffects(context))
-                return true;
-        }
-        return false;
-    }
-    include(context, includeChildrenRecursively) {
-        this.included = true;
-        for (const node of this.body) {
-            if (includeChildrenRecursively || node.shouldBeIncluded(context))
-                node.include(context, includeChildrenRecursively);
-        }
-    }
-    render(code, options) {
-        if (this.body.length > 0) {
-            renderStatementList(this.body, code, this.start + 1, this.end - 1, options);
-        }
-        else {
-            super.render(code, options);
-        }
-    }
-}
-
 class Super extends NodeBase {
     bind() {
         this.variable = this.scope.findVariable('this');
@@ -12152,9 +11248,6 @@
     deoptimizePath(path) {
         this.variable.deoptimizePath(path);
     }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        this.variable.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
-    }
     include() {
         if (!this.included) {
             this.included = true;
@@ -12165,7 +11258,7 @@
 
 class SwitchCase extends NodeBase {
     hasEffects(context) {
-        if (this.test?.hasEffects(context))
+        if (this.test && this.test.hasEffects(context))
             return true;
         for (const node of this.consequent) {
             if (context.brokenFlow)
@@ -12177,14 +11270,15 @@
     }
     include(context, includeChildrenRecursively) {
         this.included = true;
-        this.test?.include(context, includeChildrenRecursively);
+        if (this.test)
+            this.test.include(context, includeChildrenRecursively);
         for (const node of this.consequent) {
             if (includeChildrenRecursively || node.shouldBeIncluded(context))
                 node.include(context, includeChildrenRecursively);
         }
     }
     render(code, options, nodeRenderOptions) {
-        if (this.consequent.length > 0) {
+        if (this.consequent.length) {
             this.test && this.test.render(code, options);
             const testEnd = this.test
                 ? this.test.end
@@ -12206,21 +11300,19 @@
     hasEffects(context) {
         if (this.discriminant.hasEffects(context))
             return true;
-        const { brokenFlow, ignore } = context;
-        const { breaks } = ignore;
+        const { brokenFlow, ignore: { breaks } } = context;
         let minBrokenFlow = Infinity;
-        ignore.breaks = true;
+        context.ignore.breaks = true;
         for (const switchCase of this.cases) {
             if (switchCase.hasEffects(context))
                 return true;
-            // eslint-disable-next-line unicorn/consistent-destructuring
             minBrokenFlow = context.brokenFlow < minBrokenFlow ? context.brokenFlow : minBrokenFlow;
             context.brokenFlow = brokenFlow;
         }
         if (this.defaultCase !== null && !(minBrokenFlow === BROKEN_FLOW_BREAK_CONTINUE)) {
             context.brokenFlow = minBrokenFlow;
         }
-        ignore.breaks = breaks;
+        context.ignore.breaks = breaks;
         return false;
     }
     include(context, includeChildrenRecursively) {
@@ -12242,7 +11334,6 @@
             }
             if (isCaseIncluded) {
                 switchCase.include(context, includeChildrenRecursively);
-                // eslint-disable-next-line unicorn/consistent-destructuring
                 minBrokenFlow = minBrokenFlow < context.brokenFlow ? minBrokenFlow : context.brokenFlow;
                 context.brokenFlow = brokenFlow;
             }
@@ -12273,53 +11364,28 @@
     }
 }
 
-class TaggedTemplateExpression extends CallExpressionBase {
+class TaggedTemplateExpression extends NodeBase {
     bind() {
         super.bind();
         if (this.tag.type === Identifier$1) {
             const name = this.tag.name;
             const variable = this.scope.findVariable(name);
             if (variable.isNamespace) {
-                this.context.warn(errorCannotCallNamespace(name), this.start);
+                this.context.warn({
+                    code: 'CANNOT_CALL_NAMESPACE',
+                    message: `Cannot call a namespace ('${name}')`
+                }, this.start);
             }
         }
     }
     hasEffects(context) {
-        try {
-            for (const argument of this.quasi.expressions) {
-                if (argument.hasEffects(context))
-                    return true;
-            }
-            return (this.tag.hasEffects(context) ||
-                this.tag.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.interaction, context));
-        }
-        finally {
-            if (!this.deoptimized)
-                this.applyDeoptimizations();
-        }
-    }
-    include(context, includeChildrenRecursively) {
-        if (!this.deoptimized)
-            this.applyDeoptimizations();
-        if (includeChildrenRecursively) {
-            super.include(context, includeChildrenRecursively);
-        }
-        else {
-            this.included = true;
-            this.tag.include(context, includeChildrenRecursively);
-            this.quasi.include(context, includeChildrenRecursively);
-        }
-        this.tag.includeCallArguments(context, this.interaction.args);
-        const [returnExpression] = this.getReturnExpression();
-        if (!returnExpression.included) {
-            returnExpression.include(context, false);
-        }
+        return (super.hasEffects(context) ||
+            this.tag.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.callOptions, context));
     }
     initialise() {
-        this.interaction = {
-            args: [UNKNOWN_EXPRESSION, ...this.quasi.expressions],
-            thisArg: this.tag instanceof MemberExpression && !this.tag.variable ? this.tag.object : null,
-            type: INTERACTION_CALLED,
+        this.callOptions = {
+            args: NO_ARGS,
+            thisParam: null,
             withNew: false
         };
     }
@@ -12327,24 +11393,6 @@
         this.tag.render(code, options, { isCalleeOfRenderedParent: true });
         this.quasi.render(code, options);
     }
-    applyDeoptimizations() {
-        this.deoptimized = true;
-        if (this.interaction.thisArg) {
-            this.tag.deoptimizeThisOnInteractionAtPath(this.interaction, EMPTY_PATH, SHARED_RECURSION_TRACKER);
-        }
-        for (const argument of this.quasi.expressions) {
-            // This will make sure all properties of parameters behave as "unknown"
-            argument.deoptimizePath(UNKNOWN_PATH);
-        }
-        this.context.requestTreeshakingPass();
-    }
-    getReturnExpression(recursionTracker = SHARED_RECURSION_TRACKER) {
-        if (this.returnExpression === null) {
-            this.returnExpression = UNKNOWN_RETURN_EXPRESSION;
-            return (this.returnExpression = this.tag.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, this.interaction, recursionTracker, this));
-        }
-        return this.returnExpression;
-    }
 }
 
 class TemplateElement extends NodeBase {
@@ -12363,35 +11411,6 @@
     render() { }
 }
 
-class TemplateLiteral extends NodeBase {
-    deoptimizeThisOnInteractionAtPath() { }
-    getLiteralValueAtPath(path) {
-        if (path.length > 0 || this.quasis.length !== 1) {
-            return UnknownValue;
-        }
-        return this.quasis[0].value.cooked;
-    }
-    getReturnExpressionWhenCalledAtPath(path) {
-        if (path.length !== 1) {
-            return UNKNOWN_RETURN_EXPRESSION;
-        }
-        return getMemberReturnExpressionWhenCalled(literalStringMembers, path[0]);
-    }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        if (interaction.type === INTERACTION_ACCESSED) {
-            return path.length > 1;
-        }
-        if (interaction.type === INTERACTION_CALLED && path.length === 1) {
-            return hasMemberEffectWhenCalled(literalStringMembers, path[0], interaction, context);
-        }
-        return true;
-    }
-    render(code, options) {
-        code.indentExclusionRanges.push([this.start, this.end]);
-        super.render(code, options);
-    }
-}
-
 class UndefinedVariable extends Variable {
     constructor() {
         super('undefined');
@@ -12422,21 +11441,17 @@
             this.name = identifier.name;
         }
     }
-    forbidName(name) {
-        const original = this.getOriginalVariable();
-        if (original === this) {
-            super.forbidName(name);
-        }
-        else {
-            original.forbidName(name);
-        }
-    }
     getAssignedVariableName() {
         return (this.originalId && this.originalId.name) || null;
     }
     getBaseVariableName() {
         const original = this.getOriginalVariable();
-        return original === this ? super.getBaseVariableName() : original.getBaseVariableName();
+        if (original === this) {
+            return super.getBaseVariableName();
+        }
+        else {
+            return original.getBaseVariableName();
+        }
     }
     getDirectOriginalVariable() {
         return this.originalId &&
@@ -12451,9 +11466,12 @@
     }
     getName(getPropertyAccess) {
         const original = this.getOriginalVariable();
-        return original === this
-            ? super.getName(getPropertyAccess)
-            : original.getName(getPropertyAccess);
+        if (original === this) {
+            return super.getName(getPropertyAccess);
+        }
+        else {
+            return original.getName(getPropertyAccess);
+        }
     }
     getOriginalVariable() {
         if (this.originalVariable)
@@ -12511,15 +11529,16 @@
     deoptimizePath(path) {
         this.variable.deoptimizePath(path);
     }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
+    deoptimizeThisOnEventAtPath(event, path, thisParameter, recursionTracker) {
+        this.variable.deoptimizeThisOnEventAtPath(event, path, 
         // We rewrite the parameter so that a ThisVariable can detect self-mutations
-        this.variable.deoptimizeThisOnInteractionAtPath(interaction.thisArg === this ? { ...interaction, thisArg: this.variable } : interaction, path, recursionTracker);
+        thisParameter === this ? this.variable : thisParameter, recursionTracker);
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        if (path.length === 0) {
-            return interaction.type !== INTERACTION_ACCESSED;
-        }
-        return this.variable.hasEffectsOnInteractionAtPath(path, interaction, context);
+    hasEffectsWhenAccessedAtPath(path, context) {
+        return path.length > 0 && this.variable.hasEffectsWhenAccessedAtPath(path, context);
+    }
+    hasEffectsWhenAssignedAtPath(path, context) {
+        return this.variable.hasEffectsWhenAssignedAtPath(path, context);
     }
     include() {
         if (!this.included) {
@@ -12531,7 +11550,11 @@
         this.alias =
             this.scope.findLexicalBoundary() instanceof ModuleScope ? this.context.moduleContext : null;
         if (this.alias === 'undefined') {
-            this.context.warn(errorThisIsUndefined(), this.start);
+            this.context.warn({
+                code: 'THIS_IS_UNDEFINED',
+                message: `The 'this' keyword is equivalent to 'undefined' at the top level of an ES module, and has been rewritten`,
+                url: `https://rollupjs.org/guide/en/#error-this-is-undefined`
+            }, this.start);
         }
     }
     render(code) {
@@ -12570,31 +11593,34 @@
     hasEffects(context) {
         return ((this.context.options.treeshake.tryCatchDeoptimization
             ? this.block.body.length > 0
-            : this.block.hasEffects(context)) || !!this.finalizer?.hasEffects(context));
+            : this.block.hasEffects(context)) ||
+            (this.finalizer !== null && this.finalizer.hasEffects(context)));
     }
     include(context, includeChildrenRecursively) {
-        const tryCatchDeoptimization = this.context.options.treeshake
-            ?.tryCatchDeoptimization;
-        const { brokenFlow, includedLabels } = context;
+        var _a;
+        const tryCatchDeoptimization = (_a = this.context.options.treeshake) === null || _a === void 0 ? void 0 : _a.tryCatchDeoptimization;
+        const { brokenFlow } = context;
         if (!this.directlyIncluded || !tryCatchDeoptimization) {
             this.included = true;
             this.directlyIncluded = true;
             this.block.include(context, tryCatchDeoptimization ? INCLUDE_PARAMETERS : includeChildrenRecursively);
-            if (includedLabels.size > 0) {
-                this.includedLabelsAfterBlock = [...includedLabels];
+            if (context.includedLabels.size > 0) {
+                this.includedLabelsAfterBlock = [...context.includedLabels];
             }
             context.brokenFlow = brokenFlow;
         }
         else if (this.includedLabelsAfterBlock) {
             for (const label of this.includedLabelsAfterBlock) {
-                includedLabels.add(label);
+                context.includedLabels.add(label);
             }
         }
         if (this.handler !== null) {
             this.handler.include(context, includeChildrenRecursively);
             context.brokenFlow = brokenFlow;
         }
-        this.finalizer?.include(context, includeChildrenRecursively);
+        if (this.finalizer !== null) {
+            this.finalizer.include(context, includeChildrenRecursively);
+        }
     }
 }
 
@@ -12608,11 +11634,15 @@
     '~': value => ~value
 };
 class UnaryExpression extends NodeBase {
+    constructor() {
+        super(...arguments);
+        this.deoptimized = false;
+    }
     getLiteralValueAtPath(path, recursionTracker, origin) {
         if (path.length > 0)
             return UnknownValue;
         const argumentValue = this.argument.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);
-        if (typeof argumentValue === 'symbol')
+        if (argumentValue === UnknownValue)
             return UnknownValue;
         return unaryOperators[this.operator](argumentValue);
     }
@@ -12623,10 +11653,13 @@
             return false;
         return (this.argument.hasEffects(context) ||
             (this.operator === 'delete' &&
-                this.argument.hasEffectsOnInteractionAtPath(EMPTY_PATH, NODE_INTERACTION_UNKNOWN_ASSIGNMENT, context)));
+                this.argument.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context)));
     }
-    hasEffectsOnInteractionAtPath(path, { type }) {
-        return type !== INTERACTION_ACCESSED || path.length > (this.operator === 'void' ? 0 : 1);
+    hasEffectsWhenAccessedAtPath(path) {
+        if (this.operator === 'void') {
+            return path.length > 0;
+        }
+        return path.length > 1;
     }
     applyDeoptimizations() {
         this.deoptimized = true;
@@ -12647,22 +11680,18 @@
 }
 
 class UpdateExpression extends NodeBase {
-    hasEffects(context) {
-        if (!this.deoptimized)
-            this.applyDeoptimizations();
-        return this.argument.hasEffectsAsAssignmentTarget(context, true);
-    }
-    hasEffectsOnInteractionAtPath(path, { type }) {
-        return path.length > 1 || type !== INTERACTION_ACCESSED;
+    constructor() {
+        super(...arguments);
+        this.deoptimized = false;
     }
-    include(context, includeChildrenRecursively) {
+    hasEffects(context) {
         if (!this.deoptimized)
             this.applyDeoptimizations();
-        this.included = true;
-        this.argument.includeAsAssignmentTarget(context, includeChildrenRecursively, true);
+        return (this.argument.hasEffects(context) ||
+            this.argument.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context));
     }
-    initialise() {
-        this.argument.setAssignedValue(UNKNOWN_EXPRESSION);
+    hasEffectsWhenAccessedAtPath(path) {
+        return path.length > 1;
     }
     render(code, options) {
         const { exportNamesByVariable, format, snippets: { _ } } = options;
@@ -12697,186 +11726,6 @@
     }
 }
 
-function isReassignedExportsMember(variable, exportNamesByVariable) {
-    return (variable.renderBaseName !== null && exportNamesByVariable.has(variable) && variable.isReassigned);
-}
-
-function areAllDeclarationsIncludedAndNotExported(declarations, exportNamesByVariable) {
-    for (const declarator of declarations) {
-        if (!declarator.id.included)
-            return false;
-        if (declarator.id.type === Identifier$1) {
-            if (exportNamesByVariable.has(declarator.id.variable))
-                return false;
-        }
-        else {
-            const exportedVariables = [];
-            declarator.id.addExportedVariables(exportedVariables, exportNamesByVariable);
-            if (exportedVariables.length > 0)
-                return false;
-        }
-    }
-    return true;
-}
-class VariableDeclaration extends NodeBase {
-    deoptimizePath() {
-        for (const declarator of this.declarations) {
-            declarator.deoptimizePath(EMPTY_PATH);
-        }
-    }
-    hasEffectsOnInteractionAtPath() {
-        return false;
-    }
-    include(context, includeChildrenRecursively, { asSingleStatement } = BLANK) {
-        this.included = true;
-        for (const declarator of this.declarations) {
-            if (includeChildrenRecursively || declarator.shouldBeIncluded(context))
-                declarator.include(context, includeChildrenRecursively);
-            const { id, init } = declarator;
-            if (asSingleStatement) {
-                id.include(context, includeChildrenRecursively);
-            }
-            if (init &&
-                id.included &&
-                !init.included &&
-                (id instanceof ObjectPattern || id instanceof ArrayPattern)) {
-                init.include(context, includeChildrenRecursively);
-            }
-        }
-    }
-    initialise() {
-        for (const declarator of this.declarations) {
-            declarator.declareDeclarator(this.kind);
-        }
-    }
-    render(code, options, nodeRenderOptions = BLANK) {
-        if (areAllDeclarationsIncludedAndNotExported(this.declarations, options.exportNamesByVariable)) {
-            for (const declarator of this.declarations) {
-                declarator.render(code, options);
-            }
-            if (!nodeRenderOptions.isNoStatement &&
-                code.original.charCodeAt(this.end - 1) !== 59 /*";"*/) {
-                code.appendLeft(this.end, ';');
-            }
-        }
-        else {
-            this.renderReplacedDeclarations(code, options);
-        }
-    }
-    applyDeoptimizations() { }
-    renderDeclarationEnd(code, separatorString, lastSeparatorPos, actualContentEnd, renderedContentEnd, systemPatternExports, options) {
-        if (code.original.charCodeAt(this.end - 1) === 59 /*";"*/) {
-            code.remove(this.end - 1, this.end);
-        }
-        separatorString += ';';
-        if (lastSeparatorPos === null) {
-            code.appendLeft(renderedContentEnd, separatorString);
-        }
-        else {
-            if (code.original.charCodeAt(actualContentEnd - 1) === 10 /*"\n"*/ &&
-                (code.original.charCodeAt(this.end) === 10 /*"\n"*/ ||
-                    code.original.charCodeAt(this.end) === 13) /*"\r"*/) {
-                actualContentEnd--;
-                if (code.original.charCodeAt(actualContentEnd) === 13 /*"\r"*/) {
-                    actualContentEnd--;
-                }
-            }
-            if (actualContentEnd === lastSeparatorPos + 1) {
-                code.overwrite(lastSeparatorPos, renderedContentEnd, separatorString);
-            }
-            else {
-                code.overwrite(lastSeparatorPos, lastSeparatorPos + 1, separatorString);
-                code.remove(actualContentEnd, renderedContentEnd);
-            }
-        }
-        if (systemPatternExports.length > 0) {
-            code.appendLeft(renderedContentEnd, ` ${getSystemExportStatement(systemPatternExports, options)};`);
-        }
-    }
-    renderReplacedDeclarations(code, options) {
-        const separatedNodes = getCommaSeparatedNodesWithBoundaries(this.declarations, code, this.start + this.kind.length, this.end - (code.original.charCodeAt(this.end - 1) === 59 /*";"*/ ? 1 : 0));
-        let actualContentEnd, renderedContentEnd;
-        renderedContentEnd = findNonWhiteSpace(code.original, this.start + this.kind.length);
-        let lastSeparatorPos = renderedContentEnd - 1;
-        code.remove(this.start, lastSeparatorPos);
-        let isInDeclaration = false;
-        let hasRenderedContent = false;
-        let separatorString = '', leadingString, nextSeparatorString;
-        const aggregatedSystemExports = [];
-        const singleSystemExport = gatherSystemExportsAndGetSingleExport(separatedNodes, options, aggregatedSystemExports);
-        for (const { node, start, separator, contentEnd, end } of separatedNodes) {
-            if (!node.included) {
-                code.remove(start, end);
-                continue;
-            }
-            node.render(code, options);
-            leadingString = '';
-            nextSeparatorString = '';
-            if (!node.id.included ||
-                (node.id instanceof Identifier &&
-                    isReassignedExportsMember(node.id.variable, options.exportNamesByVariable))) {
-                if (hasRenderedContent) {
-                    separatorString += ';';
-                }
-                isInDeclaration = false;
-            }
-            else {
-                if (singleSystemExport && singleSystemExport === node.id.variable) {
-                    const operatorPos = findFirstOccurrenceOutsideComment(code.original, '=', node.id.end);
-                    renderSystemExportExpression(singleSystemExport, findNonWhiteSpace(code.original, operatorPos + 1), separator === null ? contentEnd : separator, code, options);
-                }
-                if (isInDeclaration) {
-                    separatorString += ',';
-                }
-                else {
-                    if (hasRenderedContent) {
-                        separatorString += ';';
-                    }
-                    leadingString += `${this.kind} `;
-                    isInDeclaration = true;
-                }
-            }
-            if (renderedContentEnd === lastSeparatorPos + 1) {
-                code.overwrite(lastSeparatorPos, renderedContentEnd, separatorString + leadingString);
-            }
-            else {
-                code.overwrite(lastSeparatorPos, lastSeparatorPos + 1, separatorString);
-                code.appendLeft(renderedContentEnd, leadingString);
-            }
-            actualContentEnd = contentEnd;
-            renderedContentEnd = end;
-            hasRenderedContent = true;
-            lastSeparatorPos = separator;
-            separatorString = nextSeparatorString;
-        }
-        this.renderDeclarationEnd(code, separatorString, lastSeparatorPos, actualContentEnd, renderedContentEnd, aggregatedSystemExports, options);
-    }
-}
-function gatherSystemExportsAndGetSingleExport(separatedNodes, options, aggregatedSystemExports) {
-    let singleSystemExport = null;
-    if (options.format === 'system') {
-        for (const { node } of separatedNodes) {
-            if (node.id instanceof Identifier &&
-                node.init &&
-                aggregatedSystemExports.length === 0 &&
-                options.exportNamesByVariable.get(node.id.variable)?.length === 1) {
-                singleSystemExport = node.id.variable;
-                aggregatedSystemExports.push(singleSystemExport);
-            }
-            else {
-                node.id.addExportedVariables(aggregatedSystemExports, options.exportNamesByVariable);
-            }
-        }
-        if (aggregatedSystemExports.length > 1) {
-            singleSystemExport = null;
-        }
-        else if (singleSystemExport) {
-            aggregatedSystemExports.length = 0;
-        }
-    }
-    return singleSystemExport;
-}
-
 class VariableDeclarator extends NodeBase {
     declareDeclarator(kind) {
         this.id.declare(kind, this.init || UNDEFINED_EXPRESSION);
@@ -12885,58 +11734,36 @@
         this.id.deoptimizePath(path);
     }
     hasEffects(context) {
-        if (!this.deoptimized)
-            this.applyDeoptimizations();
-        const initEffect = this.init?.hasEffects(context);
+        const initEffect = this.init !== null && this.init.hasEffects(context);
         this.id.markDeclarationReached();
         return initEffect || this.id.hasEffects(context);
     }
     include(context, includeChildrenRecursively) {
-        const { deoptimized, id, init } = this;
-        if (!deoptimized)
-            this.applyDeoptimizations();
         this.included = true;
-        init?.include(context, includeChildrenRecursively);
-        id.markDeclarationReached();
-        if (includeChildrenRecursively || id.shouldBeIncluded(context)) {
-            id.include(context, includeChildrenRecursively);
+        if (this.init) {
+            this.init.include(context, includeChildrenRecursively);
+        }
+        this.id.markDeclarationReached();
+        if (includeChildrenRecursively || this.id.shouldBeIncluded(context)) {
+            this.id.include(context, includeChildrenRecursively);
         }
     }
     render(code, options) {
-        const { exportNamesByVariable, snippets: { _, getPropertyAccess } } = options;
-        const { end, id, init, start } = this;
-        const renderId = id.included;
+        const { exportNamesByVariable, snippets: { _ } } = options;
+        const renderId = this.id.included;
         if (renderId) {
-            id.render(code, options);
+            this.id.render(code, options);
         }
         else {
-            const operatorPos = findFirstOccurrenceOutsideComment(code.original, '=', id.end);
-            code.remove(start, findNonWhiteSpace(code.original, operatorPos + 1));
+            const operatorPos = findFirstOccurrenceOutsideComment(code.original, '=', this.id.end);
+            code.remove(this.start, findNonWhiteSpace(code.original, operatorPos + 1));
         }
-        if (init) {
-            if (id instanceof Identifier && init instanceof ClassExpression && !init.id) {
-                const renderedVariable = id.variable.getName(getPropertyAccess);
-                if (renderedVariable !== id.name) {
-                    code.appendLeft(init.start + 5, ` ${id.name}`);
-                }
-            }
-            init.render(code, options, renderId ? BLANK : { renderedSurroundingElement: ExpressionStatement$1 });
+        if (this.init) {
+            this.init.render(code, options, renderId ? BLANK : { renderedSurroundingElement: ExpressionStatement$1 });
         }
-        else if (id instanceof Identifier &&
-            isReassignedExportsMember(id.variable, exportNamesByVariable)) {
-            code.appendLeft(end, `${_}=${_}void 0`);
-        }
-    }
-    applyDeoptimizations() {
-        this.deoptimized = true;
-        const { id, init } = this;
-        if (init && id instanceof Identifier && init instanceof ClassExpression && !init.id) {
-            const { name, variable } = id;
-            for (const accessedVariable of init.scope.accessedOutsideVariables.values()) {
-                if (accessedVariable !== variable) {
-                    accessedVariable.forbidName(name);
-                }
-            }
+        else if (this.id instanceof Identifier &&
+            isReassignedExportsMember(this.id.variable, exportNamesByVariable)) {
+            code.appendLeft(this.end, `${_}=${_}void 0`);
         }
     }
 }
@@ -12945,14 +11772,13 @@
     hasEffects(context) {
         if (this.test.hasEffects(context))
             return true;
-        const { brokenFlow, ignore } = context;
-        const { breaks, continues } = ignore;
-        ignore.breaks = true;
-        ignore.continues = true;
+        const { brokenFlow, ignore: { breaks, continues } } = context;
+        context.ignore.breaks = true;
+        context.ignore.continues = true;
         if (this.body.hasEffects(context))
             return true;
-        ignore.breaks = breaks;
-        ignore.continues = continues;
+        context.ignore.breaks = breaks;
+        context.ignore.continues = continues;
         context.brokenFlow = brokenFlow;
         return false;
     }
@@ -12960,16 +11786,20 @@
         this.included = true;
         this.test.include(context, includeChildrenRecursively);
         const { brokenFlow } = context;
-        this.body.include(context, includeChildrenRecursively, { asSingleStatement: true });
+        this.body.includeAsSingleStatement(context, includeChildrenRecursively);
         context.brokenFlow = brokenFlow;
     }
 }
 
 class YieldExpression extends NodeBase {
+    constructor() {
+        super(...arguments);
+        this.deoptimized = false;
+    }
     hasEffects(context) {
         if (!this.deoptimized)
             this.applyDeoptimizations();
-        return !(context.ignore.returnYield && !this.argument?.hasEffects(context));
+        return (!context.ignore.returnYield || (this.argument !== null && this.argument.hasEffects(context)));
     }
     render(code, options) {
         if (this.argument) {
@@ -12979,6 +11809,14 @@
             }
         }
     }
+    applyDeoptimizations() {
+        this.deoptimized = true;
+        const { argument } = this;
+        if (argument) {
+            argument.deoptimizePath(UNKNOWN_PATH);
+            this.context.requestTreeshakingPass();
+        }
+    }
 }
 
 const nodeConstructors = {
@@ -13013,7 +11851,6 @@
     FunctionExpression,
     Identifier,
     IfStatement,
-    ImportAttribute,
     ImportDeclaration,
     ImportDefaultSpecifier,
     ImportExpression,
@@ -13036,7 +11873,6 @@
     ReturnStatement,
     SequenceExpression,
     SpreadElement,
-    StaticBlock,
     Super,
     SwitchCase,
     SwitchStatement,
@@ -13082,38 +11918,12 @@
         this.references.push(identifier);
         this.name = identifier.name;
     }
-    deoptimizePath(path) {
-        if (path.length > 1) {
-            const key = path[0];
-            if (typeof key === 'string') {
-                this.getMemberVariables()[key]?.deoptimizePath(path.slice(1));
-            }
-        }
-    }
-    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
-        if (path.length > 1 || (path.length === 1 && interaction.type === INTERACTION_CALLED)) {
-            const key = path[0];
-            if (typeof key === 'string') {
-                this.getMemberVariables()[key]?.deoptimizeThisOnInteractionAtPath(interaction, path.slice(1), recursionTracker);
-            }
-            else {
-                interaction.thisArg.deoptimizePath(UNKNOWN_PATH);
-            }
-        }
-    }
-    getLiteralValueAtPath(path) {
-        if (path[0] === SymbolToStringTag) {
-            return 'Module';
-        }
-        return UnknownValue;
-    }
     getMemberVariables() {
         if (this.memberVariables) {
             return this.memberVariables;
         }
         const memberVariables = Object.create(null);
-        const sortedExports = [...this.context.getExports(), ...this.context.getReexports()].sort();
-        for (const name of sortedExports) {
+        for (const name of this.context.getExports().concat(this.context.getReexports())) {
             if (name[0] !== '*' && name !== this.module.info.syntheticNamedExports) {
                 const exportedVariable = this.context.traceExport(name);
                 if (exportedVariable) {
@@ -13123,23 +11933,6 @@
         }
         return (this.memberVariables = memberVariables);
     }
-    hasEffectsOnInteractionAtPath(path, interaction, context) {
-        const { type } = interaction;
-        if (path.length === 0) {
-            // This can only be a call anyway
-            return true;
-        }
-        if (path.length === 1 && type !== INTERACTION_CALLED) {
-            return type === INTERACTION_ASSIGNED;
-        }
-        const key = path[0];
-        if (typeof key !== 'string') {
-            return true;
-        }
-        const memberVariable = this.getMemberVariables()[key];
-        return (!memberVariable ||
-            memberVariable.hasEffectsOnInteractionAtPath(path.slice(1), interaction, context));
-    }
     include() {
         this.included = true;
         this.context.includeAllExports();
@@ -13161,20 +11954,17 @@
             }
             return [name, original.getName(getPropertyAccess)];
         });
+        if (namespaceToStringTag) {
+            members.unshift([null, `[Symbol.toStringTag]:${_}'Module'`]);
+        }
         members.unshift([null, `__proto__:${_}null`]);
         let output = getObject(members, { lineBreakIndent: { base: '', t } });
         if (this.mergedNamespaces.length > 0) {
-            const assignmentArguments = this.mergedNamespaces.map(variable => variable.getName(getPropertyAccess));
-            output = `/*#__PURE__*/${MERGE_NAMESPACES_VARIABLE}(${output},${_}[${assignmentArguments.join(`,${_}`)}])`;
+            const assignmentArgs = this.mergedNamespaces.map(variable => variable.getName(getPropertyAccess));
+            output = `/*#__PURE__*/${MERGE_NAMESPACES_VARIABLE}(${output}, [${assignmentArgs.join(`,${_}`)}])`;
         }
-        else {
-            // The helper to merge namespaces will also take care of freezing and toStringTag
-            if (namespaceToStringTag) {
-                output = `/*#__PURE__*/Object.defineProperty(${output},${_}Symbol.toStringTag,${_}${getToStringTagValue(getObject)})`;
-            }
-            if (freeze) {
-                output = `/*#__PURE__*/Object.freeze(${output})`;
-            }
+        if (freeze) {
+            output = `/*#__PURE__*/Object.freeze(${output})`;
         }
         const name = this.getName(getPropertyAccess);
         output = `${cnst} ${name}${_}=${_}${output};`;
@@ -13240,181 +12030,142 @@
     }
 }
 
-var BuildPhase;
-(function (BuildPhase) {
-    BuildPhase[BuildPhase["LOAD_AND_PARSE"] = 0] = "LOAD_AND_PARSE";
-    BuildPhase[BuildPhase["ANALYSE"] = 1] = "ANALYSE";
-    BuildPhase[BuildPhase["GENERATE"] = 2] = "GENERATE";
-})(BuildPhase || (BuildPhase = {}));
-
 function getId(m) {
     return m.id;
 }
 
 function getOriginalLocation(sourcemapChain, location) {
-    const filteredSourcemapChain = sourcemapChain.filter((sourcemap) => !!sourcemap.mappings);
-    traceSourcemap: while (filteredSourcemapChain.length > 0) {
+    // This cast is guaranteed. If it were a missing Map, it wouldn't have a mappings.
+    const filteredSourcemapChain = sourcemapChain.filter(sourcemap => sourcemap.mappings);
+    while (filteredSourcemapChain.length > 0) {
         const sourcemap = filteredSourcemapChain.pop();
         const line = sourcemap.mappings[location.line - 1];
-        if (line) {
-            const filteredLine = line.filter((segment) => segment.length > 1);
-            const lastSegment = filteredLine[filteredLine.length - 1];
-            for (const segment of filteredLine) {
-                if (segment[0] >= location.column || segment === lastSegment) {
+        let locationFound = false;
+        if (line !== undefined) {
+            for (const segment of line) {
+                if (segment[0] >= location.column) {
+                    if (segment.length === 1)
+                        break;
                     location = {
                         column: segment[3],
-                        line: segment[2] + 1
+                        line: segment[2] + 1,
+                        name: segment.length === 5 ? sourcemap.names[segment[4]] : undefined,
+                        source: sourcemap.sources[segment[1]]
                     };
-                    continue traceSourcemap;
+                    locationFound = true;
+                    break;
                 }
             }
         }
-        throw new Error("Can't resolve original location of error.");
+        if (!locationFound) {
+            throw new Error("Can't resolve original location of error.");
+        }
     }
     return location;
 }
 
-function getAssertionsFromImportExpression(node) {
-    const assertProperty = node.arguments?.[0]?.properties.find((property) => getPropertyKey(property) === 'assert')?.value;
-    if (!assertProperty) {
-        return EMPTY_OBJECT;
-    }
-    const assertFields = assertProperty.properties
-        .map(property => {
-        const key = getPropertyKey(property);
-        if (typeof key === 'string' &&
-            typeof property.value.value === 'string') {
-            return [key, property.value.value];
-        }
-        return null;
-    })
-        .filter((property) => !!property);
-    if (assertFields.length > 0) {
-        return Object.fromEntries(assertFields);
-    }
-    return EMPTY_OBJECT;
-}
-const getPropertyKey = (property) => {
-    const key = property.key;
-    return key && (key.name || key.value);
-};
-function getAssertionsFromImportExportDeclaration(assertions) {
-    return assertions?.length
-        ? Object.fromEntries(assertions.map(assertion => [getPropertyKey(assertion), assertion.value.value]))
-        : EMPTY_OBJECT;
-}
-function doAssertionsDiffer(assertionA, assertionB) {
-    const keysA = Object.keys(assertionA);
-    return (keysA.length !== Object.keys(assertionB).length ||
-        keysA.some(key => assertionA[key] !== assertionB[key]));
-}
-
 const NOOP = () => { };
-let timers = new Map();
+let getStartTime = () => [0, 0];
+let getElapsedTime = () => 0;
+let getMemory = () => 0;
+let timers = {};
+const normalizeHrTime = (time) => time[0] * 1e3 + time[1] / 1e6;
+function setTimeHelpers() {
+    if (typeof process !== 'undefined' && typeof process.hrtime === 'function') {
+        getStartTime = process.hrtime.bind(process);
+        getElapsedTime = previous => normalizeHrTime(process.hrtime(previous));
+    }
+    else if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
+        getStartTime = () => [performance.now(), 0];
+        getElapsedTime = previous => performance.now() - previous[0];
+    }
+    if (typeof process !== 'undefined' && typeof process.memoryUsage === 'function') {
+        getMemory = () => process.memoryUsage().heapUsed;
+    }
+}
 function getPersistedLabel(label, level) {
     switch (level) {
-        case 1: {
+        case 1:
             return `# ${label}`;
-        }
-        case 2: {
+        case 2:
             return `## ${label}`;
-        }
-        case 3: {
+        case 3:
             return label;
-        }
-        default: {
+        default:
             return `${'  '.repeat(level - 4)}- ${label}`;
-        }
     }
 }
 function timeStartImpl(label, level = 3) {
     label = getPersistedLabel(label, level);
-    const startMemory = process$1.memoryUsage().heapUsed;
-    const startTime = node_perf_hooks.performance.now();
-    const timer = timers.get(label);
-    if (timer === undefined) {
-        timers.set(label, {
+    if (!timers.hasOwnProperty(label)) {
+        timers[label] = {
             memory: 0,
-            startMemory,
-            startTime,
+            startMemory: undefined,
+            startTime: undefined,
             time: 0,
             totalMemory: 0
-        });
-    }
-    else {
-        timer.startMemory = startMemory;
-        timer.startTime = startTime;
+        };
     }
+    const currentMemory = getMemory();
+    timers[label].startTime = getStartTime();
+    timers[label].startMemory = currentMemory;
 }
 function timeEndImpl(label, level = 3) {
     label = getPersistedLabel(label, level);
-    const timer = timers.get(label);
-    if (timer !== undefined) {
-        const currentMemory = process$1.memoryUsage().heapUsed;
-        timer.memory += currentMemory - timer.startMemory;
-        timer.time += node_perf_hooks.performance.now() - timer.startTime;
-        timer.totalMemory = Math.max(timer.totalMemory, currentMemory);
+    if (timers.hasOwnProperty(label)) {
+        const currentMemory = getMemory();
+        timers[label].time += getElapsedTime(timers[label].startTime);
+        timers[label].totalMemory = Math.max(timers[label].totalMemory, currentMemory);
+        timers[label].memory += currentMemory - timers[label].startMemory;
     }
 }
 function getTimings() {
     const newTimings = {};
-    for (const [label, { memory, time, totalMemory }] of timers) {
+    for (const [label, { time, memory, totalMemory }] of Object.entries(timers)) {
         newTimings[label] = [time, memory, totalMemory];
     }
     return newTimings;
 }
-let timeStart = NOOP;
-let timeEnd = NOOP;
-const TIMED_PLUGIN_HOOKS = [
-    'augmentChunkHash',
-    'buildEnd',
-    'buildStart',
-    'generateBundle',
-    'load',
-    'moduleParsed',
-    'options',
-    'outputOptions',
-    'renderChunk',
-    'renderDynamicImport',
-    'renderStart',
-    'resolveDynamicImport',
-    'resolveFileUrl',
-    'resolveId',
-    'resolveImportMeta',
-    'shouldTransformCachedModule',
-    'transform',
-    'writeBundle'
-];
+let timeStart = NOOP, timeEnd = NOOP;
+const TIMED_PLUGIN_HOOKS = {
+    load: true,
+    resolveDynamicImport: true,
+    resolveId: true,
+    transform: true
+};
 function getPluginWithTimers(plugin, index) {
-    for (const hook of TIMED_PLUGIN_HOOKS) {
-        if (hook in plugin) {
+    const timedPlugin = {};
+    for (const hook of Object.keys(plugin)) {
+        if (TIMED_PLUGIN_HOOKS[hook] === true) {
             let timerLabel = `plugin ${index}`;
             if (plugin.name) {
                 timerLabel += ` (${plugin.name})`;
             }
             timerLabel += ` - ${hook}`;
-            const handler = function (...parameters) {
+            timedPlugin[hook] = function (...args) {
                 timeStart(timerLabel, 4);
-                const result = hookFunction.apply(this, parameters);
+                let result = plugin[hook].apply(this === timedPlugin ? plugin : this, args);
                 timeEnd(timerLabel, 4);
+                if (result && typeof result.then === 'function') {
+                    timeStart(`${timerLabel} (async)`, 4);
+                    result = result.then((hookResult) => {
+                        timeEnd(`${timerLabel} (async)`, 4);
+                        return hookResult;
+                    });
+                }
                 return result;
             };
-            let hookFunction;
-            if (typeof plugin[hook].handler === 'function') {
-                hookFunction = plugin[hook].handler;
-                plugin[hook].handler = handler;
-            }
-            else {
-                hookFunction = plugin[hook];
-                plugin[hook] = handler;
-            }
+        }
+        else {
+            timedPlugin[hook] = plugin[hook];
         }
     }
-    return plugin;
+    return timedPlugin;
 }
 function initialiseTimers(inputOptions) {
     if (inputOptions.perf) {
-        timers = new Map();
+        timers = {};
+        setTimeHelpers();
         timeStart = timeStartImpl;
         timeEnd = timeEndImpl;
         inputOptions.plugins = inputOptions.plugins.map(getPluginWithTimers);
@@ -13433,7 +12184,7 @@
         for (const dependency of [...module.dependencies, ...module.implicitlyLoadedBefore]) {
             if (!(dependency instanceof ExternalModule) &&
                 !dependency.isExecuted &&
-                (dependency.info.moduleSideEffects || module.implicitlyLoadedBefore.has(dependency)) &&
+                (dependency.info.hasModuleSideEffects || module.implicitlyLoadedBefore.has(dependency)) &&
                 !visitedModules.has(dependency.id)) {
                 dependency.isExecuted = true;
                 visitedModules.add(dependency.id);
@@ -13447,11 +12198,11 @@
     identifier: null,
     localName: MISSING_EXPORT_SHIM_VARIABLE
 };
-function getVariableForExportNameRecursive(target, name, importerForSideEffects, isExportAllSearch, searchedNamesAndModules = new Map()) {
+function getVariableForExportNameRecursive(target, name, importerForSideEffects, isExportAllSearch, searchedNamesAndModules = new Map(), skipExternalNamespaceReexports) {
     const searchedModules = searchedNamesAndModules.get(name);
     if (searchedModules) {
         if (searchedModules.has(target)) {
-            return isExportAllSearch ? [null] : error(errorCircularReexport(name, target.id));
+            return isExportAllSearch ? null : error(errCircularReexport(name, target.id));
         }
         searchedModules.add(target);
     }
@@ -13461,11 +12212,12 @@
     return target.getVariableForExportName(name, {
         importerForSideEffects,
         isExportAllSearch,
-        searchedNamesAndModules
+        searchedNamesAndModules,
+        skipExternalNamespaceReexports
     });
 }
 function getAndExtendSideEffectModules(variable, module) {
-    const sideEffectModules = getOrCreate(module.sideEffectDependenciesByVariable, variable, getNewSet);
+    const sideEffectModules = getOrCreate(module.sideEffectDependenciesByVariable, variable, () => new Set());
     let currentVariable = variable;
     const referencedVariables = new Set([currentVariable]);
     while (true) {
@@ -13491,41 +12243,45 @@
     return sideEffectModules;
 }
 class Module {
-    constructor(graph, id, options, isEntry, moduleSideEffects, syntheticNamedExports, meta, assertions) {
+    constructor(graph, id, options, isEntry, hasModuleSideEffects, syntheticNamedExports, meta) {
         this.graph = graph;
         this.id = id;
         this.options = options;
         this.alternativeReexportModules = new Map();
+        this.ast = null;
         this.chunkFileNames = new Set();
-        this.chunkNames = [];
+        this.chunkName = null;
         this.cycles = new Set();
         this.dependencies = new Set();
         this.dynamicDependencies = new Set();
         this.dynamicImporters = [];
         this.dynamicImports = [];
         this.execIndex = Infinity;
+        this.exportAllSources = new Set();
+        this.exports = Object.create(null);
+        this.exportsAll = Object.create(null);
         this.implicitlyLoadedAfter = new Set();
         this.implicitlyLoadedBefore = new Set();
-        this.importDescriptions = new Map();
+        this.importDescriptions = Object.create(null);
         this.importMetas = [];
         this.importedFromNotTreeshaken = false;
         this.importers = [];
+        this.imports = new Set();
         this.includedDynamicImporters = [];
-        this.includedImports = new Set();
         this.isExecuted = false;
         this.isUserDefinedEntryPoint = false;
         this.needsExportShim = false;
+        this.preserveSignature = this.options.preserveEntrySignatures;
+        this.reexportDescriptions = Object.create(null);
         this.sideEffectDependenciesByVariable = new Map();
-        this.sourcesWithAssertions = new Map();
+        this.sources = new Set();
+        this.userChunkNames = new Set();
+        this.usesTopLevelAwait = false;
         this.allExportNames = null;
-        this.ast = null;
         this.exportAllModules = [];
-        this.exportAllSources = new Set();
         this.exportNamesByVariable = null;
         this.exportShimVariable = new ExportShimVariable(this);
-        this.exports = new Map();
-        this.namespaceReexportsByName = new Map();
-        this.reexportDescriptions = new Map();
+        this.namespaceReexportsByName = Object.create(null);
         this.relevantDependencies = null;
         this.syntheticExports = new Map();
         this.syntheticNamespace = null;
@@ -13533,142 +12289,92 @@
         this.transitiveReexports = null;
         this.excludeFromSourcemap = /\0/.test(id);
         this.context = options.moduleContext(id);
-        this.preserveSignature = this.options.preserveEntrySignatures;
         // eslint-disable-next-line @typescript-eslint/no-this-alias
         const module = this;
-        const { dynamicImports, dynamicImporters, exportAllSources, exports, implicitlyLoadedAfter, implicitlyLoadedBefore, importers, reexportDescriptions, sourcesWithAssertions } = this;
         this.info = {
-            assertions,
             ast: null,
             code: null,
-            get dynamicallyImportedIdResolutions() {
-                return dynamicImports
-                    .map(({ argument }) => typeof argument === 'string' && module.resolvedIds[argument])
-                    .filter(Boolean);
-            },
             get dynamicallyImportedIds() {
-                // We cannot use this.dynamicDependencies because this is needed before
-                // dynamicDependencies are populated
-                return dynamicImports.map(({ id }) => id).filter((id) => id != null);
-            },
-            get dynamicImporters() {
-                return dynamicImporters.sort();
-            },
-            get exportedBindings() {
-                const exportBindings = { '.': [...exports.keys()] };
-                for (const [name, { source }] of reexportDescriptions) {
-                    (exportBindings[source] ?? (exportBindings[source] = [])).push(name);
-                }
-                for (const source of exportAllSources) {
-                    (exportBindings[source] ?? (exportBindings[source] = [])).push('*');
-                }
-                return exportBindings;
-            },
-            get exports() {
-                return [
-                    ...exports.keys(),
-                    ...reexportDescriptions.keys(),
-                    ...[...exportAllSources].map(() => '*')
-                ];
-            },
-            get hasDefaultExport() {
-                // This information is only valid after parsing
-                if (!module.ast) {
-                    return null;
+                const dynamicallyImportedIds = [];
+                for (const { id } of module.dynamicImports) {
+                    if (id) {
+                        dynamicallyImportedIds.push(id);
+                    }
                 }
-                return module.exports.has('default') || reexportDescriptions.has('default');
+                return dynamicallyImportedIds;
             },
-            get hasModuleSideEffects() {
-                warnDeprecation('Accessing ModuleInfo.hasModuleSideEffects from plugins is deprecated. Please use ModuleInfo.moduleSideEffects instead.', URL_THIS_GETMODULEINFO, true, options);
-                return this.moduleSideEffects;
+            get dynamicImporters() {
+                return module.dynamicImporters.sort();
             },
+            hasModuleSideEffects,
             id,
             get implicitlyLoadedAfterOneOf() {
-                // eslint-disable-next-line unicorn/prefer-spread
-                return Array.from(implicitlyLoadedAfter, getId).sort();
+                return Array.from(module.implicitlyLoadedAfter, getId);
             },
             get implicitlyLoadedBefore() {
-                // eslint-disable-next-line unicorn/prefer-spread
-                return Array.from(implicitlyLoadedBefore, getId).sort();
-            },
-            get importedIdResolutions() {
-                // eslint-disable-next-line unicorn/prefer-spread
-                return Array.from(sourcesWithAssertions.keys(), source => module.resolvedIds[source]).filter(Boolean);
+                return Array.from(module.implicitlyLoadedBefore, getId);
             },
             get importedIds() {
-                // We cannot use this.dependencies because this is needed before
-                // dependencies are populated
-                // eslint-disable-next-line unicorn/prefer-spread
-                return Array.from(sourcesWithAssertions.keys(), source => module.resolvedIds[source]?.id).filter(Boolean);
+                return Array.from(module.sources, source => module.resolvedIds[source].id);
             },
             get importers() {
-                return importers.sort();
+                return module.importers.sort();
             },
             isEntry,
             isExternal: false,
-            get isIncluded() {
-                if (graph.phase !== BuildPhase.GENERATE) {
-                    return null;
-                }
-                return module.isIncluded();
-            },
-            meta: { ...meta },
-            moduleSideEffects,
+            meta,
             syntheticNamedExports
         };
-        // Hide the deprecated key so that it only warns when accessed explicitly
-        // eslint-disable-next-line unicorn/consistent-destructuring
-        Object.defineProperty(this.info, 'hasModuleSideEffects', {
-            enumerable: false
-        });
     }
     basename() {
-        const base = node_path.basename(this.id);
-        const extension = node_path.extname(this.id);
-        return makeLegal(extension ? base.slice(0, -extension.length) : base);
+        const base = path$2.basename(this.id);
+        const ext = path$2.extname(this.id);
+        return makeLegal(ext ? base.slice(0, -ext.length) : base);
     }
     bindReferences() {
         this.ast.bind();
     }
-    error(properties, pos) {
-        this.addLocationToLogProps(properties, pos);
-        return error(properties);
+    error(props, pos) {
+        this.addLocationToLogProps(props, pos);
+        return error(props);
     }
     getAllExportNames() {
         if (this.allExportNames) {
             return this.allExportNames;
         }
-        this.allExportNames = new Set([...this.exports.keys(), ...this.reexportDescriptions.keys()]);
+        const allExportNames = (this.allExportNames = new Set());
+        for (const name of Object.keys(this.exports)) {
+            allExportNames.add(name);
+        }
+        for (const name of Object.keys(this.reexportDescriptions)) {
+            allExportNames.add(name);
+        }
         for (const module of this.exportAllModules) {
             if (module instanceof ExternalModule) {
-                this.allExportNames.add(`*${module.id}`);
+                allExportNames.add(`*${module.id}`);
                 continue;
             }
             for (const name of module.getAllExportNames()) {
                 if (name !== 'default')
-                    this.allExportNames.add(name);
+                    allExportNames.add(name);
             }
         }
-        // We do not count the synthetic namespace as a regular export to hide it
-        // from entry signatures and namespace objects
-        if (typeof this.info.syntheticNamedExports === 'string') {
-            this.allExportNames.delete(this.info.syntheticNamedExports);
-        }
-        return this.allExportNames;
+        return allExportNames;
     }
     getDependenciesToBeIncluded() {
         if (this.relevantDependencies)
             return this.relevantDependencies;
-        this.relevantDependencies = new Set();
+        const relevantDependencies = new Set();
         const necessaryDependencies = new Set();
         const alwaysCheckedDependencies = new Set();
-        const dependencyVariables = new Set(this.includedImports);
+        let dependencyVariables = this.imports.keys();
         if (this.info.isEntry ||
             this.includedDynamicImporters.length > 0 ||
             this.namespace.included ||
             this.implicitlyLoadedAfter.size > 0) {
+            dependencyVariables = new Set(dependencyVariables);
             for (const exportName of [...this.getReexports(), ...this.getExports()]) {
-                const [exportedVariable] = this.getVariableForExportName(exportName);
+                const exportedVariable = this.getVariableForExportName(exportName);
                 if (exportedVariable) {
                     dependencyVariables.add(exportedVariable);
                 }
@@ -13689,18 +12395,18 @@
             }
             necessaryDependencies.add(variable.module);
         }
-        if (!this.options.treeshake || this.info.moduleSideEffects === 'no-treeshake') {
+        if (!this.options.treeshake || this.info.hasModuleSideEffects === 'no-treeshake') {
             for (const dependency of this.dependencies) {
-                this.relevantDependencies.add(dependency);
+                relevantDependencies.add(dependency);
             }
         }
         else {
-            this.addRelevantSideEffectDependencies(this.relevantDependencies, necessaryDependencies, alwaysCheckedDependencies);
+            this.addRelevantSideEffectDependencies(relevantDependencies, necessaryDependencies, alwaysCheckedDependencies);
         }
         for (const dependency of necessaryDependencies) {
-            this.relevantDependencies.add(dependency);
+            relevantDependencies.add(dependency);
         }
-        return this.relevantDependencies;
+        return (this.relevantDependencies = relevantDependencies);
     }
     getExportNamesByVariable() {
         if (this.exportNamesByVariable) {
@@ -13708,7 +12414,9 @@
         }
         const exportNamesByVariable = new Map();
         for (const exportName of this.getAllExportNames()) {
-            let [tracedVariable] = this.getVariableForExportName(exportName);
+            if (exportName === this.info.syntheticNamedExports)
+                continue;
+            let tracedVariable = this.getVariableForExportName(exportName);
             if (tracedVariable instanceof ExportDefaultVariable) {
                 tracedVariable = tracedVariable.getOriginalVariable();
             }
@@ -13727,7 +12435,7 @@
         return (this.exportNamesByVariable = exportNamesByVariable);
     }
     getExports() {
-        return [...this.exports.keys()];
+        return Object.keys(this.exports);
     }
     getReexports() {
         if (this.transitiveReexports) {
@@ -13735,7 +12443,10 @@
         }
         // to avoid infinite recursion when using circular `export * from X`
         this.transitiveReexports = [];
-        const reexports = new Set(this.reexportDescriptions.keys());
+        const reexports = new Set();
+        for (const name in this.reexportDescriptions) {
+            reexports.add(name);
+        }
         for (const module of this.exportAllModules) {
             if (module instanceof ExternalModule) {
                 reexports.add(`*${module.id}`);
@@ -13753,8 +12464,8 @@
         // only direct exports are counted here, not reexports at all
         const renderedExports = [];
         const removedExports = [];
-        for (const exportName of this.exports.keys()) {
-            const [variable] = this.getVariableForExportName(exportName);
+        for (const exportName in this.exports) {
+            const variable = this.getVariableForExportName(exportName);
             (variable && variable.included ? renderedExports : removedExports).push(exportName);
         }
         return { removedExports, renderedExports };
@@ -13762,79 +12473,85 @@
     getSyntheticNamespace() {
         if (this.syntheticNamespace === null) {
             this.syntheticNamespace = undefined;
-            [this.syntheticNamespace] = this.getVariableForExportName(typeof this.info.syntheticNamedExports === 'string'
+            this.syntheticNamespace = this.getVariableForExportName(typeof this.info.syntheticNamedExports === 'string'
                 ? this.info.syntheticNamedExports
-                : 'default', { onlyExplicit: true });
+                : 'default');
         }
         if (!this.syntheticNamespace) {
-            return error(errorSyntheticNamedExportsNeedNamespaceExport(this.id, this.info.syntheticNamedExports));
+            return error(errSyntheticNamedExportsNeedNamespaceExport(this.id, this.info.syntheticNamedExports));
         }
         return this.syntheticNamespace;
     }
-    getVariableForExportName(name, { importerForSideEffects, isExportAllSearch, onlyExplicit, searchedNamesAndModules } = EMPTY_OBJECT) {
+    getVariableForExportName(name, { importerForSideEffects, isExportAllSearch, searchedNamesAndModules, skipExternalNamespaceReexports } = EMPTY_OBJECT) {
         if (name[0] === '*') {
             if (name.length === 1) {
                 // export * from './other'
-                return [this.namespace];
+                return this.namespace;
+            }
+            else {
+                // export * from 'external'
+                const module = this.graph.modulesById.get(name.slice(1));
+                return module.getVariableForExportName('*');
             }
-            // export * from 'external'
-            const module = this.graph.modulesById.get(name.slice(1));
-            return module.getVariableForExportName('*');
         }
         // export { foo } from './other'
-        const reexportDeclaration = this.reexportDescriptions.get(name);
+        const reexportDeclaration = this.reexportDescriptions[name];
         if (reexportDeclaration) {
-            const [variable] = getVariableForExportNameRecursive(reexportDeclaration.module, reexportDeclaration.localName, importerForSideEffects, false, searchedNamesAndModules);
+            const variable = getVariableForExportNameRecursive(reexportDeclaration.module, reexportDeclaration.localName, importerForSideEffects, false, searchedNamesAndModules, false);
             if (!variable) {
-                return this.error(errorMissingExport(reexportDeclaration.localName, this.id, reexportDeclaration.module.id), reexportDeclaration.start);
+                return this.error(errMissingExport(reexportDeclaration.localName, this.id, reexportDeclaration.module.id), reexportDeclaration.start);
             }
             if (importerForSideEffects) {
                 setAlternativeExporterIfCyclic(variable, importerForSideEffects, this);
             }
-            return [variable];
+            return variable;
         }
-        const exportDeclaration = this.exports.get(name);
+        const exportDeclaration = this.exports[name];
         if (exportDeclaration) {
             if (exportDeclaration === MISSING_EXPORT_SHIM_DESCRIPTION) {
-                return [this.exportShimVariable];
+                return this.exportShimVariable;
             }
             const name = exportDeclaration.localName;
-            const variable = this.traceVariable(name, {
-                importerForSideEffects,
-                searchedNamesAndModules
-            });
+            const variable = this.traceVariable(name, importerForSideEffects);
             if (importerForSideEffects) {
-                getOrCreate(importerForSideEffects.sideEffectDependenciesByVariable, variable, getNewSet).add(this);
+                getOrCreate(importerForSideEffects.sideEffectDependenciesByVariable, variable, () => new Set()).add(this);
                 setAlternativeExporterIfCyclic(variable, importerForSideEffects, this);
             }
-            return [variable];
-        }
-        if (onlyExplicit) {
-            return [null];
+            return variable;
         }
         if (name !== 'default') {
-            const foundNamespaceReexport = this.namespaceReexportsByName.get(name) ??
-                this.getVariableFromNamespaceReexports(name, importerForSideEffects, searchedNamesAndModules);
-            this.namespaceReexportsByName.set(name, foundNamespaceReexport);
-            if (foundNamespaceReexport[0]) {
+            const foundNamespaceReexport = name in this.namespaceReexportsByName
+                ? this.namespaceReexportsByName[name]
+                : this.getVariableFromNamespaceReexports(name, importerForSideEffects, searchedNamesAndModules, skipExternalNamespaceReexports);
+            if (!skipExternalNamespaceReexports) {
+                this.namespaceReexportsByName[name] = foundNamespaceReexport;
+            }
+            if (foundNamespaceReexport) {
                 return foundNamespaceReexport;
             }
         }
         if (this.info.syntheticNamedExports) {
-            return [
-                getOrCreate(this.syntheticExports, name, () => new SyntheticNamedExportVariable(this.astContext, name, this.getSyntheticNamespace()))
-            ];
+            let syntheticExport = this.syntheticExports.get(name);
+            if (!syntheticExport) {
+                const syntheticNamespace = this.getSyntheticNamespace();
+                syntheticExport = new SyntheticNamedExportVariable(this.astContext, name, syntheticNamespace);
+                this.syntheticExports.set(name, syntheticExport);
+                return syntheticExport;
+            }
+            return syntheticExport;
         }
         // we don't want to create shims when we are just
         // probing export * modules for exports
-        if (!isExportAllSearch && this.options.shimMissingExports) {
-            this.shimMissingExport(name);
-            return [this.exportShimVariable];
+        if (!isExportAllSearch) {
+            if (this.options.shimMissingExports) {
+                this.shimMissingExport(name);
+                return this.exportShimVariable;
+            }
         }
-        return [null];
+        return null;
     }
     hasEffects() {
-        return (this.info.moduleSideEffects === 'no-treeshake' ||
+        return (this.info.hasModuleSideEffects === 'no-treeshake' ||
             (this.ast.included && this.ast.hasEffects(createHasEffectsContext())));
     }
     include() {
@@ -13847,9 +12564,9 @@
             markModuleAndImpureDependenciesAsExecuted(this);
             this.graph.needsTreeshakingPass = true;
         }
-        for (const exportName of this.exports.keys()) {
+        for (const exportName of this.getExports()) {
             if (includeNamespaceMembers || exportName !== this.info.syntheticNamedExports) {
-                const variable = this.getVariableForExportName(exportName)[0];
+                const variable = this.getVariableForExportName(exportName);
                 variable.deoptimizePath(UNKNOWN_PATH);
                 if (!variable.included) {
                     this.includeVariable(variable);
@@ -13857,7 +12574,7 @@
             }
         }
         for (const name of this.getReexports()) {
-            const [variable] = this.getVariableForExportName(name);
+            const variable = this.getVariableForExportName(name);
             if (variable) {
                 variable.deoptimizePath(UNKNOWN_PATH);
                 if (!variable.included) {
@@ -13877,13 +12594,16 @@
         this.includeAllExports(false);
     }
     isIncluded() {
-        // Modules where this.ast is missing have been loaded via this.load and are
-        // not yet fully processed, hence they cannot be included.
-        return (this.ast && (this.ast.included || this.namespace.included || this.importedFromNotTreeshaken));
+        return this.ast.included || this.namespace.included || this.importedFromNotTreeshaken;
     }
     linkImports() {
         this.addModulesToImportDescriptions(this.importDescriptions);
         this.addModulesToImportDescriptions(this.reexportDescriptions);
+        for (const name in this.exports) {
+            if (name !== 'default' && name !== this.info.syntheticNamedExports) {
+                this.exportsAll[name] = this.id;
+            }
+        }
         const externalExportAllModules = [];
         for (const source of this.exportAllSources) {
             const module = this.graph.modulesById.get(this.resolvedIds[source].id);
@@ -13892,21 +12612,24 @@
                 continue;
             }
             this.exportAllModules.push(module);
+            for (const name in module.exportsAll) {
+                if (name in this.exportsAll) {
+                    this.options.onwarn(errNamespaceConflict(name, this, module));
+                }
+                else {
+                    this.exportsAll[name] = module.exportsAll[name];
+                }
+            }
         }
         this.exportAllModules.push(...externalExportAllModules);
     }
     render(options) {
-        const source = this.magicString.clone();
-        this.ast.render(source, options);
-        source.trim();
-        const { usesTopLevelAwait } = this.astContext;
-        if (usesTopLevelAwait && options.format !== 'es' && options.format !== 'system') {
-            return error(errorInvalidFormatForTopLevelAwait(this.id, options.format));
-        }
-        return { source, usesTopLevelAwait };
+        const magicString = this.magicString.clone();
+        this.ast.render(magicString, options);
+        this.usesTopLevelAwait = this.astContext.usesTopLevelAwait;
+        return magicString;
     }
     setSource({ ast, code, customTransformCache, originalCode, originalSourcemap, resolvedIds, sourcemapChain, transformDependencies, transformFiles, ...moduleOptions }) {
-        timeStart('generate ast', 3);
         this.info.code = code;
         this.originalCode = originalCode;
         this.originalSourcemap = originalSourcemap;
@@ -13917,17 +12640,20 @@
         this.transformDependencies = transformDependencies;
         this.customTransformCache = customTransformCache;
         this.updateOptions(moduleOptions);
-        const moduleAst = ast ?? this.tryParse();
+        timeStart('generate ast', 3);
+        if (!ast) {
+            ast = this.tryParse();
+        }
         timeEnd('generate ast', 3);
-        timeStart('analyze ast', 3);
-        this.resolvedIds = resolvedIds ?? Object.create(null);
+        this.resolvedIds = resolvedIds || Object.create(null);
         // By default, `id` is the file name. Custom resolvers and loaders
         // can change that, but it makes sense to use it for the source file name
         const fileName = this.id;
-        this.magicString = new MagicString(code, {
+        this.magicString = new MagicString$1(code, {
             filename: (this.excludeFromSourcemap ? null : fileName),
             indentExclusionRanges: []
         });
+        timeStart('analyse ast', 3);
         this.astContext = {
             addDynamicImport: this.addDynamicImport.bind(this),
             addExport: this.addExport.bind(this),
@@ -13940,59 +12666,37 @@
             getExports: this.getExports.bind(this),
             getModuleExecIndex: () => this.execIndex,
             getModuleName: this.basename.bind(this),
-            getNodeConstructor: (name) => nodeConstructors[name] || nodeConstructors.UnknownNode,
             getReexports: this.getReexports.bind(this),
             importDescriptions: this.importDescriptions,
             includeAllExports: () => this.includeAllExports(true),
             includeDynamicImport: this.includeDynamicImport.bind(this),
             includeVariableInModule: this.includeVariableInModule.bind(this),
             magicString: this.magicString,
-            manualPureFunctions: this.graph.pureFunctions,
             module: this,
             moduleContext: this.context,
+            nodeConstructors,
             options: this.options,
             requestTreeshakingPass: () => (this.graph.needsTreeshakingPass = true),
-            traceExport: (name) => this.getVariableForExportName(name)[0],
+            traceExport: this.getVariableForExportName.bind(this),
             traceVariable: this.traceVariable.bind(this),
             usesTopLevelAwait: false,
             warn: this.warn.bind(this)
         };
         this.scope = new ModuleScope(this.graph.scope, this.astContext);
         this.namespace = new NamespaceVariable(this.astContext);
-        this.ast = new Program(moduleAst, { context: this.astContext, type: 'Module' }, this.scope);
-        // Assign AST directly if has existing one as there's no way to drop it from memory.
-        // If cache is enabled, also assign directly as otherwise it takes more CPU and memory to re-compute.
-        if (ast || this.options.cache !== false) {
-            this.info.ast = moduleAst;
-        }
-        else {
-            // Make lazy and apply LRU cache to not hog the memory
-            Object.defineProperty(this.info, 'ast', {
-                get: () => {
-                    if (this.graph.astLru.has(fileName)) {
-                        return this.graph.astLru.get(fileName);
-                    }
-                    else {
-                        const parsedAst = this.tryParse();
-                        this.graph.astLru.set(fileName, parsedAst);
-                        return parsedAst;
-                    }
-                }
-            });
-        }
-        timeEnd('analyze ast', 3);
+        this.ast = new Program(ast, { context: this.astContext, type: 'Module' }, this.scope);
+        this.info.ast = ast;
+        timeEnd('analyse ast', 3);
     }
     toJSON() {
         return {
-            assertions: this.info.assertions,
-            ast: this.info.ast,
+            ast: this.ast.esTreeNode,
             code: this.info.code,
             customTransformCache: this.customTransformCache,
-            // eslint-disable-next-line unicorn/prefer-spread
             dependencies: Array.from(this.dependencies, getId),
             id: this.id,
             meta: this.info.meta,
-            moduleSideEffects: this.info.moduleSideEffects,
+            moduleSideEffects: this.info.hasModuleSideEffects,
             originalCode: this.originalCode,
             originalSourcemap: this.originalSourcemap,
             resolvedIds: this.resolvedIds,
@@ -14002,39 +12706,60 @@
             transformFiles: this.transformFiles
         };
     }
-    traceVariable(name, { importerForSideEffects, isExportAllSearch, searchedNamesAndModules } = EMPTY_OBJECT) {
+    traceVariable(name, importerForSideEffects) {
         const localVariable = this.scope.variables.get(name);
         if (localVariable) {
             return localVariable;
         }
-        const importDescription = this.importDescriptions.get(name);
-        if (importDescription) {
-            const otherModule = importDescription.module;
-            if (otherModule instanceof Module && importDescription.name === '*') {
+        if (name in this.importDescriptions) {
+            const importDeclaration = this.importDescriptions[name];
+            const otherModule = importDeclaration.module;
+            if (otherModule instanceof Module && importDeclaration.name === '*') {
                 return otherModule.namespace;
             }
-            const [declaration] = getVariableForExportNameRecursive(otherModule, importDescription.name, importerForSideEffects || this, isExportAllSearch, searchedNamesAndModules);
+            const declaration = otherModule.getVariableForExportName(importDeclaration.name, {
+                importerForSideEffects: importerForSideEffects || this
+            });
             if (!declaration) {
-                return this.error(errorMissingExport(importDescription.name, this.id, otherModule.id), importDescription.start);
+                return this.error(errMissingExport(importDeclaration.name, this.id, otherModule.id), importDeclaration.start);
             }
             return declaration;
         }
         return null;
     }
+    tryParse() {
+        try {
+            return this.graph.contextParse(this.info.code);
+        }
+        catch (err) {
+            let message = err.message.replace(/ \(\d+:\d+\)$/, '');
+            if (this.id.endsWith('.json')) {
+                message += ' (Note that you need @rollup/plugin-json to import JSON files)';
+            }
+            else if (!this.id.endsWith('.js')) {
+                message += ' (Note that you need plugins to import files that are not JavaScript)';
+            }
+            return this.error({
+                code: 'PARSE_ERROR',
+                message,
+                parserError: err
+            }, err.pos);
+        }
+    }
     updateOptions({ meta, moduleSideEffects, syntheticNamedExports }) {
         if (moduleSideEffects != null) {
-            this.info.moduleSideEffects = moduleSideEffects;
+            this.info.hasModuleSideEffects = moduleSideEffects;
         }
         if (syntheticNamedExports != null) {
             this.info.syntheticNamedExports = syntheticNamedExports;
         }
         if (meta != null) {
-            Object.assign(this.info.meta, meta);
+            this.info.meta = { ...this.info.meta, ...meta };
         }
     }
-    warn(properties, pos) {
-        this.addLocationToLogProps(properties, pos);
-        this.options.onwarn(properties);
+    warn(props, pos) {
+        this.addLocationToLogProps(props, pos);
+        this.options.onwarn(props);
     }
     addDynamicImport(node) {
         let argument = node.source;
@@ -14051,23 +12776,23 @@
     addExport(node) {
         if (node instanceof ExportDefaultDeclaration) {
             // export default foo;
-            this.exports.set('default', {
+            this.exports.default = {
                 identifier: node.variable.getAssignedVariableName(),
                 localName: 'default'
-            });
+            };
         }
         else if (node instanceof ExportAllDeclaration) {
             const source = node.source.value;
-            this.addSource(source, node);
+            this.sources.add(source);
             if (node.exported) {
                 // export * as name from './other'
                 const name = node.exported.name;
-                this.reexportDescriptions.set(name, {
+                this.reexportDescriptions[name] = {
                     localName: '*',
                     module: null,
                     source,
                     start: node.start
-                });
+                };
             }
             else {
                 // export * from './other'
@@ -14077,15 +12802,15 @@
         else if (node.source instanceof Literal) {
             // export { name } from './other'
             const source = node.source.value;
-            this.addSource(source, node);
-            for (const { exported, local, start } of node.specifiers) {
-                const name = exported instanceof Literal ? exported.value : exported.name;
-                this.reexportDescriptions.set(name, {
-                    localName: local instanceof Literal ? local.value : local.name,
+            this.sources.add(source);
+            for (const specifier of node.specifiers) {
+                const name = specifier.exported.name;
+                this.reexportDescriptions[name] = {
+                    localName: specifier.local.name,
                     module: null,
                     source,
-                    start
-                });
+                    start: specifier.start
+                };
             }
         }
         else if (node.declaration) {
@@ -14095,51 +12820,50 @@
                 // export var foo = 1, bar = 2;
                 for (const declarator of declaration.declarations) {
                     for (const localName of extractAssignedNames(declarator.id)) {
-                        this.exports.set(localName, { identifier: null, localName });
+                        this.exports[localName] = { identifier: null, localName };
                     }
                 }
             }
             else {
                 // export function foo () {}
                 const localName = declaration.id.name;
-                this.exports.set(localName, { identifier: null, localName });
+                this.exports[localName] = { identifier: null, localName };
             }
         }
         else {
             // export { foo, bar, baz }
-            for (const { local, exported } of node.specifiers) {
-                // except for reexports, local must be an Identifier
-                const localName = local.name;
-                const exportedName = exported instanceof Identifier ? exported.name : exported.value;
-                this.exports.set(exportedName, { identifier: null, localName });
+            for (const specifier of node.specifiers) {
+                const localName = specifier.local.name;
+                const exportedName = specifier.exported.name;
+                this.exports[exportedName] = { identifier: null, localName };
             }
         }
     }
     addImport(node) {
         const source = node.source.value;
-        this.addSource(source, node);
+        this.sources.add(source);
         for (const specifier of node.specifiers) {
-            const name = specifier instanceof ImportDefaultSpecifier
+            const isDefault = specifier.type === ImportDefaultSpecifier$1;
+            const isNamespace = specifier.type === ImportNamespaceSpecifier$1;
+            const name = isDefault
                 ? 'default'
-                : specifier instanceof ImportNamespaceSpecifier
+                : isNamespace
                     ? '*'
-                    : specifier.imported instanceof Identifier
-                        ? specifier.imported.name
-                        : specifier.imported.value;
-            this.importDescriptions.set(specifier.local.name, {
+                    : specifier.imported.name;
+            this.importDescriptions[specifier.local.name] = {
                 module: null,
                 name,
                 source,
                 start: specifier.start
-            });
+            };
         }
     }
     addImportMeta(node) {
         this.importMetas.push(node);
     }
-    addLocationToLogProps(properties, pos) {
-        properties.id = this.id;
-        properties.pos = pos;
+    addLocationToLogProps(props, pos) {
+        props.id = this.id;
+        props.pos = pos;
         let code = this.info.code;
         const location = locate(code, pos, { offsetLine: 1 });
         if (location) {
@@ -14148,15 +12872,25 @@
                 ({ column, line } = getOriginalLocation(this.sourcemapChain, { column, line }));
                 code = this.originalCode;
             }
-            catch (error_) {
-                this.options.onwarn(errorInvalidSourcemapForError(error_, this.id, column, line, pos));
+            catch (err) {
+                this.options.onwarn({
+                    code: 'SOURCEMAP_ERROR',
+                    id: this.id,
+                    loc: {
+                        column,
+                        file: this.id,
+                        line
+                    },
+                    message: `Error when using sourcemap for reporting an error: ${err.message}`,
+                    pos
+                });
             }
-            augmentCodeLocation(properties, { column, line }, code, this.id);
+            augmentCodeLocation(props, { column, line }, code, this.id);
         }
     }
     addModulesToImportDescriptions(importDescription) {
-        for (const specifier of importDescription.values()) {
-            const { id } = this.resolvedIds[specifier.source];
+        for (const specifier of Object.values(importDescription)) {
+            const id = this.resolvedIds[specifier.source].id;
             specifier.module = this.graph.modulesById.get(id);
         }
     }
@@ -14172,7 +12906,7 @@
                     relevantDependencies.add(dependency);
                     continue;
                 }
-                if (!(dependency.info.moduleSideEffects || alwaysCheckedDependencies.has(dependency))) {
+                if (!(dependency.info.hasModuleSideEffects || alwaysCheckedDependencies.has(dependency))) {
                     continue;
                 }
                 if (dependency instanceof ExternalModule || dependency.hasEffects()) {
@@ -14185,80 +12919,66 @@
         addSideEffectDependencies(this.dependencies);
         addSideEffectDependencies(alwaysCheckedDependencies);
     }
-    addSource(source, declaration) {
-        const parsedAssertions = getAssertionsFromImportExportDeclaration(declaration.assertions);
-        const existingAssertions = this.sourcesWithAssertions.get(source);
-        if (existingAssertions) {
-            if (doAssertionsDiffer(existingAssertions, parsedAssertions)) {
-                this.warn(errorInconsistentImportAssertions(existingAssertions, parsedAssertions, source, this.id), declaration.start);
-            }
-        }
-        else {
-            this.sourcesWithAssertions.set(source, parsedAssertions);
-        }
-    }
-    getVariableFromNamespaceReexports(name, importerForSideEffects, searchedNamesAndModules) {
+    getVariableFromNamespaceReexports(name, importerForSideEffects, searchedNamesAndModules, skipExternalNamespaceReexports = false) {
         let foundSyntheticDeclaration = null;
-        const foundInternalDeclarations = new Map();
-        const foundExternalDeclarations = new Set();
-        for (const module of this.exportAllModules) {
-            // Synthetic namespaces should not hide "regular" exports of the same name
-            if (module.info.syntheticNamedExports === name) {
-                continue;
-            }
-            const [variable, indirectExternal] = getVariableForExportNameRecursive(module, name, importerForSideEffects, true, 
-            // We are creating a copy to handle the case where the same binding is
-            // imported through different namespace reexports gracefully
-            copyNameToModulesMap(searchedNamesAndModules));
-            if (module instanceof ExternalModule || indirectExternal) {
-                foundExternalDeclarations.add(variable);
-            }
-            else if (variable instanceof SyntheticNamedExportVariable) {
-                if (!foundSyntheticDeclaration) {
-                    foundSyntheticDeclaration = variable;
+        const skipExternalNamespaceValues = [{ searchedNamesAndModules, skipExternalNamespaces: true }];
+        if (!skipExternalNamespaceReexports) {
+            const clonedSearchedNamesAndModules = new Map();
+            for (const [name, modules] of searchedNamesAndModules || []) {
+                clonedSearchedNamesAndModules.set(name, new Set(modules));
+            }
+            skipExternalNamespaceValues.push({
+                searchedNamesAndModules: clonedSearchedNamesAndModules,
+                skipExternalNamespaces: false
+            });
+        }
+        for (const { skipExternalNamespaces, searchedNamesAndModules } of skipExternalNamespaceValues) {
+            const foundDeclarations = new Set();
+            for (const module of this.exportAllModules) {
+                if (module instanceof Module || !skipExternalNamespaces) {
+                    const declaration = getVariableForExportNameRecursive(module, name, importerForSideEffects, true, searchedNamesAndModules, skipExternalNamespaces);
+                    if (declaration) {
+                        if (!(declaration instanceof SyntheticNamedExportVariable)) {
+                            foundDeclarations.add(declaration);
+                        }
+                        else if (!foundSyntheticDeclaration) {
+                            foundSyntheticDeclaration = declaration;
+                        }
+                    }
                 }
             }
-            else if (variable) {
-                foundInternalDeclarations.set(variable, module);
-            }
-        }
-        if (foundInternalDeclarations.size > 0) {
-            const foundDeclarationList = [...foundInternalDeclarations];
-            const usedDeclaration = foundDeclarationList[0][0];
-            if (foundDeclarationList.length === 1) {
-                return [usedDeclaration];
+            if (foundDeclarations.size === 1) {
+                return [...foundDeclarations][0];
             }
-            this.options.onwarn(errorNamespaceConflict(name, this.id, foundDeclarationList.map(([, module]) => module.id)));
-            // TODO we are pretending it was not found while it should behave like "undefined"
-            return [null];
-        }
-        if (foundExternalDeclarations.size > 0) {
-            const foundDeclarationList = [...foundExternalDeclarations];
-            const usedDeclaration = foundDeclarationList[0];
-            if (foundDeclarationList.length > 1) {
-                this.options.onwarn(errorAmbiguousExternalNamespaces(name, this.id, usedDeclaration.module.id, foundDeclarationList.map(declaration => declaration.module.id)));
+            if (foundDeclarations.size > 1) {
+                if (skipExternalNamespaces) {
+                    return null;
+                }
+                const foundDeclarationList = [...foundDeclarations];
+                const usedDeclaration = foundDeclarationList[0];
+                this.options.onwarn(errAmbiguousExternalNamespaces(name, this.id, usedDeclaration.module.id, foundDeclarationList.map(declaration => declaration.module.id)));
+                return usedDeclaration;
             }
-            return [usedDeclaration, true];
         }
         if (foundSyntheticDeclaration) {
-            return [foundSyntheticDeclaration];
+            return foundSyntheticDeclaration;
         }
-        return [null];
+        return null;
     }
     includeAndGetAdditionalMergedNamespaces() {
         const externalNamespaces = new Set();
         const syntheticNamespaces = new Set();
         for (const module of [this, ...this.exportAllModules]) {
             if (module instanceof ExternalModule) {
-                const [externalVariable] = module.getVariableForExportName('*');
+                const externalVariable = module.getVariableForExportName('*');
                 externalVariable.include();
-                this.includedImports.add(externalVariable);
+                this.imports.add(externalVariable);
                 externalNamespaces.add(externalVariable);
             }
             else if (module.info.syntheticNamedExports) {
                 const syntheticNamespace = module.getSyntheticNamespace();
                 syntheticNamespace.include();
-                this.includedImports.add(syntheticNamespace);
+                this.imports.add(syntheticNamespace);
                 syntheticNamespaces.add(syntheticNamespace);
             }
         }
@@ -14276,7 +12996,7 @@
             variable.include();
             this.graph.needsTreeshakingPass = true;
             const variableModule = variable.module;
-            if (variableModule instanceof Module) {
+            if (variableModule && variableModule instanceof Module) {
                 if (!variableModule.isExecuted) {
                     markModuleAndImpureDependenciesAsExecuted(variableModule);
                 }
@@ -14295,20 +13015,17 @@
         this.includeVariable(variable);
         const variableModule = variable.module;
         if (variableModule && variableModule !== this) {
-            this.includedImports.add(variable);
+            this.imports.add(variable);
         }
     }
     shimMissingExport(name) {
-        this.options.onwarn(errorShimmedExport(this.id, name));
-        this.exports.set(name, MISSING_EXPORT_SHIM_DESCRIPTION);
-    }
-    tryParse() {
-        try {
-            return this.graph.contextParse(this.info.code);
-        }
-        catch (error_) {
-            return this.error(errorParseError(error_, this.id), error_.pos);
-        }
+        this.options.onwarn({
+            code: 'SHIMMED_EXPORT',
+            exporter: relativeId(this.id),
+            exportName: name,
+            message: `Missing export "${name}" has been shimmed in module ${relativeId(this.id)}.`
+        });
+        this.exports[name] = MISSING_EXPORT_SHIM_DESCRIPTION;
     }
 }
 // if there is a cyclic import in the reexport chain, we should not
@@ -14328,32 +13045,31 @@
         }
     }
 }
-const copyNameToModulesMap = (searchedNamesAndModules) => searchedNamesAndModules &&
-    // eslint-disable-next-line unicorn/prefer-spread
-    new Map(Array.from(searchedNamesAndModules, ([name, modules]) => [name, new Set(modules)]));
 
 function removeJsExtension(name) {
     return name.endsWith('.js') ? name.slice(0, -3) : name;
 }
 
 function getCompleteAmdId(options, chunkId) {
-    if (options.autoId) {
+    if (!options.autoId) {
+        return options.id || '';
+    }
+    else {
         return `${options.basePath ? options.basePath + '/' : ''}${removeJsExtension(chunkId)}`;
     }
-    return options.id ?? '';
 }
 
 function getExportBlock$1(exports, dependencies, namedExportsMode, interop, snippets, t, externalLiveBindings, mechanism = 'return ') {
-    const { _, getDirectReturnFunction, getFunctionIntro, getPropertyAccess, n, s } = snippets;
+    const { _, cnst, getDirectReturnFunction, getFunctionIntro, getPropertyAccess, n, s } = snippets;
     if (!namedExportsMode) {
         return `${n}${n}${mechanism}${getSingleDefaultExport(exports, dependencies, interop, externalLiveBindings, getPropertyAccess)};`;
     }
     let exportBlock = '';
-    for (const { defaultVariableName, importPath, isChunk, name, namedExportsMode: depNamedExportsMode, namespaceVariableName, reexports } of dependencies) {
+    for (const { defaultVariableName, id, isChunk, name, namedExportsMode: depNamedExportsMode, namespaceVariableName, reexports } of dependencies) {
         if (reexports && namedExportsMode) {
             for (const specifier of reexports) {
                 if (specifier.reexported !== '*') {
-                    const importName = getReexportedImportName(name, specifier.imported, depNamedExportsMode, isChunk, defaultVariableName, namespaceVariableName, interop, importPath, externalLiveBindings, getPropertyAccess);
+                    const importName = getReexportedImportName(name, specifier.imported, depNamedExportsMode, isChunk, defaultVariableName, namespaceVariableName, interop, id, externalLiveBindings, getPropertyAccess);
                     if (exportBlock)
                         exportBlock += n;
                     if (specifier.imported !== '*' && specifier.needsLiveBinding) {
@@ -14390,10 +13106,13 @@
                     if (exportBlock)
                         exportBlock += n;
                     const copyPropertyIfNecessary = `{${n}${t}if${_}(k${_}!==${_}'default'${_}&&${_}!exports.hasOwnProperty(k))${_}${getDefineProperty(name, specifier.needsLiveBinding, t, snippets)}${s}${n}}`;
-                    exportBlock += `Object.keys(${name}).forEach(${getFunctionIntro(['k'], {
-                        isAsync: false,
-                        name: null
-                    })}${copyPropertyIfNecessary});`;
+                    exportBlock +=
+                        cnst === 'var' && specifier.needsLiveBinding
+                            ? `Object.keys(${name}).forEach(${getFunctionIntro(['k'], {
+                                isAsync: false,
+                                name: null
+                            })}${copyPropertyIfNecessary});`
+                            : `for${_}(${cnst} k in ${name})${_}${copyPropertyIfNecessary}`;
                 }
             }
         }
@@ -14408,9 +13127,9 @@
         return exports[0].local;
     }
     else {
-        for (const { defaultVariableName, importPath, isChunk, name, namedExportsMode: depNamedExportsMode, namespaceVariableName, reexports } of dependencies) {
+        for (const { defaultVariableName, id, isChunk, name, namedExportsMode: depNamedExportsMode, namespaceVariableName, reexports } of dependencies) {
             if (reexports) {
-                return getReexportedImportName(name, reexports[0].imported, depNamedExportsMode, isChunk, defaultVariableName, namespaceVariableName, interop, importPath, externalLiveBindings, getPropertyAccess);
+                return getReexportedImportName(name, reexports[0].imported, depNamedExportsMode, isChunk, defaultVariableName, namespaceVariableName, interop, id, externalLiveBindings, getPropertyAccess);
             }
         }
     }
@@ -14418,7 +13137,7 @@
 function getReexportedImportName(moduleVariableName, imported, depNamedExportsMode, isChunk, defaultVariableName, namespaceVariableName, interop, moduleId, externalLiveBindings, getPropertyAccess) {
     if (imported === 'default') {
         if (!isChunk) {
-            const moduleInterop = interop(moduleId);
+            const moduleInterop = String(interop(moduleId));
             const variableName = defaultInteropHelpersByInteropType[moduleInterop]
                 ? defaultVariableName
                 : moduleVariableName;
@@ -14431,35 +13150,34 @@
             : moduleVariableName;
     }
     if (imported === '*') {
-        return (isChunk ? !depNamedExportsMode : namespaceInteropHelpersByInteropType[interop(moduleId)])
+        return (isChunk
+            ? !depNamedExportsMode
+            : namespaceInteropHelpersByInteropType[String(interop(moduleId))])
             ? namespaceVariableName
             : moduleVariableName;
     }
     return `${moduleVariableName}${getPropertyAccess(imported)}`;
 }
-function getEsModuleValue(getObject) {
-    return getObject([['value', 'true']], {
-        lineBreakIndent: null
-    });
+function getEsModuleExport(_) {
+    return `Object.defineProperty(exports,${_}'__esModule',${_}{${_}value:${_}true${_}});`;
+}
+function getNamespaceToStringExport(_) {
+    return `exports[Symbol.toStringTag]${_}=${_}'Module';`;
 }
-function getNamespaceMarkers(hasNamedExports, addEsModule, addNamespaceToStringTag, { _, getObject }) {
+function getNamespaceMarkers(hasNamedExports, addEsModule, addNamespaceToStringTag, _, n) {
+    let namespaceMarkers = '';
     if (hasNamedExports) {
         if (addEsModule) {
-            if (addNamespaceToStringTag) {
-                return `Object.defineProperties(exports,${_}${getObject([
-                    ['__esModule', getEsModuleValue(getObject)],
-                    [null, `[Symbol.toStringTag]:${_}${getToStringTagValue(getObject)}`]
-                ], {
-                    lineBreakIndent: null
-                })});`;
-            }
-            return `Object.defineProperty(exports,${_}'__esModule',${_}${getEsModuleValue(getObject)});`;
+            namespaceMarkers += getEsModuleExport(_);
         }
         if (addNamespaceToStringTag) {
-            return `Object.defineProperty(exports,${_}Symbol.toStringTag,${_}${getToStringTagValue(getObject)});`;
+            if (namespaceMarkers) {
+                namespaceMarkers += n;
+            }
+            namespaceMarkers += getNamespaceToStringExport(_);
         }
     }
-    return '';
+    return namespaceMarkers;
 }
 const getDefineProperty = (name, needsLiveBinding, t, { _, getDirectReturnFunction, n }) => {
     if (needsLiveBinding) {
@@ -14483,7 +13201,7 @@
         neededInteropHelpers.add(helper);
         interopStatements.push(`${cnst} ${helperVariableName}${_}=${_}/*#__PURE__*/${helper}(${dependencyVariableName});`);
     };
-    for (const { defaultVariableName, imports, importPath, isChunk, name, namedExportsMode, namespaceVariableName, reexports } of dependencies) {
+    for (const { defaultVariableName, imports, id, isChunk, name, namedExportsMode, namespaceVariableName, reexports } of dependencies) {
         if (isChunk) {
             for (const { imported, reexported } of [
                 ...(imports || []),
@@ -14498,7 +13216,7 @@
             }
         }
         else {
-            const moduleInterop = interop(importPath);
+            const moduleInterop = String(interop(id));
             let hasDefault = false;
             let hasNamespace = false;
             for (const { imported, reexported } of [
@@ -14516,10 +13234,12 @@
                         }
                     }
                 }
-                else if (imported === '*' && reexported !== '*' && !hasNamespace) {
-                    hasNamespace = true;
-                    helper = namespaceInteropHelpersByInteropType[moduleInterop];
-                    variableName = namespaceVariableName;
+                else if (imported === '*' && reexported !== '*') {
+                    if (!hasNamespace) {
+                        hasNamespace = true;
+                        helper = namespaceInteropHelpersByInteropType[moduleInterop];
+                        variableName = namespaceVariableName;
+                    }
                 }
                 if (helper) {
                     addInteropStatement(variableName, helper, name);
@@ -14530,144 +13250,90 @@
     return `${getHelpersBlock(neededInteropHelpers, accessedGlobals, indent, snippets, externalLiveBindings, freeze, namespaceToStringTag)}${interopStatements.length > 0 ? `${interopStatements.join(n)}${n}${n}` : ''}`;
 }
 
-function addJsExtension(name) {
-    return name.endsWith('.js') ? name : name + '.js';
-}
-
 // AMD resolution will only respect the AMD baseUrl if the .js extension is omitted.
 // The assumption is that this makes sense for all relative ids:
 // https://requirejs.org/docs/api.html#jsfiles
-function updateExtensionForRelativeAmdId(id, forceJsExtensionForImports) {
-    if (id[0] !== '.') {
-        return id;
-    }
-    return forceJsExtensionForImports ? addJsExtension(id) : removeJsExtension(id);
+function removeExtensionFromRelativeAmdId(id) {
+    return id[0] === '.' ? removeJsExtension(id) : id;
 }
 
-var _staticExports = {};
-var _static = {
-  get exports(){ return _staticExports; },
-  set exports(v){ _staticExports = v; },
-};
-
-const require$$0 = [
-	"assert",
-	"async_hooks",
-	"buffer",
-	"child_process",
-	"cluster",
-	"console",
-	"constants",
-	"crypto",
-	"dgram",
-	"diagnostics_channel",
-	"dns",
-	"domain",
-	"events",
-	"fs",
-	"http",
-	"http2",
-	"https",
-	"inspector",
-	"module",
-	"net",
-	"os",
-	"path",
-	"perf_hooks",
-	"process",
-	"punycode",
-	"querystring",
-	"readline",
-	"repl",
-	"stream",
-	"string_decoder",
-	"timers",
-	"tls",
-	"trace_events",
-	"tty",
-	"url",
-	"util",
-	"v8",
-	"vm",
-	"wasi",
-	"worker_threads",
-	"zlib"
-];
-
-(function (module) {
-	module.exports = require$$0;
-} (_static));
-
-const builtinModules = /*@__PURE__*/getDefaultExportFromCjs(_staticExports);
-
-const nodeBuiltins = new Set([
-    ...builtinModules,
-    // TODO
-    // remove once builtin-modules includes PR: https://github.com/sindresorhus/builtin-modules/pull/17
-    'assert/strict',
-    'dns/promises',
-    'fs/promises',
-    'path/posix',
-    'path/win32',
-    'readline/promises',
-    'stream/consumers',
-    'stream/promises',
-    'stream/web',
-    'timers/promises',
-    'util/types'
-]);
+const builtins = {
+    assert: true,
+    buffer: true,
+    console: true,
+    constants: true,
+    domain: true,
+    events: true,
+    http: true,
+    https: true,
+    os: true,
+    path: true,
+    process: true,
+    punycode: true,
+    querystring: true,
+    stream: true,
+    string_decoder: true,
+    timers: true,
+    tty: true,
+    url: true,
+    util: true,
+    vm: true,
+    zlib: true
+};
 function warnOnBuiltins(warn, dependencies) {
-    const externalBuiltins = dependencies
-        .map(({ importPath }) => importPath)
-        .filter(importPath => nodeBuiltins.has(importPath) || importPath.startsWith('node:'));
-    if (externalBuiltins.length === 0)
+    const externalBuiltins = dependencies.map(({ id }) => id).filter(id => id in builtins);
+    if (!externalBuiltins.length)
         return;
-    warn(errorMissingNodeBuiltins(externalBuiltins));
+    warn({
+        code: 'MISSING_NODE_BUILTINS',
+        message: `Creating a browser bundle that depends on Node.js built-in modules (${printQuotedStringList(externalBuiltins)}). You might need to include https://github.com/snowpackjs/rollup-plugin-polyfill-node`,
+        modules: externalBuiltins
+    });
 }
 
-function amd(magicString, { accessedGlobals, dependencies, exports, hasDefaultExport, hasExports, id, indent: t, intro, isEntryFacade, isModuleFacade, namedExportsMode, outro, snippets, onwarn }, { amd, esModule, externalLiveBindings, freeze, interop, namespaceToStringTag, strict }) {
-    warnOnBuiltins(onwarn, dependencies);
-    const deps = dependencies.map(m => `'${updateExtensionForRelativeAmdId(m.importPath, amd.forceJsExtensionForImports)}'`);
-    const parameters = dependencies.map(m => m.name);
+function amd(magicString, { accessedGlobals, dependencies, exports, hasExports, id, indent: t, intro, isEntryFacade, isModuleFacade, namedExportsMode, outro, snippets, warn }, { amd, esModule, externalLiveBindings, freeze, interop, namespaceToStringTag, strict }) {
+    warnOnBuiltins(warn, dependencies);
+    const deps = dependencies.map(m => `'${removeExtensionFromRelativeAmdId(m.id)}'`);
+    const args = dependencies.map(m => m.name);
     const { n, getNonArrowFunctionIntro, _ } = snippets;
     if (namedExportsMode && hasExports) {
-        parameters.unshift(`exports`);
+        args.unshift(`exports`);
         deps.unshift(`'exports'`);
     }
     if (accessedGlobals.has('require')) {
-        parameters.unshift('require');
+        args.unshift('require');
         deps.unshift(`'require'`);
     }
     if (accessedGlobals.has('module')) {
-        parameters.unshift('module');
+        args.unshift('module');
         deps.unshift(`'module'`);
     }
     const completeAmdId = getCompleteAmdId(amd, id);
-    const defineParameters = (completeAmdId ? `'${completeAmdId}',${_}` : ``) +
-        (deps.length > 0 ? `[${deps.join(`,${_}`)}],${_}` : ``);
+    const params = (completeAmdId ? `'${completeAmdId}',${_}` : ``) +
+        (deps.length ? `[${deps.join(`,${_}`)}],${_}` : ``);
     const useStrict = strict ? `${_}'use strict';` : '';
     magicString.prepend(`${intro}${getInteropBlock(dependencies, interop, externalLiveBindings, freeze, namespaceToStringTag, accessedGlobals, t, snippets)}`);
     const exportBlock = getExportBlock$1(exports, dependencies, namedExportsMode, interop, snippets, t, externalLiveBindings);
-    let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, isEntryFacade && (esModule === true || (esModule === 'if-default-prop' && hasDefaultExport)), isModuleFacade && namespaceToStringTag, snippets);
+    let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, isEntryFacade && esModule, isModuleFacade && namespaceToStringTag, _, n);
     if (namespaceMarkers) {
         namespaceMarkers = n + n + namespaceMarkers;
     }
-    magicString
-        .append(`${exportBlock}${namespaceMarkers}${outro}`)
+    magicString.append(`${exportBlock}${namespaceMarkers}${outro}`);
+    return (magicString
         .indent(t)
         // factory function should be wrapped by parentheses to avoid lazy parsing,
         // cf. https://v8.dev/blog/preparser#pife
-        .prepend(`${amd.define}(${defineParameters}(${getNonArrowFunctionIntro(parameters, {
+        .prepend(`${amd.define}(${params}(${getNonArrowFunctionIntro(args, {
         isAsync: false,
         name: null
     })}{${useStrict}${n}${n}`)
-        .append(`${n}${n}}));`);
+        .append(`${n}${n}}));`));
 }
 
-function cjs(magicString, { accessedGlobals, dependencies, exports, hasDefaultExport, hasExports, indent: t, intro, isEntryFacade, isModuleFacade, namedExportsMode, outro, snippets }, { compact, esModule, externalLiveBindings, freeze, interop, namespaceToStringTag, strict }) {
+function cjs(magicString, { accessedGlobals, dependencies, exports, hasExports, indent: t, intro, isEntryFacade, isModuleFacade, namedExportsMode, outro, snippets }, { compact, esModule, externalLiveBindings, freeze, interop, namespaceToStringTag, strict }) {
     const { _, n } = snippets;
     const useStrict = strict ? `'use strict';${n}${n}` : '';
-    let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, isEntryFacade && (esModule === true || (esModule === 'if-default-prop' && hasDefaultExport)), isModuleFacade && namespaceToStringTag, snippets);
+    let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, isEntryFacade && esModule, isModuleFacade && namespaceToStringTag, _, n);
     if (namespaceMarkers) {
         namespaceMarkers += n + n;
     }
@@ -14675,23 +13341,23 @@
     const interopBlock = getInteropBlock(dependencies, interop, externalLiveBindings, freeze, namespaceToStringTag, accessedGlobals, t, snippets);
     magicString.prepend(`${useStrict}${intro}${namespaceMarkers}${importBlock}${interopBlock}`);
     const exportBlock = getExportBlock$1(exports, dependencies, namedExportsMode, interop, snippets, t, externalLiveBindings, `module.exports${_}=${_}`);
-    magicString.append(`${exportBlock}${outro}`);
+    return magicString.append(`${exportBlock}${outro}`);
 }
 function getImportBlock$1(dependencies, { _, cnst, n }, compact) {
     let importBlock = '';
     let definingVariable = false;
-    for (const { importPath, name, reexports, imports } of dependencies) {
+    for (const { id, name, reexports, imports } of dependencies) {
         if (!reexports && !imports) {
             if (importBlock) {
                 importBlock += compact && !definingVariable ? ',' : `;${n}`;
             }
             definingVariable = false;
-            importBlock += `require('${importPath}')`;
+            importBlock += `require('${id}')`;
         }
         else {
             importBlock += compact && definingVariable ? ',' : `${importBlock ? `;${n}` : ''}${cnst} `;
             definingVariable = true;
-            importBlock += `${name}${_}=${_}require('${importPath}')`;
+            importBlock += `${name}${_}=${_}require('${id}')`;
         }
     }
     if (importBlock) {
@@ -14701,27 +13367,25 @@
 }
 
 function es(magicString, { accessedGlobals, indent: t, intro, outro, dependencies, exports, snippets }, { externalLiveBindings, freeze, namespaceToStringTag }) {
-    const { n } = snippets;
-    const importBlock = getImportBlock(dependencies, snippets);
+    const { _, n } = snippets;
+    const importBlock = getImportBlock(dependencies, _);
     if (importBlock.length > 0)
         intro += importBlock.join(n) + n + n;
     intro += getHelpersBlock(null, accessedGlobals, t, snippets, externalLiveBindings, freeze, namespaceToStringTag);
     if (intro)
         magicString.prepend(intro);
     const exportBlock = getExportBlock(exports, snippets);
-    if (exportBlock.length > 0)
+    if (exportBlock.length)
         magicString.append(n + n + exportBlock.join(n).trim());
     if (outro)
         magicString.append(outro);
-    magicString.trim();
+    return magicString.trim();
 }
-function getImportBlock(dependencies, { _ }) {
+function getImportBlock(dependencies, _) {
     const importBlock = [];
-    for (const { importPath, reexports, imports, name, assertions } of dependencies) {
-        const assertion = assertions ? `${_}assert${_}${assertions}` : '';
-        const pathWithAssertion = `'${importPath}'${assertion};`;
+    for (const { id, reexports, imports, name } of dependencies) {
         if (!reexports && !imports) {
-            importBlock.push(`import${_}${pathWithAssertion}`);
+            importBlock.push(`import${_}'${id}';`);
             continue;
         }
         if (imports) {
@@ -14740,17 +13404,22 @@
                 }
             }
             if (starImport) {
-                importBlock.push(`import${_}*${_}as ${starImport.local} from${_}${pathWithAssertion}`);
+                importBlock.push(`import${_}*${_}as ${starImport.local} from${_}'${id}';`);
             }
             if (defaultImport && importedNames.length === 0) {
-                importBlock.push(`import ${defaultImport.local} from${_}${pathWithAssertion}`);
+                importBlock.push(`import ${defaultImport.local} from${_}'${id}';`);
             }
             else if (importedNames.length > 0) {
                 importBlock.push(`import ${defaultImport ? `${defaultImport.local},${_}` : ''}{${_}${importedNames
-                    .map(specifier => specifier.imported === specifier.local
-                    ? specifier.imported
-                    : `${specifier.imported} as ${specifier.local}`)
-                    .join(`,${_}`)}${_}}${_}from${_}${pathWithAssertion}`);
+                    .map(specifier => {
+                    if (specifier.imported === specifier.local) {
+                        return specifier.imported;
+                    }
+                    else {
+                        return `${specifier.imported} as ${specifier.local}`;
+                    }
+                })
+                    .join(`,${_}`)}${_}}${_}from${_}'${id}';`);
             }
         }
         if (reexports) {
@@ -14769,12 +13438,12 @@
                 }
             }
             if (starExport) {
-                importBlock.push(`export${_}*${_}from${_}${pathWithAssertion}`);
+                importBlock.push(`export${_}*${_}from${_}'${id}';`);
             }
             if (namespaceReexports.length > 0) {
                 if (!imports ||
                     !imports.some(specifier => specifier.imported === '*' && specifier.local === name)) {
-                    importBlock.push(`import${_}*${_}as ${name} from${_}${pathWithAssertion}`);
+                    importBlock.push(`import${_}*${_}as ${name} from${_}'${id}';`);
                 }
                 for (const specifier of namespaceReexports) {
                     importBlock.push(`export${_}{${_}${name === specifier.reexported ? name : `${name} as ${specifier.reexported}`} };`);
@@ -14782,10 +13451,15 @@
             }
             if (namedReexports.length > 0) {
                 importBlock.push(`export${_}{${_}${namedReexports
-                    .map(specifier => specifier.imported === specifier.reexported
-                    ? specifier.imported
-                    : `${specifier.imported} as ${specifier.reexported}`)
-                    .join(`,${_}`)}${_}}${_}from${_}${pathWithAssertion}`);
+                    .map(specifier => {
+                    if (specifier.imported === specifier.reexported) {
+                        return specifier.imported;
+                    }
+                    else {
+                        return `${specifier.imported} as ${specifier.reexported}`;
+                    }
+                })
+                    .join(`,${_}`)}${_}}${_}from${_}'${id}';`);
             }
         }
     }
@@ -14802,7 +13476,7 @@
             ? specifier.local
             : `${specifier.local} as ${specifier.exported}`);
     }
-    if (exportDeclaration.length > 0) {
+    if (exportDeclaration.length) {
         exportBlock.push(`export${_}{${_}${exportDeclaration.join(`,${_}`)}${_}};`);
     }
     return exportBlock;
@@ -14820,20 +13494,20 @@
         propertyPath += getPropertyAccess(part);
         return `${propertyPath}${_}=${_}${propertyPath}${_}||${_}{}${s}`;
     })
-        .join(compact ? ',' : '\n') + (compact && parts.length > 0 ? ';' : '\n'));
+        .join(compact ? ',' : '\n') + (compact && parts.length ? ';' : '\n'));
 }
 function assignToDeepVariable(deepName, root, globals, assignment, { _, getPropertyAccess }) {
     const parts = deepName.split('.');
     parts[0] = (typeof globals === 'function' ? globals(parts[0]) : globals[parts[0]]) || parts[0];
     const last = parts.pop();
     let propertyPath = root;
-    let deepAssignment = [
-        ...parts.map(part => {
-            propertyPath += getPropertyAccess(part);
-            return `${propertyPath}${_}=${_}${propertyPath}${_}||${_}{}`;
-        }),
-        `${propertyPath}${getPropertyAccess(last)}`
-    ].join(`,${_}`) + `${_}=${_}${assignment}`;
+    let deepAssignment = parts
+        .map(part => {
+        propertyPath += getPropertyAccess(part);
+        return `${propertyPath}${_}=${_}${propertyPath}${_}||${_}{}`;
+    })
+        .concat(`${propertyPath}${getPropertyAccess(last)}`)
+        .join(`,${_}`) + `${_}=${_}${assignment}`;
     if (parts.length > 0) {
         deepAssignment = `(${deepAssignment})`;
     }
@@ -14841,51 +13515,57 @@
 }
 
 function trimEmptyImports(dependencies) {
-    let index = dependencies.length;
-    while (index--) {
-        const { imports, reexports } = dependencies[index];
+    let i = dependencies.length;
+    while (i--) {
+        const { imports, reexports } = dependencies[i];
         if (imports || reexports) {
-            return dependencies.slice(0, index + 1);
+            return dependencies.slice(0, i + 1);
         }
     }
     return [];
 }
 
-function iife(magicString, { accessedGlobals, dependencies, exports, hasDefaultExport, hasExports, indent: t, intro, namedExportsMode, outro, snippets, onwarn }, { compact, esModule, extend, freeze, externalLiveBindings, globals, interop, name, namespaceToStringTag, strict }) {
-    const { _, getNonArrowFunctionIntro, getPropertyAccess, n } = snippets;
-    const isNamespaced = name && name.includes('.');
+function iife(magicString, { accessedGlobals, dependencies, exports, hasExports, indent: t, intro, namedExportsMode, outro, snippets, warn }, { compact, esModule, extend, freeze, externalLiveBindings, globals, interop, name, namespaceToStringTag, strict }) {
+    const { _, cnst, getNonArrowFunctionIntro, getPropertyAccess, n } = snippets;
+    const isNamespaced = name && name.indexOf('.') !== -1;
     const useVariableAssignment = !extend && !isNamespaced;
     if (name && useVariableAssignment && !isLegal(name)) {
-        return error(errorIllegalIdentifierAsName(name));
+        return error({
+            code: 'ILLEGAL_IDENTIFIER_AS_NAME',
+            message: `Given name "${name}" is not a legal JS identifier. If you need this, you can try "output.extend: true".`
+        });
     }
-    warnOnBuiltins(onwarn, dependencies);
+    warnOnBuiltins(warn, dependencies);
     const external = trimEmptyImports(dependencies);
     const deps = external.map(dep => dep.globalName || 'null');
-    const parameters = external.map(m => m.name);
+    const args = external.map(m => m.name);
     if (hasExports && !name) {
-        onwarn(errorMissingNameOptionForIifeExport());
+        warn({
+            code: 'MISSING_NAME_OPTION_FOR_IIFE_EXPORT',
+            message: `If you do not supply "output.name", you may not be able to access the exports of an IIFE bundle.`
+        });
     }
     if (namedExportsMode && hasExports) {
         if (extend) {
             deps.unshift(`this${keypath(name, getPropertyAccess)}${_}=${_}this${keypath(name, getPropertyAccess)}${_}||${_}{}`);
-            parameters.unshift('exports');
+            args.unshift('exports');
         }
         else {
             deps.unshift('{}');
-            parameters.unshift('exports');
+            args.unshift('exports');
         }
     }
     const useStrict = strict ? `${t}'use strict';${n}` : '';
     const interopBlock = getInteropBlock(dependencies, interop, externalLiveBindings, freeze, namespaceToStringTag, accessedGlobals, t, snippets);
     magicString.prepend(`${intro}${interopBlock}`);
-    let wrapperIntro = `(${getNonArrowFunctionIntro(parameters, {
+    let wrapperIntro = `(${getNonArrowFunctionIntro(args, {
         isAsync: false,
         name: null
     })}{${n}${useStrict}${n}`;
     if (hasExports) {
         if (name && !(extend && namedExportsMode)) {
             wrapperIntro =
-                (useVariableAssignment ? `var ${name}` : `this${keypath(name, getPropertyAccess)}`) +
+                (useVariableAssignment ? `${cnst} ${name}` : `this${keypath(name, getPropertyAccess)}`) +
                     `${_}=${_}${wrapperIntro}`;
         }
         if (isNamespaced) {
@@ -14897,22 +13577,19 @@
         wrapperOutro = `${n}${n}${t}return exports;${wrapperOutro}`;
     }
     const exportBlock = getExportBlock$1(exports, dependencies, namedExportsMode, interop, snippets, t, externalLiveBindings);
-    let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, esModule === true || (esModule === 'if-default-prop' && hasDefaultExport), namespaceToStringTag, snippets);
+    let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, esModule, namespaceToStringTag, _, n);
     if (namespaceMarkers) {
         namespaceMarkers = n + n + namespaceMarkers;
     }
-    magicString
-        .append(`${exportBlock}${namespaceMarkers}${outro}`)
-        .indent(t)
-        .prepend(wrapperIntro)
-        .append(wrapperOutro);
+    magicString.append(`${exportBlock}${namespaceMarkers}${outro}`);
+    return magicString.indent(t).prepend(wrapperIntro).append(wrapperOutro);
 }
 
 function system(magicString, { accessedGlobals, dependencies, exports, hasExports, indent: t, intro, snippets, outro, usesTopLevelAwait }, { externalLiveBindings, freeze, name, namespaceToStringTag, strict, systemNullSetters }) {
     const { _, getFunctionIntro, getNonArrowFunctionIntro, n, s } = snippets;
     const { importBindings, setters, starExcludes } = analyzeDependencies(dependencies, exports, t, snippets);
     const registeredName = name ? `'${name}',${_}` : '';
-    const wrapperParameters = accessedGlobals.has('module')
+    const wrapperParams = accessedGlobals.has('module')
         ? ['exports', 'module']
         : hasExports
             ? ['exports']
@@ -14920,14 +13597,11 @@
     // factory function should be wrapped by parentheses to avoid lazy parsing,
     // cf. https://v8.dev/blog/preparser#pife
     let wrapperStart = `System.register(${registeredName}[` +
-        dependencies.map(({ importPath }) => `'${importPath}'`).join(`,${_}`) +
-        `],${_}(${getNonArrowFunctionIntro(wrapperParameters, {
-            isAsync: false,
-            name: null
-        })}{${n}${t}${strict ? "'use strict';" : ''}` +
+        dependencies.map(({ id }) => `'${id}'`).join(`,${_}`) +
+        `],${_}(${getNonArrowFunctionIntro(wrapperParams, { isAsync: false, name: null })}{${n}${t}${strict ? "'use strict';" : ''}` +
         getStarExcludesBlock(starExcludes, t, snippets) +
         getImportBindingsBlock(importBindings, t, snippets) +
-        `${n}${t}return${_}{${setters.length > 0
+        `${n}${t}return${_}{${setters.length
             ? `${n}${t}${t}setters:${_}[${setters
                 .map(setter => setter
                 ? `${getFunctionIntro(['module'], {
@@ -14944,16 +13618,13 @@
         name: null
     })}{${n}${n}`;
     const wrapperEnd = `${t}${t}})${n}${t}}${s}${n}}));`;
-    magicString
-        .prepend(intro +
+    magicString.prepend(intro +
         getHelpersBlock(null, accessedGlobals, t, snippets, externalLiveBindings, freeze, namespaceToStringTag) +
-        getHoistedExportsBlock(exports, t, snippets))
-        .append(`${outro}${n}${n}` +
+        getHoistedExportsBlock(exports, t, snippets));
+    magicString.append(`${outro}${n}${n}` +
         getSyntheticExportsBlock(exports, t, snippets) +
-        getMissingExportsBlock(exports, t, snippets))
-        .indent(`${t}${t}${t}`)
-        .append(wrapperEnd)
-        .prepend(wrapperStart);
+        getMissingExportsBlock(exports, t, snippets));
+    return magicString.indent(`${t}${t}${t}`).append(wrapperEnd).prepend(wrapperStart);
 }
 function analyzeDependencies(dependencies, exports, t, { _, cnst, getObject, getPropertyAccess, n }) {
     const importBindings = [];
@@ -15021,9 +13692,9 @@
     return starExcludes;
 };
 const getStarExcludesBlock = (starExcludes, t, { _, cnst, getObject, n }) => starExcludes
-    ? `${n}${t}${cnst} _starExcludes${_}=${_}${getObject([...starExcludes].map(property => [property, '1']), { lineBreakIndent: { base: t, t } })};`
+    ? `${n}${t}${cnst} _starExcludes${_}=${_}${getObject([...starExcludes].map(prop => [prop, '1']), { lineBreakIndent: { base: t, t } })};`
     : '';
-const getImportBindingsBlock = (importBindings, t, { _, n }) => (importBindings.length > 0 ? `${n}${t}var ${importBindings.join(`,${_}`)};` : '');
+const getImportBindingsBlock = (importBindings, t, { _, n }) => (importBindings.length ? `${n}${t}var ${importBindings.join(`,${_}`)};` : '');
 const getHoistedExportsBlock = (exports, t, snippets) => getExportsBlock(exports.filter(expt => expt.hoisted).map(expt => ({ name: expt.exported, value: expt.local })), t, snippets);
 function getExportsBlock(exports, t, { _, n }) {
     if (exports.length === 0) {
@@ -15043,138 +13714,273 @@
     .filter(expt => expt.local === MISSING_EXPORT_SHIM_VARIABLE)
     .map(expt => ({ name: expt.exported, value: MISSING_EXPORT_SHIM_VARIABLE })), t, snippets);
 
-function globalProperty(name, globalVariable, getPropertyAccess) {
+function globalProp(name, globalVar, getPropertyAccess) {
     if (!name)
         return 'null';
-    return `${globalVariable}${keypath(name, getPropertyAccess)}`;
+    return `${globalVar}${keypath(name, getPropertyAccess)}`;
 }
-function safeAccess(name, globalVariable, { _, getPropertyAccess }) {
-    let propertyPath = globalVariable;
+function safeAccess(name, globalVar, { _, getPropertyAccess }) {
+    let propertyPath = globalVar;
     return name
         .split('.')
         .map(part => (propertyPath += getPropertyAccess(part)))
         .join(`${_}&&${_}`);
 }
-function umd(magicString, { accessedGlobals, dependencies, exports, hasDefaultExport, hasExports, id, indent: t, intro, namedExportsMode, outro, snippets, onwarn }, { amd, compact, esModule, extend, externalLiveBindings, freeze, interop, name, namespaceToStringTag, globals, noConflict, strict }) {
+function umd(magicString, { accessedGlobals, dependencies, exports, hasExports, id, indent: t, intro, namedExportsMode, outro, snippets, warn }, { amd, compact, esModule, extend, externalLiveBindings, freeze, interop, name, namespaceToStringTag, globals, noConflict, strict }) {
     const { _, cnst, getFunctionIntro, getNonArrowFunctionIntro, getPropertyAccess, n, s } = snippets;
-    const factoryVariable = compact ? 'f' : 'factory';
-    const globalVariable = compact ? 'g' : 'global';
+    const factoryVar = compact ? 'f' : 'factory';
+    const globalVar = compact ? 'g' : 'global';
     if (hasExports && !name) {
-        return error(errorMissingNameOptionForUmdExport());
+        return error({
+            code: 'MISSING_NAME_OPTION_FOR_IIFE_EXPORT',
+            message: 'You must supply "output.name" for UMD bundles that have exports so that the exports are accessible in environments without a module loader.'
+        });
     }
-    warnOnBuiltins(onwarn, dependencies);
-    const amdDeps = dependencies.map(m => `'${updateExtensionForRelativeAmdId(m.importPath, amd.forceJsExtensionForImports)}'`);
-    const cjsDeps = dependencies.map(m => `require('${m.importPath}')`);
+    warnOnBuiltins(warn, dependencies);
+    const amdDeps = dependencies.map(m => `'${removeExtensionFromRelativeAmdId(m.id)}'`);
+    const cjsDeps = dependencies.map(m => `require('${m.id}')`);
     const trimmedImports = trimEmptyImports(dependencies);
-    const globalDeps = trimmedImports.map(module => globalProperty(module.globalName, globalVariable, getPropertyAccess));
-    const factoryParameters = trimmedImports.map(m => m.name);
+    const globalDeps = trimmedImports.map(module => globalProp(module.globalName, globalVar, getPropertyAccess));
+    const factoryParams = trimmedImports.map(m => m.name);
     if (namedExportsMode && (hasExports || noConflict)) {
         amdDeps.unshift(`'exports'`);
         cjsDeps.unshift(`exports`);
-        globalDeps.unshift(assignToDeepVariable(name, globalVariable, globals, `${extend ? `${globalProperty(name, globalVariable, getPropertyAccess)}${_}||${_}` : ''}{}`, snippets));
-        factoryParameters.unshift('exports');
+        globalDeps.unshift(assignToDeepVariable(name, globalVar, globals, `${extend ? `${globalProp(name, globalVar, getPropertyAccess)}${_}||${_}` : ''}{}`, snippets));
+        factoryParams.unshift('exports');
     }
     const completeAmdId = getCompleteAmdId(amd, id);
-    const amdParameters = (completeAmdId ? `'${completeAmdId}',${_}` : ``) +
-        (amdDeps.length > 0 ? `[${amdDeps.join(`,${_}`)}],${_}` : ``);
+    const amdParams = (completeAmdId ? `'${completeAmdId}',${_}` : ``) +
+        (amdDeps.length ? `[${amdDeps.join(`,${_}`)}],${_}` : ``);
     const define = amd.define;
     const cjsExport = !namedExportsMode && hasExports ? `module.exports${_}=${_}` : ``;
     const useStrict = strict ? `${_}'use strict';${n}` : ``;
     let iifeExport;
     if (noConflict) {
-        const noConflictExportsVariable = compact ? 'e' : 'exports';
+        const noConflictExportsVar = compact ? 'e' : 'exports';
         let factory;
         if (!namedExportsMode && hasExports) {
-            factory = `${cnst} ${noConflictExportsVariable}${_}=${_}${assignToDeepVariable(name, globalVariable, globals, `${factoryVariable}(${globalDeps.join(`,${_}`)})`, snippets)};`;
+            factory = `${cnst} ${noConflictExportsVar}${_}=${_}${assignToDeepVariable(name, globalVar, globals, `${factoryVar}(${globalDeps.join(`,${_}`)})`, snippets)};`;
         }
         else {
             const module = globalDeps.shift();
             factory =
-                `${cnst} ${noConflictExportsVariable}${_}=${_}${module};${n}` +
-                    `${t}${t}${factoryVariable}(${[noConflictExportsVariable, ...globalDeps].join(`,${_}`)});`;
+                `${cnst} ${noConflictExportsVar}${_}=${_}${module};${n}` +
+                    `${t}${t}${factoryVar}(${[noConflictExportsVar].concat(globalDeps).join(`,${_}`)});`;
         }
         iifeExport =
             `(${getFunctionIntro([], { isAsync: false, name: null })}{${n}` +
-                `${t}${t}${cnst} current${_}=${_}${safeAccess(name, globalVariable, snippets)};${n}` +
+                `${t}${t}${cnst} current${_}=${_}${safeAccess(name, globalVar, snippets)};${n}` +
                 `${t}${t}${factory}${n}` +
-                `${t}${t}${noConflictExportsVariable}.noConflict${_}=${_}${getFunctionIntro([], {
+                `${t}${t}${noConflictExportsVar}.noConflict${_}=${_}${getFunctionIntro([], {
                     isAsync: false,
                     name: null
                 })}{${_}` +
-                `${globalProperty(name, globalVariable, getPropertyAccess)}${_}=${_}current;${_}return ${noConflictExportsVariable}${s}${_}};${n}` +
+                `${globalProp(name, globalVar, getPropertyAccess)}${_}=${_}current;${_}return ${noConflictExportsVar}${s}${_}};${n}` +
                 `${t}})()`;
     }
     else {
-        iifeExport = `${factoryVariable}(${globalDeps.join(`,${_}`)})`;
+        iifeExport = `${factoryVar}(${globalDeps.join(`,${_}`)})`;
         if (!namedExportsMode && hasExports) {
-            iifeExport = assignToDeepVariable(name, globalVariable, globals, iifeExport, snippets);
+            iifeExport = assignToDeepVariable(name, globalVar, globals, iifeExport, snippets);
         }
     }
     const iifeNeedsGlobal = hasExports || (noConflict && namedExportsMode) || globalDeps.length > 0;
-    const wrapperParameters = [factoryVariable];
+    const wrapperParams = [factoryVar];
     if (iifeNeedsGlobal) {
-        wrapperParameters.unshift(globalVariable);
+        wrapperParams.unshift(globalVar);
     }
-    const globalArgument = iifeNeedsGlobal ? `this,${_}` : '';
+    const globalArg = iifeNeedsGlobal ? `this,${_}` : '';
     const iifeStart = iifeNeedsGlobal
-        ? `(${globalVariable}${_}=${_}typeof globalThis${_}!==${_}'undefined'${_}?${_}globalThis${_}:${_}${globalVariable}${_}||${_}self,${_}`
+        ? `(${globalVar}${_}=${_}typeof globalThis${_}!==${_}'undefined'${_}?${_}globalThis${_}:${_}${globalVar}${_}||${_}self,${_}`
         : '';
     const iifeEnd = iifeNeedsGlobal ? ')' : '';
     const cjsIntro = iifeNeedsGlobal
         ? `${t}typeof exports${_}===${_}'object'${_}&&${_}typeof module${_}!==${_}'undefined'${_}?` +
-            `${_}${cjsExport}${factoryVariable}(${cjsDeps.join(`,${_}`)})${_}:${n}`
+            `${_}${cjsExport}${factoryVar}(${cjsDeps.join(`,${_}`)})${_}:${n}`
         : '';
-    const wrapperIntro = `(${getNonArrowFunctionIntro(wrapperParameters, { isAsync: false, name: null })}{${n}` +
+    const wrapperIntro = `(${getNonArrowFunctionIntro(wrapperParams, { isAsync: false, name: null })}{${n}` +
         cjsIntro +
-        `${t}typeof ${define}${_}===${_}'function'${_}&&${_}${define}.amd${_}?${_}${define}(${amdParameters}${factoryVariable})${_}:${n}` +
+        `${t}typeof ${define}${_}===${_}'function'${_}&&${_}${define}.amd${_}?${_}${define}(${amdParams}${factoryVar})${_}:${n}` +
         `${t}${iifeStart}${iifeExport}${iifeEnd};${n}` +
         // factory function should be wrapped by parentheses to avoid lazy parsing,
         // cf. https://v8.dev/blog/preparser#pife
-        `})(${globalArgument}(${getNonArrowFunctionIntro(factoryParameters, {
+        `})(${globalArg}(${getNonArrowFunctionIntro(factoryParams, {
             isAsync: false,
             name: null
         })}{${useStrict}${n}`;
     const wrapperOutro = n + n + '}));';
     magicString.prepend(`${intro}${getInteropBlock(dependencies, interop, externalLiveBindings, freeze, namespaceToStringTag, accessedGlobals, t, snippets)}`);
     const exportBlock = getExportBlock$1(exports, dependencies, namedExportsMode, interop, snippets, t, externalLiveBindings);
-    let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, esModule === true || (esModule === 'if-default-prop' && hasDefaultExport), namespaceToStringTag, snippets);
+    let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, esModule, namespaceToStringTag, _, n);
     if (namespaceMarkers) {
         namespaceMarkers = n + n + namespaceMarkers;
     }
-    magicString
-        .append(`${exportBlock}${namespaceMarkers}${outro}`)
-        .trim()
-        .indent(t)
-        .append(wrapperOutro)
-        .prepend(wrapperIntro);
+    magicString.append(`${exportBlock}${namespaceMarkers}${outro}`);
+    return magicString.trim().indent(t).append(wrapperOutro).prepend(wrapperIntro);
 }
 
 const finalisers = { amd, cjs, es, iife, system, umd };
 
-const concatSeparator = (out, next) => (next ? `${out}\n${next}` : out);
-const concatDblSeparator = (out, next) => (next ? `${out}\n\n${next}` : out);
-async function createAddons(options, outputPluginDriver, chunk) {
-    try {
-        let [banner, footer, intro, outro] = await Promise.all([
-            outputPluginDriver.hookReduceValue('banner', options.banner(chunk), [chunk], concatSeparator),
-            outputPluginDriver.hookReduceValue('footer', options.footer(chunk), [chunk], concatSeparator),
-            outputPluginDriver.hookReduceValue('intro', options.intro(chunk), [chunk], concatDblSeparator),
-            outputPluginDriver.hookReduceValue('outro', options.outro(chunk), [chunk], concatDblSeparator)
-        ]);
-        if (intro)
-            intro += '\n\n';
-        if (outro)
-            outro = `\n\n${outro}`;
-        if (banner)
-            banner += '\n';
-        if (footer)
-            footer = '\n' + footer;
-        return { banner, footer, intro, outro };
+class Source {
+    constructor(filename, content) {
+        this.isOriginal = true;
+        this.filename = filename;
+        this.content = content;
     }
-    catch (error_) {
-        return error(errorAddonNotGenerated(error_.message, error_.hook, error_.plugin));
+    traceSegment(line, column, name) {
+        return { column, line, name, source: this };
     }
 }
+class Link {
+    constructor(map, sources) {
+        this.sources = sources;
+        this.names = map.names;
+        this.mappings = map.mappings;
+    }
+    traceMappings() {
+        const sources = [];
+        const sourcesContent = [];
+        const names = [];
+        const nameIndexMap = new Map();
+        const mappings = [];
+        for (const line of this.mappings) {
+            const tracedLine = [];
+            for (const segment of line) {
+                if (segment.length == 1)
+                    continue;
+                const source = this.sources[segment[1]];
+                if (!source)
+                    continue;
+                const traced = source.traceSegment(segment[2], segment[3], segment.length === 5 ? this.names[segment[4]] : '');
+                if (traced) {
+                    // newer sources are more likely to be used, so search backwards.
+                    let sourceIndex = sources.lastIndexOf(traced.source.filename);
+                    if (sourceIndex === -1) {
+                        sourceIndex = sources.length;
+                        sources.push(traced.source.filename);
+                        sourcesContent[sourceIndex] = traced.source.content;
+                    }
+                    else if (sourcesContent[sourceIndex] == null) {
+                        sourcesContent[sourceIndex] = traced.source.content;
+                    }
+                    else if (traced.source.content != null &&
+                        sourcesContent[sourceIndex] !== traced.source.content) {
+                        return error({
+                            message: `Multiple conflicting contents for sourcemap source ${traced.source.filename}`
+                        });
+                    }
+                    const tracedSegment = [
+                        segment[0],
+                        sourceIndex,
+                        traced.line,
+                        traced.column
+                    ];
+                    if (traced.name) {
+                        let nameIndex = nameIndexMap.get(traced.name);
+                        if (nameIndex === undefined) {
+                            nameIndex = names.length;
+                            names.push(traced.name);
+                            nameIndexMap.set(traced.name, nameIndex);
+                        }
+                        tracedSegment[4] = nameIndex;
+                    }
+                    tracedLine.push(tracedSegment);
+                }
+            }
+            mappings.push(tracedLine);
+        }
+        return { mappings, names, sources, sourcesContent };
+    }
+    traceSegment(line, column, name) {
+        const segments = this.mappings[line];
+        if (!segments)
+            return null;
+        // binary search through segments for the given column
+        let i = 0;
+        let j = segments.length - 1;
+        while (i <= j) {
+            const m = (i + j) >> 1;
+            const segment = segments[m];
+            if (segment[0] === column) {
+                if (segment.length == 1)
+                    return null;
+                const source = this.sources[segment[1]];
+                if (!source)
+                    return null;
+                return source.traceSegment(segment[2], segment[3], segment.length === 5 ? this.names[segment[4]] : name);
+            }
+            if (segment[0] > column) {
+                j = m - 1;
+            }
+            else {
+                i = m + 1;
+            }
+        }
+        return null;
+    }
+}
+function getLinkMap(warn) {
+    return function linkMap(source, map) {
+        if (map.mappings) {
+            return new Link(map, [source]);
+        }
+        warn({
+            code: 'SOURCEMAP_BROKEN',
+            message: `Sourcemap is likely to be incorrect: a plugin (${map.plugin}) was used to transform ` +
+                "files, but didn't generate a sourcemap for the transformation. Consult the plugin " +
+                'documentation for help',
+            plugin: map.plugin,
+            url: `https://rollupjs.org/guide/en/#warning-sourcemap-is-likely-to-be-incorrect`
+        });
+        return new Link({
+            mappings: [],
+            names: []
+        }, [source]);
+    };
+}
+function getCollapsedSourcemap(id, originalCode, originalSourcemap, sourcemapChain, linkMap) {
+    let source;
+    if (!originalSourcemap) {
+        source = new Source(id, originalCode);
+    }
+    else {
+        const sources = originalSourcemap.sources;
+        const sourcesContent = originalSourcemap.sourcesContent || [];
+        const directory = path$2.dirname(id) || '.';
+        const sourceRoot = originalSourcemap.sourceRoot || '.';
+        const baseSources = sources.map((source, i) => new Source(path$2.resolve(directory, sourceRoot, source), sourcesContent[i]));
+        source = new Link(originalSourcemap, baseSources);
+    }
+    return sourcemapChain.reduce(linkMap, source);
+}
+function collapseSourcemaps(file, map, modules, bundleSourcemapChain, excludeContent, warn) {
+    const linkMap = getLinkMap(warn);
+    const moduleSources = modules
+        .filter(module => !module.excludeFromSourcemap)
+        .map(module => getCollapsedSourcemap(module.id, module.originalCode, module.originalSourcemap, module.sourcemapChain, linkMap));
+    // DecodedSourceMap (from magic-string) uses a number[] instead of the more
+    // correct SourceMapSegment tuples. Cast it here to gain type safety.
+    let source = new Link(map, moduleSources);
+    source = bundleSourcemapChain.reduce(linkMap, source);
+    let { sources, sourcesContent, names, mappings } = source.traceMappings();
+    if (file) {
+        const directory = path$2.dirname(file);
+        sources = sources.map((source) => path$2.relative(directory, source));
+        file = path$2.basename(file);
+    }
+    sourcesContent = (excludeContent ? null : sourcesContent);
+    return new SourceMap({ file, mappings, names, sources, sourcesContent });
+}
+function collapseSourcemap(id, originalCode, originalSourcemap, sourcemapChain, warn) {
+    if (!sourcemapChain.length) {
+        return originalSourcemap;
+    }
+    const source = getCollapsedSourcemap(id, originalCode, originalSourcemap, sourcemapChain, getLinkMap(warn));
+    const map = source.traceMappings();
+    return { version: 3, ...map };
+}
+
+const createHash = () => crypto.createHash('sha256');
 
 const DECONFLICT_IMPORTED_VARIABLES_BY_FORMAT = {
     amd: deconflictImportsOther,
@@ -15184,69 +13990,68 @@
     system: deconflictImportsEsmOrSystem,
     umd: deconflictImportsOther
 };
-function deconflictChunk(modules, dependenciesToBeDeconflicted, imports, usedNames, format, interop, preserveModules, externalLiveBindings, chunkByModule, externalChunkByModule, syntheticExports, exportNamesByVariable, accessedGlobalsByScope, includedNamespaces) {
-    const reversedModules = [...modules].reverse();
+function deconflictChunk(modules, dependenciesToBeDeconflicted, imports, usedNames, format, interop, preserveModules, externalLiveBindings, chunkByModule, syntheticExports, exportNamesByVariable, accessedGlobalsByScope, includedNamespaces) {
+    const reversedModules = modules.slice().reverse();
     for (const module of reversedModules) {
         module.scope.addUsedOutsideNames(usedNames, format, exportNamesByVariable, accessedGlobalsByScope);
     }
     deconflictTopLevelVariables(usedNames, reversedModules, includedNamespaces);
-    DECONFLICT_IMPORTED_VARIABLES_BY_FORMAT[format](usedNames, imports, dependenciesToBeDeconflicted, interop, preserveModules, externalLiveBindings, chunkByModule, externalChunkByModule, syntheticExports);
+    DECONFLICT_IMPORTED_VARIABLES_BY_FORMAT[format](usedNames, imports, dependenciesToBeDeconflicted, interop, preserveModules, externalLiveBindings, chunkByModule, syntheticExports);
     for (const module of reversedModules) {
         module.scope.deconflict(format, exportNamesByVariable, accessedGlobalsByScope);
     }
 }
-function deconflictImportsEsmOrSystem(usedNames, imports, dependenciesToBeDeconflicted, _interop, preserveModules, _externalLiveBindings, chunkByModule, externalChunkByModule, syntheticExports) {
+function deconflictImportsEsmOrSystem(usedNames, imports, dependenciesToBeDeconflicted, _interop, preserveModules, _externalLiveBindings, chunkByModule, syntheticExports) {
     // This is needed for namespace reexports
     for (const dependency of dependenciesToBeDeconflicted.dependencies) {
-        if (preserveModules || dependency instanceof ExternalChunk) {
-            dependency.variableName = getSafeName(dependency.suggestedVariableName, usedNames, null);
+        if (preserveModules || dependency instanceof ExternalModule) {
+            dependency.variableName = getSafeName(dependency.suggestedVariableName, usedNames);
         }
     }
     for (const variable of imports) {
         const module = variable.module;
         const name = variable.name;
         if (variable.isNamespace && (preserveModules || module instanceof ExternalModule)) {
-            variable.setRenderNames(null, (module instanceof ExternalModule
-                ? externalChunkByModule.get(module)
-                : chunkByModule.get(module)).variableName);
+            variable.setRenderNames(null, (module instanceof ExternalModule ? module : chunkByModule.get(module)).variableName);
         }
         else if (module instanceof ExternalModule && name === 'default') {
             variable.setRenderNames(null, getSafeName([...module.exportedVariables].some(([exportedVariable, exportedName]) => exportedName === '*' && exportedVariable.included)
                 ? module.suggestedVariableName + '__default'
-                : module.suggestedVariableName, usedNames, variable.forbiddenNames));
+                : module.suggestedVariableName, usedNames));
         }
         else {
-            variable.setRenderNames(null, getSafeName(name, usedNames, variable.forbiddenNames));
+            variable.setRenderNames(null, getSafeName(name, usedNames));
         }
     }
     for (const variable of syntheticExports) {
-        variable.setRenderNames(null, getSafeName(variable.name, usedNames, variable.forbiddenNames));
+        variable.setRenderNames(null, getSafeName(variable.name, usedNames));
     }
 }
-function deconflictImportsOther(usedNames, imports, { deconflictedDefault, deconflictedNamespace, dependencies }, interop, preserveModules, externalLiveBindings, chunkByModule, externalChunkByModule) {
-    for (const chunk of dependencies) {
-        chunk.variableName = getSafeName(chunk.suggestedVariableName, usedNames, null);
+function deconflictImportsOther(usedNames, imports, { deconflictedDefault, deconflictedNamespace, dependencies }, interop, preserveModules, externalLiveBindings, chunkByModule) {
+    for (const chunkOrExternalModule of dependencies) {
+        chunkOrExternalModule.variableName = getSafeName(chunkOrExternalModule.suggestedVariableName, usedNames);
     }
-    for (const chunk of deconflictedNamespace) {
-        chunk.namespaceVariableName = getSafeName(`${chunk.suggestedVariableName}__namespace`, usedNames, null);
+    for (const externalModuleOrChunk of deconflictedNamespace) {
+        externalModuleOrChunk.namespaceVariableName = getSafeName(`${externalModuleOrChunk.suggestedVariableName}__namespace`, usedNames);
     }
     for (const externalModule of deconflictedDefault) {
-        externalModule.defaultVariableName =
-            deconflictedNamespace.has(externalModule) &&
-                canDefaultBeTakenFromNamespace(interop(externalModule.id), externalLiveBindings)
-                ? externalModule.namespaceVariableName
-                : getSafeName(`${externalModule.suggestedVariableName}__default`, usedNames, null);
+        if (deconflictedNamespace.has(externalModule) &&
+            canDefaultBeTakenFromNamespace(String(interop(externalModule.id)), externalLiveBindings)) {
+            externalModule.defaultVariableName = externalModule.namespaceVariableName;
+        }
+        else {
+            externalModule.defaultVariableName = getSafeName(`${externalModule.suggestedVariableName}__default`, usedNames);
+        }
     }
     for (const variable of imports) {
         const module = variable.module;
         if (module instanceof ExternalModule) {
-            const chunk = externalChunkByModule.get(module);
             const name = variable.name;
             if (name === 'default') {
-                const moduleInterop = interop(module.id);
+                const moduleInterop = String(interop(module.id));
                 const variableName = defaultInteropHelpersByInteropType[moduleInterop]
-                    ? chunk.defaultVariableName
-                    : chunk.variableName;
+                    ? module.defaultVariableName
+                    : module.variableName;
                 if (isDefaultAProperty(moduleInterop, externalLiveBindings)) {
                     variable.setRenderNames(variableName, 'default');
                 }
@@ -15255,13 +14060,13 @@
                 }
             }
             else if (name === '*') {
-                variable.setRenderNames(null, namespaceInteropHelpersByInteropType[interop(module.id)]
-                    ? chunk.namespaceVariableName
-                    : chunk.variableName);
+                variable.setRenderNames(null, namespaceInteropHelpersByInteropType[String(interop(module.id))]
+                    ? module.namespaceVariableName
+                    : module.variableName);
             }
             else {
                 // if the second parameter is `null`, it uses its "name" for the property name
-                variable.setRenderNames(chunk.variableName, null);
+                variable.setRenderNames(module.variableName, null);
             }
         }
         else {
@@ -15285,21 +14090,30 @@
                 // this will only happen for exports in some formats
                 !(variable.renderBaseName ||
                     (variable instanceof ExportDefaultVariable && variable.getOriginalVariable() !== variable))) {
-                variable.setRenderNames(null, getSafeName(variable.name, usedNames, variable.forbiddenNames));
+                variable.setRenderNames(null, getSafeName(variable.name, usedNames));
             }
         }
         if (includedNamespaces.has(module)) {
             const namespace = module.namespace;
-            namespace.setRenderNames(null, getSafeName(namespace.name, usedNames, namespace.forbiddenNames));
+            namespace.setRenderNames(null, getSafeName(namespace.name, usedNames));
         }
     }
 }
 
+const needsEscapeRegEx = /[\\'\r\n\u2028\u2029]/;
+const quoteNewlineRegEx = /(['\r\n\u2028\u2029])/g;
+const backSlashRegEx = /\\/g;
+function escapeId(id) {
+    if (!id.match(needsEscapeRegEx))
+        return id;
+    return id.replace(backSlashRegEx, '\\\\').replace(quoteNewlineRegEx, '\\$1');
+}
+
 function assignExportsToMangledNames(exports, exportsByName, exportNamesByVariable) {
     let nameIndex = 0;
     for (const variable of exports) {
-        let [exportName] = variable.name;
-        if (exportsByName.has(exportName)) {
+        let exportName = variable.name[0];
+        if (exportsByName[exportName]) {
             do {
                 exportName = toBase64(++nameIndex);
                 // skip past leading number identifiers
@@ -15307,9 +14121,9 @@
                     nameIndex += 9 * 64 ** (exportName.length - 1);
                     exportName = toBase64(nameIndex);
                 }
-            } while (RESERVED_NAMES$1.has(exportName) || exportsByName.has(exportName));
+            } while (RESERVED_NAMES[exportName] || exportsByName[exportName]);
         }
-        exportsByName.set(exportName, variable);
+        exportsByName[exportName] = variable;
         exportNamesByVariable.set(variable, [exportName]);
     }
 }
@@ -15317,34 +14131,37 @@
     for (const variable of exports) {
         let nameIndex = 0;
         let exportName = variable.name;
-        while (exportsByName.has(exportName)) {
+        while (exportsByName[exportName]) {
             exportName = variable.name + '$' + ++nameIndex;
         }
-        exportsByName.set(exportName, variable);
+        exportsByName[exportName] = variable;
         exportNamesByVariable.set(variable, [exportName]);
     }
 }
 
-function getExportMode(chunk, { exports: exportMode, name, format }, facadeModuleId, warn) {
+function getExportMode(chunk, { exports: exportMode, name, format }, unsetOptions, facadeModuleId, warn) {
     const exportKeys = chunk.getExportNames();
     if (exportMode === 'default') {
         if (exportKeys.length !== 1 || exportKeys[0] !== 'default') {
-            return error(errorIncompatibleExportOptionValue('default', exportKeys, facadeModuleId));
+            return error(errIncompatibleExportOptionValue('default', exportKeys, facadeModuleId));
         }
     }
-    else if (exportMode === 'none' && exportKeys.length > 0) {
-        return error(errorIncompatibleExportOptionValue('none', exportKeys, facadeModuleId));
+    else if (exportMode === 'none' && exportKeys.length) {
+        return error(errIncompatibleExportOptionValue('none', exportKeys, facadeModuleId));
     }
     if (exportMode === 'auto') {
         if (exportKeys.length === 0) {
             exportMode = 'none';
         }
         else if (exportKeys.length === 1 && exportKeys[0] === 'default') {
+            if (format === 'cjs' && unsetOptions.has('exports')) {
+                warn(errPreferNamedExports(facadeModuleId));
+            }
             exportMode = 'default';
         }
         else {
-            if (format !== 'es' && format !== 'system' && exportKeys.includes('default')) {
-                warn(errorMixedExport(facadeModuleId, name));
+            if (format !== 'es' && format !== 'system' && exportKeys.indexOf('default') !== -1) {
+                warn(errMixedExport(facadeModuleId, name));
             }
             exportMode = 'named';
         }
@@ -15367,10 +14184,10 @@
     }
     // Otherwise, we need to guess the multiple
     const min = spaced.reduce((previous, current) => {
-        const numberSpaces = /^ +/.exec(current)[0].length;
-        return Math.min(numberSpaces, previous);
+        const numSpaces = /^ +/.exec(current)[0].length;
+        return Math.min(numSpaces, previous);
     }, Infinity);
-    return ' '.repeat(min);
+    return new Array(min + 1).join(' ');
 }
 function getIndentString(modules, options) {
     if (options.indent !== true)
@@ -15383,14 +14200,14 @@
     return '\t';
 }
 
-function getStaticDependencies(chunk, orderedModules, chunkByModule, externalChunkByModule) {
+function getStaticDependencies(chunk, orderedModules, chunkByModule) {
     const staticDependencyBlocks = [];
     const handledDependencies = new Set();
     for (let modulePos = orderedModules.length - 1; modulePos >= 0; modulePos--) {
         const module = orderedModules[modulePos];
         if (!handledDependencies.has(module)) {
             const staticDependencies = [];
-            addStaticDependencies(module, staticDependencies, handledDependencies, chunk, chunkByModule, externalChunkByModule);
+            addStaticDependencies(module, staticDependencies, handledDependencies, chunk, chunkByModule);
             staticDependencyBlocks.unshift(staticDependencies);
         }
     }
@@ -15402,11 +14219,11 @@
     }
     return dependencies;
 }
-function addStaticDependencies(module, staticDependencies, handledModules, chunk, chunkByModule, externalChunkByModule) {
+function addStaticDependencies(module, staticDependencies, handledModules, chunk, chunkByModule) {
     const dependencies = module.getDependenciesToBeIncluded();
     for (const dependency of dependencies) {
         if (dependency instanceof ExternalModule) {
-            staticDependencies.push(externalChunkByModule.get(dependency));
+            staticDependencies.push(dependency);
             continue;
         }
         const dependencyChunk = chunkByModule.get(dependency);
@@ -15416,137 +14233,97 @@
         }
         if (!handledModules.has(dependency)) {
             handledModules.add(dependency);
-            addStaticDependencies(dependency, staticDependencies, handledModules, chunk, chunkByModule, externalChunkByModule);
+            addStaticDependencies(dependency, staticDependencies, handledModules, chunk, chunkByModule);
         }
     }
 }
 
-// Four random characters from the private use area to minimize risk of conflicts
-const hashPlaceholderLeft = '!~{';
-const hashPlaceholderRight = '}~';
-const hashPlaceholderOverhead = hashPlaceholderLeft.length + hashPlaceholderRight.length;
-// This is the size of a sha256
-const maxHashSize = 64;
-const defaultHashSize = 8;
-const getHashPlaceholderGenerator = () => {
-    let nextIndex = 0;
-    return (optionName, hashSize = defaultHashSize) => {
-        if (hashSize > maxHashSize) {
-            return error(errorFailedValidation(`Hashes cannot be longer than ${maxHashSize} characters, received ${hashSize}. Check the "${optionName}" option.`));
-        }
-        const placeholder = `${hashPlaceholderLeft}${toBase64(++nextIndex).padStart(hashSize - hashPlaceholderOverhead, '0')}${hashPlaceholderRight}`;
-        if (placeholder.length > hashSize) {
-            return error(errorFailedValidation(`To generate hashes for this number of chunks (currently ${nextIndex}), you need a minimum hash size of ${placeholder.length}, received ${hashSize}. Check the "${optionName}" option.`));
-        }
-        return placeholder;
-    };
-};
-const REPLACER_REGEX = new RegExp(`${hashPlaceholderLeft}[0-9a-zA-Z_$]{1,${maxHashSize - hashPlaceholderOverhead}}${hashPlaceholderRight}`, 'g');
-const replacePlaceholders = (code, hashesByPlaceholder) => code.replace(REPLACER_REGEX, placeholder => hashesByPlaceholder.get(placeholder) || placeholder);
-const replaceSinglePlaceholder = (code, placeholder, value) => code.replace(REPLACER_REGEX, match => (match === placeholder ? value : match));
-const replacePlaceholdersWithDefaultAndGetContainedPlaceholders = (code, placeholders) => {
-    const containedPlaceholders = new Set();
-    const transformedCode = code.replace(REPLACER_REGEX, placeholder => {
-        if (placeholders.has(placeholder)) {
-            containedPlaceholders.add(placeholder);
-            return `${hashPlaceholderLeft}${'0'.repeat(placeholder.length - hashPlaceholderOverhead)}${hashPlaceholderRight}`;
-        }
-        return placeholder;
-    });
-    return { containedPlaceholders, transformedCode };
-};
-
-const lowercaseBundleKeys = Symbol('bundleKeys');
-const FILE_PLACEHOLDER = {
-    type: 'placeholder'
-};
-const getOutputBundle = (outputBundleBase) => {
-    const reservedLowercaseBundleKeys = new Set();
-    return new Proxy(outputBundleBase, {
-        deleteProperty(target, key) {
-            if (typeof key === 'string') {
-                reservedLowercaseBundleKeys.delete(key.toLowerCase());
-            }
-            return Reflect.deleteProperty(target, key);
-        },
-        get(target, key) {
-            if (key === lowercaseBundleKeys) {
-                return reservedLowercaseBundleKeys;
-            }
-            return Reflect.get(target, key);
-        },
-        set(target, key, value) {
-            if (typeof key === 'string') {
-                reservedLowercaseBundleKeys.add(key.toLowerCase());
-            }
-            return Reflect.set(target, key, value);
-        }
-    });
-};
-const removeUnreferencedAssets = (outputBundle) => {
-    const unreferencedAssets = new Set();
-    const bundleEntries = Object.values(outputBundle);
-    for (const asset of bundleEntries) {
-        asset.type === 'asset' && asset.needsCodeReference && unreferencedAssets.add(asset.fileName);
+function decodedSourcemap(map) {
+    if (!map)
+        return null;
+    if (typeof map === 'string') {
+        map = JSON.parse(map);
     }
-    for (const chunk of bundleEntries) {
-        if (chunk.type === 'chunk') {
-            for (const referencedFile of chunk.referencedFiles) {
-                unreferencedAssets.has(referencedFile) && unreferencedAssets.delete(referencedFile);
-            }
-        }
+    if (map.mappings === '') {
+        return {
+            mappings: [],
+            names: [],
+            sources: [],
+            version: 3
+        };
     }
-    for (const file of unreferencedAssets) {
-        delete outputBundle[file];
+    let mappings;
+    if (typeof map.mappings === 'string') {
+        mappings = decode(map.mappings);
     }
-};
+    else {
+        mappings = map.mappings;
+    }
+    return { ...map, mappings };
+}
+
+function renderChunk({ code, options, outputPluginDriver, renderChunk, sourcemapChain }) {
+    const renderChunkReducer = (code, result, plugin) => {
+        if (result == null)
+            return code;
+        if (typeof result === 'string')
+            result = {
+                code: result,
+                map: undefined
+            };
+        // strict null check allows 'null' maps to not be pushed to the chain, while 'undefined' gets the missing map warning
+        if (result.map !== null) {
+            const map = decodedSourcemap(result.map);
+            sourcemapChain.push(map || { missing: true, plugin: plugin.name });
+        }
+        return result.code;
+    };
+    return outputPluginDriver.hookReduceArg0('renderChunk', [code, renderChunk, options], renderChunkReducer);
+}
 
 function renderNamePattern(pattern, patternName, replacements) {
     if (isPathFragment(pattern))
-        return error(errorFailedValidation(`Invalid pattern "${pattern}" for "${patternName}", patterns can be neither absolute nor relative paths. If you want your files to be stored in a subdirectory, write its name without a leading slash like this: subdirectory/pattern.`));
-    return pattern.replace(/\[(\w+)(:\d+)?]/g, (_match, type, size) => {
-        if (!replacements.hasOwnProperty(type) || (size && type !== 'hash')) {
-            return error(errorFailedValidation(`"[${type}${size || ''}]" is not a valid placeholder in the "${patternName}" pattern.`));
+        return error(errFailedValidation(`Invalid pattern "${pattern}" for "${patternName}", patterns can be neither absolute nor relative paths.`));
+    return pattern.replace(/\[(\w+)\]/g, (_match, type) => {
+        if (!replacements.hasOwnProperty(type)) {
+            return error(errFailedValidation(`"[${type}]" is not a valid placeholder in "${patternName}" pattern.`));
         }
-        const replacement = replacements[type](size && Number.parseInt(size.slice(1)));
+        const replacement = replacements[type]();
         if (isPathFragment(replacement))
-            return error(errorFailedValidation(`Invalid substitution "${replacement}" for placeholder "[${type}]" in "${patternName}" pattern, can be neither absolute nor relative path.`));
+            return error(errFailedValidation(`Invalid substitution "${replacement}" for placeholder "[${type}]" in "${patternName}" pattern, can be neither absolute nor relative path.`));
         return replacement;
     });
 }
-function makeUnique(name, { [lowercaseBundleKeys]: reservedLowercaseBundleKeys }) {
-    if (!reservedLowercaseBundleKeys.has(name.toLowerCase()))
+function makeUnique(name, existingNames) {
+    const existingNamesLowercase = new Set(Object.keys(existingNames).map(key => key.toLowerCase()));
+    if (!existingNamesLowercase.has(name.toLocaleLowerCase()))
         return name;
-    const extension = node_path.extname(name);
-    name = name.slice(0, Math.max(0, name.length - extension.length));
+    const ext = path$2.extname(name);
+    name = name.substr(0, name.length - ext.length);
     let uniqueName, uniqueIndex = 1;
-    while (reservedLowercaseBundleKeys.has((uniqueName = name + ++uniqueIndex + extension).toLowerCase()))
+    while (existingNamesLowercase.has((uniqueName = name + ++uniqueIndex + ext).toLowerCase()))
         ;
     return uniqueName;
 }
 
-const NON_ASSET_EXTENSIONS = new Set([
-    '.js',
-    '.jsx',
-    '.ts',
-    '.tsx',
-    '.mjs',
-    '.mts',
-    '.cjs',
-    '.cts'
-]);
-function getGlobalName(chunk, globals, hasExports, warn) {
-    const globalName = typeof globals === 'function' ? globals(chunk.id) : globals[chunk.id];
+const NON_ASSET_EXTENSIONS = ['.js', '.jsx', '.ts', '.tsx'];
+function getGlobalName(module, globals, hasExports, warn) {
+    const globalName = typeof globals === 'function' ? globals(module.id) : globals[module.id];
     if (globalName) {
         return globalName;
     }
     if (hasExports) {
-        warn(errorMissingGlobalName(chunk.id, chunk.variableName));
-        return chunk.variableName;
+        warn({
+            code: 'MISSING_GLOBAL_NAME',
+            guess: module.variableName,
+            message: `No name was provided for external module '${module.id}' in output.globals – guessing '${module.variableName}'`,
+            source: module.id
+        });
+        return module.variableName;
     }
 }
 class Chunk {
-    constructor(orderedModules, inputOptions, outputOptions, unsetOptions, pluginDriver, modulesById, chunkByModule, externalChunkByModule, facadeChunkByModule, includedNamespaces, manualChunkAlias, getPlaceholder, bundle, inputBase, snippets) {
+    constructor(orderedModules, inputOptions, outputOptions, unsetOptions, pluginDriver, modulesById, chunkByModule, facadeChunkByModule, includedNamespaces, manualChunkAlias) {
         this.orderedModules = orderedModules;
         this.inputOptions = inputOptions;
         this.outputOptions = outputOptions;
@@ -15554,47 +14331,43 @@
         this.pluginDriver = pluginDriver;
         this.modulesById = modulesById;
         this.chunkByModule = chunkByModule;
-        this.externalChunkByModule = externalChunkByModule;
         this.facadeChunkByModule = facadeChunkByModule;
         this.includedNamespaces = includedNamespaces;
         this.manualChunkAlias = manualChunkAlias;
-        this.getPlaceholder = getPlaceholder;
-        this.bundle = bundle;
-        this.inputBase = inputBase;
-        this.snippets = snippets;
         this.entryModules = [];
         this.exportMode = 'named';
         this.facadeModule = null;
+        this.id = null;
         this.namespaceVariableName = '';
+        this.needsExportsShim = false;
         this.variableName = '';
         this.accessedGlobalsByScope = new Map();
         this.dependencies = new Set();
+        this.dynamicDependencies = new Set();
         this.dynamicEntryModules = [];
         this.dynamicName = null;
         this.exportNamesByVariable = new Map();
         this.exports = new Set();
-        this.exportsByName = new Map();
+        this.exportsByName = Object.create(null);
         this.fileName = null;
         this.implicitEntryModules = [];
         this.implicitlyLoadedBefore = new Set();
         this.imports = new Set();
-        this.includedDynamicImports = null;
-        this.includedReexportsByModule = new Map();
-        // This may be updated in the constructor
+        this.indentString = undefined;
         this.isEmpty = true;
         this.name = null;
-        this.needsExportsShim = false;
-        this.preRenderedChunkInfo = null;
-        this.preliminaryFileName = null;
-        this.renderedChunkInfo = null;
         this.renderedDependencies = null;
+        this.renderedExports = null;
+        this.renderedHash = undefined;
+        this.renderedModuleSources = new Map();
         this.renderedModules = Object.create(null);
+        this.renderedSource = null;
         this.sortedExportNames = null;
         this.strictFacade = false;
+        this.usedModules = undefined;
         this.execIndex = orderedModules.length > 0 ? orderedModules[0].execIndex : Infinity;
         const chunkModules = new Set(orderedModules);
         for (const module of orderedModules) {
-            chunkByModule.set(module, this);
             if (module.namespace.included) {
                 includedNamespaces.add(module);
             }
@@ -15620,19 +14393,17 @@
         }
         this.suggestedVariableName = makeLegal(this.generateVariableName());
     }
-    static generateFacade(inputOptions, outputOptions, unsetOptions, pluginDriver, modulesById, chunkByModule, externalChunkByModule, facadeChunkByModule, includedNamespaces, facadedModule, facadeName, getPlaceholder, bundle, inputBase, snippets) {
-        const chunk = new Chunk([], inputOptions, outputOptions, unsetOptions, pluginDriver, modulesById, chunkByModule, externalChunkByModule, facadeChunkByModule, includedNamespaces, null, getPlaceholder, bundle, inputBase, snippets);
+    static generateFacade(inputOptions, outputOptions, unsetOptions, pluginDriver, modulesById, chunkByModule, facadeChunkByModule, includedNamespaces, facadedModule, facadeName) {
+        const chunk = new Chunk([], inputOptions, outputOptions, unsetOptions, pluginDriver, modulesById, chunkByModule, facadeChunkByModule, includedNamespaces, null);
         chunk.assignFacadeName(facadeName, facadedModule);
         if (!facadeChunkByModule.has(facadedModule)) {
             facadeChunkByModule.set(facadedModule, chunk);
         }
         for (const dependency of facadedModule.getDependenciesToBeIncluded()) {
-            chunk.dependencies.add(dependency instanceof Module
-                ? chunkByModule.get(dependency)
-                : externalChunkByModule.get(dependency));
+            chunk.dependencies.add(dependency instanceof Module ? chunkByModule.get(dependency) : dependency);
         }
         if (!chunk.dependencies.has(chunkByModule.get(facadedModule)) &&
-            facadedModule.info.moduleSideEffects &&
+            facadedModule.info.hasModuleSideEffects &&
             facadedModule.hasEffects()) {
             chunk.dependencies.add(chunkByModule.get(facadedModule));
         }
@@ -15645,6 +14416,17 @@
         const moduleExportNamesByVariable = module.getExportNamesByVariable();
         for (const exposedVariable of this.exports) {
             if (!moduleExportNamesByVariable.has(exposedVariable)) {
+                if (moduleExportNamesByVariable.size === 0 &&
+                    module.isUserDefinedEntryPoint &&
+                    module.preserveSignature === 'strict' &&
+                    this.unsetOptions.has('preserveEntrySignatures')) {
+                    this.inputOptions.onwarn({
+                        code: 'EMPTY_FACADE',
+                        id: module.id,
+                        message: `To preserve the export signature of the entry module "${relativeId(module.id)}", an empty facade chunk was created. This often happens when creating a bundle for a web app where chunks are placed in script tags and exports are ignored. In this case it is recommended to set "preserveEntrySignatures: false" to avoid this and reduce the number of chunks. Otherwise if this is intentional, set "preserveEntrySignatures: 'strict'" explicitly to silence this warning.`,
+                        url: 'https://rollupjs.org/guide/en/#preserveentrysignatures'
+                    });
+                }
                 return false;
             }
         }
@@ -15655,25 +14437,6 @@
         }
         return true;
     }
-    finalizeChunk(code, map, hashesByPlaceholder) {
-        const renderedChunkInfo = this.getRenderedChunkInfo();
-        const finalize = (code) => replacePlaceholders(code, hashesByPlaceholder);
-        const fileName = (this.fileName = finalize(renderedChunkInfo.fileName));
-        return {
-            ...renderedChunkInfo,
-            code,
-            dynamicImports: renderedChunkInfo.dynamicImports.map(finalize),
-            fileName,
-            implicitlyLoadedBefore: renderedChunkInfo.implicitlyLoadedBefore.map(finalize),
-            importedBindings: Object.fromEntries(Object.entries(renderedChunkInfo.importedBindings).map(([fileName, bindings]) => [
-                finalize(fileName),
-                bindings
-            ])),
-            imports: renderedChunkInfo.imports.map(finalize),
-            map,
-            referencedFiles: renderedChunkInfo.referencedFiles.map(finalize)
-        };
-    }
     generateExports() {
         this.sortedExportNames = null;
         const remainingExports = new Set(this.exports);
@@ -15683,7 +14446,7 @@
             for (const [variable, exportNames] of exportNamesByVariable) {
                 this.exportNamesByVariable.set(variable, [...exportNames]);
                 for (const exportName of exportNames) {
-                    this.exportsByName.set(exportName, variable);
+                    this.exportsByName[exportName] = variable;
                 }
                 remainingExports.delete(variable);
             }
@@ -15695,12 +14458,13 @@
             assignExportsToNames(remainingExports, this.exportsByName, this.exportNamesByVariable);
         }
         if (this.outputOptions.preserveModules || (this.facadeModule && this.facadeModule.info.isEntry))
-            this.exportMode = getExportMode(this, this.outputOptions, this.facadeModule.id, this.inputOptions.onwarn);
+            this.exportMode = getExportMode(this, this.outputOptions, this.unsetOptions, this.facadeModule.id, this.inputOptions.onwarn);
     }
     generateFacades() {
+        var _a;
         const facades = [];
         const entryModules = new Set([...this.entryModules, ...this.implicitEntryModules]);
-        const exposedVariables = new Set(this.dynamicEntryModules.map(({ namespace }) => namespace));
+        const exposedVariables = new Set(this.dynamicEntryModules.map(module => module.namespace));
         for (const module of entryModules) {
             if (module.preserveSignature) {
                 for (const exportedVariable of module.getExportNamesByVariable().keys()) {
@@ -15709,16 +14473,12 @@
             }
         }
         for (const module of entryModules) {
-            // eslint-disable-next-line unicorn/prefer-spread
-            const requiredFacades = Array.from(new Set(module.chunkNames.filter(({ isUserDefined }) => isUserDefined).map(({ name }) => name)), 
-            // mapping must run after Set 'name' dedupe
-            name => ({
+            const requiredFacades = Array.from(module.userChunkNames, name => ({
                 name
             }));
             if (requiredFacades.length === 0 && module.isUserDefinedEntryPoint) {
                 requiredFacades.push({});
             }
-            // eslint-disable-next-line unicorn/prefer-spread
             requiredFacades.push(...Array.from(module.chunkFileNames, fileName => ({ fileName })));
             if (requiredFacades.length === 0) {
                 requiredFacades.push({});
@@ -15726,7 +14486,7 @@
             if (!this.facadeModule) {
                 const needsStrictFacade = module.preserveSignature === 'strict' ||
                     (module.preserveSignature === 'exports-only' &&
-                        module.getExportNamesByVariable().size > 0);
+                        module.getExportNamesByVariable().size !== 0);
                 if (!needsStrictFacade ||
                     this.outputOptions.preserveModules ||
                     this.canModuleBeFacade(module, exposedVariables)) {
@@ -15735,11 +14495,11 @@
                     if (module.preserveSignature) {
                         this.strictFacade = needsStrictFacade;
                     }
-                    this.assignFacadeName(requiredFacades.shift(), module, this.outputOptions.preserveModules);
+                    this.assignFacadeName(requiredFacades.shift(), module);
                 }
             }
             for (const facadeName of requiredFacades) {
-                facades.push(Chunk.generateFacade(this.inputOptions, this.outputOptions, this.unsetOptions, this.pluginDriver, this.modulesById, this.chunkByModule, this.externalChunkByModule, this.facadeChunkByModule, this.includedNamespaces, module, facadeName, this.getPlaceholder, this.bundle, this.inputBase, this.snippets));
+                facades.push(Chunk.generateFacade(this.inputOptions, this.outputOptions, this.unsetOptions, this.pluginDriver, this.modulesById, this.chunkByModule, this.facadeChunkByModule, this.includedNamespaces, module, facadeName));
             }
         }
         for (const module of this.dynamicEntryModules) {
@@ -15756,77 +14516,113 @@
                 this.canModuleBeFacade(module, exposedVariables)) {
                 this.strictFacade = true;
             }
-            else if (!this.facadeChunkByModule.get(module)?.strictFacade) {
+            else if (!((_a = this.facadeChunkByModule.get(module)) === null || _a === void 0 ? void 0 : _a.strictFacade)) {
                 this.includedNamespaces.add(module);
                 this.exports.add(module.namespace);
             }
         }
-        if (!this.outputOptions.preserveModules) {
-            this.addNecessaryImportsForFacades();
-        }
         return facades;
     }
-    getChunkName() {
-        return (this.name ?? (this.name = this.outputOptions.sanitizeFileName(this.getFallbackChunkName())));
-    }
-    getExportNames() {
-        return (this.sortedExportNames ?? (this.sortedExportNames = [...this.exportsByName.keys()].sort()));
-    }
-    getFileName() {
-        return this.fileName || this.getPreliminaryFileName().fileName;
-    }
-    getImportPath(importer) {
-        return escapeId(getImportPath(importer, this.getFileName(), this.outputOptions.format === 'amd' && !this.outputOptions.amd.forceJsExtensionForImports, true));
-    }
-    getPreliminaryFileName() {
-        if (this.preliminaryFileName) {
-            return this.preliminaryFileName;
-        }
-        let fileName;
-        let hashPlaceholder = null;
-        const { chunkFileNames, entryFileNames, file, format, preserveModules } = this.outputOptions;
-        if (file) {
-            fileName = node_path.basename(file);
-        }
-        else if (this.fileName === null) {
-            const [pattern, patternName] = preserveModules || this.facadeModule?.isUserDefinedEntryPoint
-                ? [entryFileNames, 'output.entryFileNames']
-                : [chunkFileNames, 'output.chunkFileNames'];
-            fileName = renderNamePattern(typeof pattern === 'function' ? pattern(this.getPreRenderedChunkInfo()) : pattern, patternName, {
-                format: () => format,
-                hash: size => hashPlaceholder || (hashPlaceholder = this.getPlaceholder(patternName, size)),
+    generateId(addons, options, existingNames, includeHash) {
+        if (this.fileName !== null) {
+            return this.fileName;
+        }
+        const [pattern, patternName] = this.facadeModule && this.facadeModule.isUserDefinedEntryPoint
+            ? [options.entryFileNames, 'output.entryFileNames']
+            : [options.chunkFileNames, 'output.chunkFileNames'];
+        return makeUnique(renderNamePattern(typeof pattern === 'function' ? pattern(this.getChunkInfo()) : pattern, patternName, {
+            format: () => options.format,
+            hash: () => includeHash
+                ? this.computeContentHashWithDependencies(addons, options, existingNames)
+                : '[hash]',
+            name: () => this.getChunkName()
+        }), existingNames);
+    }
+    generateIdPreserveModules(preserveModulesRelativeDir, options, existingNames, unsetOptions) {
+        const id = this.orderedModules[0].id;
+        const sanitizedId = this.outputOptions.sanitizeFileName(id);
+        let path;
+        if (isAbsolute(id)) {
+            const extension = path$2.extname(id);
+            const pattern = unsetOptions.has('entryFileNames')
+                ? '[name][assetExtname].js'
+                : options.entryFileNames;
+            const currentDir = path$2.dirname(sanitizedId);
+            const fileName = renderNamePattern(typeof pattern === 'function' ? pattern(this.getChunkInfo()) : pattern, 'output.entryFileNames', {
+                assetExtname: () => (NON_ASSET_EXTENSIONS.includes(extension) ? '' : extension),
+                ext: () => extension.substr(1),
+                extname: () => extension,
+                format: () => options.format,
                 name: () => this.getChunkName()
             });
-            if (!hashPlaceholder) {
-                fileName = makeUnique(fileName, this.bundle);
+            const currentPath = `${currentDir}/${fileName}`;
+            const { preserveModulesRoot } = options;
+            if (preserveModulesRoot && currentPath.startsWith(preserveModulesRoot)) {
+                path = currentPath.slice(preserveModulesRoot.length).replace(/^[\\/]/, '');
+            }
+            else {
+                path = relative(preserveModulesRelativeDir, currentPath);
             }
         }
         else {
-            fileName = this.fileName;
-        }
-        if (!hashPlaceholder) {
-            this.bundle[fileName] = FILE_PLACEHOLDER;
+            path = `_virtual/${path$2.basename(sanitizedId)}`;
         }
-        // Caching is essential to not conflict with the file name reservation above
-        return (this.preliminaryFileName = { fileName, hashPlaceholder });
+        return makeUnique(normalize(path), existingNames);
     }
-    getRenderedChunkInfo() {
-        if (this.renderedChunkInfo) {
-            return this.renderedChunkInfo;
-        }
-        return (this.renderedChunkInfo = {
-            ...this.getPreRenderedChunkInfo(),
-            dynamicImports: this.getDynamicDependencies().map(resolveFileName),
-            fileName: this.getFileName(),
-            // eslint-disable-next-line unicorn/prefer-spread
-            implicitlyLoadedBefore: Array.from(this.implicitlyLoadedBefore, resolveFileName),
-            importedBindings: getImportedBindingsPerDependency(this.getRenderedDependencies(), resolveFileName),
-            // eslint-disable-next-line unicorn/prefer-spread
-            imports: Array.from(this.dependencies, resolveFileName),
+    getChunkInfo() {
+        const facadeModule = this.facadeModule;
+        const getChunkName = this.getChunkName.bind(this);
+        return {
+            exports: this.getExportNames(),
+            facadeModuleId: facadeModule && facadeModule.id,
+            isDynamicEntry: this.dynamicEntryModules.length > 0,
+            isEntry: facadeModule !== null && facadeModule.info.isEntry,
+            isImplicitEntry: this.implicitEntryModules.length > 0,
             modules: this.renderedModules,
+            get name() {
+                return getChunkName();
+            },
+            type: 'chunk'
+        };
+    }
+    getChunkInfoWithFileNames() {
+        return Object.assign(this.getChunkInfo(), {
+            code: undefined,
+            dynamicImports: Array.from(this.dynamicDependencies, getId),
+            fileName: this.id,
+            implicitlyLoadedBefore: Array.from(this.implicitlyLoadedBefore, getId),
+            importedBindings: this.getImportedBindingsPerDependency(),
+            imports: Array.from(this.dependencies, getId),
+            map: undefined,
             referencedFiles: this.getReferencedFiles()
         });
     }
+    getChunkName() {
+        return (this.name || (this.name = this.outputOptions.sanitizeFileName(this.getFallbackChunkName())));
+    }
+    getExportNames() {
+        return (this.sortedExportNames || (this.sortedExportNames = Object.keys(this.exportsByName).sort()));
+    }
+    getRenderedHash() {
+        if (this.renderedHash)
+            return this.renderedHash;
+        const hash = createHash();
+        const hashAugmentation = this.pluginDriver.hookReduceValueSync('augmentChunkHash', '', [this.getChunkInfo()], (augmentation, pluginHash) => {
+            if (pluginHash) {
+                augmentation += pluginHash;
+            }
+            return augmentation;
+        });
+        hash.update(hashAugmentation);
+        hash.update(this.renderedSource.toString());
+        hash.update(this.getExportNames()
+            .map(exportName => {
+            const variable = this.exportsByName[exportName];
+            return `${relativeId(variable.module.id).replace(/\\/g, '/')}:${variable.name}:${exportName}`;
+        })
+            .join(','));
+        return (this.renderedHash = hash.digest('hex'));
+    }
     getVariableExportName(variable) {
         if (this.outputOptions.preserveModules && variable instanceof NamespaceVariable) {
             return '*';
@@ -15834,107 +14630,231 @@
         return this.exportNamesByVariable.get(variable)[0];
     }
     link() {
-        this.dependencies = getStaticDependencies(this, this.orderedModules, this.chunkByModule, this.externalChunkByModule);
+        this.dependencies = getStaticDependencies(this, this.orderedModules, this.chunkByModule);
         for (const module of this.orderedModules) {
-            this.addImplicitlyLoadedBeforeFromModule(module);
+            this.addDependenciesToChunk(module.dynamicDependencies, this.dynamicDependencies);
+            this.addDependenciesToChunk(module.implicitlyLoadedBefore, this.implicitlyLoadedBefore);
             this.setUpChunkImportsAndExportsForModule(module);
         }
     }
-    async render() {
-        const { dependencies, exportMode, facadeModule, inputOptions: { onwarn }, outputOptions, pluginDriver, snippets } = this;
-        const { format, hoistTransitiveImports, preserveModules } = outputOptions;
-        // for static and dynamic entry points, add transitive dependencies to this
-        // chunk's dependencies to avoid loading latency
-        if (hoistTransitiveImports && !preserveModules && facadeModule !== null) {
-            for (const dep of dependencies) {
+    // prerender allows chunk hashes and names to be generated before finalizing
+    preRender(options, inputBase, snippets) {
+        const { _, getPropertyAccess, n } = snippets;
+        const magicString = new Bundle$1({ separator: `${n}${n}` });
+        this.usedModules = [];
+        this.indentString = getIndentString(this.orderedModules, options);
+        const renderOptions = {
+            dynamicImportFunction: options.dynamicImportFunction,
+            exportNamesByVariable: this.exportNamesByVariable,
+            format: options.format,
+            freeze: options.freeze,
+            indent: this.indentString,
+            namespaceToStringTag: options.namespaceToStringTag,
+            outputPluginDriver: this.pluginDriver,
+            snippets
+        };
+        // for static and dynamic entry points, inline the execution list to avoid loading latency
+        if (options.hoistTransitiveImports &&
+            !this.outputOptions.preserveModules &&
+            this.facadeModule !== null) {
+            for (const dep of this.dependencies) {
                 if (dep instanceof Chunk)
                     this.inlineChunkDependencies(dep);
             }
         }
-        const preliminaryFileName = this.getPreliminaryFileName();
-        const { accessedGlobals, indent, magicString, renderedSource, usedModules, usesTopLevelAwait } = this.renderModules(preliminaryFileName.fileName);
-        const renderedDependencies = [...this.getRenderedDependencies().values()];
-        const renderedExports = exportMode === 'none' ? [] : this.getChunkExportDeclarations(format);
-        let hasExports = renderedExports.length > 0;
-        let hasDefaultExport = false;
-        for (const renderedDependence of renderedDependencies) {
-            const { reexports } = renderedDependence;
-            if (reexports?.length) {
-                hasExports = true;
-                if (!hasDefaultExport && reexports.some(reexport => reexport.reexported === 'default')) {
-                    hasDefaultExport = true;
+        this.prepareModulesForRendering(snippets);
+        this.setIdentifierRenderResolutions(options);
+        let hoistedSource = '';
+        const renderedModules = this.renderedModules;
+        for (const module of this.orderedModules) {
+            let renderedLength = 0;
+            if (module.isIncluded() || this.includedNamespaces.has(module)) {
+                const source = module.render(renderOptions).trim();
+                renderedLength = source.length();
+                if (renderedLength) {
+                    if (options.compact && source.lastLine().indexOf('//') !== -1)
+                        source.append('\n');
+                    this.renderedModuleSources.set(module, source);
+                    magicString.addSource(source);
+                    this.usedModules.push(module);
                 }
-                if (format === 'es') {
-                    renderedDependence.reexports = reexports.filter(
-                    // eslint-disable-next-line unicorn/prefer-array-some
-                    ({ reexported }) => !renderedExports.find(({ exported }) => exported === reexported));
+                const namespace = module.namespace;
+                if (this.includedNamespaces.has(module) && !this.outputOptions.preserveModules) {
+                    const rendered = namespace.renderBlock(renderOptions);
+                    if (namespace.renderFirst())
+                        hoistedSource += n + rendered;
+                    else
+                        magicString.addSource(new MagicString$1(rendered));
                 }
             }
+            const { renderedExports, removedExports } = module.getRenderedExports();
+            const { renderedModuleSources } = this;
+            renderedModules[module.id] = {
+                get code() {
+                    var _a, _b;
+                    return (_b = (_a = renderedModuleSources.get(module)) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : null;
+                },
+                originalLength: module.originalCode.length,
+                removedExports,
+                renderedExports,
+                renderedLength
+            };
         }
-        if (!hasDefaultExport) {
-            for (const { exported } of renderedExports) {
-                if (exported === 'default') {
-                    hasDefaultExport = true;
-                    break;
+        if (hoistedSource)
+            magicString.prepend(hoistedSource + n + n);
+        if (this.needsExportsShim) {
+            magicString.prepend(`${n}${snippets.cnst} ${MISSING_EXPORT_SHIM_VARIABLE}${_}=${_}void 0;${n}${n}`);
+        }
+        if (options.compact) {
+            this.renderedSource = magicString;
+        }
+        else {
+            this.renderedSource = magicString.trim();
+        }
+        this.renderedHash = undefined;
+        if (this.isEmpty && this.getExportNames().length === 0 && this.dependencies.size === 0) {
+            const chunkName = this.getChunkName();
+            this.inputOptions.onwarn({
+                chunkName,
+                code: 'EMPTY_BUNDLE',
+                message: `Generated an empty chunk: "${chunkName}"`
+            });
+        }
+        this.setExternalRenderPaths(options, inputBase);
+        this.renderedDependencies = this.getChunkDependencyDeclarations(options, getPropertyAccess);
+        this.renderedExports =
+            this.exportMode === 'none'
+                ? []
+                : this.getChunkExportDeclarations(options.format, getPropertyAccess);
+    }
+    async render(options, addons, outputChunk, snippets) {
+        timeStart('render format', 2);
+        const format = options.format;
+        const finalise = finalisers[format];
+        if (options.dynamicImportFunction && format !== 'es') {
+            this.inputOptions.onwarn(errInvalidOption('output.dynamicImportFunction', 'outputdynamicImportFunction', 'this option is ignored for formats other than "es"'));
+        }
+        // populate ids in the rendered declarations only here
+        // as chunk ids known only after prerender
+        for (const dependency of this.dependencies) {
+            const renderedDependency = this.renderedDependencies.get(dependency);
+            if (dependency instanceof ExternalModule) {
+                const originalId = dependency.renderPath;
+                renderedDependency.id = escapeId(dependency.renormalizeRenderPath ? this.getRelativePath(originalId, false) : originalId);
+            }
+            else {
+                renderedDependency.namedExportsMode = dependency.exportMode !== 'default';
+                renderedDependency.id = escapeId(this.getRelativePath(dependency.id, false));
+            }
+        }
+        this.finaliseDynamicImports(options, snippets);
+        this.finaliseImportMetas(format, snippets);
+        const hasExports = this.renderedExports.length !== 0 ||
+            [...this.renderedDependencies.values()].some(dep => (dep.reexports && dep.reexports.length !== 0));
+        let usesTopLevelAwait = false;
+        const accessedGlobals = new Set();
+        for (const module of this.orderedModules) {
+            if (module.usesTopLevelAwait) {
+                usesTopLevelAwait = true;
+            }
+            const accessedGlobalVariables = this.accessedGlobalsByScope.get(module.scope);
+            if (accessedGlobalVariables) {
+                for (const name of accessedGlobalVariables) {
+                    accessedGlobals.add(name);
                 }
             }
         }
-        const { intro, outro, banner, footer } = await createAddons(outputOptions, pluginDriver, this.getRenderedChunkInfo());
-        finalisers[format](renderedSource, {
+        if (usesTopLevelAwait && format !== 'es' && format !== 'system') {
+            return error({
+                code: 'INVALID_TLA_FORMAT',
+                message: `Module format ${format} does not support top-level await. Use the "es" or "system" output formats rather.`
+            });
+        }
+        /* istanbul ignore next */
+        if (!this.id) {
+            throw new Error('Internal Error: expecting chunk id');
+        }
+        const magicString = finalise(this.renderedSource, {
             accessedGlobals,
-            dependencies: renderedDependencies,
-            exports: renderedExports,
-            hasDefaultExport,
+            dependencies: [...this.renderedDependencies.values()],
+            exports: this.renderedExports,
             hasExports,
-            id: preliminaryFileName.fileName,
-            indent,
-            intro,
-            isEntryFacade: preserveModules || (facadeModule !== null && facadeModule.info.isEntry),
-            isModuleFacade: facadeModule !== null,
-            namedExportsMode: exportMode !== 'default',
-            onwarn,
-            outro,
+            id: this.id,
+            indent: this.indentString,
+            intro: addons.intro,
+            isEntryFacade: this.outputOptions.preserveModules ||
+                (this.facadeModule !== null && this.facadeModule.info.isEntry),
+            isModuleFacade: this.facadeModule !== null,
+            namedExportsMode: this.exportMode !== 'default',
+            outro: addons.outro,
             snippets,
-            usesTopLevelAwait
-        }, outputOptions);
-        if (banner)
-            magicString.prepend(banner);
-        if (footer)
-            magicString.append(footer);
-        return {
-            chunk: this,
-            magicString,
-            preliminaryFileName,
-            usedModules
-        };
-    }
-    addImplicitlyLoadedBeforeFromModule(baseModule) {
-        const { chunkByModule, implicitlyLoadedBefore } = this;
-        for (const module of baseModule.implicitlyLoadedBefore) {
-            const chunk = chunkByModule.get(module);
-            if (chunk && chunk !== this) {
-                implicitlyLoadedBefore.add(chunk);
-            }
+            usesTopLevelAwait,
+            warn: this.inputOptions.onwarn
+        }, options);
+        if (addons.banner)
+            magicString.prepend(addons.banner);
+        if (addons.footer)
+            magicString.append(addons.footer);
+        const prevCode = magicString.toString();
+        timeEnd('render format', 2);
+        let map = null;
+        const chunkSourcemapChain = [];
+        let code = await renderChunk({
+            code: prevCode,
+            options,
+            outputPluginDriver: this.pluginDriver,
+            renderChunk: outputChunk,
+            sourcemapChain: chunkSourcemapChain
+        });
+        if (options.sourcemap) {
+            timeStart('sourcemap', 2);
+            let file;
+            if (options.file)
+                file = path$2.resolve(options.sourcemapFile || options.file);
+            else if (options.dir)
+                file = path$2.resolve(options.dir, this.id);
+            else
+                file = path$2.resolve(this.id);
+            const decodedMap = magicString.generateDecodedMap({});
+            map = collapseSourcemaps(file, decodedMap, this.usedModules, chunkSourcemapChain, options.sourcemapExcludeSources, this.inputOptions.onwarn);
+            map.sources = map.sources
+                .map(sourcePath => {
+                const { sourcemapPathTransform } = options;
+                if (sourcemapPathTransform) {
+                    const newSourcePath = sourcemapPathTransform(sourcePath, `${file}.map`);
+                    if (typeof newSourcePath !== 'string') {
+                        error(errFailedValidation(`sourcemapPathTransform function must return a string.`));
+                    }
+                    return newSourcePath;
+                }
+                return sourcePath;
+            })
+                .map(normalize);
+            timeEnd('sourcemap', 2);
         }
+        if (!options.compact && code[code.length - 1] !== '\n')
+            code += '\n';
+        return { code, map };
     }
-    addNecessaryImportsForFacades() {
-        for (const [module, variables] of this.includedReexportsByModule) {
-            if (this.includedNamespaces.has(module)) {
-                for (const variable of variables) {
-                    this.imports.add(variable);
+    addDependenciesToChunk(moduleDependencies, chunkDependencies) {
+        for (const module of moduleDependencies) {
+            if (module instanceof Module) {
+                const chunk = this.chunkByModule.get(module);
+                if (chunk && chunk !== this) {
+                    chunkDependencies.add(chunk);
                 }
             }
+            else {
+                chunkDependencies.add(module);
+            }
         }
     }
-    assignFacadeName({ fileName, name }, facadedModule, preservePath) {
+    assignFacadeName({ fileName, name }, facadedModule) {
         if (fileName) {
             this.fileName = fileName;
         }
         else {
-            this.name = this.outputOptions.sanitizeFileName(name ||
-                (preservePath
-                    ? this.getPreserveModulesChunkNameFromModule(facadedModule)
-                    : getChunkNameFromModule(facadedModule)));
+            this.name = this.outputOptions.sanitizeFileName(name || getChunkNameFromModule(facadedModule));
         }
     }
     checkCircularDependencyImport(variable, importingModule) {
@@ -15947,19 +14867,41 @@
                 if (alternativeReexportModule) {
                     const exportingChunk = this.chunkByModule.get(alternativeReexportModule);
                     if (exportingChunk && exportingChunk !== exportChunk) {
-                        this.inputOptions.onwarn(errorCyclicCrossChunkReexport(variableModule.getExportNamesByVariable().get(variable)[0], variableModule.id, alternativeReexportModule.id, importingModule.id));
+                        this.inputOptions.onwarn(errCyclicCrossChunkReexport(variableModule.getExportNamesByVariable().get(variable)[0], variableModule.id, alternativeReexportModule.id, importingModule.id));
                     }
                     importingModule = alternativeReexportModule;
                 }
             } while (alternativeReexportModule);
         }
     }
+    computeContentHashWithDependencies(addons, options, existingNames) {
+        const hash = createHash();
+        hash.update([addons.intro, addons.outro, addons.banner, addons.footer].map(addon => addon || '').join(':'));
+        hash.update(options.format);
+        const dependenciesForHashing = new Set([this]);
+        for (const current of dependenciesForHashing) {
+            if (current instanceof ExternalModule) {
+                hash.update(':' + current.renderPath);
+            }
+            else {
+                hash.update(current.getRenderedHash());
+                hash.update(current.generateId(addons, options, existingNames, false));
+            }
+            if (current instanceof ExternalModule)
+                continue;
+            for (const dependency of [...current.dependencies, ...current.dynamicDependencies]) {
+                dependenciesForHashing.add(dependency);
+            }
+        }
+        return hash.digest('hex').substr(0, 8);
+    }
     ensureReexportsAreAvailableForModule(module) {
-        const includedReexports = [];
         const map = module.getExportNamesByVariable();
         for (const exportedVariable of map.keys()) {
             const isSynthetic = exportedVariable instanceof SyntheticNamedExportVariable;
-            const importedVariable = isSynthetic ? exportedVariable.getBaseVariable() : exportedVariable;
+            const importedVariable = isSynthetic
+                ? exportedVariable.getBaseVariable()
+                : exportedVariable;
             if (!(importedVariable instanceof NamespaceVariable && this.outputOptions.preserveModules)) {
                 this.checkCircularDependencyImport(importedVariable, module);
                 const exportingModule = importedVariable.module;
@@ -15967,7 +14909,6 @@
                     const chunk = this.chunkByModule.get(exportingModule);
                     if (chunk && chunk !== this) {
                         chunk.exports.add(importedVariable);
-                        includedReexports.push(importedVariable);
                         if (isSynthetic) {
                             this.imports.add(importedVariable);
                         }
@@ -15975,8 +14916,34 @@
                 }
             }
         }
-        if (includedReexports.length > 0) {
-            this.includedReexportsByModule.set(module, includedReexports);
+    }
+    finaliseDynamicImports(options, snippets) {
+        const stripKnownJsExtensions = options.format === 'amd';
+        for (const [module, code] of this.renderedModuleSources) {
+            for (const { node, resolution } of module.dynamicImports) {
+                const chunk = this.chunkByModule.get(resolution);
+                const facadeChunk = this.facadeChunkByModule.get(resolution);
+                if (!resolution || !node.included || chunk === this) {
+                    continue;
+                }
+                const renderedResolution = resolution instanceof Module
+                    ? `'${this.getRelativePath((facadeChunk || chunk).id, stripKnownJsExtensions)}'`
+                    : resolution instanceof ExternalModule
+                        ? `'${resolution.renormalizeRenderPath
+                            ? this.getRelativePath(resolution.renderPath, stripKnownJsExtensions)
+                            : resolution.renderPath}'`
+                        : resolution;
+                node.renderFinalResolution(code, renderedResolution, resolution instanceof Module &&
+                    !(facadeChunk === null || facadeChunk === void 0 ? void 0 : facadeChunk.strictFacade) &&
+                    chunk.exportNamesByVariable.get(resolution.namespace)[0], snippets);
+            }
+        }
+    }
+    finaliseImportMetas(format, snippets) {
+        for (const [module, code] of this.renderedModuleSources) {
+            for (const importMeta of module.importMetas) {
+                importMeta.renderFinalMechanism(code, this.id, format, snippets, this.pluginDriver);
+            }
         }
     }
     generateVariableName() {
@@ -15988,40 +14955,48 @@
             this.dynamicEntryModules[0] ||
             this.orderedModules[this.orderedModules.length - 1];
         if (moduleForNaming) {
-            return getChunkNameFromModule(moduleForNaming);
+            return moduleForNaming.chunkName || getAliasName(moduleForNaming.id);
         }
         return 'chunk';
     }
-    getChunkExportDeclarations(format) {
+    getChunkDependencyDeclarations(options, getPropertyAccess) {
+        const importSpecifiers = this.getImportSpecifiers(getPropertyAccess);
+        const reexportSpecifiers = this.getReexportSpecifiers();
+        const dependencyDeclaration = new Map();
+        for (const dep of this.dependencies) {
+            const imports = importSpecifiers.get(dep) || null;
+            const reexports = reexportSpecifiers.get(dep) || null;
+            const namedExportsMode = dep instanceof ExternalModule || dep.exportMode !== 'default';
+            dependencyDeclaration.set(dep, {
+                defaultVariableName: dep.defaultVariableName,
+                globalName: (dep instanceof ExternalModule &&
+                    (options.format === 'umd' || options.format === 'iife') &&
+                    getGlobalName(dep, options.globals, (imports || reexports) !== null, this.inputOptions.onwarn)),
+                id: undefined,
+                imports,
+                isChunk: dep instanceof Chunk,
+                name: dep.variableName,
+                namedExportsMode,
+                namespaceVariableName: dep.namespaceVariableName,
+                reexports
+            });
+        }
+        return dependencyDeclaration;
+    }
+    getChunkExportDeclarations(format, getPropertyAccess) {
         const exports = [];
         for (const exportName of this.getExportNames()) {
             if (exportName[0] === '*')
                 continue;
-            const variable = this.exportsByName.get(exportName);
+            const variable = this.exportsByName[exportName];
             if (!(variable instanceof SyntheticNamedExportVariable)) {
                 const module = variable.module;
-                if (module) {
-                    const chunk = this.chunkByModule.get(module);
-                    if (chunk !== this) {
-                        if (!chunk || format !== 'es') {
-                            continue;
-                        }
-                        const chunkDep = this.renderedDependencies.get(chunk);
-                        if (!chunkDep) {
-                            continue;
-                        }
-                        const { imports, reexports } = chunkDep;
-                        const importedByReexported = reexports?.find(({ reexported }) => reexported === exportName);
-                        const isImported = imports?.find(({ imported }) => imported === importedByReexported?.imported);
-                        if (!isImported) {
-                            continue;
-                        }
-                    }
-                }
+                if (module && this.chunkByModule.get(module) !== this)
+                    continue;
             }
             let expression = null;
             let hoisted = false;
-            let local = variable.getName(this.snippets.getPropertyAccess);
+            let local = variable.getName(getPropertyAccess);
             if (variable instanceof LocalVariable) {
                 for (const declaration of variable.declarations) {
                     if (declaration.parent instanceof FunctionDeclaration ||
@@ -16055,17 +15030,17 @@
             if (addNonNamespacesAndInteropHelpers || variable.isNamespace) {
                 const module = variable.module;
                 if (module instanceof ExternalModule) {
-                    const chunk = this.externalChunkByModule.get(module);
-                    dependencies.add(chunk);
+                    dependencies.add(module);
                     if (addNonNamespacesAndInteropHelpers) {
                         if (variable.name === 'default') {
-                            if (defaultInteropHelpersByInteropType[interop(module.id)]) {
-                                deconflictedDefault.add(chunk);
+                            if (defaultInteropHelpersByInteropType[String(interop(module.id))]) {
+                                deconflictedDefault.add(module);
                             }
                         }
-                        else if (variable.name === '*' &&
-                            namespaceInteropHelpersByInteropType[interop(module.id)]) {
-                            deconflictedNamespace.add(chunk);
+                        else if (variable.name === '*') {
+                            if (namespaceInteropHelpersByInteropType[String(interop(module.id))]) {
+                                deconflictedNamespace.add(module);
+                            }
                         }
                     }
                 }
@@ -16089,25 +15064,6 @@
         }
         return { deconflictedDefault, deconflictedNamespace, dependencies };
     }
-    getDynamicDependencies() {
-        return this.getIncludedDynamicImports()
-            .map(resolvedDynamicImport => resolvedDynamicImport.facadeChunk ||
-            resolvedDynamicImport.chunk ||
-            resolvedDynamicImport.externalChunk ||
-            resolvedDynamicImport.resolution)
-            .filter((resolution) => resolution !== this &&
-            (resolution instanceof Chunk || resolution instanceof ExternalChunk));
-    }
-    getDynamicImportStringAndAssertions(resolution, fileName) {
-        if (resolution instanceof ExternalModule) {
-            const chunk = this.externalChunkByModule.get(resolution);
-            return [`'${chunk.getImportPath(fileName)}'`, chunk.getImportAssertions(this.snippets)];
-        }
-        return [
-            resolution || '',
-            (this.outputOptions.format === 'es' && this.outputOptions.externalImportAssertions) || null
-        ];
-    }
     getFallbackChunkName() {
         if (this.manualChunkAlias) {
             return this.manualChunkAlias;
@@ -16120,7 +15076,7 @@
         }
         return getAliasName(this.orderedModules[this.orderedModules.length - 1].id);
     }
-    getImportSpecifiers() {
+    getImportSpecifiers(getPropertyAccess) {
         const { interop } = this.outputOptions;
         const importsByDependency = new Map();
         for (const variable of this.imports) {
@@ -16128,88 +15084,40 @@
             let dependency;
             let imported;
             if (module instanceof ExternalModule) {
-                dependency = this.externalChunkByModule.get(module);
+                dependency = module;
                 imported = variable.name;
                 if (imported !== 'default' && imported !== '*' && interop(module.id) === 'defaultOnly') {
-                    return error(errorUnexpectedNamedImport(module.id, imported, false));
+                    return error(errUnexpectedNamedImport(module.id, imported, false));
                 }
             }
             else {
                 dependency = this.chunkByModule.get(module);
                 imported = dependency.getVariableExportName(variable);
             }
-            getOrCreate(importsByDependency, dependency, getNewArray).push({
+            getOrCreate(importsByDependency, dependency, () => []).push({
                 imported,
-                local: variable.getName(this.snippets.getPropertyAccess)
+                local: variable.getName(getPropertyAccess)
             });
         }
         return importsByDependency;
     }
-    getIncludedDynamicImports() {
-        if (this.includedDynamicImports) {
-            return this.includedDynamicImports;
-        }
-        const includedDynamicImports = [];
-        for (const module of this.orderedModules) {
-            for (const { node, resolution } of module.dynamicImports) {
-                if (!node.included) {
-                    continue;
+    getImportedBindingsPerDependency() {
+        const importSpecifiers = {};
+        for (const [dependency, declaration] of this.renderedDependencies) {
+            const specifiers = new Set();
+            if (declaration.imports) {
+                for (const { imported } of declaration.imports) {
+                    specifiers.add(imported);
                 }
-                includedDynamicImports.push(resolution instanceof Module
-                    ? {
-                        chunk: this.chunkByModule.get(resolution),
-                        externalChunk: null,
-                        facadeChunk: this.facadeChunkByModule.get(resolution),
-                        node,
-                        resolution
-                    }
-                    : resolution instanceof ExternalModule
-                        ? {
-                            chunk: null,
-                            externalChunk: this.externalChunkByModule.get(resolution),
-                            facadeChunk: null,
-                            node,
-                            resolution
-                        }
-                        : { chunk: null, externalChunk: null, facadeChunk: null, node, resolution });
             }
+            if (declaration.reexports) {
+                for (const { imported } of declaration.reexports) {
+                    specifiers.add(imported);
+                }
+            }
+            importSpecifiers[dependency.id] = [...specifiers];
         }
-        return (this.includedDynamicImports = includedDynamicImports);
-    }
-    getPreRenderedChunkInfo() {
-        if (this.preRenderedChunkInfo) {
-            return this.preRenderedChunkInfo;
-        }
-        const { dynamicEntryModules, facadeModule, implicitEntryModules, orderedModules } = this;
-        return (this.preRenderedChunkInfo = {
-            exports: this.getExportNames(),
-            facadeModuleId: facadeModule && facadeModule.id,
-            isDynamicEntry: dynamicEntryModules.length > 0,
-            isEntry: !!facadeModule?.info.isEntry,
-            isImplicitEntry: implicitEntryModules.length > 0,
-            moduleIds: orderedModules.map(({ id }) => id),
-            name: this.getChunkName(),
-            type: 'chunk'
-        });
-    }
-    getPreserveModulesChunkNameFromModule(module) {
-        const predefinedChunkName = getPredefinedChunkNameFromModule(module);
-        if (predefinedChunkName)
-            return predefinedChunkName;
-        const { preserveModulesRoot, sanitizeFileName } = this.outputOptions;
-        const sanitizedId = sanitizeFileName(normalize(module.id.split(QUERY_HASH_REGEX, 1)[0]));
-        const extensionName = node_path.extname(sanitizedId);
-        const idWithoutExtension = NON_ASSET_EXTENSIONS.has(extensionName)
-            ? sanitizedId.slice(0, -extensionName.length)
-            : sanitizedId;
-        if (isAbsolute(idWithoutExtension)) {
-            return preserveModulesRoot && node_path.resolve(idWithoutExtension).startsWith(preserveModulesRoot)
-                ? idWithoutExtension.slice(preserveModulesRoot.length).replace(/^[/\\]/, '')
-                : relative(this.inputBase, idWithoutExtension);
-        }
-        else {
-            return `_virtual/${node_path.basename(idWithoutExtension)}`;
-        }
+        return importSpecifiers;
     }
     getReexportSpecifiers() {
         const { externalLiveBindings, interop } = this.outputOptions;
@@ -16219,16 +15127,16 @@
             let imported;
             let needsLiveBinding = false;
             if (exportName[0] === '*') {
-                const id = exportName.slice(1);
+                const id = exportName.substr(1);
                 if (interop(id) === 'defaultOnly') {
-                    this.inputOptions.onwarn(errorUnexpectedNamespaceReexport(id));
+                    this.inputOptions.onwarn(errUnexpectedNamespaceReexport(id));
                 }
                 needsLiveBinding = externalLiveBindings;
-                dependency = this.externalChunkByModule.get(this.modulesById.get(id));
+                dependency = this.modulesById.get(id);
                 imported = exportName = '*';
             }
             else {
-                const variable = this.exportsByName.get(exportName);
+                const variable = this.exportsByName[exportName];
                 if (variable instanceof SyntheticNamedExportVariable)
                     continue;
                 const module = variable.module;
@@ -16240,17 +15148,17 @@
                     needsLiveBinding = variable.isReassigned;
                 }
                 else {
-                    dependency = this.externalChunkByModule.get(module);
+                    dependency = module;
                     imported = variable.name;
                     if (imported !== 'default' && imported !== '*' && interop(module.id) === 'defaultOnly') {
-                        return error(errorUnexpectedNamedImport(module.id, imported, true));
+                        return error(errUnexpectedNamedImport(module.id, imported, true));
                     }
                     needsLiveBinding =
                         externalLiveBindings &&
-                            (imported !== 'default' || isDefaultAProperty(interop(module.id), true));
+                            (imported !== 'default' || isDefaultAProperty(String(interop(module.id)), true));
                 }
             }
-            getOrCreate(reexportSpecifiers, dependency, getNewArray).push({
+            getOrCreate(reexportSpecifiers, dependency, () => []).push({
                 imported,
                 needsLiveBinding,
                 reexported: exportName
@@ -16259,46 +15167,27 @@
         return reexportSpecifiers;
     }
     getReferencedFiles() {
-        const referencedFiles = new Set();
+        const referencedFiles = [];
         for (const module of this.orderedModules) {
             for (const meta of module.importMetas) {
                 const fileName = meta.getReferencedFileName(this.pluginDriver);
                 if (fileName) {
-                    referencedFiles.add(fileName);
+                    referencedFiles.push(fileName);
                 }
             }
         }
-        return [...referencedFiles];
+        return referencedFiles;
     }
-    getRenderedDependencies() {
-        if (this.renderedDependencies) {
-            return this.renderedDependencies;
+    getRelativePath(targetPath, stripJsExtension) {
+        let relativePath = normalize(relative(path$2.dirname(this.id), targetPath));
+        if (stripJsExtension && relativePath.endsWith('.js')) {
+            relativePath = relativePath.slice(0, -3);
         }
-        const importSpecifiers = this.getImportSpecifiers();
-        const reexportSpecifiers = this.getReexportSpecifiers();
-        const renderedDependencies = new Map();
-        const fileName = this.getFileName();
-        for (const dep of this.dependencies) {
-            const imports = importSpecifiers.get(dep) || null;
-            const reexports = reexportSpecifiers.get(dep) || null;
-            const namedExportsMode = dep instanceof ExternalChunk || dep.exportMode !== 'default';
-            const importPath = dep.getImportPath(fileName);
-            renderedDependencies.set(dep, {
-                assertions: dep instanceof ExternalChunk ? dep.getImportAssertions(this.snippets) : null,
-                defaultVariableName: dep.defaultVariableName,
-                globalName: dep instanceof ExternalChunk &&
-                    (this.outputOptions.format === 'umd' || this.outputOptions.format === 'iife') &&
-                    getGlobalName(dep, this.outputOptions.globals, (imports || reexports) !== null, this.inputOptions.onwarn),
-                importPath,
-                imports,
-                isChunk: dep instanceof Chunk,
-                name: dep.variableName,
-                namedExportsMode,
-                namespaceVariableName: dep.namespaceVariableName,
-                reexports
-            });
-        }
-        return (this.renderedDependencies = renderedDependencies);
+        if (relativePath === '..')
+            return '../../' + path$2.basename(targetPath);
+        if (relativePath === '')
+            return '../' + path$2.basename(targetPath);
+        return relativePath.startsWith('../') ? relativePath : './' + relativePath;
     }
     inlineChunkDependencies(chunk) {
         for (const dep of chunk.dependencies) {
@@ -16310,108 +15199,45 @@
             }
         }
     }
-    // This method changes properties on the AST before rendering and must not be async
-    renderModules(fileName) {
-        const { accessedGlobalsByScope, dependencies, exportNamesByVariable, includedNamespaces, inputOptions: { onwarn }, isEmpty, orderedModules, outputOptions, pluginDriver, renderedModules, snippets } = this;
-        const { compact, dynamicImportFunction, format, freeze, namespaceToStringTag, preserveModules } = outputOptions;
-        const { _, cnst, n } = snippets;
-        this.setDynamicImportResolutions(fileName);
-        this.setImportMetaResolutions(fileName);
-        this.setIdentifierRenderResolutions();
-        const magicString = new Bundle$1({ separator: `${n}${n}` });
-        const indent = getIndentString(orderedModules, outputOptions);
-        const usedModules = [];
-        let hoistedSource = '';
-        const accessedGlobals = new Set();
-        const renderedModuleSources = new Map();
-        const renderOptions = {
-            dynamicImportFunction,
-            exportNamesByVariable,
-            format,
-            freeze,
-            indent,
-            namespaceToStringTag,
-            pluginDriver,
-            snippets
-        };
-        let usesTopLevelAwait = false;
-        for (const module of orderedModules) {
-            let renderedLength = 0;
-            let source;
-            if (module.isIncluded() || includedNamespaces.has(module)) {
-                const rendered = module.render(renderOptions);
-                ({ source } = rendered);
-                usesTopLevelAwait || (usesTopLevelAwait = rendered.usesTopLevelAwait);
-                renderedLength = source.length();
-                if (renderedLength) {
-                    if (compact && source.lastLine().includes('//'))
-                        source.append('\n');
-                    renderedModuleSources.set(module, source);
-                    magicString.addSource(source);
-                    usedModules.push(module);
-                }
-                const namespace = module.namespace;
-                if (includedNamespaces.has(module) && !preserveModules) {
-                    const rendered = namespace.renderBlock(renderOptions);
-                    if (namespace.renderFirst())
-                        hoistedSource += n + rendered;
-                    else
-                        magicString.addSource(new MagicString(rendered));
-                }
-                const accessedGlobalVariables = accessedGlobalsByScope.get(module.scope);
-                if (accessedGlobalVariables) {
-                    for (const name of accessedGlobalVariables) {
-                        accessedGlobals.add(name);
+    prepareModulesForRendering(snippets) {
+        var _a;
+        const accessedGlobalsByScope = this.accessedGlobalsByScope;
+        for (const module of this.orderedModules) {
+            for (const { node, resolution } of module.dynamicImports) {
+                if (node.included) {
+                    if (resolution instanceof Module) {
+                        const chunk = this.chunkByModule.get(resolution);
+                        if (chunk === this) {
+                            node.setInternalResolution(resolution.namespace);
+                        }
+                        else {
+                            node.setExternalResolution(((_a = this.facadeChunkByModule.get(resolution)) === null || _a === void 0 ? void 0 : _a.exportMode) || chunk.exportMode, resolution, this.outputOptions, snippets, this.pluginDriver, accessedGlobalsByScope);
+                        }
+                    }
+                    else {
+                        node.setExternalResolution('external', resolution, this.outputOptions, snippets, this.pluginDriver, accessedGlobalsByScope);
                     }
                 }
             }
-            const { renderedExports, removedExports } = module.getRenderedExports();
-            renderedModules[module.id] = {
-                get code() {
-                    return source?.toString() ?? null;
-                },
-                originalLength: module.originalCode.length,
-                removedExports,
-                renderedExports,
-                renderedLength
-            };
-        }
-        if (hoistedSource)
-            magicString.prepend(hoistedSource + n + n);
-        // eslint-disable-next-line unicorn/consistent-destructuring
-        if (this.needsExportsShim) {
-            magicString.prepend(`${n}${cnst} ${MISSING_EXPORT_SHIM_VARIABLE}${_}=${_}void 0;${n}${n}`);
-        }
-        const renderedSource = compact ? magicString : magicString.trim();
-        if (isEmpty && this.getExportNames().length === 0 && dependencies.size === 0) {
-            onwarn(errorEmptyChunk(this.getChunkName()));
-        }
-        return { accessedGlobals, indent, magicString, renderedSource, usedModules, usesTopLevelAwait };
-    }
-    setDynamicImportResolutions(fileName) {
-        const { accessedGlobalsByScope, outputOptions, pluginDriver, snippets } = this;
-        for (const resolvedDynamicImport of this.getIncludedDynamicImports()) {
-            if (resolvedDynamicImport.chunk) {
-                const { chunk, facadeChunk, node, resolution } = resolvedDynamicImport;
-                if (chunk === this) {
-                    node.setInternalResolution(resolution.namespace);
-                }
-                else {
-                    node.setExternalResolution((facadeChunk || chunk).exportMode, resolution, outputOptions, snippets, pluginDriver, accessedGlobalsByScope, `'${(facadeChunk || chunk).getImportPath(fileName)}'`, !facadeChunk?.strictFacade && chunk.exportNamesByVariable.get(resolution.namespace)[0], null);
-                }
+            for (const importMeta of module.importMetas) {
+                importMeta.addAccessedGlobals(this.outputOptions.format, accessedGlobalsByScope);
             }
-            else {
-                const { node, resolution } = resolvedDynamicImport;
-                const [resolutionString, assertions] = this.getDynamicImportStringAndAssertions(resolution, fileName);
-                node.setExternalResolution('external', resolution, outputOptions, snippets, pluginDriver, accessedGlobalsByScope, resolutionString, false, assertions);
+            if (this.includedNamespaces.has(module) && !this.outputOptions.preserveModules) {
+                module.namespace.prepare(accessedGlobalsByScope);
             }
         }
     }
-    setIdentifierRenderResolutions() {
-        const { format, interop, namespaceToStringTag, preserveModules, externalLiveBindings } = this.outputOptions;
+    setExternalRenderPaths(options, inputBase) {
+        for (const dependency of [...this.dependencies, ...this.dynamicDependencies]) {
+            if (dependency instanceof ExternalModule) {
+                dependency.setRenderPath(options, inputBase);
+            }
+        }
+    }
+    setIdentifierRenderResolutions({ format, interop, namespaceToStringTag }) {
         const syntheticExports = new Set();
         for (const exportName of this.getExportNames()) {
-            const exportVariable = this.exportsByName.get(exportName);
+            const exportVariable = this.exportsByName[exportName];
             if (format !== 'es' &&
                 format !== 'system' &&
                 exportVariable.isReassigned &&
@@ -16439,45 +15265,32 @@
             usedNames.add('Symbol');
         }
         switch (format) {
-            case 'system': {
+            case 'system':
                 usedNames.add('module').add('exports');
                 break;
-            }
-            case 'es': {
+            case 'es':
                 break;
-            }
-            case 'cjs': {
+            case 'cjs':
                 usedNames.add('module').add('require').add('__filename').add('__dirname');
-            }
             // fallthrough
-            default: {
+            default:
                 usedNames.add('exports');
                 for (const helper of HELPER_NAMES) {
                     usedNames.add(helper);
                 }
-            }
-        }
-        deconflictChunk(this.orderedModules, this.getDependenciesToBeDeconflicted(format !== 'es' && format !== 'system', format === 'amd' || format === 'umd' || format === 'iife', interop), this.imports, usedNames, format, interop, preserveModules, externalLiveBindings, this.chunkByModule, this.externalChunkByModule, syntheticExports, this.exportNamesByVariable, this.accessedGlobalsByScope, this.includedNamespaces);
-    }
-    setImportMetaResolutions(fileName) {
-        const { accessedGlobalsByScope, includedNamespaces, orderedModules, outputOptions: { format, preserveModules } } = this;
-        for (const module of orderedModules) {
-            for (const importMeta of module.importMetas) {
-                importMeta.setResolution(format, accessedGlobalsByScope, fileName);
-            }
-            if (includedNamespaces.has(module) && !preserveModules) {
-                module.namespace.prepare(accessedGlobalsByScope);
-            }
         }
+        deconflictChunk(this.orderedModules, this.getDependenciesToBeDeconflicted(format !== 'es' && format !== 'system', format === 'amd' || format === 'umd' || format === 'iife', interop), this.imports, usedNames, format, interop, this.outputOptions.preserveModules, this.outputOptions.externalLiveBindings, this.chunkByModule, syntheticExports, this.exportNamesByVariable, this.accessedGlobalsByScope, this.includedNamespaces);
     }
     setUpChunkImportsAndExportsForModule(module) {
-        const moduleImports = new Set(module.includedImports);
+        const moduleImports = new Set(module.imports);
         // when we are not preserving modules, we need to make all namespace variables available for
         // rendering the namespace object
-        if (!this.outputOptions.preserveModules && this.includedNamespaces.has(module)) {
-            const memberVariables = module.namespace.getMemberVariables();
-            for (const variable of Object.values(memberVariables)) {
-                moduleImports.add(variable);
+        if (!this.outputOptions.preserveModules) {
+            if (this.includedNamespaces.has(module)) {
+                const memberVariables = module.namespace.getMemberVariables();
+                for (const variable of Object.values(memberVariables)) {
+                    moduleImports.add(variable);
+                }
             }
         }
         for (let variable of moduleImports) {
@@ -16514,62 +15327,340 @@
     }
 }
 function getChunkNameFromModule(module) {
-    return getPredefinedChunkNameFromModule(module) ?? getAliasName(module.id);
+    return module.chunkName || getAliasName(module.id);
 }
-function getPredefinedChunkNameFromModule(module) {
-    return (module.chunkNames.find(({ isUserDefined }) => isUserDefined)?.name ?? module.chunkNames[0]?.name);
+
+var BuildPhase;
+(function (BuildPhase) {
+    BuildPhase[BuildPhase["LOAD_AND_PARSE"] = 0] = "LOAD_AND_PARSE";
+    BuildPhase[BuildPhase["ANALYSE"] = 1] = "ANALYSE";
+    BuildPhase[BuildPhase["GENERATE"] = 2] = "GENERATE";
+})(BuildPhase || (BuildPhase = {}));
+
+function generateAssetFileName(name, source, outputOptions, bundle) {
+    const emittedName = outputOptions.sanitizeFileName(name || 'asset');
+    return makeUnique(renderNamePattern(typeof outputOptions.assetFileNames === 'function'
+        ? outputOptions.assetFileNames({ name, source, type: 'asset' })
+        : outputOptions.assetFileNames, 'output.assetFileNames', {
+        ext: () => path$2.extname(emittedName).substr(1),
+        extname: () => path$2.extname(emittedName),
+        hash() {
+            const hash = createHash();
+            hash.update(emittedName);
+            hash.update(':');
+            hash.update(source);
+            return hash.digest('hex').substr(0, 8);
+        },
+        name: () => emittedName.substr(0, emittedName.length - path$2.extname(emittedName).length)
+    }), bundle);
+}
+function reserveFileNameInBundle(fileName, bundle, warn) {
+    if (fileName in bundle) {
+        warn(errFileNameConflict(fileName));
+    }
+    bundle[fileName] = FILE_PLACEHOLDER;
+}
+const FILE_PLACEHOLDER = {
+    type: 'placeholder'
+};
+function hasValidType(emittedFile) {
+    return Boolean(emittedFile &&
+        (emittedFile.type === 'asset' ||
+            emittedFile.type === 'chunk'));
+}
+function hasValidName(emittedFile) {
+    const validatedName = emittedFile.fileName || emittedFile.name;
+    return !validatedName || (typeof validatedName === 'string' && !isPathFragment(validatedName));
+}
+function getValidSource(source, emittedFile, fileReferenceId) {
+    if (!(typeof source === 'string' || source instanceof Uint8Array)) {
+        const assetName = emittedFile.fileName || emittedFile.name || fileReferenceId;
+        return error(errFailedValidation(`Could not set source for ${typeof assetName === 'string' ? `asset "${assetName}"` : 'unnamed asset'}, asset source needs to be a string, Uint8Array or Buffer.`));
+    }
+    return source;
+}
+function getAssetFileName(file, referenceId) {
+    if (typeof file.fileName !== 'string') {
+        return error(errAssetNotFinalisedForFileName(file.name || referenceId));
+    }
+    return file.fileName;
 }
-function getImportedBindingsPerDependency(renderedDependencies, resolveFileName) {
-    const importedBindingsPerDependency = {};
-    for (const [dependency, declaration] of renderedDependencies) {
-        const specifiers = new Set();
-        if (declaration.imports) {
-            for (const { imported } of declaration.imports) {
-                specifiers.add(imported);
+function getChunkFileName(file, facadeChunkByModule) {
+    var _a;
+    const fileName = file.fileName || (file.module && ((_a = facadeChunkByModule === null || facadeChunkByModule === void 0 ? void 0 : facadeChunkByModule.get(file.module)) === null || _a === void 0 ? void 0 : _a.id));
+    if (!fileName)
+        return error(errChunkNotGeneratedForFileName(file.fileName || file.name));
+    return fileName;
+}
+class FileEmitter {
+    constructor(graph, options, baseFileEmitter) {
+        this.graph = graph;
+        this.options = options;
+        this.bundle = null;
+        this.facadeChunkByModule = null;
+        this.outputOptions = null;
+        this.assertAssetsFinalized = () => {
+            for (const [referenceId, emittedFile] of this.filesByReferenceId.entries()) {
+                if (emittedFile.type === 'asset' && typeof emittedFile.fileName !== 'string')
+                    return error(errNoAssetSourceSet(emittedFile.name || referenceId));
             }
-        }
-        if (declaration.reexports) {
-            for (const { imported } of declaration.reexports) {
-                specifiers.add(imported);
+        };
+        this.emitFile = (emittedFile) => {
+            if (!hasValidType(emittedFile)) {
+                return error(errFailedValidation(`Emitted files must be of type "asset" or "chunk", received "${emittedFile && emittedFile.type}".`));
             }
+            if (!hasValidName(emittedFile)) {
+                return error(errFailedValidation(`The "fileName" or "name" properties of emitted files must be strings that are neither absolute nor relative paths, received "${emittedFile.fileName || emittedFile.name}".`));
+            }
+            if (emittedFile.type === 'chunk') {
+                return this.emitChunk(emittedFile);
+            }
+            else {
+                return this.emitAsset(emittedFile);
+            }
+        };
+        this.getFileName = (fileReferenceId) => {
+            const emittedFile = this.filesByReferenceId.get(fileReferenceId);
+            if (!emittedFile)
+                return error(errFileReferenceIdNotFoundForFilename(fileReferenceId));
+            if (emittedFile.type === 'chunk') {
+                return getChunkFileName(emittedFile, this.facadeChunkByModule);
+            }
+            else {
+                return getAssetFileName(emittedFile, fileReferenceId);
+            }
+        };
+        this.setAssetSource = (referenceId, requestedSource) => {
+            const consumedFile = this.filesByReferenceId.get(referenceId);
+            if (!consumedFile)
+                return error(errAssetReferenceIdNotFoundForSetSource(referenceId));
+            if (consumedFile.type !== 'asset') {
+                return error(errFailedValidation(`Asset sources can only be set for emitted assets but "${referenceId}" is an emitted chunk.`));
+            }
+            if (consumedFile.source !== undefined) {
+                return error(errAssetSourceAlreadySet(consumedFile.name || referenceId));
+            }
+            const source = getValidSource(requestedSource, consumedFile, referenceId);
+            if (this.bundle) {
+                this.finalizeAsset(consumedFile, source, referenceId, this.bundle);
+            }
+            else {
+                consumedFile.source = source;
+            }
+        };
+        this.setOutputBundle = (outputBundle, outputOptions, facadeChunkByModule) => {
+            this.outputOptions = outputOptions;
+            this.bundle = outputBundle;
+            this.facadeChunkByModule = facadeChunkByModule;
+            for (const emittedFile of this.filesByReferenceId.values()) {
+                if (emittedFile.fileName) {
+                    reserveFileNameInBundle(emittedFile.fileName, this.bundle, this.options.onwarn);
+                }
+            }
+            for (const [referenceId, consumedFile] of this.filesByReferenceId.entries()) {
+                if (consumedFile.type === 'asset' && consumedFile.source !== undefined) {
+                    this.finalizeAsset(consumedFile, consumedFile.source, referenceId, this.bundle);
+                }
+            }
+        };
+        this.filesByReferenceId = baseFileEmitter
+            ? new Map(baseFileEmitter.filesByReferenceId)
+            : new Map();
+    }
+    assignReferenceId(file, idBase) {
+        let referenceId;
+        do {
+            const hash = createHash();
+            if (referenceId) {
+                hash.update(referenceId);
+            }
+            else {
+                hash.update(idBase);
+            }
+            referenceId = hash.digest('hex').substr(0, 8);
+        } while (this.filesByReferenceId.has(referenceId));
+        this.filesByReferenceId.set(referenceId, file);
+        return referenceId;
+    }
+    emitAsset(emittedAsset) {
+        const source = typeof emittedAsset.source !== 'undefined'
+            ? getValidSource(emittedAsset.source, emittedAsset, null)
+            : undefined;
+        const consumedAsset = {
+            fileName: emittedAsset.fileName,
+            name: emittedAsset.name,
+            source,
+            type: 'asset'
+        };
+        const referenceId = this.assignReferenceId(consumedAsset, emittedAsset.fileName || emittedAsset.name || emittedAsset.type);
+        if (this.bundle) {
+            if (emittedAsset.fileName) {
+                reserveFileNameInBundle(emittedAsset.fileName, this.bundle, this.options.onwarn);
+            }
+            if (source !== undefined) {
+                this.finalizeAsset(consumedAsset, source, referenceId, this.bundle);
+            }
+        }
+        return referenceId;
+    }
+    emitChunk(emittedChunk) {
+        if (this.graph.phase > BuildPhase.LOAD_AND_PARSE) {
+            return error(errInvalidRollupPhaseForChunkEmission());
+        }
+        if (typeof emittedChunk.id !== 'string') {
+            return error(errFailedValidation(`Emitted chunks need to have a valid string id, received "${emittedChunk.id}"`));
+        }
+        const consumedChunk = {
+            fileName: emittedChunk.fileName,
+            module: null,
+            name: emittedChunk.name || emittedChunk.id,
+            type: 'chunk'
+        };
+        this.graph.moduleLoader
+            .emitChunk(emittedChunk)
+            .then(module => (consumedChunk.module = module))
+            .catch(() => {
+            // Avoid unhandled Promise rejection as the error will be thrown later
+            // once module loading has finished
+        });
+        return this.assignReferenceId(consumedChunk, emittedChunk.id);
+    }
+    finalizeAsset(consumedFile, source, referenceId, bundle) {
+        const fileName = consumedFile.fileName ||
+            findExistingAssetFileNameWithSource(bundle, source) ||
+            generateAssetFileName(consumedFile.name, source, this.outputOptions, bundle);
+        // We must not modify the original assets to avoid interaction between outputs
+        const assetWithFileName = { ...consumedFile, fileName, source };
+        this.filesByReferenceId.set(referenceId, assetWithFileName);
+        const { options } = this;
+        bundle[fileName] = {
+            fileName,
+            get isAsset() {
+                warnDeprecation('Accessing "isAsset" on files in the bundle is deprecated, please use "type === \'asset\'" instead', true, options);
+                return true;
+            },
+            name: consumedFile.name,
+            source,
+            type: 'asset'
+        };
+    }
+}
+function findExistingAssetFileNameWithSource(bundle, source) {
+    for (const [fileName, outputFile] of Object.entries(bundle)) {
+        if (outputFile.type === 'asset' && areSourcesEqual(source, outputFile.source))
+            return fileName;
+    }
+    return null;
+}
+function areSourcesEqual(sourceA, sourceB) {
+    if (typeof sourceA === 'string') {
+        return sourceA === sourceB;
+    }
+    if (typeof sourceB === 'string') {
+        return false;
+    }
+    if ('equals' in sourceA) {
+        return sourceA.equals(sourceB);
+    }
+    if (sourceA.length !== sourceB.length) {
+        return false;
+    }
+    for (let index = 0; index < sourceA.length; index++) {
+        if (sourceA[index] !== sourceB[index]) {
+            return false;
         }
-        importedBindingsPerDependency[resolveFileName(dependency)] = [...specifiers];
     }
-    return importedBindingsPerDependency;
+    return true;
 }
-const QUERY_HASH_REGEX = /[#?]/;
-const resolveFileName = (dependency) => dependency.getFileName();
 
-/**
- * Concatenate a number of iterables to a new iterable without fully evaluating
- * their iterators. Useful when e.g. working with large sets or lists and when
- * there is a chance that the iterators will not be fully exhausted.
- */
-function* concatLazy(...iterables) {
-    for (const iterable of iterables) {
-        yield* iterable;
+const concatSep = (out, next) => (next ? `${out}\n${next}` : out);
+const concatDblSep = (out, next) => (next ? `${out}\n\n${next}` : out);
+async function createAddons(options, outputPluginDriver) {
+    try {
+        let [banner, footer, intro, outro] = await Promise.all([
+            outputPluginDriver.hookReduceValue('banner', options.banner(), [], concatSep),
+            outputPluginDriver.hookReduceValue('footer', options.footer(), [], concatSep),
+            outputPluginDriver.hookReduceValue('intro', options.intro(), [], concatDblSep),
+            outputPluginDriver.hookReduceValue('outro', options.outro(), [], concatDblSep)
+        ]);
+        if (intro)
+            intro += '\n\n';
+        if (outro)
+            outro = `\n\n${outro}`;
+        if (banner.length)
+            banner += '\n';
+        if (footer.length)
+            footer = '\n' + footer;
+        return { banner, footer, intro, outro };
+    }
+    catch (err) {
+        return error({
+            code: 'ADDON_ERROR',
+            message: `Could not retrieve ${err.hook}. Check configuration of plugin ${err.plugin}.
+\tError Message: ${err.message}`
+        });
     }
 }
 
-function getChunkAssignments(entries, manualChunkAliasByEntry, minChunkSize) {
+function getChunkAssignments(entryModules, manualChunkAliasByEntry) {
     const chunkDefinitions = [];
     const modulesInManualChunks = new Set(manualChunkAliasByEntry.keys());
     const manualChunkModulesByAlias = Object.create(null);
     for (const [entry, alias] of manualChunkAliasByEntry) {
-        addStaticDependenciesToManualChunk(entry, (manualChunkModulesByAlias[alias] || (manualChunkModulesByAlias[alias] = [])), modulesInManualChunks);
+        const chunkModules = (manualChunkModulesByAlias[alias] =
+            manualChunkModulesByAlias[alias] || []);
+        addStaticDependenciesToManualChunk(entry, chunkModules, modulesInManualChunks);
     }
     for (const [alias, modules] of Object.entries(manualChunkModulesByAlias)) {
         chunkDefinitions.push({ alias, modules });
     }
-    const { allEntries, dependentEntriesByModule, dynamicallyDependentEntriesByDynamicEntry } = analyzeModuleGraph(entries);
-    const staticEntries = new Set(entries);
-    const assignedEntriesByModule = new Map();
-    for (const entry of allEntries) {
+    const assignedEntryPointsByModule = new Map();
+    const { dependentEntryPointsByModule, dynamicEntryModules } = analyzeModuleGraph(entryModules);
+    const dynamicallyDependentEntryPointsByDynamicEntry = getDynamicDependentEntryPoints(dependentEntryPointsByModule, dynamicEntryModules);
+    const staticEntries = new Set(entryModules);
+    function assignEntryToStaticDependencies(entry, dynamicDependentEntryPoints) {
+        const modulesToHandle = new Set([entry]);
+        for (const module of modulesToHandle) {
+            const assignedEntryPoints = getOrCreate(assignedEntryPointsByModule, module, () => new Set());
+            if (dynamicDependentEntryPoints &&
+                areEntryPointsContainedOrDynamicallyDependent(dynamicDependentEntryPoints, dependentEntryPointsByModule.get(module))) {
+                continue;
+            }
+            else {
+                assignedEntryPoints.add(entry);
+            }
+            for (const dependency of module.getDependenciesToBeIncluded()) {
+                if (!(dependency instanceof ExternalModule || modulesInManualChunks.has(dependency))) {
+                    modulesToHandle.add(dependency);
+                }
+            }
+        }
+    }
+    function areEntryPointsContainedOrDynamicallyDependent(entryPoints, containedIn) {
+        const entriesToCheck = new Set(entryPoints);
+        for (const entry of entriesToCheck) {
+            if (!containedIn.has(entry)) {
+                if (staticEntries.has(entry))
+                    return false;
+                const dynamicallyDependentEntryPoints = dynamicallyDependentEntryPointsByDynamicEntry.get(entry);
+                for (const dependentEntry of dynamicallyDependentEntryPoints) {
+                    entriesToCheck.add(dependentEntry);
+                }
+            }
+        }
+        return true;
+    }
+    for (const entry of entryModules) {
+        if (!modulesInManualChunks.has(entry)) {
+            assignEntryToStaticDependencies(entry, null);
+        }
+    }
+    for (const entry of dynamicEntryModules) {
         if (!modulesInManualChunks.has(entry)) {
-            assignEntryToStaticDependencies(entry, dependentEntriesByModule, assignedEntriesByModule, modulesInManualChunks, staticEntries, dynamicallyDependentEntriesByDynamicEntry);
+            assignEntryToStaticDependencies(entry, dynamicallyDependentEntryPointsByDynamicEntry.get(entry));
         }
     }
-    chunkDefinitions.push(...createChunks(allEntries, assignedEntriesByModule, minChunkSize));
+    chunkDefinitions.push(...createChunks([...entryModules, ...dynamicEntryModules], assignedEntryPointsByModule));
     return chunkDefinitions;
 }
 function addStaticDependenciesToManualChunk(entry, manualChunkModules, modulesInManualChunks) {
@@ -16584,155 +15675,54 @@
         }
     }
 }
-function analyzeModuleGraph(entries) {
-    const dynamicEntries = new Set();
-    const dependentEntriesByModule = new Map();
-    const allEntries = new Set(entries);
-    for (const currentEntry of allEntries) {
+function analyzeModuleGraph(entryModules) {
+    const dynamicEntryModules = new Set();
+    const dependentEntryPointsByModule = new Map();
+    const entriesToHandle = new Set(entryModules);
+    for (const currentEntry of entriesToHandle) {
         const modulesToHandle = new Set([currentEntry]);
         for (const module of modulesToHandle) {
-            getOrCreate(dependentEntriesByModule, module, getNewSet).add(currentEntry);
+            getOrCreate(dependentEntryPointsByModule, module, () => new Set()).add(currentEntry);
             for (const dependency of module.getDependenciesToBeIncluded()) {
                 if (!(dependency instanceof ExternalModule)) {
                     modulesToHandle.add(dependency);
                 }
             }
             for (const { resolution } of module.dynamicImports) {
-                if (resolution instanceof Module &&
-                    resolution.includedDynamicImporters.length > 0 &&
-                    !allEntries.has(resolution)) {
-                    dynamicEntries.add(resolution);
-                    allEntries.add(resolution);
+                if (resolution instanceof Module && resolution.includedDynamicImporters.length > 0) {
+                    dynamicEntryModules.add(resolution);
+                    entriesToHandle.add(resolution);
                 }
             }
             for (const dependency of module.implicitlyLoadedBefore) {
-                if (!allEntries.has(dependency)) {
-                    dynamicEntries.add(dependency);
-                    allEntries.add(dependency);
-                }
+                dynamicEntryModules.add(dependency);
+                entriesToHandle.add(dependency);
             }
         }
     }
-    return {
-        allEntries,
-        dependentEntriesByModule,
-        dynamicallyDependentEntriesByDynamicEntry: getDynamicallyDependentEntriesByDynamicEntry(dependentEntriesByModule, dynamicEntries)
-    };
+    return { dependentEntryPointsByModule, dynamicEntryModules };
 }
-function getDynamicallyDependentEntriesByDynamicEntry(dependentEntriesByModule, dynamicEntries) {
-    const dynamicallyDependentEntriesByDynamicEntry = new Map();
-    for (const dynamicEntry of dynamicEntries) {
-        const dynamicallyDependentEntries = getOrCreate(dynamicallyDependentEntriesByDynamicEntry, dynamicEntry, getNewSet);
+function getDynamicDependentEntryPoints(dependentEntryPointsByModule, dynamicEntryModules) {
+    const dynamicallyDependentEntryPointsByDynamicEntry = new Map();
+    for (const dynamicEntry of dynamicEntryModules) {
+        const dynamicDependentEntryPoints = getOrCreate(dynamicallyDependentEntryPointsByDynamicEntry, dynamicEntry, () => new Set());
         for (const importer of [
             ...dynamicEntry.includedDynamicImporters,
             ...dynamicEntry.implicitlyLoadedAfter
         ]) {
-            for (const entry of dependentEntriesByModule.get(importer)) {
-                dynamicallyDependentEntries.add(entry);
-            }
-        }
-    }
-    return dynamicallyDependentEntriesByDynamicEntry;
-}
-function assignEntryToStaticDependencies(entry, dependentEntriesByModule, assignedEntriesByModule, modulesInManualChunks, staticEntries, dynamicallyDependentEntriesByDynamicEntry) {
-    const dynamicallyDependentEntries = dynamicallyDependentEntriesByDynamicEntry.get(entry);
-    const modulesToHandle = new Set([entry]);
-    for (const module of modulesToHandle) {
-        const assignedEntries = getOrCreate(assignedEntriesByModule, module, getNewSet);
-        if (dynamicallyDependentEntries &&
-            isModuleAlreadyLoaded(dynamicallyDependentEntries, dependentEntriesByModule.get(module), staticEntries, dynamicallyDependentEntriesByDynamicEntry)) {
-            continue;
-        }
-        else {
-            assignedEntries.add(entry);
-        }
-        for (const dependency of module.getDependenciesToBeIncluded()) {
-            if (!(dependency instanceof ExternalModule || modulesInManualChunks.has(dependency))) {
-                modulesToHandle.add(dependency);
-            }
-        }
-    }
-}
-const MAX_ENTRIES_TO_CHECK_FOR_SHARED_DEPENDENCIES = 3;
-// An approach to further speed this up might be
-// - first, create chunks without looking for modules already in memory
-// - all modules that are in the same chunk after this will behave the same
-//   -> Do not iterate by module but by equivalence group and merge chunks
-function isModuleAlreadyLoaded(dynamicallyDependentEntries, containedIn, staticEntries, dynamicallyDependentEntriesByDynamicEntry) {
-    if (dynamicallyDependentEntries.size > MAX_ENTRIES_TO_CHECK_FOR_SHARED_DEPENDENCIES) {
-        return false;
-    }
-    const entriesToCheck = new Set(dynamicallyDependentEntries);
-    for (const entry of entriesToCheck) {
-        if (!containedIn.has(entry)) {
-            if (staticEntries.has(entry)) {
-                return false;
-            }
-            const dynamicallyDependentEntries = dynamicallyDependentEntriesByDynamicEntry.get(entry);
-            if (dynamicallyDependentEntries.size > MAX_ENTRIES_TO_CHECK_FOR_SHARED_DEPENDENCIES) {
-                return false;
-            }
-            for (const dependentEntry of dynamicallyDependentEntries) {
-                entriesToCheck.add(dependentEntry);
-            }
-        }
-    }
-    return true;
-}
-function createChunks(allEntries, assignedEntriesByModule, minChunkSize) {
-    const chunkModulesBySignature = getChunkModulesBySignature(assignedEntriesByModule, allEntries);
-    return minChunkSize === 0
-        ? Object.values(chunkModulesBySignature).map(modules => ({
-            alias: null,
-            modules
-        }))
-        : getOptimizedChunks(chunkModulesBySignature, minChunkSize);
-}
-function getOptimizedChunks(chunkModulesBySignature, minChunkSize) {
-    timeStart('optimize chunks', 3);
-    const { chunksToBeMerged, unmergeableChunks } = getMergeableChunks(chunkModulesBySignature, minChunkSize);
-    for (const sourceChunk of chunksToBeMerged) {
-        chunksToBeMerged.delete(sourceChunk);
-        let closestChunk = null;
-        let closestChunkDistance = Infinity;
-        const { signature, size, modules } = sourceChunk;
-        for (const targetChunk of concatLazy(chunksToBeMerged, unmergeableChunks)) {
-            const distance = getSignatureDistance(signature, targetChunk.signature, !chunksToBeMerged.has(targetChunk));
-            if (distance === 1) {
-                closestChunk = targetChunk;
-                break;
-            }
-            else if (distance < closestChunkDistance) {
-                closestChunk = targetChunk;
-                closestChunkDistance = distance;
-            }
-        }
-        if (closestChunk) {
-            closestChunk.modules.push(...modules);
-            if (chunksToBeMerged.has(closestChunk)) {
-                closestChunk.signature = mergeSignatures(signature, closestChunk.signature);
-                if ((closestChunk.size += size) > minChunkSize) {
-                    chunksToBeMerged.delete(closestChunk);
-                    unmergeableChunks.push(closestChunk);
-                }
+            for (const entryPoint of dependentEntryPointsByModule.get(importer)) {
+                dynamicDependentEntryPoints.add(entryPoint);
             }
         }
-        else {
-            unmergeableChunks.push(sourceChunk);
-        }
     }
-    timeEnd('optimize chunks', 3);
-    return unmergeableChunks;
+    return dynamicallyDependentEntryPointsByDynamicEntry;
 }
-const CHAR_DEPENDENT = 'X';
-const CHAR_INDEPENDENT = '_';
-const CHAR_CODE_DEPENDENT = CHAR_DEPENDENT.charCodeAt(0);
-function getChunkModulesBySignature(assignedEntriesByModule, allEntries) {
+function createChunks(allEntryPoints, assignedEntryPointsByModule) {
     const chunkModules = Object.create(null);
-    for (const [module, assignedEntries] of assignedEntriesByModule) {
+    for (const [module, assignedEntryPoints] of assignedEntryPointsByModule) {
         let chunkSignature = '';
-        for (const entry of allEntries) {
-            chunkSignature += assignedEntries.has(entry) ? CHAR_DEPENDENT : CHAR_INDEPENDENT;
+        for (const entry of allEntryPoints) {
+            chunkSignature += assignedEntryPoints.has(entry) ? 'X' : '_';
         }
         const chunk = chunkModules[chunkSignature];
         if (chunk) {
@@ -16742,56 +15732,10 @@
             chunkModules[chunkSignature] = [module];
         }
     }
-    return chunkModules;
-}
-function getMergeableChunks(chunkModulesBySignature, minChunkSize) {
-    const chunksToBeMerged = new Set();
-    const unmergeableChunks = [];
-    const alias = null;
-    for (const [signature, modules] of Object.entries(chunkModulesBySignature)) {
-        let size = 0;
-        checkModules: {
-            for (const module of modules) {
-                if (module.hasEffects()) {
-                    break checkModules;
-                }
-                size += module.magicString.toString().length;
-                if (size > minChunkSize) {
-                    break checkModules;
-                }
-            }
-            chunksToBeMerged.add({ alias, modules, signature, size });
-            continue;
-        }
-        unmergeableChunks.push({ alias, modules, signature, size: null });
-    }
-    return { chunksToBeMerged, unmergeableChunks };
-}
-function getSignatureDistance(sourceSignature, targetSignature, enforceSubset) {
-    let distance = 0;
-    const { length } = sourceSignature;
-    for (let index = 0; index < length; index++) {
-        const sourceValue = sourceSignature.charCodeAt(index);
-        if (sourceValue !== targetSignature.charCodeAt(index)) {
-            if (enforceSubset && sourceValue === CHAR_CODE_DEPENDENT) {
-                return Infinity;
-            }
-            distance++;
-        }
-    }
-    return distance;
-}
-function mergeSignatures(sourceSignature, targetSignature) {
-    let signature = '';
-    const { length } = sourceSignature;
-    for (let index = 0; index < length; index++) {
-        signature +=
-            sourceSignature.charCodeAt(index) === CHAR_CODE_DEPENDENT ||
-                targetSignature.charCodeAt(index) === CHAR_CODE_DEPENDENT
-                ? CHAR_DEPENDENT
-                : CHAR_INDEPENDENT;
-    }
-    return signature;
+    return Object.values(chunkModules).map(modules => ({
+        alias: null,
+        modules
+    }));
 }
 
 // ported from https://github.com/substack/node-commondir
@@ -16799,14 +15743,14 @@
     if (files.length === 0)
         return '/';
     if (files.length === 1)
-        return node_path.dirname(files[0]);
+        return path$2.dirname(files[0]);
     const commonSegments = files.slice(1).reduce((commonSegments, file) => {
         const pathSegements = file.split(/\/+|\\+/);
-        let index;
-        for (index = 0; commonSegments[index] === pathSegements[index] &&
-            index < Math.min(commonSegments.length, pathSegements.length); index++)
+        let i;
+        for (i = 0; commonSegments[i] === pathSegements[i] &&
+            i < Math.min(commonSegments.length, pathSegements.length); i++)
             ;
-        return commonSegments.slice(0, index);
+        return commonSegments.slice(0, i);
     }, files[0].split(/\/+|\\+/));
     // Windows correctly handles paths with forward-slashes
     return commonSegments.length > 1 ? commonSegments.join('/') : '/';
@@ -16848,28 +15792,28 @@
         module.execIndex = nextExecIndex++;
         analysedModules.add(module);
     };
-    for (const currentEntry of entryModules) {
-        if (!parents.has(currentEntry)) {
-            parents.set(currentEntry, null);
-            analyseModule(currentEntry);
+    for (const curEntry of entryModules) {
+        if (!parents.has(curEntry)) {
+            parents.set(curEntry, null);
+            analyseModule(curEntry);
         }
     }
-    for (const currentEntry of dynamicImports) {
-        if (!parents.has(currentEntry)) {
-            parents.set(currentEntry, null);
-            analyseModule(currentEntry);
+    for (const curEntry of dynamicImports) {
+        if (!parents.has(curEntry)) {
+            parents.set(curEntry, null);
+            analyseModule(curEntry);
         }
     }
     return { cyclePaths, orderedModules };
 }
 function getCyclePath(module, parent, parents) {
     const cycleSymbol = Symbol(module.id);
-    const path = [module.id];
+    const path = [relativeId(module.id)];
     let nextModule = parent;
     module.cycles.add(cycleSymbol);
     while (nextModule !== module) {
         nextModule.cycles.add(cycleSymbol);
-        path.push(nextModule.id);
+        path.push(relativeId(nextModule.id));
         nextModule = parents.get(nextModule);
     }
     path.push(path[0]);
@@ -16880,16 +15824,16 @@
 function getGenerateCodeSnippets({ compact, generatedCode: { arrowFunctions, constBindings, objectShorthand, reservedNamesAsProps } }) {
     const { _, n, s } = compact ? { _: '', n: '', s: '' } : { _: ' ', n: '\n', s: ';' };
     const cnst = constBindings ? 'const' : 'var';
-    const getNonArrowFunctionIntro = (parameters, { isAsync, name }) => `${isAsync ? `async ` : ''}function${name ? ` ${name}` : ''}${_}(${parameters.join(`,${_}`)})${_}`;
+    const getNonArrowFunctionIntro = (params, { isAsync, name }) => `${isAsync ? `async ` : ''}function${name ? ` ${name}` : ''}${_}(${params.join(`,${_}`)})${_}`;
     const getFunctionIntro = arrowFunctions
-        ? (parameters, { isAsync, name }) => {
-            const singleParameter = parameters.length === 1;
-            const asyncString = isAsync ? `async${singleParameter ? ' ' : _}` : '';
-            return `${name ? `${cnst} ${name}${_}=${_}` : ''}${asyncString}${singleParameter ? parameters[0] : `(${parameters.join(`,${_}`)})`}${_}=>${_}`;
+        ? (params, { isAsync, name }) => {
+            const singleParam = params.length === 1;
+            const asyncString = isAsync ? `async${singleParam ? ' ' : _}` : '';
+            return `${name ? `${cnst} ${name}${_}=${_}` : ''}${asyncString}${singleParam ? params[0] : `(${params.join(`,${_}`)})`}${_}=>${_}`;
         }
         : getNonArrowFunctionIntro;
-    const getDirectReturnFunction = (parameters, { functionReturn, lineBreakIndent, name }) => [
-        `${getFunctionIntro(parameters, {
+    const getDirectReturnFunction = (params, { functionReturn, lineBreakIndent, name }) => [
+        `${getFunctionIntro(params, {
             isAsync: false,
             name
         })}${arrowFunctions
@@ -16901,15 +15845,15 @@
             ? `${name ? ';' : ''}${lineBreakIndent ? `${n}${lineBreakIndent.base}` : ''}`
             : `${s}${lineBreakIndent ? `${n}${lineBreakIndent.base}` : _}}`
     ];
-    const isValidPropertyName = reservedNamesAsProps
-        ? (name) => validPropertyName.test(name)
-        : (name) => !RESERVED_NAMES$1.has(name) && validPropertyName.test(name);
+    const isValidPropName = reservedNamesAsProps
+        ? (name) => validPropName.test(name)
+        : (name) => !RESERVED_NAMES[name] && validPropName.test(name);
     return {
         _,
         cnst,
         getDirectReturnFunction,
-        getDirectReturnIifeLeft: (parameters, returned, { needsArrowReturnParens, needsWrappedFunction }) => {
-            const [left, right] = getDirectReturnFunction(parameters, {
+        getDirectReturnIifeLeft: (params, returned, { needsArrowReturnParens, needsWrappedFunction }) => {
+            const [left, right] = getDirectReturnFunction(params, {
                 functionReturn: true,
                 lineBreakIndent: null,
                 name: null
@@ -16924,373 +15868,20 @@
                 .map(([key, value]) => {
                 if (key === null)
                     return `${prefix}${value}`;
-                const needsQuotes = !isValidPropertyName(key);
+                const needsQuotes = !isValidPropName(key);
                 return key === value && objectShorthand && !needsQuotes
                     ? prefix + key
                     : `${prefix}${needsQuotes ? `'${key}'` : key}:${_}${value}`;
             })
                 .join(`,`)}${fields.length === 0 ? '' : lineBreakIndent ? `${n}${lineBreakIndent.base}` : _}}`;
         },
-        getPropertyAccess: (name) => isValidPropertyName(name) ? `.${name}` : `[${JSON.stringify(name)}]`,
+        getPropertyAccess: (name) => isValidPropName(name) ? `.${name}` : `[${JSON.stringify(name)}]`,
         n,
         s
     };
 }
 const wrapIfNeeded = (code, needsParens) => needsParens ? `(${code})` : code;
-const validPropertyName = /^(?!\d)[\w$]+$/;
-
-class Source {
-    constructor(filename, content) {
-        this.isOriginal = true;
-        this.filename = filename;
-        this.content = content;
-    }
-    traceSegment(line, column, name) {
-        return { column, line, name, source: this };
-    }
-}
-class Link {
-    constructor(map, sources) {
-        this.sources = sources;
-        this.names = map.names;
-        this.mappings = map.mappings;
-    }
-    traceMappings() {
-        const sources = [];
-        const sourceIndexMap = new Map();
-        const sourcesContent = [];
-        const names = [];
-        const nameIndexMap = new Map();
-        const mappings = [];
-        for (const line of this.mappings) {
-            const tracedLine = [];
-            for (const segment of line) {
-                if (segment.length === 1)
-                    continue;
-                const source = this.sources[segment[1]];
-                if (!source)
-                    continue;
-                const traced = source.traceSegment(segment[2], segment[3], segment.length === 5 ? this.names[segment[4]] : '');
-                if (traced) {
-                    const { column, line, name, source: { content, filename } } = traced;
-                    let sourceIndex = sourceIndexMap.get(filename);
-                    if (sourceIndex === undefined) {
-                        sourceIndex = sources.length;
-                        sources.push(filename);
-                        sourceIndexMap.set(filename, sourceIndex);
-                        sourcesContent[sourceIndex] = content;
-                    }
-                    else if (sourcesContent[sourceIndex] == null) {
-                        sourcesContent[sourceIndex] = content;
-                    }
-                    else if (content != null && sourcesContent[sourceIndex] !== content) {
-                        return error(errorConflictingSourcemapSources(filename));
-                    }
-                    const tracedSegment = [segment[0], sourceIndex, line, column];
-                    if (name) {
-                        let nameIndex = nameIndexMap.get(name);
-                        if (nameIndex === undefined) {
-                            nameIndex = names.length;
-                            names.push(name);
-                            nameIndexMap.set(name, nameIndex);
-                        }
-                        tracedSegment[4] = nameIndex;
-                    }
-                    tracedLine.push(tracedSegment);
-                }
-            }
-            mappings.push(tracedLine);
-        }
-        return { mappings, names, sources, sourcesContent };
-    }
-    traceSegment(line, column, name) {
-        const segments = this.mappings[line];
-        if (!segments)
-            return null;
-        // binary search through segments for the given column
-        let searchStart = 0;
-        let searchEnd = segments.length - 1;
-        while (searchStart <= searchEnd) {
-            const m = (searchStart + searchEnd) >> 1;
-            const segment = segments[m];
-            // If a sourcemap does not have sufficient resolution to contain a
-            // necessary mapping, e.g. because it only contains line information, we
-            // use the best approximation we could find
-            if (segment[0] === column || searchStart === searchEnd) {
-                if (segment.length == 1)
-                    return null;
-                const source = this.sources[segment[1]];
-                if (!source)
-                    return null;
-                return source.traceSegment(segment[2], segment[3], segment.length === 5 ? this.names[segment[4]] : name);
-            }
-            if (segment[0] > column) {
-                searchEnd = m - 1;
-            }
-            else {
-                searchStart = m + 1;
-            }
-        }
-        return null;
-    }
-}
-function getLinkMap(warn) {
-    return function linkMap(source, map) {
-        if (map.mappings) {
-            return new Link(map, [source]);
-        }
-        warn(errorSourcemapBroken(map.plugin));
-        return new Link({
-            mappings: [],
-            names: []
-        }, [source]);
-    };
-}
-function getCollapsedSourcemap(id, originalCode, originalSourcemap, sourcemapChain, linkMap) {
-    let source;
-    if (originalSourcemap) {
-        const sources = originalSourcemap.sources;
-        const sourcesContent = originalSourcemap.sourcesContent || [];
-        const directory = node_path.dirname(id) || '.';
-        const sourceRoot = originalSourcemap.sourceRoot || '.';
-        const baseSources = sources.map((source, index) => new Source(node_path.resolve(directory, sourceRoot, source), sourcesContent[index]));
-        source = new Link(originalSourcemap, baseSources);
-    }
-    else {
-        source = new Source(id, originalCode);
-    }
-    return sourcemapChain.reduce(linkMap, source);
-}
-function collapseSourcemaps(file, map, modules, bundleSourcemapChain, excludeContent, warn) {
-    const linkMap = getLinkMap(warn);
-    const moduleSources = modules
-        .filter(module => !module.excludeFromSourcemap)
-        .map(module => getCollapsedSourcemap(module.id, module.originalCode, module.originalSourcemap, module.sourcemapChain, linkMap));
-    const link = new Link(map, moduleSources);
-    const source = bundleSourcemapChain.reduce(linkMap, link);
-    let { sources, sourcesContent, names, mappings } = source.traceMappings();
-    if (file) {
-        const directory = node_path.dirname(file);
-        sources = sources.map((source) => node_path.relative(directory, source));
-        file = node_path.basename(file);
-    }
-    sourcesContent = (excludeContent ? null : sourcesContent);
-    return new SourceMap({ file, mappings, names, sources, sourcesContent });
-}
-function collapseSourcemap(id, originalCode, originalSourcemap, sourcemapChain, warn) {
-    if (sourcemapChain.length === 0) {
-        return originalSourcemap;
-    }
-    const source = getCollapsedSourcemap(id, originalCode, originalSourcemap, sourcemapChain, getLinkMap(warn));
-    const map = source.traceMappings();
-    return { version: 3, ...map };
-}
-
-const createHash = () => node_crypto.createHash('sha256');
-
-function decodedSourcemap(map) {
-    if (!map)
-        return null;
-    if (typeof map === 'string') {
-        map = JSON.parse(map);
-    }
-    if (map.mappings === '') {
-        return {
-            mappings: [],
-            names: [],
-            sources: [],
-            version: 3
-        };
-    }
-    const mappings = typeof map.mappings === 'string' ? decode(map.mappings) : map.mappings;
-    return { ...map, mappings };
-}
-
-async function renderChunks(chunks, bundle, pluginDriver, outputOptions, onwarn) {
-    timeStart('render chunks', 2);
-    reserveEntryChunksInBundle(chunks);
-    const renderedChunks = await Promise.all(chunks.map(chunk => chunk.render()));
-    timeEnd('render chunks', 2);
-    timeStart('transform chunks', 2);
-    const chunkGraph = getChunkGraph(chunks);
-    const { nonHashedChunksWithPlaceholders, renderedChunksByPlaceholder, hashDependenciesByPlaceholder } = await transformChunksAndGenerateContentHashes(renderedChunks, chunkGraph, outputOptions, pluginDriver, onwarn);
-    const hashesByPlaceholder = generateFinalHashes(renderedChunksByPlaceholder, hashDependenciesByPlaceholder, bundle);
-    addChunksToBundle(renderedChunksByPlaceholder, hashesByPlaceholder, bundle, nonHashedChunksWithPlaceholders, pluginDriver, outputOptions);
-    timeEnd('transform chunks', 2);
-}
-function reserveEntryChunksInBundle(chunks) {
-    for (const chunk of chunks) {
-        if (chunk.facadeModule && chunk.facadeModule.isUserDefinedEntryPoint) {
-            // reserves name in bundle as side effect if it does not contain a hash
-            chunk.getPreliminaryFileName();
-        }
-    }
-}
-function getChunkGraph(chunks) {
-    return Object.fromEntries(chunks.map(chunk => {
-        const renderedChunkInfo = chunk.getRenderedChunkInfo();
-        return [renderedChunkInfo.fileName, renderedChunkInfo];
-    }));
-}
-async function transformChunk(magicString, fileName, usedModules, chunkGraph, options, outputPluginDriver, onwarn) {
-    let map = null;
-    const sourcemapChain = [];
-    let code = await outputPluginDriver.hookReduceArg0('renderChunk', [magicString.toString(), chunkGraph[fileName], options, { chunks: chunkGraph }], (code, result, plugin) => {
-        if (result == null)
-            return code;
-        if (typeof result === 'string')
-            result = {
-                code: result,
-                map: undefined
-            };
-        // strict null check allows 'null' maps to not be pushed to the chain, while 'undefined' gets the missing map warning
-        if (result.map !== null) {
-            const map = decodedSourcemap(result.map);
-            sourcemapChain.push(map || { missing: true, plugin: plugin.name });
-        }
-        return result.code;
-    });
-    const { compact, dir, file, sourcemap, sourcemapExcludeSources, sourcemapFile, sourcemapPathTransform } = options;
-    if (!compact && code[code.length - 1] !== '\n')
-        code += '\n';
-    if (sourcemap) {
-        timeStart('sourcemaps', 3);
-        let resultingFile;
-        if (file)
-            resultingFile = node_path.resolve(sourcemapFile || file);
-        else if (dir)
-            resultingFile = node_path.resolve(dir, fileName);
-        else
-            resultingFile = node_path.resolve(fileName);
-        const decodedMap = magicString.generateDecodedMap({});
-        map = collapseSourcemaps(resultingFile, decodedMap, usedModules, sourcemapChain, sourcemapExcludeSources, onwarn);
-        map.sources = map.sources
-            .map(sourcePath => {
-            if (sourcemapPathTransform) {
-                const newSourcePath = sourcemapPathTransform(sourcePath, `${resultingFile}.map`);
-                if (typeof newSourcePath !== 'string') {
-                    error(errorFailedValidation(`sourcemapPathTransform function must return a string.`));
-                }
-                return newSourcePath;
-            }
-            return sourcePath;
-        })
-            .map(normalize);
-        timeEnd('sourcemaps', 3);
-    }
-    return {
-        code,
-        map
-    };
-}
-async function transformChunksAndGenerateContentHashes(renderedChunks, chunkGraph, outputOptions, pluginDriver, onwarn) {
-    const nonHashedChunksWithPlaceholders = [];
-    const renderedChunksByPlaceholder = new Map();
-    const hashDependenciesByPlaceholder = new Map();
-    const placeholders = new Set();
-    for (const { preliminaryFileName: { hashPlaceholder } } of renderedChunks) {
-        if (hashPlaceholder)
-            placeholders.add(hashPlaceholder);
-    }
-    await Promise.all(renderedChunks.map(async ({ chunk, preliminaryFileName: { fileName, hashPlaceholder }, magicString, usedModules }) => {
-        const transformedChunk = {
-            chunk,
-            fileName,
-            ...(await transformChunk(magicString, fileName, usedModules, chunkGraph, outputOptions, pluginDriver, onwarn))
-        };
-        const { code } = transformedChunk;
-        if (hashPlaceholder) {
-            const hash = createHash();
-            // To create a reproducible content-only hash, all placeholders are
-            // replaced with the same value before hashing
-            const { containedPlaceholders, transformedCode } = replacePlaceholdersWithDefaultAndGetContainedPlaceholders(code, placeholders);
-            hash.update(transformedCode);
-            const hashAugmentation = pluginDriver.hookReduceValueSync('augmentChunkHash', '', [chunk.getRenderedChunkInfo()], (augmentation, pluginHash) => {
-                if (pluginHash) {
-                    augmentation += pluginHash;
-                }
-                return augmentation;
-            });
-            if (hashAugmentation) {
-                hash.update(hashAugmentation);
-            }
-            renderedChunksByPlaceholder.set(hashPlaceholder, transformedChunk);
-            hashDependenciesByPlaceholder.set(hashPlaceholder, {
-                containedPlaceholders,
-                contentHash: hash.digest('hex')
-            });
-        }
-        else {
-            nonHashedChunksWithPlaceholders.push(transformedChunk);
-        }
-    }));
-    return {
-        hashDependenciesByPlaceholder,
-        nonHashedChunksWithPlaceholders,
-        renderedChunksByPlaceholder
-    };
-}
-function generateFinalHashes(renderedChunksByPlaceholder, hashDependenciesByPlaceholder, bundle) {
-    const hashesByPlaceholder = new Map();
-    for (const [placeholder, { fileName }] of renderedChunksByPlaceholder) {
-        let hash = createHash();
-        const hashDependencyPlaceholders = new Set([placeholder]);
-        for (const dependencyPlaceholder of hashDependencyPlaceholders) {
-            const { containedPlaceholders, contentHash } = hashDependenciesByPlaceholder.get(dependencyPlaceholder);
-            hash.update(contentHash);
-            for (const containedPlaceholder of containedPlaceholders) {
-                // When looping over a map, setting an entry only causes a new iteration if the key is new
-                hashDependencyPlaceholders.add(containedPlaceholder);
-            }
-        }
-        let finalFileName;
-        let finalHash;
-        do {
-            // In case of a hash collision, create a hash of the hash
-            if (finalHash) {
-                hash = createHash();
-                hash.update(finalHash);
-            }
-            finalHash = hash.digest('hex').slice(0, placeholder.length);
-            finalFileName = replaceSinglePlaceholder(fileName, placeholder, finalHash);
-        } while (bundle[lowercaseBundleKeys].has(finalFileName.toLowerCase()));
-        bundle[finalFileName] = FILE_PLACEHOLDER;
-        hashesByPlaceholder.set(placeholder, finalHash);
-    }
-    return hashesByPlaceholder;
-}
-function addChunksToBundle(renderedChunksByPlaceholder, hashesByPlaceholder, bundle, nonHashedChunksWithPlaceholders, pluginDriver, options) {
-    for (const { chunk, code, fileName, map } of renderedChunksByPlaceholder.values()) {
-        let updatedCode = replacePlaceholders(code, hashesByPlaceholder);
-        const finalFileName = replacePlaceholders(fileName, hashesByPlaceholder);
-        if (map) {
-            map.file = replacePlaceholders(map.file, hashesByPlaceholder);
-            updatedCode += emitSourceMapAndGetComment(finalFileName, map, pluginDriver, options);
-        }
-        bundle[finalFileName] = chunk.finalizeChunk(updatedCode, map, hashesByPlaceholder);
-    }
-    for (const { chunk, code, fileName, map } of nonHashedChunksWithPlaceholders) {
-        let updatedCode = hashesByPlaceholder.size > 0 ? replacePlaceholders(code, hashesByPlaceholder) : code;
-        if (map) {
-            updatedCode += emitSourceMapAndGetComment(fileName, map, pluginDriver, options);
-        }
-        bundle[fileName] = chunk.finalizeChunk(updatedCode, map, hashesByPlaceholder);
-    }
-}
-function emitSourceMapAndGetComment(fileName, map, pluginDriver, { sourcemap, sourcemapBaseUrl }) {
-    let url;
-    if (sourcemap === 'inline') {
-        url = map.toUrl();
-    }
-    else {
-        const sourcemapFileName = `${node_path.basename(fileName)}.map`;
-        url = sourcemapBaseUrl
-            ? new URL(sourcemapFileName, sourcemapBaseUrl).toString()
-            : sourcemapFileName;
-        pluginDriver.emitFile({ fileName: `${fileName}.map`, source: map.toString(), type: 'asset' });
-    }
-    return sourcemap === 'hidden' ? '' : `//# ${SOURCEMAPPING_URL}=${url}\n`;
-}
+const validPropName = /^(?!\d)[\w$]+$/;
 
 class Bundle {
     constructor(outputOptions, unsetOptions, inputOptions, pluginDriver, graph) {
@@ -17304,41 +15895,48 @@
     }
     async generate(isWrite) {
         timeStart('GENERATE', 1);
-        const outputBundleBase = Object.create(null);
-        const outputBundle = getOutputBundle(outputBundleBase);
-        this.pluginDriver.setOutputBundle(outputBundle, this.outputOptions);
+        const outputBundle = Object.create(null);
+        this.pluginDriver.setOutputBundle(outputBundle, this.outputOptions, this.facadeChunkByModule);
         try {
-            timeStart('initialize render', 2);
             await this.pluginDriver.hookParallel('renderStart', [this.outputOptions, this.inputOptions]);
-            timeEnd('initialize render', 2);
             timeStart('generate chunks', 2);
-            const getHashPlaceholder = getHashPlaceholderGenerator();
-            const chunks = await this.generateChunks(outputBundle, getHashPlaceholder);
+            const chunks = await this.generateChunks();
             if (chunks.length > 1) {
                 validateOptionsForMultiChunkOutput(this.outputOptions, this.inputOptions.onwarn);
             }
-            this.pluginDriver.setChunkInformation(this.facadeChunkByModule);
-            for (const chunk of chunks) {
-                chunk.generateExports();
-            }
+            const inputBase = commondir(getAbsoluteEntryModulePaths(chunks));
             timeEnd('generate chunks', 2);
-            await renderChunks(chunks, outputBundle, this.pluginDriver, this.outputOptions, this.inputOptions.onwarn);
-        }
-        catch (error_) {
-            await this.pluginDriver.hookParallel('renderError', [error_]);
-            throw error_;
+            timeStart('render modules', 2);
+            // We need to create addons before prerender because at the moment, there
+            // can be no async code between prerender and render due to internal state
+            const addons = await createAddons(this.outputOptions, this.pluginDriver);
+            const snippets = getGenerateCodeSnippets(this.outputOptions);
+            this.prerenderChunks(chunks, inputBase, snippets);
+            timeEnd('render modules', 2);
+            await this.addFinalizedChunksToBundle(chunks, inputBase, addons, outputBundle, snippets);
+        }
+        catch (err) {
+            await this.pluginDriver.hookParallel('renderError', [err]);
+            throw err;
         }
-        removeUnreferencedAssets(outputBundle);
-        timeStart('generate bundle', 2);
         await this.pluginDriver.hookSeq('generateBundle', [
             this.outputOptions,
             outputBundle,
             isWrite
         ]);
         this.finaliseAssets(outputBundle);
-        timeEnd('generate bundle', 2);
         timeEnd('GENERATE', 1);
-        return outputBundleBase;
+        return outputBundle;
+    }
+    async addFinalizedChunksToBundle(chunks, inputBase, addons, outputBundle, snippets) {
+        this.assignChunkIds(chunks, inputBase, addons, outputBundle);
+        for (const chunk of chunks) {
+            outputBundle[chunk.id] = chunk.getChunkInfoWithFileNames();
+        }
+        await Promise.all(chunks.map(async (chunk) => {
+            const outputChunk = outputBundle[chunk.id];
+            Object.assign(outputChunk, await chunk.render(this.outputOptions, addons, outputChunk, snippets));
+        }));
     }
     async addManualChunks(manualChunks) {
         const manualChunkAliasByEntry = new Map();
@@ -17353,9 +15951,31 @@
         }
         return manualChunkAliasByEntry;
     }
+    assignChunkIds(chunks, inputBase, addons, bundle) {
+        const entryChunks = [];
+        const otherChunks = [];
+        for (const chunk of chunks) {
+            (chunk.facadeModule && chunk.facadeModule.isUserDefinedEntryPoint
+                ? entryChunks
+                : otherChunks).push(chunk);
+        }
+        // make sure entry chunk names take precedence with regard to deconflicting
+        const chunksForNaming = entryChunks.concat(otherChunks);
+        for (const chunk of chunksForNaming) {
+            if (this.outputOptions.file) {
+                chunk.id = path$2.basename(this.outputOptions.file);
+            }
+            else if (this.outputOptions.preserveModules) {
+                chunk.id = chunk.generateIdPreserveModules(inputBase, this.outputOptions, bundle, this.unsetOptions);
+            }
+            else {
+                chunk.id = chunk.generateId(addons, this.outputOptions, bundle, true);
+            }
+            bundle[chunk.id] = FILE_PLACEHOLDER;
+        }
+    }
     assignManualChunks(getManualChunk) {
-        // eslint-disable-next-line unicorn/prefer-module
-        const manualChunkAliasesWithEntry = [];
+        const manualChunkAliasByEntry = new Map();
         const manualChunksApi = {
             getModuleIds: () => this.graph.modulesById.keys(),
             getModuleInfo: this.graph.getModuleInfo
@@ -17364,53 +15984,53 @@
             if (module instanceof Module) {
                 const manualChunkAlias = getManualChunk(module.id, manualChunksApi);
                 if (typeof manualChunkAlias === 'string') {
-                    manualChunkAliasesWithEntry.push([manualChunkAlias, module]);
+                    addModuleToManualChunk(manualChunkAlias, module, manualChunkAliasByEntry);
                 }
             }
         }
-        manualChunkAliasesWithEntry.sort(([aliasA], [aliasB]) => aliasA > aliasB ? 1 : aliasA < aliasB ? -1 : 0);
-        const manualChunkAliasByEntry = new Map();
-        for (const [alias, module] of manualChunkAliasesWithEntry) {
-            addModuleToManualChunk(alias, module, manualChunkAliasByEntry);
-        }
         return manualChunkAliasByEntry;
     }
-    finaliseAssets(bundle) {
-        if (this.outputOptions.validate) {
-            for (const file of Object.values(bundle)) {
-                if ('code' in file) {
-                    try {
-                        this.graph.contextParse(file.code, {
-                            ecmaVersion: 'latest'
-                        });
-                    }
-                    catch (error_) {
-                        this.inputOptions.onwarn(errorChunkInvalid(file, error_));
-                    }
+    finaliseAssets(outputBundle) {
+        for (const file of Object.values(outputBundle)) {
+            if (!file.type) {
+                warnDeprecation('A plugin is directly adding properties to the bundle object in the "generateBundle" hook. This is deprecated and will be removed in a future Rollup version, please use "this.emitFile" instead.', true, this.inputOptions);
+                file.type = 'asset';
+            }
+            if (this.outputOptions.validate && typeof file.code == 'string') {
+                try {
+                    this.graph.contextParse(file.code, {
+                        allowHashBang: true,
+                        ecmaVersion: 'latest'
+                    });
+                }
+                catch (err) {
+                    this.inputOptions.onwarn(errChunkInvalid(file, err));
                 }
             }
         }
         this.pluginDriver.finaliseAssets();
     }
-    async generateChunks(bundle, getHashPlaceholder) {
-        const { experimentalMinChunkSize, inlineDynamicImports, manualChunks, preserveModules } = this.outputOptions;
+    async generateChunks() {
+        const { manualChunks } = this.outputOptions;
         const manualChunkAliasByEntry = typeof manualChunks === 'object'
             ? await this.addManualChunks(manualChunks)
             : this.assignManualChunks(manualChunks);
-        const snippets = getGenerateCodeSnippets(this.outputOptions);
-        const includedModules = getIncludedModules(this.graph.modulesById);
-        const inputBase = commondir(getAbsoluteEntryModulePaths(includedModules, preserveModules));
-        const externalChunkByModule = getExternalChunkByModule(this.graph.modulesById, this.outputOptions, inputBase);
         const chunks = [];
         const chunkByModule = new Map();
-        for (const { alias, modules } of inlineDynamicImports
-            ? [{ alias: null, modules: includedModules }]
-            : preserveModules
-                ? includedModules.map(module => ({ alias: null, modules: [module] }))
-                : getChunkAssignments(this.graph.entryModules, manualChunkAliasByEntry, experimentalMinChunkSize)) {
+        for (const { alias, modules } of this.outputOptions.inlineDynamicImports
+            ? [{ alias: null, modules: getIncludedModules(this.graph.modulesById) }]
+            : this.outputOptions.preserveModules
+                ? getIncludedModules(this.graph.modulesById).map(module => ({
+                    alias: null,
+                    modules: [module]
+                }))
+                : getChunkAssignments(this.graph.entryModules, manualChunkAliasByEntry)) {
             sortByExecutionOrder(modules);
-            const chunk = new Chunk(modules, this.inputOptions, this.outputOptions, this.unsetOptions, this.pluginDriver, this.graph.modulesById, chunkByModule, externalChunkByModule, this.facadeChunkByModule, this.includedNamespaces, alias, getHashPlaceholder, bundle, inputBase, snippets);
+            const chunk = new Chunk(modules, this.inputOptions, this.outputOptions, this.unsetOptions, this.pluginDriver, this.graph.modulesById, chunkByModule, this.facadeChunkByModule, this.includedNamespaces, alias);
             chunks.push(chunk);
+            for (const module of modules) {
+                chunkByModule.set(module, chunk);
+            }
         }
         for (const chunk of chunks) {
             chunk.link();
@@ -17421,67 +16041,48 @@
         }
         return [...chunks, ...facades];
     }
-}
-function validateOptionsForMultiChunkOutput(outputOptions, onWarn) {
-    if (outputOptions.format === 'umd' || outputOptions.format === 'iife')
-        return error(errorInvalidOption('output.format', URL_OUTPUT_FORMAT, 'UMD and IIFE output formats are not supported for code-splitting builds', outputOptions.format));
-    if (typeof outputOptions.file === 'string')
-        return error(errorInvalidOption('output.file', URL_OUTPUT_DIR, 'when building multiple chunks, the "output.dir" option must be used, not "output.file". To inline dynamic imports, set the "inlineDynamicImports" option'));
-    if (outputOptions.sourcemapFile)
-        return error(errorInvalidOption('output.sourcemapFile', URL_OUTPUT_SOURCEMAPFILE, '"output.sourcemapFile" is only supported for single-file builds'));
-    if (!outputOptions.amd.autoId && outputOptions.amd.id)
-        onWarn(errorInvalidOption('output.amd.id', URL_OUTPUT_AMD_ID, 'this option is only properly supported for single-file builds. Use "output.amd.autoId" and "output.amd.basePath" instead'));
-}
-function getIncludedModules(modulesById) {
-    const includedModules = [];
-    for (const module of modulesById.values()) {
-        if (module instanceof Module &&
-            (module.isIncluded() || module.info.isEntry || module.includedDynamicImporters.length > 0)) {
-            includedModules.push(module);
+    prerenderChunks(chunks, inputBase, snippets) {
+        for (const chunk of chunks) {
+            chunk.generateExports();
+        }
+        for (const chunk of chunks) {
+            chunk.preRender(this.outputOptions, inputBase, snippets);
         }
     }
-    return includedModules;
 }
-function getAbsoluteEntryModulePaths(includedModules, preserveModules) {
+function getAbsoluteEntryModulePaths(chunks) {
     const absoluteEntryModulePaths = [];
-    for (const module of includedModules) {
-        if ((module.info.isEntry || preserveModules) && isAbsolute(module.id)) {
-            absoluteEntryModulePaths.push(module.id);
+    for (const chunk of chunks) {
+        for (const entryModule of chunk.entryModules) {
+            if (isAbsolute(entryModule.id)) {
+                absoluteEntryModulePaths.push(entryModule.id);
+            }
         }
     }
     return absoluteEntryModulePaths;
 }
-function getExternalChunkByModule(modulesById, outputOptions, inputBase) {
-    const externalChunkByModule = new Map();
-    for (const module of modulesById.values()) {
-        if (module instanceof ExternalModule) {
-            externalChunkByModule.set(module, new ExternalChunk(module, outputOptions, inputBase));
-        }
-    }
-    return externalChunkByModule;
+function validateOptionsForMultiChunkOutput(outputOptions, onWarn) {
+    if (outputOptions.format === 'umd' || outputOptions.format === 'iife')
+        return error(errInvalidOption('output.format', 'outputformat', 'UMD and IIFE output formats are not supported for code-splitting builds', outputOptions.format));
+    if (typeof outputOptions.file === 'string')
+        return error(errInvalidOption('output.file', 'outputdir', 'when building multiple chunks, the "output.dir" option must be used, not "output.file". To inline dynamic imports, set the "inlineDynamicImports" option'));
+    if (outputOptions.sourcemapFile)
+        return error(errInvalidOption('output.sourcemapFile', 'outputsourcemapfile', '"output.sourcemapFile" is only supported for single-file builds'));
+    if (!outputOptions.amd.autoId && outputOptions.amd.id)
+        onWarn(errInvalidOption('output.amd.id', 'outputamd', 'this option is only properly supported for single-file builds. Use "output.amd.autoId" and "output.amd.basePath" instead'));
+}
+function getIncludedModules(modulesById) {
+    return [...modulesById.values()].filter(module => module instanceof Module &&
+        (module.isIncluded() || module.info.isEntry || module.includedDynamicImporters.length > 0));
 }
 function addModuleToManualChunk(alias, module, manualChunkAliasByEntry) {
     const existingAlias = manualChunkAliasByEntry.get(module);
     if (typeof existingAlias === 'string' && existingAlias !== alias) {
-        return error(errorCannotAssignModuleToChunk(module.id, alias, existingAlias));
+        return error(errCannotAssignModuleToChunk(module.id, alias, existingAlias));
     }
     manualChunkAliasByEntry.set(module, alias);
 }
 
-// This file was generated. Do not modify manually!
-var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
-
-// This file was generated. Do not modify manually!
-var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
-
-// This file was generated. Do not modify manually!
-var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0898-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
-
-// This file was generated. Do not modify manually!
-var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ca\ua7d0\ua7d1\ua7d3\ua7d5-\ua7d9\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
-
-// These are a run-length and offset encoded representation of the
-
 // Reserved word lists for various dialects of the language
 
 var reservedWords = {
@@ -17496,7 +16097,7 @@
 
 var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
 
-var keywords$1 = {
+var keywords = {
   5: ecma5AndLessKeywords,
   "5module": ecma5AndLessKeywords + " export import",
   6: ecma5AndLessKeywords + " const class extends export import super"
@@ -17506,9 +16107,31 @@
 
 // ## Character categories
 
+// Big ugly regular expressions that match characters in the
+// whitespace, identifier, and identifier-start categories. These
+// are only applied when a character is found to actually have a
+// code point above 128.
+// Generated by `bin/generate-identifier-regex.js`.
+var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08c7\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\u9ffc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7ca\ua7f5-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
+var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf\u1ac0\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
+
 var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
 var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
 
+nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
+
+// These are a run-length and offset encoded representation of the
+// >0xffff code points that are a valid part of identifiers. The
+// offset starts at 0x10000, and each pair of numbers represents an
+// offset to the next range, and then a size of the range. They were
+// generated by bin/generate-identifier-regex.js
+
+// eslint-disable-next-line comma-spacing
+var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,349,41,7,1,79,28,11,0,9,21,107,20,28,22,13,52,76,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,190,0,80,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,43,8,8952,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42717,35,4148,12,221,3,5761,15,7472,3104,541,1507,4938];
+
+// eslint-disable-next-line comma-spacing
+var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,370,1,154,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,82,0,12,1,19628,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,4759,9,787719,239];
+
 // This has a complexity linear to the value of the code. The
 // assumption is that looking up astral identifier characters is
 // rare.
@@ -17593,17 +16216,17 @@
 
 // Map keyword names to token types.
 
-var keywords = {};
+var keywords$1 = {};
 
 // Succinct definitions of keyword token types
 function kw(name, options) {
   if ( options === void 0 ) options = {};
 
   options.keyword = name;
-  return keywords[name] = new TokenType(name, options)
+  return keywords$1[name] = new TokenType(name, options)
 }
 
-var types$1 = {
+var types = {
   num: new TokenType("num", startsExpr),
   regexp: new TokenType("regexp", startsExpr),
   string: new TokenType("string", startsExpr),
@@ -17712,17 +16335,6 @@
   return code === 10 || code === 13 || code === 0x2028 || code === 0x2029
 }
 
-function nextLineBreak(code, from, end) {
-  if ( end === void 0 ) end = code.length;
-
-  for (var i = from; i < end; i++) {
-    var next = code.charCodeAt(i);
-    if (isNewLine(next))
-      { return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1 }
-  }
-  return -1
-}
-
 var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
 
 var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
@@ -17731,9 +16343,11 @@
 var hasOwnProperty = ref.hasOwnProperty;
 var toString = ref.toString;
 
-var hasOwn = Object.hasOwn || (function (obj, propName) { return (
-  hasOwnProperty.call(obj, propName)
-); });
+// Checks if an object has a property.
+
+function has(obj, propName) {
+  return hasOwnProperty.call(obj, propName)
+}
 
 var isArray = Array.isArray || (function (obj) { return (
   toString.call(obj) === "[object Array]"
@@ -17743,15 +16357,6 @@
   return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
 }
 
-function codePointToString(code) {
-  // UTF-16 Decoding
-  if (code <= 0xFFFF) { return String.fromCharCode(code) }
-  code -= 0x10000;
-  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
-}
-
-var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
-
 // These are used when `options.locations` is on, for the
 // `startLoc` and `endLoc` properties.
 
@@ -17778,10 +16383,14 @@
 
 function getLineInfo(input, offset) {
   for (var line = 1, cur = 0;;) {
-    var nextBreak = nextLineBreak(input, cur, offset);
-    if (nextBreak < 0) { return new Position(line, offset - cur) }
-    ++line;
-    cur = nextBreak;
+    lineBreakG.lastIndex = cur;
+    var match = lineBreakG.exec(input);
+    if (match && match.index < offset) {
+      ++line;
+      cur = match.index + match[0].length;
+    } else {
+      return new Position(line, offset - cur)
+    }
   }
 }
 
@@ -17791,10 +16400,10 @@
 var defaultOptions = {
   // `ecmaVersion` indicates the ECMAScript version to parse. Must be
   // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
-  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
-  // (the latest version the library supports). This influences
-  // support for strict mode, the set of reserved words, and support
-  // for new syntax features.
+  // (2019), 11 (2020), 12 (2021), 13 (2022), or `"latest"` (the
+  // latest version the library supports). This influences support
+  // for strict mode, the set of reserved words, and support for
+  // new syntax features.
   ecmaVersion: null,
   // `sourceType` indicates the mode the code should be parsed in.
   // Can be either `"script"` or `"module"`. This influences global
@@ -17828,9 +16437,8 @@
   // When enabled, super identifiers are not constrained to
   // appearing in methods and do not raise an error when they appear elsewhere.
   allowSuperOutsideMethod: null,
-  // When enabled, hashbang directive in the beginning of file is
-  // allowed and treated as a line comment. Enabled by default when
-  // `ecmaVersion` >= 2023.
+  // When enabled, hashbang directive in the beginning of file
+  // is allowed and treated as a line comment.
   allowHashBang: false,
   // When `locations` is on, `loc` properties holding objects with
   // `start` and `end` properties in `{line, column}` form (with
@@ -17888,7 +16496,7 @@
   var options = {};
 
   for (var opt in defaultOptions)
-    { options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt]; }
+    { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }
 
   if (options.ecmaVersion === "latest") {
     options.ecmaVersion = 1e8;
@@ -17905,9 +16513,6 @@
   if (options.allowReserved == null)
     { options.allowReserved = options.ecmaVersion < 5; }
 
-  if (opts.allowHashBang == null)
-    { options.allowHashBang = options.ecmaVersion >= 14; }
-
   if (isArray(options.onToken)) {
     var tokens = options.onToken;
     options.onToken = function (token) { return tokens.push(token); };
@@ -17963,7 +16568,7 @@
 var Parser = function Parser(options, input, startPos) {
   this.options = options = getOptions(options);
   this.sourceFile = options.sourceFile;
-  this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
+  this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
   var reserved = "";
   if (options.allowReserved !== true) {
     reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
@@ -17994,7 +16599,7 @@
 
   // Properties of the current token:
   // Its type
-  this.type = types$1.eof;
+  this.type = types.eof;
   // For tokens that include more information than their type, the value
   this.value = null;
   // Its start and end offset
@@ -18054,11 +16659,8 @@
 };
 
 prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };
-
 prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit };
-
 prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit };
-
 prototypeAccessors.canAwait.get = function () {
   for (var i = this.scopeStack.length - 1; i >= 0; i--) {
     var scope = this.scopeStack[i];
@@ -18067,25 +16669,20 @@
   }
   return (this.inModule && this.options.ecmaVersion >= 13) || this.options.allowAwaitOutsideFunction
 };
-
 prototypeAccessors.allowSuper.get = function () {
   var ref = this.currentThisScope();
     var flags = ref.flags;
     var inClassFieldInit = ref.inClassFieldInit;
   return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod
 };
-
 prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };
-
 prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };
-
 prototypeAccessors.allowNewDotTarget.get = function () {
   var ref = this.currentThisScope();
     var flags = ref.flags;
     var inClassFieldInit = ref.inClassFieldInit;
   return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit
 };
-
 prototypeAccessors.inClassStaticBlock.get = function () {
   return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0
 };
@@ -18115,13 +16712,12 @@
 
 Object.defineProperties( Parser.prototype, prototypeAccessors );
 
-var pp$9 = Parser.prototype;
+var pp = Parser.prototype;
 
 // ## Parser utilities
 
 var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
-pp$9.strictDirective = function(start) {
-  if (this.options.ecmaVersion < 5) { return false }
+pp.strictDirective = function(start) {
   for (;;) {
     // Try to find string literal.
     skipWhiteSpace.lastIndex = start;
@@ -18149,7 +16745,7 @@
 // Predicate that tests whether the next token is of the given
 // type, and if yes, consumes it as a side effect.
 
-pp$9.eat = function(type) {
+pp.eat = function(type) {
   if (this.type === type) {
     this.next();
     return true
@@ -18160,13 +16756,13 @@
 
 // Tests whether parsed token is a contextual keyword.
 
-pp$9.isContextual = function(name) {
-  return this.type === types$1.name && this.value === name && !this.containsEsc
+pp.isContextual = function(name) {
+  return this.type === types.name && this.value === name && !this.containsEsc
 };
 
 // Consumes contextual keyword if possible.
 
-pp$9.eatContextual = function(name) {
+pp.eatContextual = function(name) {
   if (!this.isContextual(name)) { return false }
   this.next();
   return true
@@ -18174,19 +16770,19 @@
 
 // Asserts that following token is given contextual keyword.
 
-pp$9.expectContextual = function(name) {
+pp.expectContextual = function(name) {
   if (!this.eatContextual(name)) { this.unexpected(); }
 };
 
 // Test whether a semicolon can be inserted at the current position.
 
-pp$9.canInsertSemicolon = function() {
-  return this.type === types$1.eof ||
-    this.type === types$1.braceR ||
+pp.canInsertSemicolon = function() {
+  return this.type === types.eof ||
+    this.type === types.braceR ||
     lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
 };
 
-pp$9.insertSemicolon = function() {
+pp.insertSemicolon = function() {
   if (this.canInsertSemicolon()) {
     if (this.options.onInsertedSemicolon)
       { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
@@ -18197,11 +16793,11 @@
 // Consume a semicolon, or, failing that, see if we are allowed to
 // pretend that there is a semicolon at this position.
 
-pp$9.semicolon = function() {
-  if (!this.eat(types$1.semi) && !this.insertSemicolon()) { this.unexpected(); }
+pp.semicolon = function() {
+  if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }
 };
 
-pp$9.afterTrailingComma = function(tokType, notNext) {
+pp.afterTrailingComma = function(tokType, notNext) {
   if (this.type === tokType) {
     if (this.options.onTrailingComma)
       { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
@@ -18214,34 +16810,34 @@
 // Expect a token of a given type. If found, consume it, otherwise,
 // raise an unexpected token error.
 
-pp$9.expect = function(type) {
+pp.expect = function(type) {
   this.eat(type) || this.unexpected();
 };
 
 // Raise an unexpected token error.
 
-pp$9.unexpected = function(pos) {
+pp.unexpected = function(pos) {
   this.raise(pos != null ? pos : this.start, "Unexpected token");
 };
 
-var DestructuringErrors = function DestructuringErrors() {
+function DestructuringErrors() {
   this.shorthandAssign =
   this.trailingComma =
   this.parenthesizedAssign =
   this.parenthesizedBind =
   this.doubleProto =
     -1;
-};
+}
 
-pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
+pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
   if (!refDestructuringErrors) { return }
   if (refDestructuringErrors.trailingComma > -1)
     { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
   var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
-  if (parens > -1) { this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern"); }
+  if (parens > -1) { this.raiseRecoverable(parens, "Parenthesized pattern"); }
 };
 
-pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
+pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
   if (!refDestructuringErrors) { return false }
   var shorthandAssign = refDestructuringErrors.shorthandAssign;
   var doubleProto = refDestructuringErrors.doubleProto;
@@ -18252,20 +16848,20 @@
     { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
 };
 
-pp$9.checkYieldAwaitInDefaultParams = function() {
+pp.checkYieldAwaitInDefaultParams = function() {
   if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
     { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
   if (this.awaitPos)
     { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
 };
 
-pp$9.isSimpleAssignTarget = function(expr) {
+pp.isSimpleAssignTarget = function(expr) {
   if (expr.type === "ParenthesizedExpression")
     { return this.isSimpleAssignTarget(expr.expression) }
   return expr.type === "Identifier" || expr.type === "MemberExpression"
 };
 
-var pp$8 = Parser.prototype;
+var pp$1 = Parser.prototype;
 
 // ### Statement parsing
 
@@ -18274,10 +16870,10 @@
 // `program` argument.  If present, the statements will be appended
 // to its body instead of creating a new node.
 
-pp$8.parseTopLevel = function(node) {
+pp$1.parseTopLevel = function(node) {
   var exports = Object.create(null);
   if (!node.body) { node.body = []; }
-  while (this.type !== types$1.eof) {
+  while (this.type !== types.eof) {
     var stmt = this.parseStatement(null, true, exports);
     node.body.push(stmt);
   }
@@ -18296,7 +16892,7 @@
 
 var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};
 
-pp$8.isLet = function(context) {
+pp$1.isLet = function(context) {
   if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
   skipWhiteSpace.lastIndex = this.pos;
   var skip = skipWhiteSpace.exec(this.input);
@@ -18322,7 +16918,7 @@
 // check 'async [no LineTerminator here] function'
 // - 'async /*foo*/ function' is OK.
 // - 'async /*\n*/ function' is invalid.
-pp$8.isAsyncFunction = function() {
+pp$1.isAsyncFunction = function() {
   if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
     { return false }
 
@@ -18342,11 +16938,11 @@
 // `if (foo) /blah/.exec(foo)`, where looking at the previous token
 // does not help.
 
-pp$8.parseStatement = function(context, topLevel, exports) {
+pp$1.parseStatement = function(context, topLevel, exports) {
   var starttype = this.type, node = this.startNode(), kind;
 
   if (this.isLet(context)) {
-    starttype = types$1._var;
+    starttype = types._var;
     kind = "let";
   }
 
@@ -18355,35 +16951,35 @@
   // complexity.
 
   switch (starttype) {
-  case types$1._break: case types$1._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
-  case types$1._debugger: return this.parseDebuggerStatement(node)
-  case types$1._do: return this.parseDoStatement(node)
-  case types$1._for: return this.parseForStatement(node)
-  case types$1._function:
+  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
+  case types._debugger: return this.parseDebuggerStatement(node)
+  case types._do: return this.parseDoStatement(node)
+  case types._for: return this.parseForStatement(node)
+  case types._function:
     // Function as sole body of either an if statement or a labeled statement
     // works, but not when it is part of a labeled statement that is the sole
     // body of an if statement.
     if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
     return this.parseFunctionStatement(node, false, !context)
-  case types$1._class:
+  case types._class:
     if (context) { this.unexpected(); }
     return this.parseClass(node, true)
-  case types$1._if: return this.parseIfStatement(node)
-  case types$1._return: return this.parseReturnStatement(node)
-  case types$1._switch: return this.parseSwitchStatement(node)
-  case types$1._throw: return this.parseThrowStatement(node)
-  case types$1._try: return this.parseTryStatement(node)
-  case types$1._const: case types$1._var:
+  case types._if: return this.parseIfStatement(node)
+  case types._return: return this.parseReturnStatement(node)
+  case types._switch: return this.parseSwitchStatement(node)
+  case types._throw: return this.parseThrowStatement(node)
+  case types._try: return this.parseTryStatement(node)
+  case types._const: case types._var:
     kind = kind || this.value;
     if (context && kind !== "var") { this.unexpected(); }
     return this.parseVarStatement(node, kind)
-  case types$1._while: return this.parseWhileStatement(node)
-  case types$1._with: return this.parseWithStatement(node)
-  case types$1.braceL: return this.parseBlock(true, node)
-  case types$1.semi: return this.parseEmptyStatement(node)
-  case types$1._export:
-  case types$1._import:
-    if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
+  case types._while: return this.parseWhileStatement(node)
+  case types._with: return this.parseWithStatement(node)
+  case types.braceL: return this.parseBlock(true, node)
+  case types.semi: return this.parseEmptyStatement(node)
+  case types._export:
+  case types._import:
+    if (this.options.ecmaVersion > 10 && starttype === types._import) {
       skipWhiteSpace.lastIndex = this.pos;
       var skip = skipWhiteSpace.exec(this.input);
       var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
@@ -18397,7 +16993,7 @@
       if (!this.inModule)
         { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
     }
-    return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports)
+    return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)
 
     // If the statement does not start with a statement keyword or a
     // brace, it's an ExpressionStatement or LabeledStatement. We
@@ -18412,17 +17008,17 @@
     }
 
     var maybeName = this.value, expr = this.parseExpression();
-    if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon))
+    if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon))
       { return this.parseLabeledStatement(node, maybeName, expr, context) }
     else { return this.parseExpressionStatement(node, expr) }
   }
 };
 
-pp$8.parseBreakContinueStatement = function(node, keyword) {
+pp$1.parseBreakContinueStatement = function(node, keyword) {
   var isBreak = keyword === "break";
   this.next();
-  if (this.eat(types$1.semi) || this.insertSemicolon()) { node.label = null; }
-  else if (this.type !== types$1.name) { this.unexpected(); }
+  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
+  else if (this.type !== types.name) { this.unexpected(); }
   else {
     node.label = this.parseIdent();
     this.semicolon();
@@ -18442,21 +17038,21 @@
   return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
 };
 
-pp$8.parseDebuggerStatement = function(node) {
+pp$1.parseDebuggerStatement = function(node) {
   this.next();
   this.semicolon();
   return this.finishNode(node, "DebuggerStatement")
 };
 
-pp$8.parseDoStatement = function(node) {
+pp$1.parseDoStatement = function(node) {
   this.next();
   this.labels.push(loopLabel);
   node.body = this.parseStatement("do");
   this.labels.pop();
-  this.expect(types$1._while);
+  this.expect(types._while);
   node.test = this.parseParenExpression();
   if (this.options.ecmaVersion >= 6)
-    { this.eat(types$1.semi); }
+    { this.eat(types.semi); }
   else
     { this.semicolon(); }
   return this.finishNode(node, "DoWhileStatement")
@@ -18470,25 +17066,25 @@
 // part (semicolon immediately after the opening parenthesis), it
 // is a regular `for` loop.
 
-pp$8.parseForStatement = function(node) {
+pp$1.parseForStatement = function(node) {
   this.next();
   var awaitAt = (this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await")) ? this.lastTokStart : -1;
   this.labels.push(loopLabel);
   this.enterScope(0);
-  this.expect(types$1.parenL);
-  if (this.type === types$1.semi) {
+  this.expect(types.parenL);
+  if (this.type === types.semi) {
     if (awaitAt > -1) { this.unexpected(awaitAt); }
     return this.parseFor(node, null)
   }
   var isLet = this.isLet();
-  if (this.type === types$1._var || this.type === types$1._const || isLet) {
+  if (this.type === types._var || this.type === types._const || isLet) {
     var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
     this.next();
     this.parseVar(init$1, true, kind);
     this.finishNode(init$1, "VariableDeclaration");
-    if ((this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
+    if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
       if (this.options.ecmaVersion >= 9) {
-        if (this.type === types$1._in) {
+        if (this.type === types._in) {
           if (awaitAt > -1) { this.unexpected(awaitAt); }
         } else { node.await = awaitAt > -1; }
       }
@@ -18500,9 +17096,9 @@
   var startsWithLet = this.isContextual("let"), isForOf = false;
   var refDestructuringErrors = new DestructuringErrors;
   var init = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
-  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
+  if (this.type === types._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
     if (this.options.ecmaVersion >= 9) {
-      if (this.type === types$1._in) {
+      if (this.type === types._in) {
         if (awaitAt > -1) { this.unexpected(awaitAt); }
       } else { node.await = awaitAt > -1; }
     }
@@ -18517,21 +17113,21 @@
   return this.parseFor(node, init)
 };
 
-pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
+pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
   this.next();
-  return this.parseFunction(node, FUNC_STATEMENT$1 | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
+  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
 };
 
-pp$8.parseIfStatement = function(node) {
+pp$1.parseIfStatement = function(node) {
   this.next();
   node.test = this.parseParenExpression();
   // allow function declarations in branches, but only in non-strict mode
   node.consequent = this.parseStatement("if");
-  node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
+  node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
   return this.finishNode(node, "IfStatement")
 };
 
-pp$8.parseReturnStatement = function(node) {
+pp$1.parseReturnStatement = function(node) {
   if (!this.inFunction && !this.options.allowReturnOutsideFunction)
     { this.raise(this.start, "'return' outside of function"); }
   this.next();
@@ -18540,16 +17136,16 @@
   // optional arguments, we eagerly look for a semicolon or the
   // possibility to insert one.
 
-  if (this.eat(types$1.semi) || this.insertSemicolon()) { node.argument = null; }
+  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
   else { node.argument = this.parseExpression(); this.semicolon(); }
   return this.finishNode(node, "ReturnStatement")
 };
 
-pp$8.parseSwitchStatement = function(node) {
+pp$1.parseSwitchStatement = function(node) {
   this.next();
   node.discriminant = this.parseParenExpression();
   node.cases = [];
-  this.expect(types$1.braceL);
+  this.expect(types.braceL);
   this.labels.push(switchLabel);
   this.enterScope(0);
 
@@ -18558,9 +17154,9 @@
   // adding statements to.
 
   var cur;
-  for (var sawDefault = false; this.type !== types$1.braceR;) {
-    if (this.type === types$1._case || this.type === types$1._default) {
-      var isCase = this.type === types$1._case;
+  for (var sawDefault = false; this.type !== types.braceR;) {
+    if (this.type === types._case || this.type === types._default) {
+      var isCase = this.type === types._case;
       if (cur) { this.finishNode(cur, "SwitchCase"); }
       node.cases.push(cur = this.startNode());
       cur.consequent = [];
@@ -18572,7 +17168,7 @@
         sawDefault = true;
         cur.test = null;
       }
-      this.expect(types$1.colon);
+      this.expect(types.colon);
     } else {
       if (!cur) { this.unexpected(); }
       cur.consequent.push(this.parseStatement(null));
@@ -18585,7 +17181,7 @@
   return this.finishNode(node, "SwitchStatement")
 };
 
-pp$8.parseThrowStatement = function(node) {
+pp$1.parseThrowStatement = function(node) {
   this.next();
   if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
     { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
@@ -18596,21 +17192,21 @@
 
 // Reused empty array added for node fields that are always empty.
 
-var empty$1 = [];
+var empty = [];
 
-pp$8.parseTryStatement = function(node) {
+pp$1.parseTryStatement = function(node) {
   this.next();
   node.block = this.parseBlock();
   node.handler = null;
-  if (this.type === types$1._catch) {
+  if (this.type === types._catch) {
     var clause = this.startNode();
     this.next();
-    if (this.eat(types$1.parenL)) {
+    if (this.eat(types.parenL)) {
       clause.param = this.parseBindingAtom();
       var simple = clause.param.type === "Identifier";
       this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
       this.checkLValPattern(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
-      this.expect(types$1.parenR);
+      this.expect(types.parenR);
     } else {
       if (this.options.ecmaVersion < 10) { this.unexpected(); }
       clause.param = null;
@@ -18620,20 +17216,20 @@
     this.exitScope();
     node.handler = this.finishNode(clause, "CatchClause");
   }
-  node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
+  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
   if (!node.handler && !node.finalizer)
     { this.raise(node.start, "Missing catch or finally clause"); }
   return this.finishNode(node, "TryStatement")
 };
 
-pp$8.parseVarStatement = function(node, kind) {
+pp$1.parseVarStatement = function(node, kind) {
   this.next();
   this.parseVar(node, false, kind);
   this.semicolon();
   return this.finishNode(node, "VariableDeclaration")
 };
 
-pp$8.parseWhileStatement = function(node) {
+pp$1.parseWhileStatement = function(node) {
   this.next();
   node.test = this.parseParenExpression();
   this.labels.push(loopLabel);
@@ -18642,7 +17238,7 @@
   return this.finishNode(node, "WhileStatement")
 };
 
-pp$8.parseWithStatement = function(node) {
+pp$1.parseWithStatement = function(node) {
   if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
   this.next();
   node.object = this.parseParenExpression();
@@ -18650,12 +17246,12 @@
   return this.finishNode(node, "WithStatement")
 };
 
-pp$8.parseEmptyStatement = function(node) {
+pp$1.parseEmptyStatement = function(node) {
   this.next();
   return this.finishNode(node, "EmptyStatement")
 };
 
-pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
+pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {
   for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
     {
     var label = list[i$1];
@@ -18663,7 +17259,7 @@
     if (label.name === maybeName)
       { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
   } }
-  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
+  var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
   for (var i = this.labels.length - 1; i >= 0; i--) {
     var label$1 = this.labels[i];
     if (label$1.statementStart === node.start) {
@@ -18679,7 +17275,7 @@
   return this.finishNode(node, "LabeledStatement")
 };
 
-pp$8.parseExpressionStatement = function(node, expr) {
+pp$1.parseExpressionStatement = function(node, expr) {
   node.expression = expr;
   this.semicolon();
   return this.finishNode(node, "ExpressionStatement")
@@ -18689,14 +17285,14 @@
 // strict"` declarations when `allowStrict` is true (used for
 // function bodies).
 
-pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
+pp$1.parseBlock = function(createNewLexicalScope, node, exitStrict) {
   if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
   if ( node === void 0 ) node = this.startNode();
 
   node.body = [];
-  this.expect(types$1.braceL);
+  this.expect(types.braceL);
   if (createNewLexicalScope) { this.enterScope(0); }
-  while (this.type !== types$1.braceR) {
+  while (this.type !== types.braceR) {
     var stmt = this.parseStatement(null);
     node.body.push(stmt);
   }
@@ -18710,13 +17306,13 @@
 // `parseStatement` will already have parsed the init statement or
 // expression.
 
-pp$8.parseFor = function(node, init) {
+pp$1.parseFor = function(node, init) {
   node.init = init;
-  this.expect(types$1.semi);
-  node.test = this.type === types$1.semi ? null : this.parseExpression();
-  this.expect(types$1.semi);
-  node.update = this.type === types$1.parenR ? null : this.parseExpression();
-  this.expect(types$1.parenR);
+  this.expect(types.semi);
+  node.test = this.type === types.semi ? null : this.parseExpression();
+  this.expect(types.semi);
+  node.update = this.type === types.parenR ? null : this.parseExpression();
+  this.expect(types.parenR);
   node.body = this.parseStatement("for");
   this.exitScope();
   this.labels.pop();
@@ -18726,8 +17322,8 @@
 // Parse a `for`/`in` and `for`/`of` loop, which are almost
 // same from parser's perspective.
 
-pp$8.parseForIn = function(node, init) {
-  var isForIn = this.type === types$1._in;
+pp$1.parseForIn = function(node, init) {
+  var isForIn = this.type === types._in;
   this.next();
 
   if (
@@ -18748,7 +17344,7 @@
   }
   node.left = init;
   node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
-  this.expect(types$1.parenR);
+  this.expect(types.parenR);
   node.body = this.parseStatement("for");
   this.exitScope();
   this.labels.pop();
@@ -18757,50 +17353,50 @@
 
 // Parse a list of variable declarations.
 
-pp$8.parseVar = function(node, isFor, kind) {
+pp$1.parseVar = function(node, isFor, kind) {
   node.declarations = [];
   node.kind = kind;
   for (;;) {
     var decl = this.startNode();
     this.parseVarId(decl, kind);
-    if (this.eat(types$1.eq)) {
+    if (this.eat(types.eq)) {
       decl.init = this.parseMaybeAssign(isFor);
-    } else if (kind === "const" && !(this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
+    } else if (kind === "const" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
       this.unexpected();
-    } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
+    } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) {
       this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
     } else {
       decl.init = null;
     }
     node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
-    if (!this.eat(types$1.comma)) { break }
+    if (!this.eat(types.comma)) { break }
   }
   return node
 };
 
-pp$8.parseVarId = function(decl, kind) {
+pp$1.parseVarId = function(decl, kind) {
   decl.id = this.parseBindingAtom();
   this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
 };
 
-var FUNC_STATEMENT$1 = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID$1 = 4;
+var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
 
 // Parse a function declaration or literal (depending on the
 // `statement & FUNC_STATEMENT`).
 
 // Remove `allowExpressionBody` for 7.0.0, as it is only called with false
-pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
+pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
   this.initFunction(node);
   if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
-    if (this.type === types$1.star && (statement & FUNC_HANGING_STATEMENT))
+    if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))
       { this.unexpected(); }
-    node.generator = this.eat(types$1.star);
+    node.generator = this.eat(types.star);
   }
   if (this.options.ecmaVersion >= 8)
     { node.async = !!isAsync; }
 
-  if (statement & FUNC_STATEMENT$1) {
-    node.id = (statement & FUNC_NULLABLE_ID$1) && this.type !== types$1.name ? null : this.parseIdent();
+  if (statement & FUNC_STATEMENT) {
+    node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();
     if (node.id && !(statement & FUNC_HANGING_STATEMENT))
       // If it is a regular function declaration in sloppy mode, then it is
       // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
@@ -18815,8 +17411,8 @@
   this.awaitIdentPos = 0;
   this.enterScope(functionFlags(node.async, node.generator));
 
-  if (!(statement & FUNC_STATEMENT$1))
-    { node.id = this.type === types$1.name ? this.parseIdent() : null; }
+  if (!(statement & FUNC_STATEMENT))
+    { node.id = this.type === types.name ? this.parseIdent() : null; }
 
   this.parseFunctionParams(node);
   this.parseFunctionBody(node, allowExpressionBody, false, forInit);
@@ -18824,19 +17420,19 @@
   this.yieldPos = oldYieldPos;
   this.awaitPos = oldAwaitPos;
   this.awaitIdentPos = oldAwaitIdentPos;
-  return this.finishNode(node, (statement & FUNC_STATEMENT$1) ? "FunctionDeclaration" : "FunctionExpression")
+  return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
 };
 
-pp$8.parseFunctionParams = function(node) {
-  this.expect(types$1.parenL);
-  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
+pp$1.parseFunctionParams = function(node) {
+  this.expect(types.parenL);
+  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
   this.checkYieldAwaitInDefaultParams();
 };
 
 // Parse a class declaration or literal (depending on the
 // `isStatement` parameter).
 
-pp$8.parseClass = function(node, isStatement) {
+pp$1.parseClass = function(node, isStatement) {
   this.next();
 
   // ecma-262 14.6 Class Definitions
@@ -18850,8 +17446,8 @@
   var classBody = this.startNode();
   var hadConstructor = false;
   classBody.body = [];
-  this.expect(types$1.braceL);
-  while (this.type !== types$1.braceR) {
+  this.expect(types.braceL);
+  while (this.type !== types.braceR) {
     var element = this.parseClassElement(node.superClass !== null);
     if (element) {
       classBody.body.push(element);
@@ -18870,8 +17466,8 @@
   return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
 };
 
-pp$8.parseClassElement = function(constructorAllowsSuper) {
-  if (this.eat(types$1.semi)) { return null }
+pp$1.parseClassElement = function(constructorAllowsSuper) {
+  if (this.eat(types.semi)) { return null }
 
   var ecmaVersion = this.options.ecmaVersion;
   var node = this.startNode();
@@ -18883,11 +17479,11 @@
 
   if (this.eatContextual("static")) {
     // Parse static init block
-    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
+    if (ecmaVersion >= 13 && this.eat(types.braceL)) {
       this.parseClassStaticBlock(node);
       return node
     }
-    if (this.isClassElementNameStart() || this.type === types$1.star) {
+    if (this.isClassElementNameStart() || this.type === types.star) {
       isStatic = true;
     } else {
       keyName = "static";
@@ -18895,13 +17491,13 @@
   }
   node.static = isStatic;
   if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
-    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
+    if ((this.isClassElementNameStart() || this.type === types.star) && !this.canInsertSemicolon()) {
       isAsync = true;
     } else {
       keyName = "async";
     }
   }
-  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
+  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types.star)) {
     isGenerator = true;
   }
   if (!keyName && !isAsync && !isGenerator) {
@@ -18928,7 +17524,7 @@
   }
 
   // Parse element value
-  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
+  if (ecmaVersion < 13 || this.type === types.parenL || kind !== "method" || isGenerator || isAsync) {
     var isConstructor = !node.static && checkKeyName(node, "constructor");
     var allowsDirectSuper = isConstructor && constructorAllowsSuper;
     // Couldn't move this check into the 'parseClassMethod' method for backward compatibility.
@@ -18942,19 +17538,19 @@
   return node
 };
 
-pp$8.isClassElementNameStart = function() {
+pp$1.isClassElementNameStart = function() {
   return (
-    this.type === types$1.name ||
-    this.type === types$1.privateId ||
-    this.type === types$1.num ||
-    this.type === types$1.string ||
-    this.type === types$1.bracketL ||
+    this.type === types.name ||
+    this.type === types.privateId ||
+    this.type === types.num ||
+    this.type === types.string ||
+    this.type === types.bracketL ||
     this.type.keyword
   )
 };
 
-pp$8.parseClassElementName = function(element) {
-  if (this.type === types$1.privateId) {
+pp$1.parseClassElementName = function(element) {
+  if (this.type === types.privateId) {
     if (this.value === "constructor") {
       this.raise(this.start, "Classes can't have an element named '#constructor'");
     }
@@ -18965,7 +17561,7 @@
   }
 };
 
-pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
+pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
   // Check key and flags
   var key = method.key;
   if (method.kind === "constructor") {
@@ -18989,14 +17585,14 @@
   return this.finishNode(method, "MethodDefinition")
 };
 
-pp$8.parseClassField = function(field) {
+pp$1.parseClassField = function(field) {
   if (checkKeyName(field, "constructor")) {
     this.raise(field.key.start, "Classes can't have a field named 'constructor'");
   } else if (field.static && checkKeyName(field, "prototype")) {
     this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
   }
 
-  if (this.eat(types$1.eq)) {
+  if (this.eat(types.eq)) {
     // To raise SyntaxError if 'arguments' exists in the initializer.
     var scope = this.currentThisScope();
     var inClassFieldInit = scope.inClassFieldInit;
@@ -19011,13 +17607,13 @@
   return this.finishNode(field, "PropertyDefinition")
 };
 
-pp$8.parseClassStaticBlock = function(node) {
+pp$1.parseClassStaticBlock = function(node) {
   node.body = [];
 
   var oldLabels = this.labels;
   this.labels = [];
   this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
-  while (this.type !== types$1.braceR) {
+  while (this.type !== types.braceR) {
     var stmt = this.parseStatement(null);
     node.body.push(stmt);
   }
@@ -19028,8 +17624,8 @@
   return this.finishNode(node, "StaticBlock")
 };
 
-pp$8.parseClassId = function(node, isStatement) {
-  if (this.type === types$1.name) {
+pp$1.parseClassId = function(node, isStatement) {
+  if (this.type === types.name) {
     node.id = this.parseIdent();
     if (isStatement)
       { this.checkLValSimple(node.id, BIND_LEXICAL, false); }
@@ -19040,17 +17636,17 @@
   }
 };
 
-pp$8.parseClassSuper = function(node) {
-  node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(false) : null;
+pp$1.parseClassSuper = function(node) {
+  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts(false) : null;
 };
 
-pp$8.enterClassBody = function() {
+pp$1.enterClassBody = function() {
   var element = {declared: Object.create(null), used: []};
   this.privateNameStack.push(element);
   return element.declared
 };
 
-pp$8.exitClassBody = function() {
+pp$1.exitClassBody = function() {
   var ref = this.privateNameStack.pop();
   var declared = ref.declared;
   var used = ref.used;
@@ -19058,7 +17654,7 @@
   var parent = len === 0 ? null : this.privateNameStack[len - 1];
   for (var i = 0; i < used.length; ++i) {
     var id = used[i];
-    if (!hasOwn(declared, id.name)) {
+    if (!has(declared, id.name)) {
       if (parent) {
         parent.used.push(id);
       } else {
@@ -19105,33 +17701,33 @@
 
 // Parses module export declaration.
 
-pp$8.parseExport = function(node, exports) {
+pp$1.parseExport = function(node, exports) {
   this.next();
   // export * from '...'
-  if (this.eat(types$1.star)) {
+  if (this.eat(types.star)) {
     if (this.options.ecmaVersion >= 11) {
       if (this.eatContextual("as")) {
-        node.exported = this.parseModuleExportName();
-        this.checkExport(exports, node.exported, this.lastTokStart);
+        node.exported = this.parseIdent(true);
+        this.checkExport(exports, node.exported.name, this.lastTokStart);
       } else {
         node.exported = null;
       }
     }
     this.expectContextual("from");
-    if (this.type !== types$1.string) { this.unexpected(); }
+    if (this.type !== types.string) { this.unexpected(); }
     node.source = this.parseExprAtom();
     this.semicolon();
     return this.finishNode(node, "ExportAllDeclaration")
   }
-  if (this.eat(types$1._default)) { // export default ...
+  if (this.eat(types._default)) { // export default ...
     this.checkExport(exports, "default", this.lastTokStart);
     var isAsync;
-    if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
+    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
       var fNode = this.startNode();
       this.next();
       if (isAsync) { this.next(); }
-      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT$1 | FUNC_NULLABLE_ID$1, false, isAsync);
-    } else if (this.type === types$1._class) {
+      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
+    } else if (this.type === types._class) {
       var cNode = this.startNode();
       node.declaration = this.parseClass(cNode, "nullableID");
     } else {
@@ -19146,14 +17742,14 @@
     if (node.declaration.type === "VariableDeclaration")
       { this.checkVariableExport(exports, node.declaration.declarations); }
     else
-      { this.checkExport(exports, node.declaration.id, node.declaration.id.start); }
+      { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
     node.specifiers = [];
     node.source = null;
   } else { // export { x, y as z } [from '...']
     node.declaration = null;
     node.specifiers = this.parseExportSpecifiers(exports);
     if (this.eatContextual("from")) {
-      if (this.type !== types$1.string) { this.unexpected(); }
+      if (this.type !== types.string) { this.unexpected(); }
       node.source = this.parseExprAtom();
     } else {
       for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
@@ -19163,10 +17759,6 @@
         this.checkUnreserved(spec.local);
         // check if export is defined
         this.checkLocalExport(spec.local);
-
-        if (spec.local.type === "Literal") {
-          this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
-        }
       }
 
       node.source = null;
@@ -19176,19 +17768,17 @@
   return this.finishNode(node, "ExportNamedDeclaration")
 };
 
-pp$8.checkExport = function(exports, name, pos) {
+pp$1.checkExport = function(exports, name, pos) {
   if (!exports) { return }
-  if (typeof name !== "string")
-    { name = name.type === "Identifier" ? name.name : name.value; }
-  if (hasOwn(exports, name))
+  if (has(exports, name))
     { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
   exports[name] = true;
 };
 
-pp$8.checkPatternExport = function(exports, pat) {
+pp$1.checkPatternExport = function(exports, pat) {
   var type = pat.type;
   if (type === "Identifier")
-    { this.checkExport(exports, pat, pat.start); }
+    { this.checkExport(exports, pat.name, pat.start); }
   else if (type === "ObjectPattern")
     { for (var i = 0, list = pat.properties; i < list.length; i += 1)
       {
@@ -19212,7 +17802,7 @@
     { this.checkPatternExport(exports, pat.expression); }
 };
 
-pp$8.checkVariableExport = function(exports, decls) {
+pp$1.checkVariableExport = function(exports, decls) {
   if (!exports) { return }
   for (var i = 0, list = decls; i < list.length; i += 1)
     {
@@ -19222,7 +17812,7 @@
   }
 };
 
-pp$8.shouldParseExportStatement = function() {
+pp$1.shouldParseExportStatement = function() {
   return this.type.keyword === "var" ||
     this.type.keyword === "const" ||
     this.type.keyword === "class" ||
@@ -19233,24 +17823,20 @@
 
 // Parses a comma-separated list of module exports.
 
-pp$8.parseExportSpecifiers = function(exports) {
+pp$1.parseExportSpecifiers = function(exports) {
   var nodes = [], first = true;
   // export { x, y as z } [from '...']
-  this.expect(types$1.braceL);
-  while (!this.eat(types$1.braceR)) {
+  this.expect(types.braceL);
+  while (!this.eat(types.braceR)) {
     if (!first) {
-      this.expect(types$1.comma);
-      if (this.afterTrailingComma(types$1.braceR)) { break }
+      this.expect(types.comma);
+      if (this.afterTrailingComma(types.braceR)) { break }
     } else { first = false; }
 
     var node = this.startNode();
-    node.local = this.parseModuleExportName();
-    node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
-    this.checkExport(
-      exports,
-      node.exported,
-      node.exported.start
-    );
+    node.local = this.parseIdent(true);
+    node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
+    this.checkExport(exports, node.exported.name, node.exported.start);
     nodes.push(this.finishNode(node, "ExportSpecifier"));
   }
   return nodes
@@ -19258,16 +17844,16 @@
 
 // Parses import declaration.
 
-pp$8.parseImport = function(node) {
+pp$1.parseImport = function(node) {
   this.next();
   // import '...'
-  if (this.type === types$1.string) {
-    node.specifiers = empty$1;
+  if (this.type === types.string) {
+    node.specifiers = empty;
     node.source = this.parseExprAtom();
   } else {
     node.specifiers = this.parseImportSpecifiers();
     this.expectContextual("from");
-    node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
+    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
   }
   this.semicolon();
   return this.finishNode(node, "ImportDeclaration")
@@ -19275,17 +17861,17 @@
 
 // Parses a comma-separated list of module imports.
 
-pp$8.parseImportSpecifiers = function() {
+pp$1.parseImportSpecifiers = function() {
   var nodes = [], first = true;
-  if (this.type === types$1.name) {
+  if (this.type === types.name) {
     // import defaultObj, { x, y as z } from '...'
     var node = this.startNode();
     node.local = this.parseIdent();
     this.checkLValSimple(node.local, BIND_LEXICAL);
     nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
-    if (!this.eat(types$1.comma)) { return nodes }
+    if (!this.eat(types.comma)) { return nodes }
   }
-  if (this.type === types$1.star) {
+  if (this.type === types.star) {
     var node$1 = this.startNode();
     this.next();
     this.expectContextual("as");
@@ -19294,15 +17880,15 @@
     nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
     return nodes
   }
-  this.expect(types$1.braceL);
-  while (!this.eat(types$1.braceR)) {
+  this.expect(types.braceL);
+  while (!this.eat(types.braceR)) {
     if (!first) {
-      this.expect(types$1.comma);
-      if (this.afterTrailingComma(types$1.braceR)) { break }
+      this.expect(types.comma);
+      if (this.afterTrailingComma(types.braceR)) { break }
     } else { first = false; }
 
     var node$2 = this.startNode();
-    node$2.imported = this.parseModuleExportName();
+    node$2.imported = this.parseIdent(true);
     if (this.eatContextual("as")) {
       node$2.local = this.parseIdent();
     } else {
@@ -19315,26 +17901,14 @@
   return nodes
 };
 
-pp$8.parseModuleExportName = function() {
-  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
-    var stringLiteral = this.parseLiteral(this.value);
-    if (loneSurrogate.test(stringLiteral.value)) {
-      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
-    }
-    return stringLiteral
-  }
-  return this.parseIdent(true)
-};
-
 // Set `ExpressionStatement#directive` property for directive prologues.
-pp$8.adaptDirectivePrologue = function(statements) {
+pp$1.adaptDirectivePrologue = function(statements) {
   for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
     statements[i].directive = statements[i].expression.raw.slice(1, -1);
   }
 };
-pp$8.isDirectiveCandidate = function(statement) {
+pp$1.isDirectiveCandidate = function(statement) {
   return (
-    this.options.ecmaVersion >= 5 &&
     statement.type === "ExpressionStatement" &&
     statement.expression.type === "Literal" &&
     typeof statement.expression.value === "string" &&
@@ -19343,12 +17917,12 @@
   )
 };
 
-var pp$7 = Parser.prototype;
+var pp$2 = Parser.prototype;
 
 // Convert existing expression atom to assignable pattern
 // if possible.
 
-pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
+pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
   if (this.options.ecmaVersion >= 6 && node) {
     switch (node.type) {
     case "Identifier":
@@ -19429,7 +18003,7 @@
 
 // Convert list of expression atoms to binding list.
 
-pp$7.toAssignableList = function(exprList, isBinding) {
+pp$2.toAssignableList = function(exprList, isBinding) {
   var end = exprList.length;
   for (var i = 0; i < end; i++) {
     var elt = exprList[i];
@@ -19445,19 +18019,19 @@
 
 // Parses spread element.
 
-pp$7.parseSpread = function(refDestructuringErrors) {
+pp$2.parseSpread = function(refDestructuringErrors) {
   var node = this.startNode();
   this.next();
   node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
   return this.finishNode(node, "SpreadElement")
 };
 
-pp$7.parseRestBinding = function() {
+pp$2.parseRestBinding = function() {
   var node = this.startNode();
   this.next();
 
   // RestElement inside of a function parameter must be an identifier
-  if (this.options.ecmaVersion === 6 && this.type !== types$1.name)
+  if (this.options.ecmaVersion === 6 && this.type !== types.name)
     { this.unexpected(); }
 
   node.argument = this.parseBindingAtom();
@@ -19467,36 +18041,36 @@
 
 // Parses lvalue (assignable) atom.
 
-pp$7.parseBindingAtom = function() {
+pp$2.parseBindingAtom = function() {
   if (this.options.ecmaVersion >= 6) {
     switch (this.type) {
-    case types$1.bracketL:
+    case types.bracketL:
       var node = this.startNode();
       this.next();
-      node.elements = this.parseBindingList(types$1.bracketR, true, true);
+      node.elements = this.parseBindingList(types.bracketR, true, true);
       return this.finishNode(node, "ArrayPattern")
 
-    case types$1.braceL:
+    case types.braceL:
       return this.parseObj(true)
     }
   }
   return this.parseIdent()
 };
 
-pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
+pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
   var elts = [], first = true;
   while (!this.eat(close)) {
     if (first) { first = false; }
-    else { this.expect(types$1.comma); }
-    if (allowEmpty && this.type === types$1.comma) {
+    else { this.expect(types.comma); }
+    if (allowEmpty && this.type === types.comma) {
       elts.push(null);
     } else if (allowTrailingComma && this.afterTrailingComma(close)) {
       break
-    } else if (this.type === types$1.ellipsis) {
+    } else if (this.type === types.ellipsis) {
       var rest = this.parseRestBinding();
       this.parseBindingListItem(rest);
       elts.push(rest);
-      if (this.type === types$1.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
+      if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
       this.expect(close);
       break
     } else {
@@ -19508,15 +18082,15 @@
   return elts
 };
 
-pp$7.parseBindingListItem = function(param) {
+pp$2.parseBindingListItem = function(param) {
   return param
 };
 
 // Parses assignment pattern around given atom if possible.
 
-pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
+pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
   left = left || this.parseBindingAtom();
-  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) { return left }
+  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }
   var node = this.startNodeAt(startPos, startLoc);
   node.left = left;
   node.right = this.parseMaybeAssign();
@@ -19587,7 +18161,7 @@
 // duplicate argument names. checkClashes is ignored if the provided construct
 // is an assignment (i.e., bindingType is BIND_NONE).
 
-pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
+pp$2.checkLValSimple = function(expr, bindingType, checkClashes) {
   if ( bindingType === void 0 ) bindingType = BIND_NONE;
 
   var isBind = bindingType !== BIND_NONE;
@@ -19600,7 +18174,7 @@
       if (bindingType === BIND_LEXICAL && expr.name === "let")
         { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
       if (checkClashes) {
-        if (hasOwn(checkClashes, expr.name))
+        if (has(checkClashes, expr.name))
           { this.raiseRecoverable(expr.start, "Argument name clash"); }
         checkClashes[expr.name] = true;
       }
@@ -19625,7 +18199,7 @@
   }
 };
 
-pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
+pp$2.checkLValPattern = function(expr, bindingType, checkClashes) {
   if ( bindingType === void 0 ) bindingType = BIND_NONE;
 
   switch (expr.type) {
@@ -19650,7 +18224,7 @@
   }
 };
 
-pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
+pp$2.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
   if ( bindingType === void 0 ) bindingType = BIND_NONE;
 
   switch (expr.type) {
@@ -19682,7 +18256,7 @@
   this.generator = !!generator;
 };
 
-var types = {
+var types$1 = {
   b_stat: new TokContext("{", false),
   b_expr: new TokContext("{", true),
   b_tmpl: new TokContext("${", false),
@@ -19695,38 +18269,38 @@
   f_gen: new TokContext("function", false, false, null, true)
 };
 
-var pp$6 = Parser.prototype;
+var pp$3 = Parser.prototype;
 
-pp$6.initialContext = function() {
-  return [types.b_stat]
+pp$3.initialContext = function() {
+  return [types$1.b_stat]
 };
 
-pp$6.curContext = function() {
+pp$3.curContext = function() {
   return this.context[this.context.length - 1]
 };
 
-pp$6.braceIsBlock = function(prevType) {
+pp$3.braceIsBlock = function(prevType) {
   var parent = this.curContext();
-  if (parent === types.f_expr || parent === types.f_stat)
+  if (parent === types$1.f_expr || parent === types$1.f_stat)
     { return true }
-  if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr))
+  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))
     { return !parent.isExpr }
 
   // The check for `tt.name && exprAllowed` detects whether we are
   // after a `yield` or `of` construct. See the `updateContext` for
   // `tt.name`.
-  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed)
+  if (prevType === types._return || prevType === types.name && this.exprAllowed)
     { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
-  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow)
+  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)
     { return true }
-  if (prevType === types$1.braceL)
-    { return parent === types.b_stat }
-  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name)
+  if (prevType === types.braceL)
+    { return parent === types$1.b_stat }
+  if (prevType === types._var || prevType === types._const || prevType === types.name)
     { return false }
   return !this.exprAllowed
 };
 
-pp$6.inGeneratorContext = function() {
+pp$3.inGeneratorContext = function() {
   for (var i = this.context.length - 1; i >= 1; i--) {
     var context = this.context[i];
     if (context.token === "function")
@@ -19735,9 +18309,9 @@
   return false
 };
 
-pp$6.updateContext = function(prevType) {
+pp$3.updateContext = function(prevType) {
   var update, type = this.type;
-  if (type.keyword && prevType === types$1.dot)
+  if (type.keyword && prevType === types.dot)
     { this.exprAllowed = false; }
   else if (update = type.updateContext)
     { update.call(this, prevType); }
@@ -19745,9 +18319,8 @@
     { this.exprAllowed = type.beforeExpr; }
 };
 
-// Used to handle egde cases when token context could not be inferred correctly during tokenization phase
-
-pp$6.overrideContext = function(tokenCtx) {
+// Used to handle egde case when token context could not be inferred correctly in tokenize phase
+pp$3.overrideContext = function(tokenCtx) {
   if (this.curContext() !== tokenCtx) {
     this.context[this.context.length - 1] = tokenCtx;
   }
@@ -19755,71 +18328,71 @@
 
 // Token-specific context update code
 
-types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
+types.parenR.updateContext = types.braceR.updateContext = function() {
   if (this.context.length === 1) {
     this.exprAllowed = true;
     return
   }
   var out = this.context.pop();
-  if (out === types.b_stat && this.curContext().token === "function") {
+  if (out === types$1.b_stat && this.curContext().token === "function") {
     out = this.context.pop();
   }
   this.exprAllowed = !out.isExpr;
 };
 
-types$1.braceL.updateContext = function(prevType) {
-  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
+types.braceL.updateContext = function(prevType) {
+  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
   this.exprAllowed = true;
 };
 
-types$1.dollarBraceL.updateContext = function() {
-  this.context.push(types.b_tmpl);
+types.dollarBraceL.updateContext = function() {
+  this.context.push(types$1.b_tmpl);
   this.exprAllowed = true;
 };
 
-types$1.parenL.updateContext = function(prevType) {
-  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
-  this.context.push(statementParens ? types.p_stat : types.p_expr);
+types.parenL.updateContext = function(prevType) {
+  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
+  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
   this.exprAllowed = true;
 };
 
-types$1.incDec.updateContext = function() {
+types.incDec.updateContext = function() {
   // tokExprAllowed stays unchanged
 };
 
-types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
-  if (prevType.beforeExpr && prevType !== types$1._else &&
-      !(prevType === types$1.semi && this.curContext() !== types.p_stat) &&
-      !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
-      !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat))
-    { this.context.push(types.f_expr); }
+types._function.updateContext = types._class.updateContext = function(prevType) {
+  if (prevType.beforeExpr && prevType !== types._else &&
+      !(prevType === types.semi && this.curContext() !== types$1.p_stat) &&
+      !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
+      !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))
+    { this.context.push(types$1.f_expr); }
   else
-    { this.context.push(types.f_stat); }
+    { this.context.push(types$1.f_stat); }
   this.exprAllowed = false;
 };
 
-types$1.backQuote.updateContext = function() {
-  if (this.curContext() === types.q_tmpl)
+types.backQuote.updateContext = function() {
+  if (this.curContext() === types$1.q_tmpl)
     { this.context.pop(); }
   else
-    { this.context.push(types.q_tmpl); }
+    { this.context.push(types$1.q_tmpl); }
   this.exprAllowed = false;
 };
 
-types$1.star.updateContext = function(prevType) {
-  if (prevType === types$1._function) {
+types.star.updateContext = function(prevType) {
+  if (prevType === types._function) {
     var index = this.context.length - 1;
-    if (this.context[index] === types.f_expr)
-      { this.context[index] = types.f_expr_gen; }
+    if (this.context[index] === types$1.f_expr)
+      { this.context[index] = types$1.f_expr_gen; }
     else
-      { this.context[index] = types.f_gen; }
+      { this.context[index] = types$1.f_gen; }
   }
   this.exprAllowed = true;
 };
 
-types$1.name.updateContext = function(prevType) {
+types.name.updateContext = function(prevType) {
   var allowed = false;
-  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
+  if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
     if (this.value === "of" && !this.exprAllowed ||
         this.value === "yield" && this.inGeneratorContext())
       { allowed = true; }
@@ -19829,14 +18402,14 @@
 
 // A recursive descent parser operates by defining functions for all
 
-var pp$5 = Parser.prototype;
+var pp$4 = Parser.prototype;
 
 // Check if property name clashes with already added.
 // Object/class getters and setters are not allowed to clash —
 // either with each other or with an init property — and in
 // strict mode, init properties are also not allowed to be repeated.
 
-pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
+pp$4.checkPropClash = function(prop, propHash, refDestructuringErrors) {
   if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
     { return }
   if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
@@ -19853,12 +18426,10 @@
     if (name === "__proto__" && kind === "init") {
       if (propHash.proto) {
         if (refDestructuringErrors) {
-          if (refDestructuringErrors.doubleProto < 0) {
-            refDestructuringErrors.doubleProto = key.start;
-          }
-        } else {
-          this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
-        }
+          if (refDestructuringErrors.doubleProto < 0)
+            { refDestructuringErrors.doubleProto = key.start; }
+          // Backwards-compat kludge. Can be removed in version 6.0
+        } else { this.raiseRecoverable(key.start, "Redefinition of __proto__ property"); }
       }
       propHash.proto = true;
     }
@@ -19900,13 +18471,13 @@
 // and object pattern might appear (so it's possible to raise
 // delayed syntax error at correct position).
 
-pp$5.parseExpression = function(forInit, refDestructuringErrors) {
+pp$4.parseExpression = function(forInit, refDestructuringErrors) {
   var startPos = this.start, startLoc = this.startLoc;
   var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
-  if (this.type === types$1.comma) {
+  if (this.type === types.comma) {
     var node = this.startNodeAt(startPos, startLoc);
     node.expressions = [expr];
-    while (this.eat(types$1.comma)) { node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors)); }
+    while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors)); }
     return this.finishNode(node, "SequenceExpression")
   }
   return expr
@@ -19915,7 +18486,7 @@
 // Parse an assignment expression. This includes applications of
 // operators like `+=`.
 
-pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
+pp$4.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
   if (this.isContextual("yield")) {
     if (this.inGenerator) { return this.parseYield(forInit) }
     // The tokenizer will assume an expression is allowed after
@@ -19923,11 +18494,10 @@
     else { this.exprAllowed = false; }
   }
 
-  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
+  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;
   if (refDestructuringErrors) {
     oldParenAssign = refDestructuringErrors.parenthesizedAssign;
     oldTrailingComma = refDestructuringErrors.trailingComma;
-    oldDoubleProto = refDestructuringErrors.doubleProto;
     refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
   } else {
     refDestructuringErrors = new DestructuringErrors;
@@ -19935,7 +18505,7 @@
   }
 
   var startPos = this.start, startLoc = this.startLoc;
-  if (this.type === types$1.parenL || this.type === types$1.name) {
+  if (this.type === types.parenL || this.type === types.name) {
     this.potentialArrowAt = this.start;
     this.potentialArrowInForAwait = forInit === "await";
   }
@@ -19944,21 +18514,20 @@
   if (this.type.isAssign) {
     var node = this.startNodeAt(startPos, startLoc);
     node.operator = this.value;
-    if (this.type === types$1.eq)
+    if (this.type === types.eq)
       { left = this.toAssignable(left, false, refDestructuringErrors); }
     if (!ownDestructuringErrors) {
       refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
     }
     if (refDestructuringErrors.shorthandAssign >= left.start)
       { refDestructuringErrors.shorthandAssign = -1; } // reset because shorthand default was used correctly
-    if (this.type === types$1.eq)
+    if (this.type === types.eq)
       { this.checkLValPattern(left); }
     else
       { this.checkLValSimple(left); }
     node.left = left;
     this.next();
     node.right = this.parseMaybeAssign(forInit);
-    if (oldDoubleProto > -1) { refDestructuringErrors.doubleProto = oldDoubleProto; }
     return this.finishNode(node, "AssignmentExpression")
   } else {
     if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
@@ -19970,15 +18539,15 @@
 
 // Parse a ternary conditional (`?:`) operator.
 
-pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
+pp$4.parseMaybeConditional = function(forInit, refDestructuringErrors) {
   var startPos = this.start, startLoc = this.startLoc;
   var expr = this.parseExprOps(forInit, refDestructuringErrors);
   if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
-  if (this.eat(types$1.question)) {
+  if (this.eat(types.question)) {
     var node = this.startNodeAt(startPos, startLoc);
     node.test = expr;
     node.consequent = this.parseMaybeAssign();
-    this.expect(types$1.colon);
+    this.expect(types.colon);
     node.alternate = this.parseMaybeAssign(forInit);
     return this.finishNode(node, "ConditionalExpression")
   }
@@ -19987,7 +18556,7 @@
 
 // Start the precedence parser.
 
-pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
+pp$4.parseExprOps = function(forInit, refDestructuringErrors) {
   var startPos = this.start, startLoc = this.startLoc;
   var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
   if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
@@ -20000,23 +18569,23 @@
 // defer further parser to one of its callers when it encounters an
 // operator that has a lower precedence than the set it is parsing.
 
-pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
+pp$4.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
   var prec = this.type.binop;
-  if (prec != null && (!forInit || this.type !== types$1._in)) {
+  if (prec != null && (!forInit || this.type !== types._in)) {
     if (prec > minPrec) {
-      var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
-      var coalesce = this.type === types$1.coalesce;
+      var logical = this.type === types.logicalOR || this.type === types.logicalAND;
+      var coalesce = this.type === types.coalesce;
       if (coalesce) {
         // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.
         // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.
-        prec = types$1.logicalAND.binop;
+        prec = types.logicalAND.binop;
       }
       var op = this.value;
       this.next();
       var startPos = this.start, startLoc = this.startLoc;
       var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
       var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
-      if ((logical && this.type === types$1.coalesce) || (coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND))) {
+      if ((logical && this.type === types.coalesce) || (coalesce && (this.type === types.logicalOR || this.type === types.logicalAND))) {
         this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
       }
       return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit)
@@ -20025,8 +18594,7 @@
   return left
 };
 
-pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
-  if (right.type === "PrivateIdentifier") { this.raise(right.start, "Private identifier can only be left side of binary expression"); }
+pp$4.buildBinary = function(startPos, startLoc, left, right, op, logical) {
   var node = this.startNodeAt(startPos, startLoc);
   node.left = left;
   node.operator = op;
@@ -20036,13 +18604,13 @@
 
 // Parse unary operators, both prefix and postfix.
 
-pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
+pp$4.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
   var startPos = this.start, startLoc = this.startLoc, expr;
   if (this.isContextual("await") && this.canAwait) {
     expr = this.parseAwait(forInit);
     sawUnary = true;
   } else if (this.type.prefix) {
-    var node = this.startNode(), update = this.type === types$1.incDec;
+    var node = this.startNode(), update = this.type === types.incDec;
     node.operator = this.value;
     node.prefix = true;
     this.next();
@@ -20056,11 +18624,6 @@
       { this.raiseRecoverable(node.start, "Private fields can not be deleted"); }
     else { sawUnary = true; }
     expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
-  } else if (!sawUnary && this.type === types$1.privateId) {
-    if (forInit || this.privateNameStack.length === 0) { this.unexpected(); }
-    expr = this.parsePrivateIdent();
-    // only could be private fields in 'in', such as #x in obj
-    if (this.type !== types$1._in) { this.unexpected(); }
   } else {
     expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
     if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
@@ -20075,7 +18638,7 @@
     }
   }
 
-  if (!incDec && this.eat(types$1.starstar)) {
+  if (!incDec && this.eat(types.starstar)) {
     if (sawUnary)
       { this.unexpected(this.lastTokStart); }
     else
@@ -20094,7 +18657,7 @@
 
 // Parse call, dot, and `[]`-subscript expressions.
 
-pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
+pp$4.parseExprSubscripts = function(refDestructuringErrors, forInit) {
   var startPos = this.start, startLoc = this.startLoc;
   var expr = this.parseExprAtom(refDestructuringErrors, forInit);
   if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
@@ -20108,7 +18671,7 @@
   return result
 };
 
-pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
+pp$4.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
   var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
       this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&
       this.potentialArrowAt === base.start;
@@ -20131,19 +18694,19 @@
   }
 };
 
-pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
+pp$4.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
   var optionalSupported = this.options.ecmaVersion >= 11;
-  var optional = optionalSupported && this.eat(types$1.questionDot);
+  var optional = optionalSupported && this.eat(types.questionDot);
   if (noCalls && optional) { this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions"); }
 
-  var computed = this.eat(types$1.bracketL);
-  if (computed || (optional && this.type !== types$1.parenL && this.type !== types$1.backQuote) || this.eat(types$1.dot)) {
+  var computed = this.eat(types.bracketL);
+  if (computed || (optional && this.type !== types.parenL && this.type !== types.backQuote) || this.eat(types.dot)) {
     var node = this.startNodeAt(startPos, startLoc);
     node.object = base;
     if (computed) {
       node.property = this.parseExpression();
-      this.expect(types$1.bracketR);
-    } else if (this.type === types$1.privateId && base.type !== "Super") {
+      this.expect(types.bracketR);
+    } else if (this.type === types.privateId && base.type !== "Super") {
       node.property = this.parsePrivateIdent();
     } else {
       node.property = this.parseIdent(this.options.allowReserved !== "never");
@@ -20153,13 +18716,13 @@
       node.optional = optional;
     }
     base = this.finishNode(node, "MemberExpression");
-  } else if (!noCalls && this.eat(types$1.parenL)) {
+  } else if (!noCalls && this.eat(types.parenL)) {
     var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
     this.yieldPos = 0;
     this.awaitPos = 0;
     this.awaitIdentPos = 0;
-    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
-    if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
+    var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
+    if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types.arrow)) {
       this.checkPatternErrors(refDestructuringErrors, false);
       this.checkYieldAwaitInDefaultParams();
       if (this.awaitIdentPos > 0)
@@ -20180,7 +18743,7 @@
       node$1.optional = optional;
     }
     base = this.finishNode(node$1, "CallExpression");
-  } else if (this.type === types$1.backQuote) {
+  } else if (this.type === types.backQuote) {
     if (optional || optionalChained) {
       this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
     }
@@ -20197,19 +18760,19 @@
 // `new`, or an expression wrapped in punctuation like `()`, `[]`,
 // or `{}`.
 
-pp$5.parseExprAtom = function(refDestructuringErrors, forInit) {
+pp$4.parseExprAtom = function(refDestructuringErrors, forInit) {
   // If a division operator appears in an expression position, the
   // tokenizer got confused, and we force it to read a regexp instead.
-  if (this.type === types$1.slash) { this.readRegexp(); }
+  if (this.type === types.slash) { this.readRegexp(); }
 
   var node, canBeArrow = this.potentialArrowAt === this.start;
   switch (this.type) {
-  case types$1._super:
+  case types._super:
     if (!this.allowSuper)
       { this.raise(this.start, "'super' keyword outside a method"); }
     node = this.startNode();
     this.next();
-    if (this.type === types$1.parenL && !this.allowDirectSuper)
+    if (this.type === types.parenL && !this.allowDirectSuper)
       { this.raise(node.start, "super() call outside constructor of a subclass"); }
     // The `super` keyword can appear at below:
     // SuperProperty:
@@ -20217,52 +18780,52 @@
     //     super . IdentifierName
     // SuperCall:
     //     super ( Arguments )
-    if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL)
+    if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)
       { this.unexpected(); }
     return this.finishNode(node, "Super")
 
-  case types$1._this:
+  case types._this:
     node = this.startNode();
     this.next();
     return this.finishNode(node, "ThisExpression")
 
-  case types$1.name:
+  case types.name:
     var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
     var id = this.parseIdent(false);
-    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
-      this.overrideContext(types.f_expr);
+    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function)) {
+      this.overrideContext(types$1.f_expr);
       return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit)
     }
     if (canBeArrow && !this.canInsertSemicolon()) {
-      if (this.eat(types$1.arrow))
+      if (this.eat(types.arrow))
         { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit) }
-      if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc &&
+      if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc &&
           (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
         id = this.parseIdent(false);
-        if (this.canInsertSemicolon() || !this.eat(types$1.arrow))
+        if (this.canInsertSemicolon() || !this.eat(types.arrow))
           { this.unexpected(); }
         return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit)
       }
     }
     return id
 
-  case types$1.regexp:
+  case types.regexp:
     var value = this.value;
     node = this.parseLiteral(value.value);
     node.regex = {pattern: value.pattern, flags: value.flags};
     return node
 
-  case types$1.num: case types$1.string:
+  case types.num: case types.string:
     return this.parseLiteral(this.value)
 
-  case types$1._null: case types$1._true: case types$1._false:
+  case types._null: case types._true: case types._false:
     node = this.startNode();
-    node.value = this.type === types$1._null ? null : this.type === types$1._true;
+    node.value = this.type === types._null ? null : this.type === types._true;
     node.raw = this.type.keyword;
     this.next();
     return this.finishNode(node, "Literal")
 
-  case types$1.parenL:
+  case types.parenL:
     var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
     if (refDestructuringErrors) {
       if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
@@ -20272,31 +18835,31 @@
     }
     return expr
 
-  case types$1.bracketL:
+  case types.bracketL:
     node = this.startNode();
     this.next();
-    node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
+    node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
     return this.finishNode(node, "ArrayExpression")
 
-  case types$1.braceL:
-    this.overrideContext(types.b_expr);
+  case types.braceL:
+    this.overrideContext(types$1.b_expr);
     return this.parseObj(false, refDestructuringErrors)
 
-  case types$1._function:
+  case types._function:
     node = this.startNode();
     this.next();
     return this.parseFunction(node, 0)
 
-  case types$1._class:
+  case types._class:
     return this.parseClass(this.startNode(), false)
 
-  case types$1._new:
+  case types._new:
     return this.parseNew()
 
-  case types$1.backQuote:
+  case types.backQuote:
     return this.parseTemplate()
 
-  case types$1._import:
+  case types._import:
     if (this.options.ecmaVersion >= 11) {
       return this.parseExprImport()
     } else {
@@ -20308,7 +18871,7 @@
   }
 };
 
-pp$5.parseExprImport = function() {
+pp$4.parseExprImport = function() {
   var node = this.startNode();
 
   // Consume `import` as an identifier for `import.meta`.
@@ -20317,9 +18880,9 @@
   var meta = this.parseIdent(true);
 
   switch (this.type) {
-  case types$1.parenL:
+  case types.parenL:
     return this.parseDynamicImport(node)
-  case types$1.dot:
+  case types.dot:
     node.meta = meta;
     return this.parseImportMeta(node)
   default:
@@ -20327,16 +18890,16 @@
   }
 };
 
-pp$5.parseDynamicImport = function(node) {
+pp$4.parseDynamicImport = function(node) {
   this.next(); // skip `(`
 
   // Parse node.source.
   node.source = this.parseMaybeAssign();
 
   // Verify ending.
-  if (!this.eat(types$1.parenR)) {
+  if (!this.eat(types.parenR)) {
     var errorPos = this.start;
-    if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
+    if (this.eat(types.comma) && this.eat(types.parenR)) {
       this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
     } else {
       this.unexpected(errorPos);
@@ -20346,7 +18909,7 @@
   return this.finishNode(node, "ImportExpression")
 };
 
-pp$5.parseImportMeta = function(node) {
+pp$4.parseImportMeta = function(node) {
   this.next(); // skip `.`
 
   var containsEsc = this.containsEsc;
@@ -20362,7 +18925,7 @@
   return this.finishNode(node, "MetaProperty")
 };
 
-pp$5.parseLiteral = function(value) {
+pp$4.parseLiteral = function(value) {
   var node = this.startNode();
   node.value = value;
   node.raw = this.input.slice(this.start, this.end);
@@ -20371,14 +18934,14 @@
   return this.finishNode(node, "Literal")
 };
 
-pp$5.parseParenExpression = function() {
-  this.expect(types$1.parenL);
+pp$4.parseParenExpression = function() {
+  this.expect(types.parenL);
   var val = this.parseExpression();
-  this.expect(types$1.parenR);
+  this.expect(types.parenR);
   return val
 };
 
-pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
+pp$4.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
   var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
   if (this.options.ecmaVersion >= 6) {
     this.next();
@@ -20389,24 +18952,24 @@
     this.yieldPos = 0;
     this.awaitPos = 0;
     // Do not save awaitIdentPos to allow checking awaits nested in parameters
-    while (this.type !== types$1.parenR) {
-      first ? first = false : this.expect(types$1.comma);
-      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
+    while (this.type !== types.parenR) {
+      first ? first = false : this.expect(types.comma);
+      if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
         lastIsComma = true;
         break
-      } else if (this.type === types$1.ellipsis) {
+      } else if (this.type === types.ellipsis) {
         spreadStart = this.start;
         exprList.push(this.parseParenItem(this.parseRestBinding()));
-        if (this.type === types$1.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
+        if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
         break
       } else {
         exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
       }
     }
     var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
-    this.expect(types$1.parenR);
+    this.expect(types.parenR);
 
-    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
+    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
       this.checkPatternErrors(refDestructuringErrors, false);
       this.checkYieldAwaitInDefaultParams();
       this.yieldPos = oldYieldPos;
@@ -20440,12 +19003,12 @@
   }
 };
 
-pp$5.parseParenItem = function(item) {
+pp$4.parseParenItem = function(item) {
   return item
 };
 
-pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
-  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit)
+pp$4.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
+  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, forInit)
 };
 
 // New's precedence is slightly tricky. It must allow its argument to
@@ -20454,13 +19017,13 @@
 // argument to parseSubscripts to prevent it from consuming the
 // argument list.
 
-var empty = [];
+var empty$1 = [];
 
-pp$5.parseNew = function() {
+pp$4.parseNew = function() {
   if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword new"); }
   var node = this.startNode();
   var meta = this.parseIdent(true);
-  if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {
+  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
     node.meta = meta;
     var containsEsc = this.containsEsc;
     node.property = this.parseIdent(true);
@@ -20472,23 +19035,23 @@
       { this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block"); }
     return this.finishNode(node, "MetaProperty")
   }
-  var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types$1._import;
+  var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;
   node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);
   if (isImport && node.callee.type === "ImportExpression") {
     this.raise(startPos, "Cannot use new with import()");
   }
-  if (this.eat(types$1.parenL)) { node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false); }
-  else { node.arguments = empty; }
+  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }
+  else { node.arguments = empty$1; }
   return this.finishNode(node, "NewExpression")
 };
 
 // Parse template expression.
 
-pp$5.parseTemplateElement = function(ref) {
+pp$4.parseTemplateElement = function(ref) {
   var isTagged = ref.isTagged;
 
   var elem = this.startNode();
-  if (this.type === types$1.invalidTemplate) {
+  if (this.type === types.invalidTemplate) {
     if (!isTagged) {
       this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
     }
@@ -20503,11 +19066,11 @@
     };
   }
   this.next();
-  elem.tail = this.type === types$1.backQuote;
+  elem.tail = this.type === types.backQuote;
   return this.finishNode(elem, "TemplateElement")
 };
 
-pp$5.parseTemplate = function(ref) {
+pp$4.parseTemplate = function(ref) {
   if ( ref === void 0 ) ref = {};
   var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;
 
@@ -20517,32 +19080,32 @@
   var curElt = this.parseTemplateElement({isTagged: isTagged});
   node.quasis = [curElt];
   while (!curElt.tail) {
-    if (this.type === types$1.eof) { this.raise(this.pos, "Unterminated template literal"); }
-    this.expect(types$1.dollarBraceL);
+    if (this.type === types.eof) { this.raise(this.pos, "Unterminated template literal"); }
+    this.expect(types.dollarBraceL);
     node.expressions.push(this.parseExpression());
-    this.expect(types$1.braceR);
+    this.expect(types.braceR);
     node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
   }
   this.next();
   return this.finishNode(node, "TemplateLiteral")
 };
 
-pp$5.isAsyncProp = function(prop) {
+pp$4.isAsyncProp = function(prop) {
   return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
-    (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types$1.star)) &&
+    (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&
     !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
 };
 
 // Parse an object literal or binding pattern.
 
-pp$5.parseObj = function(isPattern, refDestructuringErrors) {
+pp$4.parseObj = function(isPattern, refDestructuringErrors) {
   var node = this.startNode(), first = true, propHash = {};
   node.properties = [];
   this.next();
-  while (!this.eat(types$1.braceR)) {
+  while (!this.eat(types.braceR)) {
     if (!first) {
-      this.expect(types$1.comma);
-      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) { break }
+      this.expect(types.comma);
+      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) { break }
     } else { first = false; }
 
     var prop = this.parseProperty(isPattern, refDestructuringErrors);
@@ -20552,20 +19115,29 @@
   return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
 };
 
-pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
+pp$4.parseProperty = function(isPattern, refDestructuringErrors) {
   var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
-  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
+  if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
     if (isPattern) {
       prop.argument = this.parseIdent(false);
-      if (this.type === types$1.comma) {
+      if (this.type === types.comma) {
         this.raise(this.start, "Comma is not permitted after the rest element");
       }
       return this.finishNode(prop, "RestElement")
     }
+    // To disallow parenthesized identifier via `this.toAssignable()`.
+    if (this.type === types.parenL && refDestructuringErrors) {
+      if (refDestructuringErrors.parenthesizedAssign < 0) {
+        refDestructuringErrors.parenthesizedAssign = this.start;
+      }
+      if (refDestructuringErrors.parenthesizedBind < 0) {
+        refDestructuringErrors.parenthesizedBind = this.start;
+      }
+    }
     // Parse argument.
     prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
     // To disallow trailing comma via `this.toAssignable()`.
-    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
+    if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
       refDestructuringErrors.trailingComma = this.start;
     }
     // Finish
@@ -20579,13 +19151,13 @@
       startLoc = this.startLoc;
     }
     if (!isPattern)
-      { isGenerator = this.eat(types$1.star); }
+      { isGenerator = this.eat(types.star); }
   }
   var containsEsc = this.containsEsc;
   this.parsePropertyName(prop);
   if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
     isAsync = true;
-    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
+    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
     this.parsePropertyName(prop, refDestructuringErrors);
   } else {
     isAsync = false;
@@ -20594,14 +19166,14 @@
   return this.finishNode(prop, "Property")
 };
 
-pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
-  if ((isGenerator || isAsync) && this.type === types$1.colon)
+pp$4.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
+  if ((isGenerator || isAsync) && this.type === types.colon)
     { this.unexpected(); }
 
-  if (this.eat(types$1.colon)) {
+  if (this.eat(types.colon)) {
     prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
     prop.kind = "init";
-  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
+  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
     if (isPattern) { this.unexpected(); }
     prop.kind = "init";
     prop.method = true;
@@ -20609,7 +19181,7 @@
   } else if (!isPattern && !containsEsc &&
              this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
              (prop.key.name === "get" || prop.key.name === "set") &&
-             (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
+             (this.type !== types.comma && this.type !== types.braceR && this.type !== types.eq)) {
     if (isGenerator || isAsync) { this.unexpected(); }
     prop.kind = prop.key.name;
     this.parsePropertyName(prop);
@@ -20633,7 +19205,7 @@
     prop.kind = "init";
     if (isPattern) {
       prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
-    } else if (this.type === types$1.eq && refDestructuringErrors) {
+    } else if (this.type === types.eq && refDestructuringErrors) {
       if (refDestructuringErrors.shorthandAssign < 0)
         { refDestructuringErrors.shorthandAssign = this.start; }
       prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
@@ -20644,23 +19216,23 @@
   } else { this.unexpected(); }
 };
 
-pp$5.parsePropertyName = function(prop) {
+pp$4.parsePropertyName = function(prop) {
   if (this.options.ecmaVersion >= 6) {
-    if (this.eat(types$1.bracketL)) {
+    if (this.eat(types.bracketL)) {
       prop.computed = true;
       prop.key = this.parseMaybeAssign();
-      this.expect(types$1.bracketR);
+      this.expect(types.bracketR);
       return prop.key
     } else {
       prop.computed = false;
     }
   }
-  return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
+  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
 };
 
 // Initialize empty function node.
 
-pp$5.initFunction = function(node) {
+pp$4.initFunction = function(node) {
   node.id = null;
   if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
   if (this.options.ecmaVersion >= 8) { node.async = false; }
@@ -20668,7 +19240,7 @@
 
 // Parse object or class method.
 
-pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
+pp$4.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
   var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
 
   this.initFunction(node);
@@ -20682,8 +19254,8 @@
   this.awaitIdentPos = 0;
   this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
 
-  this.expect(types$1.parenL);
-  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
+  this.expect(types.parenL);
+  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
   this.checkYieldAwaitInDefaultParams();
   this.parseFunctionBody(node, false, true, false);
 
@@ -20695,7 +19267,7 @@
 
 // Parse arrow function expression with given parameters.
 
-pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
+pp$4.parseArrowExpression = function(node, params, isAsync, forInit) {
   var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
 
   this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
@@ -20717,8 +19289,8 @@
 
 // Parse function body and check parameters.
 
-pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
-  var isExpression = isArrowFunction && this.type !== types$1.braceL;
+pp$4.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
+  var isExpression = isArrowFunction && this.type !== types.braceL;
   var oldStrict = this.strict, useStrict = false;
 
   if (isExpression) {
@@ -20754,7 +19326,7 @@
   this.exitScope();
 };
 
-pp$5.isSimpleParamList = function(params) {
+pp$4.isSimpleParamList = function(params) {
   for (var i = 0, list = params; i < list.length; i += 1)
     {
     var param = list[i];
@@ -20767,7 +19339,7 @@
 // Checks function params for various disallowed patterns such as using "eval"
 // or "arguments" and duplicate parameters.
 
-pp$5.checkParams = function(node, allowDuplicates) {
+pp$4.checkParams = function(node, allowDuplicates) {
   var nameHash = Object.create(null);
   for (var i = 0, list = node.params; i < list.length; i += 1)
     {
@@ -20783,20 +19355,20 @@
 // nothing in between them to be parsed as `null` (which is needed
 // for array literals).
 
-pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
+pp$4.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
   var elts = [], first = true;
   while (!this.eat(close)) {
     if (!first) {
-      this.expect(types$1.comma);
+      this.expect(types.comma);
       if (allowTrailingComma && this.afterTrailingComma(close)) { break }
     } else { first = false; }
 
     var elt = (void 0);
-    if (allowEmpty && this.type === types$1.comma)
+    if (allowEmpty && this.type === types.comma)
       { elt = null; }
-    else if (this.type === types$1.ellipsis) {
+    else if (this.type === types.ellipsis) {
       elt = this.parseSpread(refDestructuringErrors);
-      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0)
+      if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)
         { refDestructuringErrors.trailingComma = this.start; }
     } else {
       elt = this.parseMaybeAssign(false, refDestructuringErrors);
@@ -20806,7 +19378,7 @@
   return elts
 };
 
-pp$5.checkUnreserved = function(ref) {
+pp$4.checkUnreserved = function(ref) {
   var start = ref.start;
   var end = ref.end;
   var name = ref.name;
@@ -20835,9 +19407,9 @@
 // when parsing properties), it will also convert keywords into
 // identifiers.
 
-pp$5.parseIdent = function(liberal, isBinding) {
+pp$4.parseIdent = function(liberal, isBinding) {
   var node = this.startNode();
-  if (this.type === types$1.name) {
+  if (this.type === types.name) {
     node.name = this.value;
   } else if (this.type.keyword) {
     node.name = this.type.keyword;
@@ -20863,9 +19435,9 @@
   return node
 };
 
-pp$5.parsePrivateIdent = function() {
+pp$4.parsePrivateIdent = function() {
   var node = this.startNode();
-  if (this.type === types$1.privateId) {
+  if (this.type === types.privateId) {
     node.name = this.value;
   } else {
     this.unexpected();
@@ -20885,22 +19457,22 @@
 
 // Parses yield expression inside generator.
 
-pp$5.parseYield = function(forInit) {
+pp$4.parseYield = function(forInit) {
   if (!this.yieldPos) { this.yieldPos = this.start; }
 
   var node = this.startNode();
   this.next();
-  if (this.type === types$1.semi || this.canInsertSemicolon() || (this.type !== types$1.star && !this.type.startsExpr)) {
+  if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {
     node.delegate = false;
     node.argument = null;
   } else {
-    node.delegate = this.eat(types$1.star);
+    node.delegate = this.eat(types.star);
     node.argument = this.parseMaybeAssign(forInit);
   }
   return this.finishNode(node, "YieldExpression")
 };
 
-pp$5.parseAwait = function(forInit) {
+pp$4.parseAwait = function(forInit) {
   if (!this.awaitPos) { this.awaitPos = this.start; }
 
   var node = this.startNode();
@@ -20909,7 +19481,7 @@
   return this.finishNode(node, "AwaitExpression")
 };
 
-var pp$4 = Parser.prototype;
+var pp$5 = Parser.prototype;
 
 // This function is used to raise exceptions on parse errors. It
 // takes an offset integer (into the current `input`) to indicate
@@ -20917,7 +19489,7 @@
 // of the error message, and then raises a `SyntaxError` with that
 // message.
 
-pp$4.raise = function(pos, message) {
+pp$5.raise = function(pos, message) {
   var loc = getLineInfo(this.input, pos);
   message += " (" + loc.line + ":" + loc.column + ")";
   var err = new SyntaxError(message);
@@ -20925,15 +19497,15 @@
   throw err
 };
 
-pp$4.raiseRecoverable = pp$4.raise;
+pp$5.raiseRecoverable = pp$5.raise;
 
-pp$4.curPosition = function() {
+pp$5.curPosition = function() {
   if (this.options.locations) {
     return new Position(this.curLine, this.pos - this.lineStart)
   }
 };
 
-var pp$3 = Parser.prototype;
+var pp$6 = Parser.prototype;
 
 var Scope = function Scope(flags) {
   this.flags = flags;
@@ -20949,22 +19521,22 @@
 
 // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.
 
-pp$3.enterScope = function(flags) {
+pp$6.enterScope = function(flags) {
   this.scopeStack.push(new Scope(flags));
 };
 
-pp$3.exitScope = function() {
+pp$6.exitScope = function() {
   this.scopeStack.pop();
 };
 
 // The spec says:
 // > At the top level of a function, or script, function declarations are
 // > treated like var declarations rather than like lexical declarations.
-pp$3.treatFunctionsAsVarInScope = function(scope) {
+pp$6.treatFunctionsAsVarInScope = function(scope) {
   return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
 };
 
-pp$3.declareName = function(name, bindingType, pos) {
+pp$6.declareName = function(name, bindingType, pos) {
   var redeclared = false;
   if (bindingType === BIND_LEXICAL) {
     var scope = this.currentScope();
@@ -20999,7 +19571,7 @@
   if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
 };
 
-pp$3.checkLocalExport = function(id) {
+pp$6.checkLocalExport = function(id) {
   // scope.functions must be empty as Module code is always strict.
   if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
       this.scopeStack[0].var.indexOf(id.name) === -1) {
@@ -21007,11 +19579,11 @@
   }
 };
 
-pp$3.currentScope = function() {
+pp$6.currentScope = function() {
   return this.scopeStack[this.scopeStack.length - 1]
 };
 
-pp$3.currentVarScope = function() {
+pp$6.currentVarScope = function() {
   for (var i = this.scopeStack.length - 1;; i--) {
     var scope = this.scopeStack[i];
     if (scope.flags & SCOPE_VAR) { return scope }
@@ -21019,7 +19591,7 @@
 };
 
 // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
-pp$3.currentThisScope = function() {
+pp$6.currentThisScope = function() {
   for (var i = this.scopeStack.length - 1;; i--) {
     var scope = this.scopeStack[i];
     if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
@@ -21040,13 +19612,13 @@
 
 // Start an AST node, attaching a start offset.
 
-var pp$2 = Parser.prototype;
+var pp$7 = Parser.prototype;
 
-pp$2.startNode = function() {
+pp$7.startNode = function() {
   return new Node(this, this.start, this.startLoc)
 };
 
-pp$2.startNodeAt = function(pos, loc) {
+pp$7.startNodeAt = function(pos, loc) {
   return new Node(this, pos, loc)
 };
 
@@ -21062,17 +19634,17 @@
   return node
 }
 
-pp$2.finishNode = function(node, type) {
+pp$7.finishNode = function(node, type) {
   return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
 };
 
 // Finish node at given position
 
-pp$2.finishNodeAt = function(node, type, pos, loc) {
+pp$7.finishNodeAt = function(node, type, pos, loc) {
   return finishNodeAt.call(this, node, type, pos, loc)
 };
 
-pp$2.copyNode = function(node) {
+pp$7.copyNode = function(node) {
   var newNode = new Node(this, node.start, this.startLoc);
   for (var prop in node) { newNode[prop] = node[prop]; }
   return newNode
@@ -21087,30 +19659,26 @@
 var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
 var ecma11BinaryProperties = ecma10BinaryProperties;
 var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
-var ecma13BinaryProperties = ecma12BinaryProperties;
 var unicodeBinaryProperties = {
   9: ecma9BinaryProperties,
   10: ecma10BinaryProperties,
   11: ecma11BinaryProperties,
-  12: ecma12BinaryProperties,
-  13: ecma13BinaryProperties
+  12: ecma12BinaryProperties
 };
 
 // #table-unicode-general-category-values
 var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
 
 // #table-unicode-script-values
-var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
+var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
 var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
 var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
 var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
-var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
 var unicodeScriptValues = {
   9: ecma9ScriptValues,
   10: ecma10ScriptValues,
   11: ecma11ScriptValues,
-  12: ecma12ScriptValues,
-  13: ecma13ScriptValues
+  12: ecma12ScriptValues
 };
 
 var data = {};
@@ -21128,19 +19696,17 @@
   d.nonBinary.sc = d.nonBinary.Script;
   d.nonBinary.scx = d.nonBinary.Script_Extensions;
 }
+buildUnicodeData(9);
+buildUnicodeData(10);
+buildUnicodeData(11);
+buildUnicodeData(12);
 
-for (var i = 0, list = [9, 10, 11, 12, 13]; i < list.length; i += 1) {
-  var ecmaVersion = list[i];
-
-  buildUnicodeData(ecmaVersion);
-}
-
-var pp$1 = Parser.prototype;
+var pp$8 = Parser.prototype;
 
 var RegExpValidationState = function RegExpValidationState(parser) {
   this.parser = parser;
   this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "");
-  this.unicodeProperties = data[parser.options.ecmaVersion >= 13 ? 13 : parser.options.ecmaVersion];
+  this.unicodeProperties = data[parser.options.ecmaVersion >= 12 ? 12 : parser.options.ecmaVersion];
   this.source = "";
   this.flags = "";
   this.start = 0;
@@ -21231,13 +19797,19 @@
   return false
 };
 
+function codePointToString(ch) {
+  if (ch <= 0xFFFF) { return String.fromCharCode(ch) }
+  ch -= 0x10000;
+  return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)
+}
+
 /**
  * Validate the flags part of a given RegExpLiteral.
  *
  * @param {RegExpValidationState} state The state to validate RegExp.
  * @returns {void}
  */
-pp$1.validateRegExpFlags = function(state) {
+pp$8.validateRegExpFlags = function(state) {
   var validFlags = state.validFlags;
   var flags = state.flags;
 
@@ -21258,7 +19830,7 @@
  * @param {RegExpValidationState} state The state to validate RegExp.
  * @returns {void}
  */
-pp$1.validateRegExpPattern = function(state) {
+pp$8.validateRegExpPattern = function(state) {
   this.regexp_pattern(state);
 
   // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
@@ -21273,7 +19845,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
-pp$1.regexp_pattern = function(state) {
+pp$8.regexp_pattern = function(state) {
   state.pos = 0;
   state.lastIntValue = 0;
   state.lastStringValue = "";
@@ -21307,7 +19879,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
-pp$1.regexp_disjunction = function(state) {
+pp$8.regexp_disjunction = function(state) {
   this.regexp_alternative(state);
   while (state.eat(0x7C /* | */)) {
     this.regexp_alternative(state);
@@ -21323,13 +19895,13 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
-pp$1.regexp_alternative = function(state) {
+pp$8.regexp_alternative = function(state) {
   while (state.pos < state.source.length && this.regexp_eatTerm(state))
     { }
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
-pp$1.regexp_eatTerm = function(state) {
+pp$8.regexp_eatTerm = function(state) {
   if (this.regexp_eatAssertion(state)) {
     // Handle `QuantifiableAssertion Quantifier` alternative.
     // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
@@ -21352,7 +19924,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
-pp$1.regexp_eatAssertion = function(state) {
+pp$8.regexp_eatAssertion = function(state) {
   var start = state.pos;
   state.lastAssertionIsQuantifiable = false;
 
@@ -21390,7 +19962,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
-pp$1.regexp_eatQuantifier = function(state, noError) {
+pp$8.regexp_eatQuantifier = function(state, noError) {
   if ( noError === void 0 ) noError = false;
 
   if (this.regexp_eatQuantifierPrefix(state, noError)) {
@@ -21401,7 +19973,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
-pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
+pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
   return (
     state.eat(0x2A /* * */) ||
     state.eat(0x2B /* + */) ||
@@ -21409,7 +19981,7 @@
     this.regexp_eatBracedQuantifier(state, noError)
   )
 };
-pp$1.regexp_eatBracedQuantifier = function(state, noError) {
+pp$8.regexp_eatBracedQuantifier = function(state, noError) {
   var start = state.pos;
   if (state.eat(0x7B /* { */)) {
     var min = 0, max = -1;
@@ -21435,7 +20007,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
-pp$1.regexp_eatAtom = function(state) {
+pp$8.regexp_eatAtom = function(state) {
   return (
     this.regexp_eatPatternCharacters(state) ||
     state.eat(0x2E /* . */) ||
@@ -21445,7 +20017,7 @@
     this.regexp_eatCapturingGroup(state)
   )
 };
-pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
+pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
   var start = state.pos;
   if (state.eat(0x5C /* \ */)) {
     if (this.regexp_eatAtomEscape(state)) {
@@ -21455,7 +20027,7 @@
   }
   return false
 };
-pp$1.regexp_eatUncapturingGroup = function(state) {
+pp$8.regexp_eatUncapturingGroup = function(state) {
   var start = state.pos;
   if (state.eat(0x28 /* ( */)) {
     if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {
@@ -21469,7 +20041,7 @@
   }
   return false
 };
-pp$1.regexp_eatCapturingGroup = function(state) {
+pp$8.regexp_eatCapturingGroup = function(state) {
   if (state.eat(0x28 /* ( */)) {
     if (this.options.ecmaVersion >= 9) {
       this.regexp_groupSpecifier(state);
@@ -21487,7 +20059,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
-pp$1.regexp_eatExtendedAtom = function(state) {
+pp$8.regexp_eatExtendedAtom = function(state) {
   return (
     state.eat(0x2E /* . */) ||
     this.regexp_eatReverseSolidusAtomEscape(state) ||
@@ -21500,7 +20072,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
-pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
+pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
   if (this.regexp_eatBracedQuantifier(state, true)) {
     state.raise("Nothing to repeat");
   }
@@ -21508,7 +20080,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
-pp$1.regexp_eatSyntaxCharacter = function(state) {
+pp$8.regexp_eatSyntaxCharacter = function(state) {
   var ch = state.current();
   if (isSyntaxCharacter(ch)) {
     state.lastIntValue = ch;
@@ -21530,7 +20102,7 @@
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
 // But eat eager.
-pp$1.regexp_eatPatternCharacters = function(state) {
+pp$8.regexp_eatPatternCharacters = function(state) {
   var start = state.pos;
   var ch = 0;
   while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
@@ -21540,7 +20112,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
-pp$1.regexp_eatExtendedPatternCharacter = function(state) {
+pp$8.regexp_eatExtendedPatternCharacter = function(state) {
   var ch = state.current();
   if (
     ch !== -1 &&
@@ -21561,7 +20133,7 @@
 // GroupSpecifier ::
 //   [empty]
 //   `?` GroupName
-pp$1.regexp_groupSpecifier = function(state) {
+pp$8.regexp_groupSpecifier = function(state) {
   if (state.eat(0x3F /* ? */)) {
     if (this.regexp_eatGroupName(state)) {
       if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
@@ -21577,7 +20149,7 @@
 // GroupName ::
 //   `<` RegExpIdentifierName `>`
 // Note: this updates `state.lastStringValue` property with the eaten name.
-pp$1.regexp_eatGroupName = function(state) {
+pp$8.regexp_eatGroupName = function(state) {
   state.lastStringValue = "";
   if (state.eat(0x3C /* < */)) {
     if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
@@ -21592,7 +20164,7 @@
 //   RegExpIdentifierStart
 //   RegExpIdentifierName RegExpIdentifierPart
 // Note: this updates `state.lastStringValue` property with the eaten name.
-pp$1.regexp_eatRegExpIdentifierName = function(state) {
+pp$8.regexp_eatRegExpIdentifierName = function(state) {
   state.lastStringValue = "";
   if (this.regexp_eatRegExpIdentifierStart(state)) {
     state.lastStringValue += codePointToString(state.lastIntValue);
@@ -21609,7 +20181,7 @@
 //   `$`
 //   `_`
 //   `\` RegExpUnicodeEscapeSequence[+U]
-pp$1.regexp_eatRegExpIdentifierStart = function(state) {
+pp$8.regexp_eatRegExpIdentifierStart = function(state) {
   var start = state.pos;
   var forceU = this.options.ecmaVersion >= 11;
   var ch = state.current(forceU);
@@ -21637,7 +20209,7 @@
 //   `\` RegExpUnicodeEscapeSequence[+U]
 //   <ZWNJ>
 //   <ZWJ>
-pp$1.regexp_eatRegExpIdentifierPart = function(state) {
+pp$8.regexp_eatRegExpIdentifierPart = function(state) {
   var start = state.pos;
   var forceU = this.options.ecmaVersion >= 11;
   var ch = state.current(forceU);
@@ -21659,7 +20231,7 @@
 }
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
-pp$1.regexp_eatAtomEscape = function(state) {
+pp$8.regexp_eatAtomEscape = function(state) {
   if (
     this.regexp_eatBackReference(state) ||
     this.regexp_eatCharacterClassEscape(state) ||
@@ -21677,7 +20249,7 @@
   }
   return false
 };
-pp$1.regexp_eatBackReference = function(state) {
+pp$8.regexp_eatBackReference = function(state) {
   var start = state.pos;
   if (this.regexp_eatDecimalEscape(state)) {
     var n = state.lastIntValue;
@@ -21695,7 +20267,7 @@
   }
   return false
 };
-pp$1.regexp_eatKGroupName = function(state) {
+pp$8.regexp_eatKGroupName = function(state) {
   if (state.eat(0x6B /* k */)) {
     if (this.regexp_eatGroupName(state)) {
       state.backReferenceNames.push(state.lastStringValue);
@@ -21707,7 +20279,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
-pp$1.regexp_eatCharacterEscape = function(state) {
+pp$8.regexp_eatCharacterEscape = function(state) {
   return (
     this.regexp_eatControlEscape(state) ||
     this.regexp_eatCControlLetter(state) ||
@@ -21718,7 +20290,7 @@
     this.regexp_eatIdentityEscape(state)
   )
 };
-pp$1.regexp_eatCControlLetter = function(state) {
+pp$8.regexp_eatCControlLetter = function(state) {
   var start = state.pos;
   if (state.eat(0x63 /* c */)) {
     if (this.regexp_eatControlLetter(state)) {
@@ -21728,7 +20300,7 @@
   }
   return false
 };
-pp$1.regexp_eatZero = function(state) {
+pp$8.regexp_eatZero = function(state) {
   if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
     state.lastIntValue = 0;
     state.advance();
@@ -21738,7 +20310,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
-pp$1.regexp_eatControlEscape = function(state) {
+pp$8.regexp_eatControlEscape = function(state) {
   var ch = state.current();
   if (ch === 0x74 /* t */) {
     state.lastIntValue = 0x09; /* \t */
@@ -21769,7 +20341,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
-pp$1.regexp_eatControlLetter = function(state) {
+pp$8.regexp_eatControlLetter = function(state) {
   var ch = state.current();
   if (isControlLetter(ch)) {
     state.lastIntValue = ch % 0x20;
@@ -21786,7 +20358,7 @@
 }
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
-pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
+pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
   if ( forceU === void 0 ) forceU = false;
 
   var start = state.pos;
@@ -21831,7 +20403,7 @@
 }
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
-pp$1.regexp_eatIdentityEscape = function(state) {
+pp$8.regexp_eatIdentityEscape = function(state) {
   if (state.switchU) {
     if (this.regexp_eatSyntaxCharacter(state)) {
       return true
@@ -21854,7 +20426,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
-pp$1.regexp_eatDecimalEscape = function(state) {
+pp$8.regexp_eatDecimalEscape = function(state) {
   state.lastIntValue = 0;
   var ch = state.current();
   if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
@@ -21868,7 +20440,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
-pp$1.regexp_eatCharacterClassEscape = function(state) {
+pp$8.regexp_eatCharacterClassEscape = function(state) {
   var ch = state.current();
 
   if (isCharacterClassEscape(ch)) {
@@ -21910,7 +20482,7 @@
 // UnicodePropertyValueExpression ::
 //   UnicodePropertyName `=` UnicodePropertyValue
 //   LoneUnicodePropertyNameOrValue
-pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
+pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
   var start = state.pos;
 
   // UnicodePropertyName `=` UnicodePropertyValue
@@ -21932,20 +20504,20 @@
   }
   return false
 };
-pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
-  if (!hasOwn(state.unicodeProperties.nonBinary, name))
+pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
+  if (!has(state.unicodeProperties.nonBinary, name))
     { state.raise("Invalid property name"); }
   if (!state.unicodeProperties.nonBinary[name].test(value))
     { state.raise("Invalid property value"); }
 };
-pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
+pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
   if (!state.unicodeProperties.binary.test(nameOrValue))
     { state.raise("Invalid property name"); }
 };
 
 // UnicodePropertyName ::
 //   UnicodePropertyNameCharacters
-pp$1.regexp_eatUnicodePropertyName = function(state) {
+pp$8.regexp_eatUnicodePropertyName = function(state) {
   var ch = 0;
   state.lastStringValue = "";
   while (isUnicodePropertyNameCharacter(ch = state.current())) {
@@ -21960,7 +20532,7 @@
 
 // UnicodePropertyValue ::
 //   UnicodePropertyValueCharacters
-pp$1.regexp_eatUnicodePropertyValue = function(state) {
+pp$8.regexp_eatUnicodePropertyValue = function(state) {
   var ch = 0;
   state.lastStringValue = "";
   while (isUnicodePropertyValueCharacter(ch = state.current())) {
@@ -21975,12 +20547,12 @@
 
 // LoneUnicodePropertyNameOrValue ::
 //   UnicodePropertyValueCharacters
-pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
+pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
   return this.regexp_eatUnicodePropertyValue(state)
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
-pp$1.regexp_eatCharacterClass = function(state) {
+pp$8.regexp_eatCharacterClass = function(state) {
   if (state.eat(0x5B /* [ */)) {
     state.eat(0x5E /* ^ */);
     this.regexp_classRanges(state);
@@ -21996,7 +20568,7 @@
 // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
 // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
 // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
-pp$1.regexp_classRanges = function(state) {
+pp$8.regexp_classRanges = function(state) {
   while (this.regexp_eatClassAtom(state)) {
     var left = state.lastIntValue;
     if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {
@@ -22013,7 +20585,7 @@
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
 // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
-pp$1.regexp_eatClassAtom = function(state) {
+pp$8.regexp_eatClassAtom = function(state) {
   var start = state.pos;
 
   if (state.eat(0x5C /* \ */)) {
@@ -22042,7 +20614,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
-pp$1.regexp_eatClassEscape = function(state) {
+pp$8.regexp_eatClassEscape = function(state) {
   var start = state.pos;
 
   if (state.eat(0x62 /* b */)) {
@@ -22069,7 +20641,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
-pp$1.regexp_eatClassControlLetter = function(state) {
+pp$8.regexp_eatClassControlLetter = function(state) {
   var ch = state.current();
   if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
     state.lastIntValue = ch % 0x20;
@@ -22080,7 +20652,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
-pp$1.regexp_eatHexEscapeSequence = function(state) {
+pp$8.regexp_eatHexEscapeSequence = function(state) {
   var start = state.pos;
   if (state.eat(0x78 /* x */)) {
     if (this.regexp_eatFixedHexDigits(state, 2)) {
@@ -22095,7 +20667,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
-pp$1.regexp_eatDecimalDigits = function(state) {
+pp$8.regexp_eatDecimalDigits = function(state) {
   var start = state.pos;
   var ch = 0;
   state.lastIntValue = 0;
@@ -22110,7 +20682,7 @@
 }
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
-pp$1.regexp_eatHexDigits = function(state) {
+pp$8.regexp_eatHexDigits = function(state) {
   var start = state.pos;
   var ch = 0;
   state.lastIntValue = 0;
@@ -22139,7 +20711,7 @@
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
 // Allows only 0-377(octal) i.e. 0-255(decimal).
-pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
+pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
   if (this.regexp_eatOctalDigit(state)) {
     var n1 = state.lastIntValue;
     if (this.regexp_eatOctalDigit(state)) {
@@ -22158,7 +20730,7 @@
 };
 
 // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
-pp$1.regexp_eatOctalDigit = function(state) {
+pp$8.regexp_eatOctalDigit = function(state) {
   var ch = state.current();
   if (isOctalDigit(ch)) {
     state.lastIntValue = ch - 0x30; /* 0 */
@@ -22175,7 +20747,7 @@
 // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
 // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
 // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
-pp$1.regexp_eatFixedHexDigits = function(state, length) {
+pp$8.regexp_eatFixedHexDigits = function(state, length) {
   var start = state.pos;
   state.lastIntValue = 0;
   for (var i = 0; i < length; ++i) {
@@ -22207,11 +20779,11 @@
 
 // ## Tokenizer
 
-var pp = Parser.prototype;
+var pp$9 = Parser.prototype;
 
 // Move to the next token
 
-pp.next = function(ignoreEscapeSequenceInKeyword) {
+pp$9.next = function(ignoreEscapeSequenceInKeyword) {
   if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)
     { this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword); }
   if (this.options.onToken)
@@ -22224,21 +20796,21 @@
   this.nextToken();
 };
 
-pp.getToken = function() {
+pp$9.getToken = function() {
   this.next();
   return new Token(this)
 };
 
 // If we're in an ES6 environment, make parsers iterable
 if (typeof Symbol !== "undefined")
-  { pp[Symbol.iterator] = function() {
+  { pp$9[Symbol.iterator] = function() {
     var this$1$1 = this;
 
     return {
       next: function () {
         var token = this$1$1.getToken();
         return {
-          done: token.type === types$1.eof,
+          done: token.type === types.eof,
           value: token
         }
       }
@@ -22251,19 +20823,19 @@
 // Read a single token, updating the parser object's token-related
 // properties.
 
-pp.nextToken = function() {
+pp$9.nextToken = function() {
   var curContext = this.curContext();
   if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }
 
   this.start = this.pos;
   if (this.options.locations) { this.startLoc = this.curPosition(); }
-  if (this.pos >= this.input.length) { return this.finishToken(types$1.eof) }
+  if (this.pos >= this.input.length) { return this.finishToken(types.eof) }
 
   if (curContext.override) { return curContext.override(this) }
   else { this.readToken(this.fullCharCodeAtPos()); }
 };
 
-pp.readToken = function(code) {
+pp$9.readToken = function(code) {
   // Identifier or keyword. '\uXXXX' sequences are allowed in
   // identifiers, so '\' also dispatches to that.
   if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
@@ -22272,22 +20844,24 @@
   return this.getTokenFromCode(code)
 };
 
-pp.fullCharCodeAtPos = function() {
+pp$9.fullCharCodeAtPos = function() {
   var code = this.input.charCodeAt(this.pos);
   if (code <= 0xd7ff || code >= 0xdc00) { return code }
   var next = this.input.charCodeAt(this.pos + 1);
   return next <= 0xdbff || next >= 0xe000 ? code : (code << 10) + next - 0x35fdc00
 };
 
-pp.skipBlockComment = function() {
+pp$9.skipBlockComment = function() {
   var startLoc = this.options.onComment && this.curPosition();
   var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
   if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
   this.pos = end + 2;
   if (this.options.locations) {
-    for (var nextBreak = (void 0), pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;) {
+    lineBreakG.lastIndex = start;
+    var match;
+    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
       ++this.curLine;
-      pos = this.lineStart = nextBreak;
+      this.lineStart = match.index + match[0].length;
     }
   }
   if (this.options.onComment)
@@ -22295,7 +20869,7 @@
                            startLoc, this.curPosition()); }
 };
 
-pp.skipLineComment = function(startSkip) {
+pp$9.skipLineComment = function(startSkip) {
   var start = this.pos;
   var startLoc = this.options.onComment && this.curPosition();
   var ch = this.input.charCodeAt(this.pos += startSkip);
@@ -22310,7 +20884,7 @@
 // Called at the start of the parse and after every token. Skips
 // whitespace and comments, and.
 
-pp.skipSpace = function() {
+pp$9.skipSpace = function() {
   loop: while (this.pos < this.input.length) {
     var ch = this.input.charCodeAt(this.pos);
     switch (ch) {
@@ -22355,7 +20929,7 @@
 // the token, so that the next one's `start` will point at the
 // right position.
 
-pp.finishToken = function(type, val) {
+pp$9.finishToken = function(type, val) {
   this.end = this.pos;
   if (this.options.locations) { this.endLoc = this.curPosition(); }
   var prevType = this.type;
@@ -22374,62 +20948,62 @@
 //
 // All in the name of speed.
 //
-pp.readToken_dot = function() {
+pp$9.readToken_dot = function() {
   var next = this.input.charCodeAt(this.pos + 1);
   if (next >= 48 && next <= 57) { return this.readNumber(true) }
   var next2 = this.input.charCodeAt(this.pos + 2);
   if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
     this.pos += 3;
-    return this.finishToken(types$1.ellipsis)
+    return this.finishToken(types.ellipsis)
   } else {
     ++this.pos;
-    return this.finishToken(types$1.dot)
+    return this.finishToken(types.dot)
   }
 };
 
-pp.readToken_slash = function() { // '/'
+pp$9.readToken_slash = function() { // '/'
   var next = this.input.charCodeAt(this.pos + 1);
   if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
-  if (next === 61) { return this.finishOp(types$1.assign, 2) }
-  return this.finishOp(types$1.slash, 1)
+  if (next === 61) { return this.finishOp(types.assign, 2) }
+  return this.finishOp(types.slash, 1)
 };
 
-pp.readToken_mult_modulo_exp = function(code) { // '%*'
+pp$9.readToken_mult_modulo_exp = function(code) { // '%*'
   var next = this.input.charCodeAt(this.pos + 1);
   var size = 1;
-  var tokentype = code === 42 ? types$1.star : types$1.modulo;
+  var tokentype = code === 42 ? types.star : types.modulo;
 
   // exponentiation operator ** and **=
   if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
     ++size;
-    tokentype = types$1.starstar;
+    tokentype = types.starstar;
     next = this.input.charCodeAt(this.pos + 2);
   }
 
-  if (next === 61) { return this.finishOp(types$1.assign, size + 1) }
+  if (next === 61) { return this.finishOp(types.assign, size + 1) }
   return this.finishOp(tokentype, size)
 };
 
-pp.readToken_pipe_amp = function(code) { // '|&'
+pp$9.readToken_pipe_amp = function(code) { // '|&'
   var next = this.input.charCodeAt(this.pos + 1);
   if (next === code) {
     if (this.options.ecmaVersion >= 12) {
       var next2 = this.input.charCodeAt(this.pos + 2);
-      if (next2 === 61) { return this.finishOp(types$1.assign, 3) }
+      if (next2 === 61) { return this.finishOp(types.assign, 3) }
     }
-    return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2)
+    return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2)
   }
-  if (next === 61) { return this.finishOp(types$1.assign, 2) }
-  return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1)
+  if (next === 61) { return this.finishOp(types.assign, 2) }
+  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
 };
 
-pp.readToken_caret = function() { // '^'
+pp$9.readToken_caret = function() { // '^'
   var next = this.input.charCodeAt(this.pos + 1);
-  if (next === 61) { return this.finishOp(types$1.assign, 2) }
-  return this.finishOp(types$1.bitwiseXOR, 1)
+  if (next === 61) { return this.finishOp(types.assign, 2) }
+  return this.finishOp(types.bitwiseXOR, 1)
 };
 
-pp.readToken_plus_min = function(code) { // '+-'
+pp$9.readToken_plus_min = function(code) { // '+-'
   var next = this.input.charCodeAt(this.pos + 1);
   if (next === code) {
     if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
@@ -22439,19 +21013,19 @@
       this.skipSpace();
       return this.nextToken()
     }
-    return this.finishOp(types$1.incDec, 2)
+    return this.finishOp(types.incDec, 2)
   }
-  if (next === 61) { return this.finishOp(types$1.assign, 2) }
-  return this.finishOp(types$1.plusMin, 1)
+  if (next === 61) { return this.finishOp(types.assign, 2) }
+  return this.finishOp(types.plusMin, 1)
 };
 
-pp.readToken_lt_gt = function(code) { // '<>'
+pp$9.readToken_lt_gt = function(code) { // '<>'
   var next = this.input.charCodeAt(this.pos + 1);
   var size = 1;
   if (next === code) {
     size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
-    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types$1.assign, size + 1) }
-    return this.finishOp(types$1.bitShift, size)
+    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
+    return this.finishOp(types.bitShift, size)
   }
   if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
       this.input.charCodeAt(this.pos + 3) === 45) {
@@ -22461,53 +21035,53 @@
     return this.nextToken()
   }
   if (next === 61) { size = 2; }
-  return this.finishOp(types$1.relational, size)
+  return this.finishOp(types.relational, size)
 };
 
-pp.readToken_eq_excl = function(code) { // '=!'
+pp$9.readToken_eq_excl = function(code) { // '=!'
   var next = this.input.charCodeAt(this.pos + 1);
-  if (next === 61) { return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
+  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
   if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
     this.pos += 2;
-    return this.finishToken(types$1.arrow)
+    return this.finishToken(types.arrow)
   }
-  return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1)
+  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
 };
 
-pp.readToken_question = function() { // '?'
+pp$9.readToken_question = function() { // '?'
   var ecmaVersion = this.options.ecmaVersion;
   if (ecmaVersion >= 11) {
     var next = this.input.charCodeAt(this.pos + 1);
     if (next === 46) {
       var next2 = this.input.charCodeAt(this.pos + 2);
-      if (next2 < 48 || next2 > 57) { return this.finishOp(types$1.questionDot, 2) }
+      if (next2 < 48 || next2 > 57) { return this.finishOp(types.questionDot, 2) }
     }
     if (next === 63) {
       if (ecmaVersion >= 12) {
         var next2$1 = this.input.charCodeAt(this.pos + 2);
-        if (next2$1 === 61) { return this.finishOp(types$1.assign, 3) }
+        if (next2$1 === 61) { return this.finishOp(types.assign, 3) }
       }
-      return this.finishOp(types$1.coalesce, 2)
+      return this.finishOp(types.coalesce, 2)
     }
   }
-  return this.finishOp(types$1.question, 1)
+  return this.finishOp(types.question, 1)
 };
 
-pp.readToken_numberSign = function() { // '#'
+pp$9.readToken_numberSign = function() { // '#'
   var ecmaVersion = this.options.ecmaVersion;
   var code = 35; // '#'
   if (ecmaVersion >= 13) {
     ++this.pos;
     code = this.fullCharCodeAtPos();
     if (isIdentifierStart(code, true) || code === 92 /* '\' */) {
-      return this.finishToken(types$1.privateId, this.readWord1())
+      return this.finishToken(types.privateId, this.readWord1())
     }
   }
 
-  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
+  this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
 };
 
-pp.getTokenFromCode = function(code) {
+pp$9.getTokenFromCode = function(code) {
   switch (code) {
   // The interpretation of a dot depends on whether it is followed
   // by a digit or another two dots.
@@ -22515,20 +21089,20 @@
     return this.readToken_dot()
 
   // Punctuation tokens.
-  case 40: ++this.pos; return this.finishToken(types$1.parenL)
-  case 41: ++this.pos; return this.finishToken(types$1.parenR)
-  case 59: ++this.pos; return this.finishToken(types$1.semi)
-  case 44: ++this.pos; return this.finishToken(types$1.comma)
-  case 91: ++this.pos; return this.finishToken(types$1.bracketL)
-  case 93: ++this.pos; return this.finishToken(types$1.bracketR)
-  case 123: ++this.pos; return this.finishToken(types$1.braceL)
-  case 125: ++this.pos; return this.finishToken(types$1.braceR)
-  case 58: ++this.pos; return this.finishToken(types$1.colon)
+  case 40: ++this.pos; return this.finishToken(types.parenL)
+  case 41: ++this.pos; return this.finishToken(types.parenR)
+  case 59: ++this.pos; return this.finishToken(types.semi)
+  case 44: ++this.pos; return this.finishToken(types.comma)
+  case 91: ++this.pos; return this.finishToken(types.bracketL)
+  case 93: ++this.pos; return this.finishToken(types.bracketR)
+  case 123: ++this.pos; return this.finishToken(types.braceL)
+  case 125: ++this.pos; return this.finishToken(types.braceR)
+  case 58: ++this.pos; return this.finishToken(types.colon)
 
   case 96: // '`'
     if (this.options.ecmaVersion < 6) { break }
     ++this.pos;
-    return this.finishToken(types$1.backQuote)
+    return this.finishToken(types.backQuote)
 
   case 48: // '0'
     var next = this.input.charCodeAt(this.pos + 1);
@@ -22551,6 +21125,7 @@
   // often referred to. `finishOp` simply skips the amount of
   // characters it is given as second argument, and returns a token
   // of the type given by its first argument.
+
   case 47: // '/'
     return this.readToken_slash()
 
@@ -22576,22 +21151,22 @@
     return this.readToken_question()
 
   case 126: // '~'
-    return this.finishOp(types$1.prefix, 1)
+    return this.finishOp(types.prefix, 1)
 
   case 35: // '#'
     return this.readToken_numberSign()
   }
 
-  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
+  this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
 };
 
-pp.finishOp = function(type, size) {
+pp$9.finishOp = function(type, size) {
   var str = this.input.slice(this.pos, this.pos + size);
   this.pos += size;
   return this.finishToken(type, str)
 };
 
-pp.readRegexp = function() {
+pp$9.readRegexp = function() {
   var escaped, inClass, start = this.pos;
   for (;;) {
     if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
@@ -22626,14 +21201,14 @@
     // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
   }
 
-  return this.finishToken(types$1.regexp, {pattern: pattern, flags: flags, value: value})
+  return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})
 };
 
 // Read an integer in the given radix. Return null if zero digits
 // were read, the integer value otherwise. When `len` is given, this
 // will return `null` unless the integer has exactly `len` digits.
 
-pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
+pp$9.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
   // `len` is used for character escape sequences. In that case, disallow separators.
   var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;
 
@@ -22687,7 +21262,7 @@
   return BigInt(str.replace(/_/g, ""))
 }
 
-pp.readRadixNumber = function(radix) {
+pp$9.readRadixNumber = function(radix) {
   var start = this.pos;
   this.pos += 2; // 0x
   var val = this.readInt(radix);
@@ -22696,12 +21271,12 @@
     val = stringToBigInt(this.input.slice(start, this.pos));
     ++this.pos;
   } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
-  return this.finishToken(types$1.num, val)
+  return this.finishToken(types.num, val)
 };
 
 // Read an integer, octal integer, or floating-point number.
 
-pp.readNumber = function(startsWithDot) {
+pp$9.readNumber = function(startsWithDot) {
   var start = this.pos;
   if (!startsWithDot && this.readInt(10, undefined, true) === null) { this.raise(start, "Invalid number"); }
   var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
@@ -22711,7 +21286,7 @@
     var val$1 = stringToBigInt(this.input.slice(start, this.pos));
     ++this.pos;
     if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
-    return this.finishToken(types$1.num, val$1)
+    return this.finishToken(types.num, val$1)
   }
   if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
   if (next === 46 && !octal) { // '.'
@@ -22727,12 +21302,12 @@
   if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
 
   var val = stringToNumber(this.input.slice(start, this.pos), octal);
-  return this.finishToken(types$1.num, val)
+  return this.finishToken(types.num, val)
 };
 
 // Read a string value, interpreting backslash-escapes.
 
-pp.readCodePoint = function() {
+pp$9.readCodePoint = function() {
   var ch = this.input.charCodeAt(this.pos), code;
 
   if (ch === 123) { // '{'
@@ -22747,7 +21322,14 @@
   return code
 };
 
-pp.readString = function(quote) {
+function codePointToString$1(code) {
+  // UTF-16 Decoding
+  if (code <= 0xFFFF) { return String.fromCharCode(code) }
+  code -= 0x10000;
+  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
+}
+
+pp$9.readString = function(quote) {
   var out = "", chunkStart = ++this.pos;
   for (;;) {
     if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
@@ -22770,14 +21352,14 @@
     }
   }
   out += this.input.slice(chunkStart, this.pos++);
-  return this.finishToken(types$1.string, out)
+  return this.finishToken(types.string, out)
 };
 
 // Reads template string tokens.
 
 var INVALID_TEMPLATE_ESCAPE_ERROR = {};
 
-pp.tryReadTemplateToken = function() {
+pp$9.tryReadTemplateToken = function() {
   this.inTemplateElement = true;
   try {
     this.readTmplToken();
@@ -22792,7 +21374,7 @@
   this.inTemplateElement = false;
 };
 
-pp.invalidStringToken = function(position, message) {
+pp$9.invalidStringToken = function(position, message) {
   if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
     throw INVALID_TEMPLATE_ESCAPE_ERROR
   } else {
@@ -22800,23 +21382,23 @@
   }
 };
 
-pp.readTmplToken = function() {
+pp$9.readTmplToken = function() {
   var out = "", chunkStart = this.pos;
   for (;;) {
     if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
     var ch = this.input.charCodeAt(this.pos);
     if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'
-      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
+      if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
         if (ch === 36) {
           this.pos += 2;
-          return this.finishToken(types$1.dollarBraceL)
+          return this.finishToken(types.dollarBraceL)
         } else {
           ++this.pos;
-          return this.finishToken(types$1.backQuote)
+          return this.finishToken(types.backQuote)
         }
       }
       out += this.input.slice(chunkStart, this.pos);
-      return this.finishToken(types$1.template, out)
+      return this.finishToken(types.template, out)
     }
     if (ch === 92) { // '\'
       out += this.input.slice(chunkStart, this.pos);
@@ -22847,7 +21429,7 @@
 };
 
 // Reads a template token to search for the end, without validating any escape sequences
-pp.readInvalidTemplateToken = function() {
+pp$9.readInvalidTemplateToken = function() {
   for (; this.pos < this.input.length; this.pos++) {
     switch (this.input[this.pos]) {
     case "\\":
@@ -22858,10 +21440,10 @@
       if (this.input[this.pos + 1] !== "{") {
         break
       }
-
     // falls through
+
     case "`":
-      return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos))
+      return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))
 
     // no default
     }
@@ -22871,14 +21453,14 @@
 
 // Used to read escaped characters
 
-pp.readEscapedChar = function(inTemplate) {
+pp$9.readEscapedChar = function(inTemplate) {
   var ch = this.input.charCodeAt(++this.pos);
   ++this.pos;
   switch (ch) {
   case 110: return "\n" // 'n' -> '\n'
   case 114: return "\r" // 'r' -> '\r'
   case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
-  case 117: return codePointToString(this.readCodePoint()) // 'u'
+  case 117: return codePointToString$1(this.readCodePoint()) // 'u'
   case 116: return "\t" // 't' -> '\t'
   case 98: return "\b" // 'b' -> '\b'
   case 118: return "\u000b" // 'v' -> '\u000b'
@@ -22936,7 +21518,7 @@
 
 // Used to read character escape sequences ('\x', '\u', '\U').
 
-pp.readHexChar = function(len) {
+pp$9.readHexChar = function(len) {
   var codePos = this.pos;
   var n = this.readInt(16, len);
   if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
@@ -22949,7 +21531,7 @@
 // Incrementally adds only escaped chars, adding other chunks as-is
 // as a micro-optimization.
 
-pp.readWord1 = function() {
+pp$9.readWord1 = function() {
   this.containsEsc = false;
   var word = "", first = true, chunkStart = this.pos;
   var astral = this.options.ecmaVersion >= 6;
@@ -22967,7 +21549,7 @@
       var esc = this.readCodePoint();
       if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
         { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
-      word += codePointToString(esc);
+      word += codePointToString$1(esc);
       chunkStart = this.pos;
     } else {
       break
@@ -22980,18 +21562,18 @@
 // Read an identifier or keyword token. Will check for reserved
 // words when necessary.
 
-pp.readWord = function() {
+pp$9.readWord = function() {
   var word = this.readWord1();
-  var type = types$1.name;
+  var type = types.name;
   if (this.keywords.test(word)) {
-    type = keywords[word];
+    type = keywords$1[word];
   }
   return this.finishToken(type, word)
 };
 
 // Acorn is a tiny, fast JavaScript parser written in JavaScript.
 
-var version = "8.8.1";
+var version = "8.5.0";
 
 Parser.acorn = {
   Parser: Parser,
@@ -23002,10 +21584,10 @@
   getLineInfo: getLineInfo,
   Node: Node,
   TokenType: TokenType,
-  tokTypes: types$1,
-  keywordTypes: keywords,
+  tokTypes: types,
+  keywordTypes: keywords$1,
   TokContext: TokContext,
-  tokContexts: types,
+  tokContexts: types$1,
   isIdentifierChar: isIdentifierChar,
   isIdentifierStart: isIdentifierStart,
   Token: Token,
@@ -23015,103 +21597,70 @@
   nonASCIIwhitespace: nonASCIIwhitespace
 };
 
-// The main exported interface (under `self.acorn` when in the
-// browser) is a `parse` function that takes a code string and
-// returns an abstract syntax tree as specified by [Mozilla parser
-// API][api].
-//
-// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
-
-function parse(input, options) {
-  return Parser.parse(input, options)
-}
-
-// This function tries to parse a single expression at a given
-// offset in a string. Useful for parsing mixed-language formats
-// that embed JavaScript expressions.
-
-function parseExpressionAt(input, pos, options) {
-  return Parser.parseExpressionAt(input, pos, options)
+const readFile = (file) => new Promise((fulfil, reject) => fs.readFile(file, 'utf-8', (err, contents) => (err ? reject(err) : fulfil(contents))));
+function mkdirpath(path) {
+    const dir = path$2.dirname(path);
+    try {
+        fs.readdirSync(dir);
+    }
+    catch (_a) {
+        mkdirpath(dir);
+        try {
+            fs.mkdirSync(dir);
+        }
+        catch (err) {
+            if (err.code !== 'EEXIST') {
+                throw err;
+            }
+        }
+    }
 }
-
-// Acorn is organized as a tokenizer and a recursive-descent parser.
-// The `tokenizer` export provides an interface to the tokenizer.
-
-function tokenizer(input, options) {
-  return Parser.tokenizer(input, options)
+function writeFile(dest, data) {
+    return new Promise((fulfil, reject) => {
+        mkdirpath(dest);
+        fs.writeFile(dest, data, err => {
+            if (err) {
+                reject(err);
+            }
+            else {
+                fulfil();
+            }
+        });
+    });
 }
 
-const _acorn = /*#__PURE__*/Object.defineProperty({
-  __proto__: null,
-  Node,
-  Parser,
-  Position,
-  SourceLocation,
-  TokContext,
-  Token,
-  TokenType,
-  defaultOptions,
-  getLineInfo,
-  isIdentifierChar,
-  isIdentifierStart,
-  isNewLine,
-  keywordTypes: keywords,
-  lineBreak,
-  lineBreakG,
-  nonASCIIwhitespace,
-  parse,
-  parseExpressionAt,
-  tokContexts: types,
-  tokTypes: types$1,
-  tokenizer,
-  version
-}, Symbol.toStringTag, { value: 'Module' });
-
-function flru (max) {
-	var num, curr, prev;
-	var limit = max || 1;
-
-	function keep(key, value) {
-		if (++num > limit) {
-			prev = curr;
-			reset(1);
-			++num;
-		}
-		curr[key] = value;
-	}
-
-	function reset(isPartial) {
-		num = 0;
-		curr = Object.create(null);
-		isPartial || (prev=Object.create(null));
-	}
-
-	reset();
-
-	return {
-		clear: reset,
-		has: function (key) {
-			return curr[key] !== void 0 || prev[key] !== void 0;
-		},
-		get: function (key) {
-			var val = curr[key];
-			if (val !== void 0) return val;
-			if ((val=prev[key]) !== void 0) {
-				keep(key, val);
-				return val;
-			}
-		},
-		set: function (key, value) {
-			if (curr[key] !== void 0) {
-				curr[key] = value;
-			} else {
-				keep(key, value);
-			}
-		}
-	};
+class Queue {
+    constructor(maxParallel = 1) {
+        this.maxParallel = maxParallel;
+        this.queue = new Array();
+        this.workerCount = 0;
+    }
+    run(task) {
+        return new Promise((resolve, reject) => {
+            this.queue.push({ reject, resolve, task });
+            this.work();
+        });
+    }
+    async work() {
+        if (this.workerCount >= this.maxParallel)
+            return;
+        this.workerCount++;
+        let entry;
+        while ((entry = this.queue.shift())) {
+            const { reject, resolve, task } = entry;
+            try {
+                const result = await task();
+                resolve(result);
+            }
+            catch (err) {
+                reject(err);
+            }
+        }
+        this.workerCount--;
+    }
 }
 
-function resolveIdViaPlugins(source, importer, pluginDriver, moduleLoaderResolveId, skip, customOptions, isEntry, assertions) {
+function resolveIdViaPlugins(source, importer, pluginDriver, moduleLoaderResolveId, skip, customOptions, isEntry) {
     let skipped = null;
     let replaceContext = null;
     if (skip) {
@@ -23123,30 +21672,18 @@
         }
         replaceContext = (pluginContext, plugin) => ({
             ...pluginContext,
-            resolve: (source, importer, { assertions, custom, isEntry, skipSelf } = BLANK) => moduleLoaderResolveId(source, importer, custom, isEntry, assertions || EMPTY_OBJECT, skipSelf ? [...skip, { importer, plugin, source }] : skip)
+            resolve: (source, importer, { custom, isEntry, skipSelf } = BLANK) => {
+                return moduleLoaderResolveId(source, importer, custom, isEntry, skipSelf ? [...skip, { importer, plugin, source }] : skip);
+            }
         });
     }
-    return pluginDriver.hookFirstAndGetPlugin('resolveId', [source, importer, { assertions, custom: customOptions, isEntry }], replaceContext, skipped);
+    return pluginDriver.hookFirst('resolveId', [source, importer, { custom: customOptions, isEntry }], replaceContext, skipped);
 }
 
-async function resolveId(source, importer, preserveSymlinks, pluginDriver, moduleLoaderResolveId, skip, customOptions, isEntry, assertions) {
-    const pluginResult = await resolveIdViaPlugins(source, importer, pluginDriver, moduleLoaderResolveId, skip, customOptions, isEntry, assertions);
-    if (pluginResult != null) {
-        const [resolveIdResult, plugin] = pluginResult;
-        if (typeof resolveIdResult === 'object' && !resolveIdResult.resolvedBy) {
-            return {
-                ...resolveIdResult,
-                resolvedBy: plugin.name
-            };
-        }
-        if (typeof resolveIdResult === 'string') {
-            return {
-                id: resolveIdResult,
-                resolvedBy: plugin.name
-            };
-        }
-        return resolveIdResult;
-    }
+async function resolveId(source, importer, preserveSymlinks, pluginDriver, moduleLoaderResolveId, skip, customOptions, isEntry) {
+    const pluginResult = await resolveIdViaPlugins(source, importer, pluginDriver, moduleLoaderResolveId, skip, customOptions, isEntry);
+    if (pluginResult != null)
+        return pluginResult;
     // external modules (non-entry modules that start with neither '.' or '/')
     // are skipped at this stage.
     if (importer !== undefined && !isAbsolute(source) && source[0] !== '.')
@@ -23155,33 +21692,69 @@
     // absolute path is created. Absolute importees therefore shortcircuit the
     // resolve call and require no special handing on our part.
     // See https://nodejs.org/api/path.html#path_path_resolve_paths
-    return addJsExtensionIfNecessary(importer ? node_path.resolve(node_path.dirname(importer), source) : node_path.resolve(source), preserveSymlinks);
+    return addJsExtensionIfNecessary(importer ? path$2.resolve(path$2.dirname(importer), source) : path$2.resolve(source), preserveSymlinks);
 }
-async function addJsExtensionIfNecessary(file, preserveSymlinks) {
-    return ((await findFile(file, preserveSymlinks)) ??
-        (await findFile(file + '.mjs', preserveSymlinks)) ??
-        (await findFile(file + '.js', preserveSymlinks)));
+function addJsExtensionIfNecessary(file, preserveSymlinks) {
+    let found = findFile(file, preserveSymlinks);
+    if (found)
+        return found;
+    found = findFile(file + '.mjs', preserveSymlinks);
+    if (found)
+        return found;
+    found = findFile(file + '.js', preserveSymlinks);
+    return found;
 }
-async function findFile(file, preserveSymlinks) {
+function findFile(file, preserveSymlinks) {
     try {
-        const stats = await promises.lstat(file);
+        const stats = fs.lstatSync(file);
         if (!preserveSymlinks && stats.isSymbolicLink())
-            return await findFile(await promises.realpath(file), preserveSymlinks);
+            return findFile(fs.realpathSync(file), preserveSymlinks);
         if ((preserveSymlinks && stats.isSymbolicLink()) || stats.isFile()) {
             // check case
-            const name = node_path.basename(file);
-            const files = await promises.readdir(node_path.dirname(file));
-            if (files.includes(name))
+            const name = path$2.basename(file);
+            const files = fs.readdirSync(path$2.dirname(file));
+            if (files.indexOf(name) !== -1)
                 return file;
         }
     }
-    catch {
+    catch (_a) {
         // suppress
     }
 }
 
 const ANONYMOUS_PLUGIN_PREFIX = 'at position ';
 const ANONYMOUS_OUTPUT_PLUGIN_PREFIX = 'at output position ';
+function throwPluginError(err, plugin, { hook, id } = {}) {
+    if (typeof err === 'string')
+        err = { message: err };
+    if (err.code && err.code !== Errors.PLUGIN_ERROR) {
+        err.pluginCode = err.code;
+    }
+    err.code = Errors.PLUGIN_ERROR;
+    err.plugin = plugin;
+    if (hook) {
+        err.hook = hook;
+    }
+    if (id) {
+        err.id = id;
+    }
+    return error(err);
+}
+const deprecatedHooks = [
+    { active: true, deprecated: 'resolveAssetUrl', replacement: 'resolveFileUrl' }
+];
+function warnDeprecatedHooks(plugins, options) {
+    for (const { active, deprecated, replacement } of deprecatedHooks) {
+        for (const plugin of plugins) {
+            if (deprecated in plugin) {
+                warnDeprecation({
+                    message: `The "${deprecated}" hook used by plugin ${plugin.name} is deprecated. The "${replacement}" hook should be used instead.`,
+                    plugin: plugin.name
+                }, active, options);
+            }
+        }
+    }
+}
 
 function createPluginCache(cache) {
     return {
@@ -23191,7 +21764,7 @@
         get(id) {
             const item = cache[id];
             if (!item)
-                return;
+                return undefined;
             item[0] = 0;
             return item[1];
         },
@@ -23242,9 +21815,15 @@
 function uncacheablePluginError(pluginName) {
     if (pluginName.startsWith(ANONYMOUS_PLUGIN_PREFIX) ||
         pluginName.startsWith(ANONYMOUS_OUTPUT_PLUGIN_PREFIX)) {
-        return error(errorAnonymousPluginCache());
+        return error({
+            code: 'ANONYMOUS_PLUGIN_CACHE',
+            message: 'A plugin is trying to use the Rollup cache but is not declaring a plugin name or cacheKey.'
+        });
     }
-    return error(errorDuplicatePluginName(pluginName));
+    return error({
+        code: 'DUPLICATE_PLUGIN_NAME',
+        message: `The plugin name ${pluginName} is being used twice in the same build. Plugin names must be distinct or provide a cacheKey (please post an issue to the plugin if you are a plugin user).`
+    });
 }
 function getCacheForUncacheablePlugin(pluginName) {
     return {
@@ -23263,7 +21842,7 @@
     };
 }
 
-async function transform(source, module, pluginDriver, warn) {
+function transform(source, module, pluginDriver, warn) {
     const id = module.id;
     const sourcemapChain = [];
     let originalSourcemap = source.map === null ? null : decodedSourcemap(source.map);
@@ -23273,8 +21852,8 @@
     const emittedFiles = [];
     let customTransformCache = false;
     const useCustomTransformCache = () => (customTransformCache = true);
-    let pluginName = '';
-    const currentSource = source.code;
+    let curPlugin;
+    const curSource = source.code;
     function transformReducer(previousCode, result, plugin) {
         let code;
         let map;
@@ -23285,7 +21864,7 @@
             module.updateOptions(result);
             if (result.code == null) {
                 if (result.map || result.ast) {
-                    warn(errorNoTransformMapOrAstWithoutCode(plugin.name));
+                    warn(errNoTransformMapOrAstWithoutCode(plugin.name));
                 }
                 return previousCode;
             }
@@ -23304,81 +21883,92 @@
         }
         return code;
     }
-    let code;
-    try {
-        code = await pluginDriver.hookReduceArg0('transform', [currentSource, id], transformReducer, (pluginContext, plugin) => {
-            pluginName = plugin.name;
-            return {
-                ...pluginContext,
-                addWatchFile(id) {
-                    transformDependencies.push(id);
-                    pluginContext.addWatchFile(id);
-                },
-                cache: customTransformCache
-                    ? pluginContext.cache
-                    : getTrackedPluginCache(pluginContext.cache, useCustomTransformCache),
-                emitFile(emittedFile) {
-                    emittedFiles.push(emittedFile);
-                    return pluginDriver.emitFile(emittedFile);
-                },
-                error(error_, pos) {
-                    if (typeof error_ === 'string')
-                        error_ = { message: error_ };
-                    if (pos)
-                        augmentCodeLocation(error_, pos, currentSource, id);
-                    error_.id = id;
-                    error_.hook = 'transform';
-                    return pluginContext.error(error_);
-                },
-                getCombinedSourcemap() {
-                    const combinedMap = collapseSourcemap(id, originalCode, originalSourcemap, sourcemapChain, warn);
-                    if (!combinedMap) {
-                        const magicString = new MagicString(originalCode);
-                        return magicString.generateMap({ hires: true, includeContent: true, source: id });
-                    }
-                    if (originalSourcemap !== combinedMap) {
-                        originalSourcemap = combinedMap;
-                        sourcemapChain.length = 0;
-                    }
-                    return new SourceMap({
-                        ...combinedMap,
-                        file: null,
-                        sourcesContent: combinedMap.sourcesContent
-                    });
-                },
-                setAssetSource() {
-                    return this.error(errorInvalidSetAssetSourceCall());
-                },
-                warn(warning, pos) {
-                    if (typeof warning === 'string')
-                        warning = { message: warning };
-                    if (pos)
-                        augmentCodeLocation(warning, pos, currentSource, id);
-                    warning.id = id;
-                    warning.hook = 'transform';
-                    pluginContext.warn(warning);
-                }
-            };
-        });
-    }
-    catch (error_) {
-        return error(errorPluginError(error_, pluginName, { hook: 'transform', id }));
-    }
-    if (!customTransformCache && // files emitted by a transform hook need to be emitted again if the hook is skipped
-        emittedFiles.length > 0)
-        module.transformFiles = emittedFiles;
-    return {
-        ast,
-        code,
-        customTransformCache,
-        originalCode,
-        originalSourcemap,
-        sourcemapChain,
-        transformDependencies
-    };
+    return pluginDriver
+        .hookReduceArg0('transform', [curSource, id], transformReducer, (pluginContext, plugin) => {
+        curPlugin = plugin;
+        return {
+            ...pluginContext,
+            addWatchFile(id) {
+                transformDependencies.push(id);
+                pluginContext.addWatchFile(id);
+            },
+            cache: customTransformCache
+                ? pluginContext.cache
+                : getTrackedPluginCache(pluginContext.cache, useCustomTransformCache),
+            emitAsset(name, source) {
+                emittedFiles.push({ name, source, type: 'asset' });
+                return pluginContext.emitAsset(name, source);
+            },
+            emitChunk(id, options) {
+                emittedFiles.push({ id, name: options && options.name, type: 'chunk' });
+                return pluginContext.emitChunk(id, options);
+            },
+            emitFile(emittedFile) {
+                emittedFiles.push(emittedFile);
+                return pluginDriver.emitFile(emittedFile);
+            },
+            error(err, pos) {
+                if (typeof err === 'string')
+                    err = { message: err };
+                if (pos)
+                    augmentCodeLocation(err, pos, curSource, id);
+                err.id = id;
+                err.hook = 'transform';
+                return pluginContext.error(err);
+            },
+            getCombinedSourcemap() {
+                const combinedMap = collapseSourcemap(id, originalCode, originalSourcemap, sourcemapChain, warn);
+                if (!combinedMap) {
+                    const magicString = new MagicString$1(originalCode);
+                    return magicString.generateMap({ hires: true, includeContent: true, source: id });
+                }
+                if (originalSourcemap !== combinedMap) {
+                    originalSourcemap = combinedMap;
+                    sourcemapChain.length = 0;
+                }
+                return new SourceMap({
+                    ...combinedMap,
+                    file: null,
+                    sourcesContent: combinedMap.sourcesContent
+                });
+            },
+            setAssetSource() {
+                return this.error({
+                    code: 'INVALID_SETASSETSOURCE',
+                    message: `setAssetSource cannot be called in transform for caching reasons. Use emitFile with a source, or call setAssetSource in another hook.`
+                });
+            },
+            warn(warning, pos) {
+                if (typeof warning === 'string')
+                    warning = { message: warning };
+                if (pos)
+                    augmentCodeLocation(warning, pos, curSource, id);
+                warning.id = id;
+                warning.hook = 'transform';
+                pluginContext.warn(warning);
+            }
+        };
+    })
+        .catch(err => throwPluginError(err, curPlugin.name, { hook: 'transform', id }))
+        .then(code => {
+        if (!customTransformCache) {
+            // files emitted by a transform hook need to be emitted again if the hook is skipped
+            if (emittedFiles.length)
+                module.transformFiles = emittedFiles;
+        }
+        return {
+            ast,
+            code,
+            customTransformCache,
+            meta: module.info.meta,
+            originalCode,
+            originalSourcemap,
+            sourcemapChain,
+            transformDependencies
+        };
+    });
 }
 
-const RESOLVE_DEPENDENCIES = 'resolveDependencies';
 class ModuleLoader {
     constructor(graph, modulesById, options, pluginDriver) {
         this.graph = graph;
@@ -23388,16 +21978,17 @@
         this.implicitEntryModules = new Set();
         this.indexedEntryModules = [];
         this.latestLoadModulesPromise = Promise.resolve();
-        this.moduleLoadPromises = new Map();
-        this.modulesWithLoadedDependencies = new Set();
-        this.nextChunkNamePriority = 0;
         this.nextEntryModuleIndex = 0;
-        this.resolveId = async (source, importer, customOptions, isEntry, assertions, skip = null) => this.getResolvedIdWithDefaults(this.getNormalizedResolvedIdWithoutDefaults(this.options.external(source, importer, false)
-            ? false
-            : await resolveId(source, importer, this.options.preserveSymlinks, this.pluginDriver, this.resolveId, skip, customOptions, typeof isEntry === 'boolean' ? isEntry : !importer, assertions), importer, source), assertions);
+        this.readQueue = new Queue();
+        this.resolveId = async (source, importer, customOptions, isEntry, skip = null) => {
+            return this.addDefaultsToResolvedId(this.getNormalizedResolvedIdWithoutDefaults(this.options.external(source, importer, false)
+                ? false
+                : await resolveId(source, importer, this.options.preserveSymlinks, this.pluginDriver, this.resolveId, skip, customOptions, typeof isEntry === 'boolean' ? isEntry : !importer), importer, source));
+        };
         this.hasModuleSideEffects = options.treeshake
             ? options.treeshake.moduleSideEffects
             : () => true;
+        this.readQueue.maxParallel = options.maxParallelFileReads;
     }
     async addAdditionalModules(unresolvedModules) {
         const result = this.extendLoadModulesPromise(Promise.all(unresolvedModules.map(id => this.loadEntryModule(id, false, undefined, null))));
@@ -23407,23 +21998,21 @@
     async addEntryModules(unresolvedEntryModules, isUserDefined) {
         const firstEntryModuleIndex = this.nextEntryModuleIndex;
         this.nextEntryModuleIndex += unresolvedEntryModules.length;
-        const firstChunkNamePriority = this.nextChunkNamePriority;
-        this.nextChunkNamePriority += unresolvedEntryModules.length;
         const newEntryModules = await this.extendLoadModulesPromise(Promise.all(unresolvedEntryModules.map(({ id, importer }) => this.loadEntryModule(id, true, importer, null))).then(entryModules => {
-            for (const [index, entryModule] of entryModules.entries()) {
+            let moduleIndex = firstEntryModuleIndex;
+            for (let index = 0; index < entryModules.length; index++) {
+                const entryModule = entryModules[index];
                 entryModule.isUserDefinedEntryPoint =
                     entryModule.isUserDefinedEntryPoint || isUserDefined;
-                addChunkNamesToModule(entryModule, unresolvedEntryModules[index], isUserDefined, firstChunkNamePriority + index);
+                addChunkNamesToModule(entryModule, unresolvedEntryModules[index], isUserDefined);
                 const existingIndexedModule = this.indexedEntryModules.find(indexedModule => indexedModule.module === entryModule);
-                if (existingIndexedModule) {
-                    existingIndexedModule.index = Math.min(existingIndexedModule.index, firstEntryModuleIndex + index);
+                if (!existingIndexedModule) {
+                    this.indexedEntryModules.push({ index: moduleIndex, module: entryModule });
                 }
                 else {
-                    this.indexedEntryModules.push({
-                        index: firstEntryModuleIndex + index,
-                        module: entryModule
-                    });
+                    existingIndexedModule.index = Math.min(existingIndexedModule.index, moduleIndex);
                 }
+                moduleIndex++;
             }
             this.indexedEntryModules.sort(({ index: indexA }, { index: indexB }) => indexA > indexB ? 1 : -1);
             return entryModules;
@@ -23450,14 +22039,23 @@
         }
         return module;
     }
-    async preloadModule(resolvedId) {
-        const module = await this.fetchModule(this.getResolvedIdWithDefaults(resolvedId, EMPTY_OBJECT), undefined, false, resolvedId.resolveDependencies ? RESOLVE_DEPENDENCIES : true);
-        return module.info;
+    addDefaultsToResolvedId(resolvedId) {
+        var _a, _b;
+        if (!resolvedId) {
+            return null;
+        }
+        const external = resolvedId.external || false;
+        return {
+            external,
+            id: resolvedId.id,
+            meta: resolvedId.meta || EMPTY_OBJECT,
+            moduleSideEffects: (_a = resolvedId.moduleSideEffects) !== null && _a !== void 0 ? _a : this.hasModuleSideEffects(resolvedId.id, !!external),
+            syntheticNamedExports: (_b = resolvedId.syntheticNamedExports) !== null && _b !== void 0 ? _b : false
+        };
     }
     addEntryWithImplicitDependants(unresolvedModule, implicitlyLoadedAfter) {
-        const chunkNamePriority = this.nextChunkNamePriority++;
         return this.extendLoadModulesPromise(this.loadEntryModule(unresolvedModule.id, false, unresolvedModule.importer, null).then(async (entryModule) => {
-            addChunkNamesToModule(entryModule, unresolvedModule, false, chunkNamePriority);
+            addChunkNamesToModule(entryModule, unresolvedModule, false);
             if (!entryModule.info.isEntry) {
                 this.implicitEntryModules.add(entryModule);
                 const implicitlyLoadedAfterModules = await Promise.all(implicitlyLoadedAfter.map(id => this.loadEntryModule(id, false, unresolvedModule.importer, entryModule.id)));
@@ -23472,38 +22070,30 @@
         }));
     }
     async addModuleSource(id, importer, module) {
+        timeStart('load modules', 3);
         let source;
         try {
-            source = await this.graph.fileOperationQueue.run(async () => (await this.pluginDriver.hookFirst('load', [id])) ?? (await promises.readFile(id, 'utf8')));
+            source = await this.readQueue.run(async () => { var _a; return (_a = (await this.pluginDriver.hookFirst('load', [id]))) !== null && _a !== void 0 ? _a : (await readFile(id)); });
         }
-        catch (error_) {
-            let message = `Could not load ${id}`;
+        catch (err) {
+            timeEnd('load modules', 3);
+            let msg = `Could not load ${id}`;
             if (importer)
-                message += ` (imported by ${relativeId(importer)})`;
-            message += `: ${error_.message}`;
-            error_.message = message;
-            throw error_;
+                msg += ` (imported by ${relativeId(importer)})`;
+            msg += `: ${err.message}`;
+            err.message = msg;
+            throw err;
         }
+        timeEnd('load modules', 3);
         const sourceDescription = typeof source === 'string'
             ? { code: source }
-            : source != null && typeof source === 'object' && typeof source.code === 'string'
+            : typeof source === 'object' && typeof source.code === 'string'
                 ? source
-                : error(errorBadLoader(id));
+                : error(errBadLoader(id));
         const cachedModule = this.graph.cachedModules.get(id);
         if (cachedModule &&
             !cachedModule.customTransformCache &&
-            cachedModule.originalCode === sourceDescription.code &&
-            !(await this.pluginDriver.hookFirst('shouldTransformCachedModule', [
-                {
-                    ast: cachedModule.ast,
-                    code: cachedModule.code,
-                    id: cachedModule.id,
-                    meta: cachedModule.meta,
-                    moduleSideEffects: cachedModule.moduleSideEffects,
-                    resolvedSources: cachedModule.resolvedIds,
-                    syntheticNamedExports: cachedModule.syntheticNamedExports
-                }
-            ]))) {
+            cachedModule.originalCode === sourceDescription.code) {
             if (cachedModule.transformFiles) {
                 for (const emittedFile of cachedModule.transformFiles)
                     this.pluginDriver.emitFile(emittedFile);
@@ -23549,79 +22139,62 @@
             }
         }
     }
-    // If this is a preload, then this method always waits for the dependencies of
-    // the module to be resolved.
-    // Otherwise, if the module does not exist, it waits for the module and all
-    // its dependencies to be loaded.
-    // Otherwise, it returns immediately.
-    async fetchModule({ assertions, id, meta, moduleSideEffects, syntheticNamedExports }, importer, isEntry, isPreload) {
+    async fetchModule({ id, meta, moduleSideEffects, syntheticNamedExports }, importer, isEntry) {
         const existingModule = this.modulesById.get(id);
         if (existingModule instanceof Module) {
-            if (importer && doAssertionsDiffer(assertions, existingModule.info.assertions)) {
-                this.options.onwarn(errorInconsistentImportAssertions(existingModule.info.assertions, assertions, id, importer));
+            if (isEntry) {
+                existingModule.info.isEntry = true;
+                this.implicitEntryModules.delete(existingModule);
+                for (const dependant of existingModule.implicitlyLoadedAfter) {
+                    dependant.implicitlyLoadedBefore.delete(existingModule);
+                }
+                existingModule.implicitlyLoadedAfter.clear();
             }
-            await this.handleExistingModule(existingModule, isEntry, isPreload);
             return existingModule;
         }
-        const module = new Module(this.graph, id, this.options, isEntry, moduleSideEffects, syntheticNamedExports, meta, assertions);
+        const module = new Module(this.graph, id, this.options, isEntry, moduleSideEffects, syntheticNamedExports, meta);
         this.modulesById.set(id, module);
         this.graph.watchFiles[id] = true;
-        const loadPromise = this.addModuleSource(id, importer, module).then(() => [
-            this.getResolveStaticDependencyPromises(module),
-            this.getResolveDynamicImportPromises(module),
-            loadAndResolveDependenciesPromise
-        ]);
-        const loadAndResolveDependenciesPromise = waitForDependencyResolution(loadPromise).then(() => this.pluginDriver.hookParallel('moduleParsed', [module.info]));
-        loadAndResolveDependenciesPromise.catch(() => {
-            /* avoid unhandled promise rejections */
+        await this.addModuleSource(id, importer, module);
+        const resolveStaticDependencyPromises = this.getResolveStaticDependencyPromises(module);
+        const resolveDynamicImportPromises = this.getResolveDynamicImportPromises(module);
+        Promise.all([
+            ...resolveStaticDependencyPromises,
+            ...resolveDynamicImportPromises
+        ])
+            .then(() => this.pluginDriver.hookParallel('moduleParsed', [module.info]))
+            .catch(() => {
+            /* rejections thrown here are also handled within PluginDriver - they are safe to ignore */
         });
-        this.moduleLoadPromises.set(module, loadPromise);
-        const resolveDependencyPromises = await loadPromise;
-        if (!isPreload) {
-            await this.fetchModuleDependencies(module, ...resolveDependencyPromises);
-        }
-        else if (isPreload === RESOLVE_DEPENDENCIES) {
-            await loadAndResolveDependenciesPromise;
-        }
-        return module;
-    }
-    async fetchModuleDependencies(module, resolveStaticDependencyPromises, resolveDynamicDependencyPromises, loadAndResolveDependenciesPromise) {
-        if (this.modulesWithLoadedDependencies.has(module)) {
-            return;
-        }
-        this.modulesWithLoadedDependencies.add(module);
         await Promise.all([
             this.fetchStaticDependencies(module, resolveStaticDependencyPromises),
-            this.fetchDynamicDependencies(module, resolveDynamicDependencyPromises)
+            this.fetchDynamicDependencies(module, resolveDynamicImportPromises)
         ]);
         module.linkImports();
-        // To handle errors when resolving dependencies or in moduleParsed
-        await loadAndResolveDependenciesPromise;
+        return module;
     }
     fetchResolvedDependency(source, importer, resolvedId) {
         if (resolvedId.external) {
-            const { assertions, external, id, moduleSideEffects, meta } = resolvedId;
-            let externalModule = this.modulesById.get(id);
-            if (!externalModule) {
-                externalModule = new ExternalModule(this.options, id, moduleSideEffects, meta, external !== 'absolute' && isAbsolute(id), assertions);
-                this.modulesById.set(id, externalModule);
-            }
-            else if (!(externalModule instanceof ExternalModule)) {
-                return error(errorInternalIdCannotBeExternal(source, importer));
-            }
-            else if (doAssertionsDiffer(externalModule.info.assertions, assertions)) {
-                this.options.onwarn(errorInconsistentImportAssertions(externalModule.info.assertions, assertions, source, importer));
+            const { external, id, moduleSideEffects, meta } = resolvedId;
+            if (!this.modulesById.has(id)) {
+                this.modulesById.set(id, new ExternalModule(this.options, id, moduleSideEffects, meta, external !== 'absolute' && isAbsolute(id)));
+            }
+            const externalModule = this.modulesById.get(id);
+            if (!(externalModule instanceof ExternalModule)) {
+                return error(errInternalIdCannotBeExternal(source, importer));
             }
             return Promise.resolve(externalModule);
         }
-        return this.fetchModule(resolvedId, importer, false, false);
+        else {
+            return this.fetchModule(resolvedId, importer, false);
+        }
     }
     async fetchStaticDependencies(module, resolveStaticDependencyPromises) {
         for (const dependency of await Promise.all(resolveStaticDependencyPromises.map(resolveStaticDependencyPromise => resolveStaticDependencyPromise.then(([source, resolvedId]) => this.fetchResolvedDependency(source, module.id, resolvedId))))) {
             module.dependencies.add(dependency);
             dependency.importers.push(module.id);
         }
-        if (!this.options.treeshake || module.info.moduleSideEffects === 'no-treeshake') {
+        if (!this.options.treeshake || module.info.hasModuleSideEffects === 'no-treeshake') {
             for (const dependency of module.dependencies) {
                 if (dependency instanceof Module) {
                     dependency.importedFromNotTreeshaken = true;
@@ -23669,7 +22242,7 @@
         return module.dynamicImports.map(async (dynamicImport) => {
             const resolvedId = await this.resolveDynamicImport(module, typeof dynamicImport.argument === 'string'
                 ? dynamicImport.argument
-                : dynamicImport.argument.esTreeNode, module.id, getAssertionsFromImportExpression(dynamicImport.node));
+                : dynamicImport.argument.esTreeNode, module.id);
             if (resolvedId && typeof resolvedId === 'object') {
                 dynamicImport.id = resolvedId.id;
             }
@@ -23677,89 +22250,55 @@
         });
     }
     getResolveStaticDependencyPromises(module) {
-        // eslint-disable-next-line unicorn/prefer-spread
-        return Array.from(module.sourcesWithAssertions, async ([source, assertions]) => [
+        return Array.from(module.sources, async (source) => [
             source,
             (module.resolvedIds[source] =
                 module.resolvedIds[source] ||
-                    this.handleInvalidResolvedId(await this.resolveId(source, module.id, EMPTY_OBJECT, false, assertions), source, module.id, assertions))
+                    this.handleResolveId(await this.resolveId(source, module.id, EMPTY_OBJECT, false), source, module.id))
         ]);
     }
-    getResolvedIdWithDefaults(resolvedId, assertions) {
-        if (!resolvedId) {
-            return null;
-        }
-        const external = resolvedId.external || false;
-        return {
-            assertions: resolvedId.assertions || assertions,
-            external,
-            id: resolvedId.id,
-            meta: resolvedId.meta || {},
-            moduleSideEffects: resolvedId.moduleSideEffects ?? this.hasModuleSideEffects(resolvedId.id, !!external),
-            resolvedBy: resolvedId.resolvedBy ?? 'rollup',
-            syntheticNamedExports: resolvedId.syntheticNamedExports ?? false
-        };
-    }
-    async handleExistingModule(module, isEntry, isPreload) {
-        const loadPromise = this.moduleLoadPromises.get(module);
-        if (isPreload) {
-            return isPreload === RESOLVE_DEPENDENCIES
-                ? waitForDependencyResolution(loadPromise)
-                : loadPromise;
-        }
-        if (isEntry) {
-            module.info.isEntry = true;
-            this.implicitEntryModules.delete(module);
-            for (const dependant of module.implicitlyLoadedAfter) {
-                dependant.implicitlyLoadedBefore.delete(module);
-            }
-            module.implicitlyLoadedAfter.clear();
-        }
-        return this.fetchModuleDependencies(module, ...(await loadPromise));
-    }
-    handleInvalidResolvedId(resolvedId, source, importer, assertions) {
+    handleResolveId(resolvedId, source, importer) {
         if (resolvedId === null) {
             if (isRelative(source)) {
-                return error(errorUnresolvedImport(source, importer));
+                return error(errUnresolvedImport(source, importer));
             }
-            this.options.onwarn(errorUnresolvedImportTreatedAsExternal(source, importer));
+            this.options.onwarn(errUnresolvedImportTreatedAsExternal(source, importer));
             return {
-                assertions,
                 external: true,
                 id: source,
-                meta: {},
+                meta: EMPTY_OBJECT,
                 moduleSideEffects: this.hasModuleSideEffects(source, true),
-                resolvedBy: 'rollup',
                 syntheticNamedExports: false
             };
         }
-        else if (resolvedId.external && resolvedId.syntheticNamedExports) {
-            this.options.onwarn(errorExternalSyntheticExports(source, importer));
+        else {
+            if (resolvedId.external && resolvedId.syntheticNamedExports) {
+                this.options.onwarn(errExternalSyntheticExports(source, importer));
+            }
         }
         return resolvedId;
     }
     async loadEntryModule(unresolvedId, isEntry, importer, implicitlyLoadedBefore) {
-        const resolveIdResult = await resolveId(unresolvedId, importer, this.options.preserveSymlinks, this.pluginDriver, this.resolveId, null, EMPTY_OBJECT, true, EMPTY_OBJECT);
+        const resolveIdResult = await resolveId(unresolvedId, importer, this.options.preserveSymlinks, this.pluginDriver, this.resolveId, null, EMPTY_OBJECT, true);
         if (resolveIdResult == null) {
             return error(implicitlyLoadedBefore === null
-                ? errorUnresolvedEntry(unresolvedId)
-                : errorUnresolvedImplicitDependant(unresolvedId, implicitlyLoadedBefore));
+                ? errUnresolvedEntry(unresolvedId)
+                : errUnresolvedImplicitDependant(unresolvedId, implicitlyLoadedBefore));
         }
         if (resolveIdResult === false ||
             (typeof resolveIdResult === 'object' && resolveIdResult.external)) {
             return error(implicitlyLoadedBefore === null
-                ? errorEntryCannotBeExternal(unresolvedId)
-                : errorImplicitDependantCannotBeExternal(unresolvedId, implicitlyLoadedBefore));
+                ? errEntryCannotBeExternal(unresolvedId)
+                : errImplicitDependantCannotBeExternal(unresolvedId, implicitlyLoadedBefore));
         }
-        return this.fetchModule(this.getResolvedIdWithDefaults(typeof resolveIdResult === 'object'
+        return this.fetchModule(this.addDefaultsToResolvedId(typeof resolveIdResult === 'object'
             ? resolveIdResult
-            : { id: resolveIdResult }, EMPTY_OBJECT), undefined, isEntry, false);
+            : { id: resolveIdResult }), undefined, isEntry);
     }
-    async resolveDynamicImport(module, specifier, importer, assertions) {
+    async resolveDynamicImport(module, specifier, importer) {
         const resolution = await this.pluginDriver.hookFirst('resolveDynamicImport', [
             specifier,
-            importer,
-            { assertions }
+            importer
         ]);
         if (typeof specifier !== 'string') {
             if (typeof resolution === 'string') {
@@ -23768,38 +22307,38 @@
             if (!resolution) {
                 return null;
             }
-            return this.getResolvedIdWithDefaults(resolution, assertions);
+            return {
+                external: false,
+                moduleSideEffects: true,
+                ...resolution
+            };
         }
         if (resolution == null) {
-            const existingResolution = module.resolvedIds[specifier];
-            if (existingResolution) {
-                if (doAssertionsDiffer(existingResolution.assertions, assertions)) {
-                    this.options.onwarn(errorInconsistentImportAssertions(existingResolution.assertions, assertions, specifier, importer));
-                }
-                return existingResolution;
-            }
-            return (module.resolvedIds[specifier] = this.handleInvalidResolvedId(await this.resolveId(specifier, module.id, EMPTY_OBJECT, false, assertions), specifier, module.id, assertions));
+            return (module.resolvedIds[specifier] =
+                module.resolvedIds[specifier] ||
+                    this.handleResolveId(await this.resolveId(specifier, module.id, EMPTY_OBJECT, false), specifier, module.id));
         }
-        return this.handleInvalidResolvedId(this.getResolvedIdWithDefaults(this.getNormalizedResolvedIdWithoutDefaults(resolution, importer, specifier), assertions), specifier, importer, assertions);
+        return this.handleResolveId(this.addDefaultsToResolvedId(this.getNormalizedResolvedIdWithoutDefaults(resolution, importer, specifier)), specifier, importer);
     }
 }
 function normalizeRelativeExternalId(source, importer) {
     return isRelative(source)
         ? importer
-            ? node_path.resolve(importer, '..', source)
-            : node_path.resolve(source)
+            ? path$2.resolve(importer, '..', source)
+            : path$2.resolve(source)
         : source;
 }
-function addChunkNamesToModule(module, { fileName, name }, isUserDefined, priority) {
+function addChunkNamesToModule(module, { fileName, name }, isUserDefined) {
     if (fileName !== null) {
         module.chunkFileNames.add(fileName);
     }
     else if (name !== null) {
-        // Always keep chunkNames sorted by priority
-        let namePosition = 0;
-        while (module.chunkNames[namePosition]?.priority < priority)
-            namePosition++;
-        module.chunkNames.splice(namePosition, 0, { isUserDefined, name, priority });
+        if (module.chunkName === null) {
+            module.chunkName = name;
+        }
+        if (isUserDefined) {
+            module.userChunkNames.add(name);
+        }
     }
 }
 function isNotAbsoluteExternal(id, source, makeAbsoluteExternalsRelative) {
@@ -23807,10 +22346,6 @@
         (makeAbsoluteExternalsRelative === 'ifRelativeSource' && isRelative(source)) ||
         !isAbsolute(id));
 }
-async function waitForDependencyResolution(loadPromise) {
-    const [resolveStaticDependencyPromises, resolveDynamicImportPromises] = await loadPromise;
-    return Promise.all([...resolveStaticDependencyPromises, ...resolveDynamicImportPromises]);
-}
 
 class GlobalScope extends Scope$1 {
     constructor() {
@@ -23828,232 +22363,20 @@
     }
 }
 
-function getSourceHash(source) {
-    return createHash().update(source).digest('hex');
-}
-function generateAssetFileName(name, source, sourceHash, outputOptions, bundle) {
-    const emittedName = outputOptions.sanitizeFileName(name || 'asset');
-    return makeUnique(renderNamePattern(typeof outputOptions.assetFileNames === 'function'
-        ? outputOptions.assetFileNames({ name, source, type: 'asset' })
-        : outputOptions.assetFileNames, 'output.assetFileNames', {
-        ext: () => node_path.extname(emittedName).slice(1),
-        extname: () => node_path.extname(emittedName),
-        hash: size => sourceHash.slice(0, Math.max(0, size || defaultHashSize)),
-        name: () => emittedName.slice(0, Math.max(0, emittedName.length - node_path.extname(emittedName).length))
-    }), bundle);
-}
-function reserveFileNameInBundle(fileName, { bundle }, warn) {
-    if (bundle[lowercaseBundleKeys].has(fileName.toLowerCase())) {
-        warn(errorFileNameConflict(fileName));
-    }
-    else {
-        bundle[fileName] = FILE_PLACEHOLDER;
-    }
-}
-function hasValidType(emittedFile) {
-    return Boolean(emittedFile &&
-        (emittedFile.type === 'asset' ||
-            emittedFile.type === 'chunk'));
-}
-function hasValidName(emittedFile) {
-    const validatedName = emittedFile.fileName || emittedFile.name;
-    return !validatedName || (typeof validatedName === 'string' && !isPathFragment(validatedName));
-}
-function getValidSource(source, emittedFile, fileReferenceId) {
-    if (!(typeof source === 'string' || source instanceof Uint8Array)) {
-        const assetName = emittedFile.fileName || emittedFile.name || fileReferenceId;
-        return error(errorFailedValidation(`Could not set source for ${typeof assetName === 'string' ? `asset "${assetName}"` : 'unnamed asset'}, asset source needs to be a string, Uint8Array or Buffer.`));
-    }
-    return source;
-}
-function getAssetFileName(file, referenceId) {
-    if (typeof file.fileName !== 'string') {
-        return error(errorAssetNotFinalisedForFileName(file.name || referenceId));
-    }
-    return file.fileName;
-}
-function getChunkFileName(file, facadeChunkByModule) {
-    if (file.fileName) {
-        return file.fileName;
-    }
-    if (facadeChunkByModule) {
-        return facadeChunkByModule.get(file.module).getFileName();
-    }
-    return error(errorChunkNotGeneratedForFileName(file.fileName || file.name));
-}
-class FileEmitter {
-    constructor(graph, options, baseFileEmitter) {
-        this.graph = graph;
-        this.options = options;
-        this.facadeChunkByModule = null;
-        this.nextIdBase = 1;
-        this.output = null;
-        this.outputFileEmitters = [];
-        this.emitFile = (emittedFile) => {
-            if (!hasValidType(emittedFile)) {
-                return error(errorFailedValidation(`Emitted files must be of type "asset" or "chunk", received "${emittedFile && emittedFile.type}".`));
-            }
-            if (!hasValidName(emittedFile)) {
-                return error(errorFailedValidation(`The "fileName" or "name" properties of emitted files must be strings that are neither absolute nor relative paths, received "${emittedFile.fileName || emittedFile.name}".`));
-            }
-            if (emittedFile.type === 'chunk') {
-                return this.emitChunk(emittedFile);
-            }
-            return this.emitAsset(emittedFile);
-        };
-        this.finaliseAssets = () => {
-            for (const [referenceId, emittedFile] of this.filesByReferenceId) {
-                if (emittedFile.type === 'asset' && typeof emittedFile.fileName !== 'string')
-                    return error(errorNoAssetSourceSet(emittedFile.name || referenceId));
-            }
-        };
-        this.getFileName = (fileReferenceId) => {
-            const emittedFile = this.filesByReferenceId.get(fileReferenceId);
-            if (!emittedFile)
-                return error(errorFileReferenceIdNotFoundForFilename(fileReferenceId));
-            if (emittedFile.type === 'chunk') {
-                return getChunkFileName(emittedFile, this.facadeChunkByModule);
-            }
-            return getAssetFileName(emittedFile, fileReferenceId);
-        };
-        this.setAssetSource = (referenceId, requestedSource) => {
-            const consumedFile = this.filesByReferenceId.get(referenceId);
-            if (!consumedFile)
-                return error(errorAssetReferenceIdNotFoundForSetSource(referenceId));
-            if (consumedFile.type !== 'asset') {
-                return error(errorFailedValidation(`Asset sources can only be set for emitted assets but "${referenceId}" is an emitted chunk.`));
-            }
-            if (consumedFile.source !== undefined) {
-                return error(errorAssetSourceAlreadySet(consumedFile.name || referenceId));
-            }
-            const source = getValidSource(requestedSource, consumedFile, referenceId);
-            if (this.output) {
-                this.finalizeAsset(consumedFile, source, referenceId, this.output);
-            }
-            else {
-                consumedFile.source = source;
-                for (const emitter of this.outputFileEmitters) {
-                    emitter.finalizeAsset(consumedFile, source, referenceId, emitter.output);
-                }
-            }
-        };
-        this.setChunkInformation = (facadeChunkByModule) => {
-            this.facadeChunkByModule = facadeChunkByModule;
-        };
-        this.setOutputBundle = (bundle, outputOptions) => {
-            const output = (this.output = {
-                bundle,
-                fileNamesBySource: new Map(),
-                outputOptions
-            });
-            for (const emittedFile of this.filesByReferenceId.values()) {
-                if (emittedFile.fileName) {
-                    reserveFileNameInBundle(emittedFile.fileName, output, this.options.onwarn);
-                }
-            }
-            for (const [referenceId, consumedFile] of this.filesByReferenceId) {
-                if (consumedFile.type === 'asset' && consumedFile.source !== undefined) {
-                    this.finalizeAsset(consumedFile, consumedFile.source, referenceId, output);
-                }
-            }
-        };
-        this.filesByReferenceId = baseFileEmitter
-            ? new Map(baseFileEmitter.filesByReferenceId)
-            : new Map();
-        baseFileEmitter?.addOutputFileEmitter(this);
-    }
-    addOutputFileEmitter(outputFileEmitter) {
-        this.outputFileEmitters.push(outputFileEmitter);
-    }
-    assignReferenceId(file, idBase) {
-        let referenceId = idBase;
-        do {
-            referenceId = createHash().update(referenceId).digest('hex').slice(0, 8);
-        } while (this.filesByReferenceId.has(referenceId) ||
-            this.outputFileEmitters.some(({ filesByReferenceId }) => filesByReferenceId.has(referenceId)));
-        this.filesByReferenceId.set(referenceId, file);
-        for (const { filesByReferenceId } of this.outputFileEmitters) {
-            filesByReferenceId.set(referenceId, file);
-        }
-        return referenceId;
-    }
-    emitAsset(emittedAsset) {
-        const source = emittedAsset.source === undefined
-            ? undefined
-            : getValidSource(emittedAsset.source, emittedAsset, null);
-        const consumedAsset = {
-            fileName: emittedAsset.fileName,
-            name: emittedAsset.name,
-            needsCodeReference: !!emittedAsset.needsCodeReference,
-            source,
-            type: 'asset'
-        };
-        const referenceId = this.assignReferenceId(consumedAsset, emittedAsset.fileName || emittedAsset.name || String(this.nextIdBase++));
-        if (this.output) {
-            this.emitAssetWithReferenceId(consumedAsset, referenceId, this.output);
-        }
-        else {
-            for (const fileEmitter of this.outputFileEmitters) {
-                fileEmitter.emitAssetWithReferenceId(consumedAsset, referenceId, fileEmitter.output);
-            }
-        }
-        return referenceId;
-    }
-    emitAssetWithReferenceId(consumedAsset, referenceId, output) {
-        const { fileName, source } = consumedAsset;
-        if (fileName) {
-            reserveFileNameInBundle(fileName, output, this.options.onwarn);
-        }
-        if (source !== undefined) {
-            this.finalizeAsset(consumedAsset, source, referenceId, output);
-        }
-    }
-    emitChunk(emittedChunk) {
-        if (this.graph.phase > BuildPhase.LOAD_AND_PARSE) {
-            return error(errorInvalidRollupPhaseForChunkEmission());
-        }
-        if (typeof emittedChunk.id !== 'string') {
-            return error(errorFailedValidation(`Emitted chunks need to have a valid string id, received "${emittedChunk.id}"`));
-        }
-        const consumedChunk = {
-            fileName: emittedChunk.fileName,
-            module: null,
-            name: emittedChunk.name || emittedChunk.id,
-            type: 'chunk'
-        };
-        this.graph.moduleLoader
-            .emitChunk(emittedChunk)
-            .then(module => (consumedChunk.module = module))
-            .catch(() => {
-            // Avoid unhandled Promise rejection as the error will be thrown later
-            // once module loading has finished
-        });
-        return this.assignReferenceId(consumedChunk, emittedChunk.id);
-    }
-    finalizeAsset(consumedFile, source, referenceId, { bundle, fileNamesBySource, outputOptions }) {
-        let fileName = consumedFile.fileName;
-        // Deduplicate assets if an explicit fileName is not provided
-        if (!fileName) {
-            const sourceHash = getSourceHash(source);
-            fileName = fileNamesBySource.get(sourceHash);
-            if (!fileName) {
-                fileName = generateAssetFileName(consumedFile.name, source, sourceHash, outputOptions, bundle);
-                fileNamesBySource.set(sourceHash, fileName);
-            }
+// eslint-disable-next-line @typescript-eslint/ban-types
+function getDeprecatedContextHandler(handler, handlerName, newHandlerName, pluginName, activeDeprecation, options) {
+    let deprecationWarningShown = false;
+    return ((...args) => {
+        if (!deprecationWarningShown) {
+            deprecationWarningShown = true;
+            warnDeprecation({
+                message: `The "this.${handlerName}" plugin context function used by plugin ${pluginName} is deprecated. The "this.${newHandlerName}" plugin context function should be used instead.`,
+                plugin: pluginName
+            }, activeDeprecation, options);
         }
-        // We must not modify the original assets to avoid interaction between outputs
-        const assetWithFileName = { ...consumedFile, fileName, source };
-        this.filesByReferenceId.set(referenceId, assetWithFileName);
-        bundle[fileName] = {
-            fileName,
-            name: consumedFile.name,
-            needsCodeReference: consumedFile.needsCodeReference,
-            source,
-            type: 'asset'
-        };
-    }
+        return handler(...args);
+    });
 }
-
 function getPluginContext(plugin, pluginCache, graph, options, fileEmitter, existingPluginNames) {
     let cacheable = true;
     if (typeof plugin.cacheKey !== 'string') {
@@ -24077,42 +22400,49 @@
     else {
         cacheInstance = getCacheForUncacheablePlugin(plugin.name);
     }
-    return {
+    const context = {
         addWatchFile(id) {
             if (graph.phase >= BuildPhase.GENERATE) {
-                return this.error(errorInvalidRollupPhaseForAddWatchFile());
+                return this.error(errInvalidRollupPhaseForAddWatchFile());
             }
             graph.watchFiles[id] = true;
         },
         cache: cacheInstance,
+        emitAsset: getDeprecatedContextHandler((name, source) => fileEmitter.emitFile({ name, source, type: 'asset' }), 'emitAsset', 'emitFile', plugin.name, true, options),
+        emitChunk: getDeprecatedContextHandler((id, options) => fileEmitter.emitFile({ id, name: options && options.name, type: 'chunk' }), 'emitChunk', 'emitFile', plugin.name, true, options),
         emitFile: fileEmitter.emitFile.bind(fileEmitter),
-        error(error_) {
-            return error(errorPluginError(error_, plugin.name));
+        error(err) {
+            return throwPluginError(err, plugin.name);
         },
+        getAssetFileName: getDeprecatedContextHandler(fileEmitter.getFileName, 'getAssetFileName', 'getFileName', plugin.name, true, options),
+        getChunkFileName: getDeprecatedContextHandler(fileEmitter.getFileName, 'getChunkFileName', 'getFileName', plugin.name, true, options),
         getFileName: fileEmitter.getFileName,
         getModuleIds: () => graph.modulesById.keys(),
         getModuleInfo: graph.getModuleInfo,
         getWatchFiles: () => Object.keys(graph.watchFiles),
-        load(resolvedId) {
-            return graph.moduleLoader.preloadModule(resolvedId);
-        },
+        isExternal: getDeprecatedContextHandler((id, parentId, isResolved = false) => options.external(id, parentId, isResolved), 'isExternal', 'resolve', plugin.name, true, options),
         meta: {
             rollupVersion: version$1,
             watchMode: graph.watchMode
         },
         get moduleIds() {
             function* wrappedModuleIds() {
-                // We are wrapping this in a generator to only show the message once we are actually iterating
-                warnDeprecation(`Accessing "this.moduleIds" on the plugin context by plugin ${plugin.name} is deprecated. The "this.getModuleIds" plugin context function should be used instead.`, URL_THIS_GETMODULEIDS, true, options, plugin.name);
+                warnDeprecation({
+                    message: `Accessing "this.moduleIds" on the plugin context by plugin ${plugin.name} is deprecated. The "this.getModuleIds" plugin context function should be used instead.`,
+                    plugin: plugin.name
+                }, false, options);
                 yield* moduleIds;
             }
             const moduleIds = graph.modulesById.keys();
             return wrappedModuleIds();
         },
         parse: graph.contextParse.bind(graph),
-        resolve(source, importer, { assertions, custom, isEntry, skipSelf } = BLANK) {
-            return graph.moduleLoader.resolveId(source, importer, custom, isEntry, assertions || EMPTY_OBJECT, skipSelf ? [{ importer, plugin, source }] : null);
+        resolve(source, importer, { custom, isEntry, skipSelf } = BLANK) {
+            return graph.moduleLoader.resolveId(source, importer, custom, isEntry, skipSelf ? [{ importer, plugin, source }] : null);
         },
+        resolveId: getDeprecatedContextHandler((source, importer) => graph.moduleLoader
+            .resolveId(source, importer, BLANK, undefined)
+            .then(resolveId => resolveId && resolveId.id), 'resolveId', 'resolve', plugin.name, true, options),
         setAssetSource: fileEmitter.setAssetSource,
         warn(warning) {
             if (typeof warning === 'string')
@@ -24124,9 +22454,9 @@
             options.onwarn(warning);
         }
     };
+    return context;
 }
 
-// This will make sure no input hook is omitted
 const inputHookNames = {
     buildEnd: 1,
     buildStart: 1,
@@ -24137,35 +22467,38 @@
     options: 1,
     resolveDynamicImport: 1,
     resolveId: 1,
-    shouldTransformCachedModule: 1,
     transform: 1,
     watchChange: 1
 };
 const inputHooks = Object.keys(inputHookNames);
+function throwInvalidHookError(hookName, pluginName) {
+    return error({
+        code: 'INVALID_PLUGIN_HOOK',
+        message: `Error running plugin hook ${hookName} for ${pluginName}, expected a function hook.`
+    });
+}
 class PluginDriver {
     constructor(graph, options, userPlugins, pluginCache, basePluginDriver) {
         this.graph = graph;
         this.options = options;
+        this.pluginContexts = new Map();
+        warnDeprecatedHooks(userPlugins, options);
         this.pluginCache = pluginCache;
-        this.sortedPlugins = new Map();
-        this.unfulfilledActions = new Set();
         this.fileEmitter = new FileEmitter(graph, options, basePluginDriver && basePluginDriver.fileEmitter);
         this.emitFile = this.fileEmitter.emitFile.bind(this.fileEmitter);
         this.getFileName = this.fileEmitter.getFileName.bind(this.fileEmitter);
-        this.finaliseAssets = this.fileEmitter.finaliseAssets.bind(this.fileEmitter);
-        this.setChunkInformation = this.fileEmitter.setChunkInformation.bind(this.fileEmitter);
+        this.finaliseAssets = this.fileEmitter.assertAssetsFinalized.bind(this.fileEmitter);
         this.setOutputBundle = this.fileEmitter.setOutputBundle.bind(this.fileEmitter);
-        this.plugins = [...(basePluginDriver ? basePluginDriver.plugins : []), ...userPlugins];
+        this.plugins = userPlugins.concat(basePluginDriver ? basePluginDriver.plugins : []);
         const existingPluginNames = new Set();
-        this.pluginContexts = new Map(this.plugins.map(plugin => [
-            plugin,
-            getPluginContext(plugin, pluginCache, graph, options, this.fileEmitter, existingPluginNames)
-        ]));
+        for (const plugin of this.plugins) {
+            this.pluginContexts.set(plugin, getPluginContext(plugin, pluginCache, graph, options, this.fileEmitter, existingPluginNames));
+        }
         if (basePluginDriver) {
             for (const plugin of userPlugins) {
                 for (const hook of inputHooks) {
                     if (hook in plugin) {
-                        options.onwarn(errorInputHookInOutputPlugin(plugin.name, hook));
+                        options.onwarn(errInputHookInOutputPlugin(plugin.name, hook));
                     }
                 }
             }
@@ -24174,236 +22507,146 @@
     createOutputPluginDriver(plugins) {
         return new PluginDriver(this.graph, this.options, plugins, this.pluginCache, this);
     }
-    getUnfulfilledHookActions() {
-        return this.unfulfilledActions;
-    }
     // chains, first non-null result stops and returns
-    hookFirst(hookName, parameters, replaceContext, skipped) {
-        return this.hookFirstAndGetPlugin(hookName, parameters, replaceContext, skipped).then(result => result && result[0]);
-    }
-    // chains, first non-null result stops and returns result and last plugin
-    async hookFirstAndGetPlugin(hookName, parameters, replaceContext, skipped) {
-        for (const plugin of this.getSortedPlugins(hookName)) {
-            if (skipped?.has(plugin))
+    hookFirst(hookName, args, replaceContext, skipped) {
+        let promise = Promise.resolve(undefined);
+        for (const plugin of this.plugins) {
+            if (skipped && skipped.has(plugin))
                 continue;
-            const result = await this.runHook(hookName, parameters, plugin, replaceContext);
-            if (result != null)
-                return [result, plugin];
+            promise = promise.then(result => {
+                if (result != null)
+                    return result;
+                return this.runHook(hookName, args, plugin, false, replaceContext);
+            });
         }
-        return null;
+        return promise;
     }
     // chains synchronously, first non-null result stops and returns
-    hookFirstSync(hookName, parameters, replaceContext) {
-        for (const plugin of this.getSortedPlugins(hookName)) {
-            const result = this.runHookSync(hookName, parameters, plugin, replaceContext);
+    hookFirstSync(hookName, args, replaceContext) {
+        for (const plugin of this.plugins) {
+            const result = this.runHookSync(hookName, args, plugin, replaceContext);
             if (result != null)
                 return result;
         }
         return null;
     }
     // parallel, ignores returns
-    async hookParallel(hookName, parameters, replaceContext) {
-        const parallelPromises = [];
-        for (const plugin of this.getSortedPlugins(hookName)) {
-            if (plugin[hookName].sequential) {
-                await Promise.all(parallelPromises);
-                parallelPromises.length = 0;
-                await this.runHook(hookName, parameters, plugin, replaceContext);
-            }
-            else {
-                parallelPromises.push(this.runHook(hookName, parameters, plugin, replaceContext));
-            }
+    hookParallel(hookName, args, replaceContext) {
+        const promises = [];
+        for (const plugin of this.plugins) {
+            const hookPromise = this.runHook(hookName, args, plugin, false, replaceContext);
+            if (!hookPromise)
+                continue;
+            promises.push(hookPromise);
         }
-        await Promise.all(parallelPromises);
+        return Promise.all(promises).then(() => { });
     }
     // chains, reduces returned value, handling the reduced value as the first hook argument
-    hookReduceArg0(hookName, [argument0, ...rest], reduce, replaceContext) {
-        let promise = Promise.resolve(argument0);
-        for (const plugin of this.getSortedPlugins(hookName)) {
-            promise = promise.then(argument0 => this.runHook(hookName, [argument0, ...rest], plugin, replaceContext).then(result => reduce.call(this.pluginContexts.get(plugin), argument0, result, plugin)));
+    hookReduceArg0(hookName, [arg0, ...rest], reduce, replaceContext) {
+        let promise = Promise.resolve(arg0);
+        for (const plugin of this.plugins) {
+            promise = promise.then(arg0 => {
+                const args = [arg0, ...rest];
+                const hookPromise = this.runHook(hookName, args, plugin, false, replaceContext);
+                if (!hookPromise)
+                    return arg0;
+                return hookPromise.then(result => reduce.call(this.pluginContexts.get(plugin), arg0, result, plugin));
+            });
         }
         return promise;
     }
     // chains synchronously, reduces returned value, handling the reduced value as the first hook argument
-    hookReduceArg0Sync(hookName, [argument0, ...rest], reduce, replaceContext) {
-        for (const plugin of this.getSortedPlugins(hookName)) {
-            const parameters = [argument0, ...rest];
-            const result = this.runHookSync(hookName, parameters, plugin, replaceContext);
-            argument0 = reduce.call(this.pluginContexts.get(plugin), argument0, result, plugin);
-        }
-        return argument0;
-    }
-    // chains, reduces returned value to type string, handling the reduced value separately. permits hooks as values.
-    async hookReduceValue(hookName, initialValue, parameters, reducer) {
-        const results = [];
-        const parallelResults = [];
-        for (const plugin of this.getSortedPlugins(hookName, validateAddonPluginHandler)) {
-            if (plugin[hookName].sequential) {
-                results.push(...(await Promise.all(parallelResults)));
-                parallelResults.length = 0;
-                results.push(await this.runHook(hookName, parameters, plugin));
-            }
-            else {
-                parallelResults.push(this.runHook(hookName, parameters, plugin));
-            }
+    hookReduceArg0Sync(hookName, [arg0, ...rest], reduce, replaceContext) {
+        for (const plugin of this.plugins) {
+            const args = [arg0, ...rest];
+            const result = this.runHookSync(hookName, args, plugin, replaceContext);
+            arg0 = reduce.call(this.pluginContexts.get(plugin), arg0, result, plugin);
+        }
+        return arg0;
+    }
+    // chains, reduces returned value to type T, handling the reduced value separately. permits hooks as values.
+    hookReduceValue(hookName, initialValue, args, reduce, replaceContext) {
+        let promise = Promise.resolve(initialValue);
+        for (const plugin of this.plugins) {
+            promise = promise.then(value => {
+                const hookPromise = this.runHook(hookName, args, plugin, true, replaceContext);
+                if (!hookPromise)
+                    return value;
+                return hookPromise.then(result => reduce.call(this.pluginContexts.get(plugin), value, result, plugin));
+            });
         }
-        results.push(...(await Promise.all(parallelResults)));
-        return results.reduce(reducer, await initialValue);
+        return promise;
     }
     // chains synchronously, reduces returned value to type T, handling the reduced value separately. permits hooks as values.
-    hookReduceValueSync(hookName, initialValue, parameters, reduce, replaceContext) {
-        let accumulator = initialValue;
-        for (const plugin of this.getSortedPlugins(hookName)) {
-            const result = this.runHookSync(hookName, parameters, plugin, replaceContext);
-            accumulator = reduce.call(this.pluginContexts.get(plugin), accumulator, result, plugin);
+    hookReduceValueSync(hookName, initialValue, args, reduce, replaceContext) {
+        let acc = initialValue;
+        for (const plugin of this.plugins) {
+            const result = this.runHookSync(hookName, args, plugin, replaceContext);
+            acc = reduce.call(this.pluginContexts.get(plugin), acc, result, plugin);
         }
-        return accumulator;
+        return acc;
     }
     // chains, ignores returns
-    hookSeq(hookName, parameters, replaceContext) {
+    hookSeq(hookName, args, replaceContext) {
         let promise = Promise.resolve();
-        for (const plugin of this.getSortedPlugins(hookName)) {
-            promise = promise.then(() => this.runHook(hookName, parameters, plugin, replaceContext));
+        for (const plugin of this.plugins) {
+            promise = promise.then(() => this.runHook(hookName, args, plugin, false, replaceContext));
         }
-        return promise.then(noReturn);
+        return promise;
     }
-    getSortedPlugins(hookName, validateHandler) {
-        return getOrCreate(this.sortedPlugins, hookName, () => getSortedValidatedPlugins(hookName, this.plugins, validateHandler));
+    // chains synchronously, ignores returns
+    hookSeqSync(hookName, args, replaceContext) {
+        for (const plugin of this.plugins) {
+            this.runHookSync(hookName, args, plugin, replaceContext);
+        }
     }
-    // Implementation signature
-    runHook(hookName, parameters, plugin, replaceContext) {
-        // We always filter for plugins that support the hook before running it
+    runHook(hookName, args, plugin, permitValues, hookContext) {
         const hook = plugin[hookName];
-        const handler = typeof hook === 'object' ? hook.handler : hook;
+        if (!hook)
+            return undefined;
         let context = this.pluginContexts.get(plugin);
-        if (replaceContext) {
-            context = replaceContext(context, plugin);
+        if (hookContext) {
+            context = hookContext(context, plugin);
         }
-        let action = null;
         return Promise.resolve()
             .then(() => {
-            if (typeof handler !== 'function') {
-                return handler;
+            // permit values allows values to be returned instead of a functional hook
+            if (typeof hook !== 'function') {
+                if (permitValues)
+                    return hook;
+                return throwInvalidHookError(hookName, plugin.name);
             }
             // eslint-disable-next-line @typescript-eslint/ban-types
-            const hookResult = handler.apply(context, parameters);
-            if (!hookResult?.then) {
-                // short circuit for non-thenables and non-Promises
-                return hookResult;
-            }
-            // Track pending hook actions to properly error out when
-            // unfulfilled promises cause rollup to abruptly and confusingly
-            // exit with a successful 0 return code but without producing any
-            // output, errors or warnings.
-            action = [plugin.name, hookName, parameters];
-            this.unfulfilledActions.add(action);
-            // Although it would be more elegant to just return hookResult here
-            // and put the .then() handler just above the .catch() handler below,
-            // doing so would subtly change the defacto async event dispatch order
-            // which at least one test and some plugins in the wild may depend on.
-            return Promise.resolve(hookResult).then(result => {
-                // action was fulfilled
-                this.unfulfilledActions.delete(action);
-                return result;
-            });
+            return hook.apply(context, args);
         })
-            .catch(error_ => {
-            if (action !== null) {
-                // action considered to be fulfilled since error being handled
-                this.unfulfilledActions.delete(action);
-            }
-            return error(errorPluginError(error_, plugin.name, { hook: hookName }));
-        });
+            .catch(err => throwPluginError(err, plugin.name, { hook: hookName }));
     }
     /**
      * Run a sync plugin hook and return the result.
      * @param hookName Name of the plugin hook. Must be in `PluginHooks`.
      * @param args Arguments passed to the plugin hook.
      * @param plugin The acutal plugin
-     * @param replaceContext When passed, the plugin context can be overridden.
+     * @param hookContext When passed, the plugin context can be overridden.
      */
-    runHookSync(hookName, parameters, plugin, replaceContext) {
+    runHookSync(hookName, args, plugin, hookContext) {
         const hook = plugin[hookName];
-        const handler = typeof hook === 'object' ? hook.handler : hook;
+        if (!hook)
+            return undefined;
         let context = this.pluginContexts.get(plugin);
-        if (replaceContext) {
-            context = replaceContext(context, plugin);
+        if (hookContext) {
+            context = hookContext(context, plugin);
         }
         try {
-            // eslint-disable-next-line @typescript-eslint/ban-types
-            return handler.apply(context, parameters);
-        }
-        catch (error_) {
-            return error(errorPluginError(error_, plugin.name, { hook: hookName }));
-        }
-    }
-}
-function getSortedValidatedPlugins(hookName, plugins, validateHandler = validateFunctionPluginHandler) {
-    const pre = [];
-    const normal = [];
-    const post = [];
-    for (const plugin of plugins) {
-        const hook = plugin[hookName];
-        if (hook) {
-            if (typeof hook === 'object') {
-                validateHandler(hook.handler, hookName, plugin);
-                if (hook.order === 'pre') {
-                    pre.push(plugin);
-                    continue;
-                }
-                if (hook.order === 'post') {
-                    post.push(plugin);
-                    continue;
-                }
+            // permit values allows values to be returned instead of a functional hook
+            if (typeof hook !== 'function') {
+                return throwInvalidHookError(hookName, plugin.name);
             }
-            else {
-                validateHandler(hook, hookName, plugin);
-            }
-            normal.push(plugin);
+            // eslint-disable-next-line @typescript-eslint/ban-types
+            return hook.apply(context, args);
         }
-    }
-    return [...pre, ...normal, ...post];
-}
-function validateFunctionPluginHandler(handler, hookName, plugin) {
-    if (typeof handler !== 'function') {
-        error(errorInvalidFunctionPluginHook(hookName, plugin.name));
-    }
-}
-function validateAddonPluginHandler(handler, hookName, plugin) {
-    if (typeof handler !== 'string' && typeof handler !== 'function') {
-        return error(errorInvalidAddonPluginHook(hookName, plugin.name));
-    }
-}
-function noReturn() { }
-
-class Queue {
-    constructor(maxParallel) {
-        this.maxParallel = maxParallel;
-        this.queue = [];
-        this.workerCount = 0;
-    }
-    run(task) {
-        return new Promise((resolve, reject) => {
-            this.queue.push({ reject, resolve, task });
-            this.work();
-        });
-    }
-    async work() {
-        if (this.workerCount >= this.maxParallel)
-            return;
-        this.workerCount++;
-        let entry;
-        while ((entry = this.queue.shift())) {
-            const { reject, resolve, task } = entry;
-            try {
-                const result = await task();
-                resolve(result);
-            }
-            catch (error) {
-                reject(error);
-            }
+        catch (err) {
+            return throwPluginError(err, plugin.name, { hook: hookName });
         }
-        this.workerCount--;
     }
 }
 
@@ -24427,8 +22670,8 @@
 }
 class Graph {
     constructor(options, watcher) {
+        var _a, _b;
         this.options = options;
-        this.astLru = flru(5);
         this.cachedModules = new Map();
         this.deoptimizationTracker = new PathTracker();
         this.entryModules = [];
@@ -24448,11 +22691,11 @@
             return foundModule.info;
         };
         if (options.cache !== false) {
-            if (options.cache?.modules) {
+            if ((_a = options.cache) === null || _a === void 0 ? void 0 : _a.modules) {
                 for (const module of options.cache.modules)
                     this.cachedModules.set(module.id, module);
             }
-            this.pluginCache = options.cache?.plugins || Object.create(null);
+            this.pluginCache = ((_b = options.cache) === null || _b === void 0 ? void 0 : _b.plugins) || Object.create(null);
             // increment access counter
             for (const name in this.pluginCache) {
                 const cache = this.pluginCache[name];
@@ -24462,25 +22705,27 @@
         }
         if (watcher) {
             this.watchMode = true;
-            const handleChange = (...parameters) => this.pluginDriver.hookParallel('watchChange', parameters);
-            const handleClose = () => this.pluginDriver.hookParallel('closeWatcher', []);
-            watcher.onCurrentRun('change', handleChange);
-            watcher.onCurrentRun('close', handleClose);
+            const handleChange = (...args) => this.pluginDriver.hookSeqSync('watchChange', args);
+            const handleClose = () => this.pluginDriver.hookSeqSync('closeWatcher', []);
+            watcher.on('change', handleChange);
+            watcher.on('close', handleClose);
+            watcher.once('restart', () => {
+                watcher.removeListener('change', handleChange);
+                watcher.removeListener('close', handleClose);
+            });
         }
         this.pluginDriver = new PluginDriver(this, options, options.plugins, this.pluginCache);
         this.acornParser = Parser.extend(...options.acornInjectPlugins);
         this.moduleLoader = new ModuleLoader(this, this.modulesById, this.options, this.pluginDriver);
-        this.fileOperationQueue = new Queue(options.maxParallelFileOps);
-        this.pureFunctions = getPureFunctions(options);
     }
     async build() {
         timeStart('generate module graph', 2);
         await this.generateModuleGraph();
         timeEnd('generate module graph', 2);
-        timeStart('sort and bind modules', 2);
+        timeStart('sort modules', 2);
         this.phase = BuildPhase.ANALYSE;
         this.sortModules();
-        timeEnd('sort and bind modules', 2);
+        timeEnd('sort modules', 2);
         timeStart('mark included statements', 2);
         this.includeStatements();
         timeEnd('mark included statements', 2);
@@ -24489,13 +22734,15 @@
     contextParse(code, options = {}) {
         const onCommentOrig = options.onComment;
         const comments = [];
-        options.onComment =
-            onCommentOrig && typeof onCommentOrig == 'function'
-                ? (block, text, start, end, ...parameters) => {
-                    comments.push({ end, start, type: block ? 'Block' : 'Line', value: text });
-                    return onCommentOrig.call(options, block, text, start, end, ...parameters);
-                }
-                : comments;
+        if (onCommentOrig && typeof onCommentOrig == 'function') {
+            options.onComment = (block, text, start, end, ...args) => {
+                comments.push({ end, start, type: block ? 'Block' : 'Line', value: text });
+                return onCommentOrig.call(options, block, text, start, end, ...args);
+            };
+        }
+        else {
+            options.onComment = comments;
+        }
         const ast = this.acornParser.parse(code, {
             ...this.options.acorn,
             ...options
@@ -24552,7 +22799,7 @@
                 this.needsTreeshakingPass = false;
                 for (const module of this.modules) {
                     if (module.isExecuted) {
-                        if (module.info.moduleSideEffects === 'no-treeshake') {
+                        if (module.info.hasModuleSideEffects === 'no-treeshake') {
                             module.includeAllInBundle();
                         }
                         else {
@@ -24582,7 +22829,7 @@
         for (const module of this.implicitEntryModules) {
             for (const dependant of module.implicitlyLoadedAfter) {
                 if (!(dependant.info.isEntry || dependant.isIncluded())) {
-                    error(errorImplicitDependantIsNotIncluded(dependant));
+                    error(errImplicitDependantIsNotIncluded(dependant));
                 }
             }
         }
@@ -24590,7 +22837,12 @@
     sortModules() {
         const { orderedModules, cyclePaths } = analyseModuleExecution(this.entryModules);
         for (const cyclePath of cyclePaths) {
-            this.options.onwarn(errorCircularDependency(cyclePath));
+            this.options.onwarn({
+                code: 'CIRCULAR_DEPENDENCY',
+                cycle: cyclePath,
+                importer: cyclePath[0],
+                message: `Circular dependency: ${cyclePath.join(' -> ')}`
+            });
         }
         this.modules = orderedModules;
         for (const module of this.modules) {
@@ -24600,331 +22852,51 @@
     }
     warnForMissingExports() {
         for (const module of this.modules) {
-            for (const importDescription of module.importDescriptions.values()) {
+            for (const importDescription of Object.values(module.importDescriptions)) {
                 if (importDescription.name !== '*' &&
-                    !importDescription.module.getVariableForExportName(importDescription.name)[0]) {
-                    module.warn(errorMissingExport(importDescription.name, module.id, importDescription.module.id), importDescription.start);
+                    !importDescription.module.getVariableForExportName(importDescription.name)) {
+                    module.warn({
+                        code: 'NON_EXISTENT_EXPORT',
+                        message: `Non-existent export '${importDescription.name}' is imported from ${relativeId(importDescription.module.id)}`,
+                        name: importDescription.name,
+                        source: importDescription.module.id
+                    }, importDescription.start);
                 }
             }
         }
     }
 }
 
-function formatAction([pluginName, hookName, parameters]) {
-    const action = `(${pluginName}) ${hookName}`;
-    const s = JSON.stringify;
-    switch (hookName) {
-        case 'resolveId': {
-            return `${action} ${s(parameters[0])} ${s(parameters[1])}`;
-        }
-        case 'load': {
-            return `${action} ${s(parameters[0])}`;
-        }
-        case 'transform': {
-            return `${action} ${s(parameters[1])}`;
-        }
-        case 'shouldTransformCachedModule': {
-            return `${action} ${s(parameters[0].id)}`;
-        }
-        case 'moduleParsed': {
-            return `${action} ${s(parameters[0].id)}`;
-        }
-    }
-    return action;
-}
-// We do not directly listen on process to avoid max listeners warnings for
-// complicated build processes
-const beforeExitEvent = 'beforeExit';
-const beforeExitEmitter = new node_events.EventEmitter();
-beforeExitEmitter.setMaxListeners(0);
-process$1.on(beforeExitEvent, () => beforeExitEmitter.emit(beforeExitEvent));
-async function catchUnfinishedHookActions(pluginDriver, callback) {
-    let handleEmptyEventLoop;
-    const emptyEventLoopPromise = new Promise((_, reject) => {
-        handleEmptyEventLoop = () => {
-            const unfulfilledActions = pluginDriver.getUnfulfilledHookActions();
-            reject(new Error(`Unexpected early exit. This happens when Promises returned by plugins cannot resolve. Unfinished hook action(s) on exit:\n` +
-                [...unfulfilledActions].map(formatAction).join('\n')));
-        };
-        beforeExitEmitter.once(beforeExitEvent, handleEmptyEventLoop);
-    });
-    const result = await Promise.race([callback(), emptyEventLoopPromise]);
-    beforeExitEmitter.off(beforeExitEvent, handleEmptyEventLoop);
-    return result;
-}
-
-const leftCurlyBrace = "{".charCodeAt(0);
-const space = " ".charCodeAt(0);
-
-const keyword = "assert";
-const FUNC_STATEMENT = 1, FUNC_NULLABLE_ID = 4;
-
-function importAssertions(Parser) {
-  // Use supplied version acorn version if present, to avoid
-  // reference mismatches due to different acorn versions. This
-  // allows this plugin to be used with Rollup which supplies
-  // its own internal version of acorn and thereby sidesteps
-  // the package manager.
-  const acorn = Parser.acorn || _acorn;
-  const { tokTypes: tt, TokenType } = acorn;
-
-  return class extends Parser {
-    constructor(...args) {
-      super(...args);
-      this.assertToken = new TokenType(keyword);
-    }
-
-    _codeAt(i) {
-      return this.input.charCodeAt(i);
-    }
-
-    _eat(t) {
-      if (this.type !== t) {
-        this.unexpected();
-      }
-      this.next();
-    }
-
-    readToken(code) {
-      let i = 0;
-      for (; i < keyword.length; i++) {
-        if (this._codeAt(this.pos + i) !== keyword.charCodeAt(i)) {
-          return super.readToken(code);
-        }
-      }
-
-      // ensure that the keyword is at the correct location
-      // ie `assert{...` or `assert {...`
-      for (;; i++) {
-        if (this._codeAt(this.pos + i) === leftCurlyBrace) {
-          // Found '{'
-          break;
-        } else if (this._codeAt(this.pos + i) === space) {
-          // white space is allowed between `assert` and `{`, so continue.
-          continue;
-        } else {
-          return super.readToken(code);
-        }
-      }
-
-      // If we're inside a dynamic import expression we'll parse
-      // the `assert` keyword as a standard object property name
-      // ie `import(""./foo.json", { assert: { type: "json" } })`
-      if (this.type.label === "{") {
-        return super.readToken(code);
-      }
-
-      this.pos += keyword.length;
-      return this.finishToken(this.assertToken);
-    }
-
-    parseDynamicImport(node) {
-      this.next(); // skip `(`
-
-      // Parse node.source.
-      node.source = this.parseMaybeAssign();
-
-      if (this.eat(tt.comma)) {
-        const obj = this.parseObj(false);
-        node.arguments = [obj];
-      }
-      this._eat(tt.parenR);
-      return this.finishNode(node, "ImportExpression");
-    }
-
-    // ported from acorn/src/statement.js pp.parseExport
-    parseExport(node, exports) {
-      this.next();
-      // export * from '...'
-      if (this.eat(tt.star)) {
-        if (this.options.ecmaVersion >= 11) {
-          if (this.eatContextual("as")) {
-            node.exported = this.parseIdent(true);
-            this.checkExport(exports, node.exported.name, this.lastTokStart);
-          } else {
-            node.exported = null;
-          }
-        }
-        this.expectContextual("from");
-        if (this.type !== tt.string) { this.unexpected(); }
-        node.source = this.parseExprAtom();
-
-        if (this.type === this.assertToken) {
-          this.next();
-          const assertions = this.parseImportAssertions();
-          if (assertions) {
-            node.assertions = assertions;
-          }
-        }
-
-        this.semicolon();
-        return this.finishNode(node, "ExportAllDeclaration")
-      }
-      if (this.eat(tt._default)) { // export default ...
-        this.checkExport(exports, "default", this.lastTokStart);
-        var isAsync;
-        if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {
-          var fNode = this.startNode();
-          this.next();
-          if (isAsync) { this.next(); }
-          node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
-        } else if (this.type === tt._class) {
-          var cNode = this.startNode();
-          node.declaration = this.parseClass(cNode, "nullableID");
-        } else {
-          node.declaration = this.parseMaybeAssign();
-          this.semicolon();
-        }
-        return this.finishNode(node, "ExportDefaultDeclaration")
-      }
-      // export var|const|let|function|class ...
-      if (this.shouldParseExportStatement()) {
-        node.declaration = this.parseStatement(null);
-        if (node.declaration.type === "VariableDeclaration")
-          { this.checkVariableExport(exports, node.declaration.declarations); }
-        else
-          { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
-        node.specifiers = [];
-        node.source = null;
-      } else { // export { x, y as z } [from '...']
-        node.declaration = null;
-        node.specifiers = this.parseExportSpecifiers(exports);
-        if (this.eatContextual("from")) {
-          if (this.type !== tt.string) { this.unexpected(); }
-          node.source = this.parseExprAtom();
-
-          if (this.type === this.assertToken) {
-            this.next();
-            const assertions = this.parseImportAssertions();
-            if (assertions) {
-              node.assertions = assertions;
-            }
-          }
-        } else {
-          for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
-            // check for keywords used as local names
-            var spec = list[i];
-
-            this.checkUnreserved(spec.local);
-            // check if export is defined
-            this.checkLocalExport(spec.local);
-          }
-
-          node.source = null;
-        }
-        this.semicolon();
-      }
-      return this.finishNode(node, "ExportNamedDeclaration")
-    }
-
-    parseImport(node) {
-      this.next();
-      // import '...'
-      if (this.type === tt.string) {
-        node.specifiers = [];
-        node.source = this.parseExprAtom();
-      } else {
-        node.specifiers = this.parseImportSpecifiers();
-        this.expectContextual("from");
-        node.source =
-          this.type === tt.string ? this.parseExprAtom() : this.unexpected();
-      }
-
-      if (this.type === this.assertToken) {
-        this.next();
-        const assertions = this.parseImportAssertions();
-        if (assertions) {
-          node.assertions = assertions;
-        }
-      }
-      this.semicolon();
-      return this.finishNode(node, "ImportDeclaration");
-    }
-
-    parseImportAssertions() {
-      this._eat(tt.braceL);
-      const attrs = this.parseAssertEntries();
-      this._eat(tt.braceR);
-      return attrs;
-    }
-
-    parseAssertEntries() {
-      const attrs = [];
-      const attrNames = new Set();
-
-      do {
-        if (this.type === tt.braceR) {
-          break;
-        }
-
-        const node = this.startNode();
-
-        // parse AssertionKey : IdentifierName, StringLiteral
-        let assertionKeyNode;
-        if (this.type === tt.string) {
-          assertionKeyNode = this.parseLiteral(this.value);
-        } else {
-          assertionKeyNode = this.parseIdent(true);
-        }
-        this.next();
-        node.key = assertionKeyNode;
-
-        // check if we already have an entry for an attribute
-        // if a duplicate entry is found, throw an error
-        // for now this logic will come into play only when someone declares `type` twice
-        if (attrNames.has(node.key.name)) {
-          this.raise(this.pos, "Duplicated key in assertions");
-        }
-        attrNames.add(node.key.name);
-
-        if (this.type !== tt.string) {
-          this.raise(
-            this.pos,
-            "Only string is supported as an assertion value"
-          );
-        }
-
-        node.value = this.parseLiteral(this.value);
-
-        attrs.push(this.finishNode(node, "ImportAttribute"));
-      } while (this.eat(tt.comma));
-
-      return attrs;
-    }
-  };
-}
-
-async function normalizeInputOptions(config) {
+function normalizeInputOptions(config) {
+    var _a, _b, _c;
     // These are options that may trigger special warnings or behaviour later
     // if the user did not select an explicit value
     const unsetOptions = new Set();
-    const context = config.context ?? 'undefined';
+    const context = (_a = config.context) !== null && _a !== void 0 ? _a : 'undefined';
     const onwarn = getOnwarn(config);
     const strictDeprecations = config.strictDeprecations || false;
-    const maxParallelFileOps = getmaxParallelFileOps(config, onwarn, strictDeprecations);
     const options = {
         acorn: getAcorn(config),
         acornInjectPlugins: getAcornInjectPlugins(config),
         cache: getCache(config),
         context,
-        experimentalCacheExpiry: config.experimentalCacheExpiry ?? 10,
+        experimentalCacheExpiry: (_b = config.experimentalCacheExpiry) !== null && _b !== void 0 ? _b : 10,
         external: getIdMatcher(config.external),
         inlineDynamicImports: getInlineDynamicImports$1(config, onwarn, strictDeprecations),
         input: getInput(config),
-        makeAbsoluteExternalsRelative: config.makeAbsoluteExternalsRelative ?? 'ifRelativeSource',
+        makeAbsoluteExternalsRelative: (_c = config.makeAbsoluteExternalsRelative) !== null && _c !== void 0 ? _c : true,
         manualChunks: getManualChunks$1(config, onwarn, strictDeprecations),
-        maxParallelFileOps,
-        maxParallelFileReads: maxParallelFileOps,
+        maxParallelFileReads: getMaxParallelFileReads(config),
         moduleContext: getModuleContext(config, context),
         onwarn,
         perf: config.perf || false,
-        plugins: await normalizePluginOption(config.plugins),
-        preserveEntrySignatures: config.preserveEntrySignatures ?? 'exports-only',
+        plugins: ensureArray$1(config.plugins),
+        preserveEntrySignatures: getPreserveEntrySignatures(config, unsetOptions),
         preserveModules: getPreserveModules$1(config, onwarn, strictDeprecations),
         preserveSymlinks: config.preserveSymlinks || false,
         shimMissingExports: config.shimMissingExports || false,
         strictDeprecations,
-        treeshake: getTreeshake(config)
+        treeshake: getTreeshake(config, onwarn, strictDeprecations)
     };
     warnUnknownOptions(config, [...Object.keys(options), 'watch'], 'input options', options.onwarn, /^(output)$/);
     return { options, unsetOptions };
@@ -24934,34 +22906,33 @@
     return onwarn
         ? warning => {
             warning.toString = () => {
-                let warningString = '';
+                let str = '';
                 if (warning.plugin)
-                    warningString += `(${warning.plugin} plugin) `;
+                    str += `(${warning.plugin} plugin) `;
                 if (warning.loc)
-                    warningString += `${relativeId(warning.loc.file)} (${warning.loc.line}:${warning.loc.column}) `;
-                warningString += warning.message;
-                return warningString;
+                    str += `${relativeId(warning.loc.file)} (${warning.loc.line}:${warning.loc.column}) `;
+                str += warning.message;
+                return str;
             };
             onwarn(warning, defaultOnWarn);
         }
         : defaultOnWarn;
 };
 const getAcorn = (config) => ({
+    allowAwaitOutsideFunction: true,
     ecmaVersion: 'latest',
+    preserveParens: false,
     sourceType: 'module',
     ...config.acorn
 });
-const getAcornInjectPlugins = (config) => [
-    importAssertions,
-    ...ensureArray$1(config.acornInjectPlugins)
-];
-const getCache = (config) => config.cache?.cache || config.cache;
+const getAcornInjectPlugins = (config) => ensureArray$1(config.acornInjectPlugins);
+const getCache = (config) => { var _a; return ((_a = config.cache) === null || _a === void 0 ? void 0 : _a.cache) || config.cache; };
 const getIdMatcher = (option) => {
     if (option === true) {
         return () => true;
     }
     if (typeof option === 'function') {
-        return (id, ...parameters) => (!id.startsWith('\0') && option(id, ...parameters)) || false;
+        return (id, ...args) => (!id.startsWith('\0') && option(id, ...args)) || false;
     }
     if (option) {
         const ids = new Set();
@@ -24974,14 +22945,14 @@
                 ids.add(value);
             }
         }
-        return (id, ..._arguments) => ids.has(id) || matchers.some(matcher => matcher.test(id));
+        return (id, ..._args) => ids.has(id) || matchers.some(matcher => matcher.test(id));
     }
     return () => false;
 };
 const getInlineDynamicImports$1 = (config, warn, strictDeprecations) => {
     const configInlineDynamicImports = config.inlineDynamicImports;
     if (configInlineDynamicImports) {
-        warnDeprecationWithOptions('The "inlineDynamicImports" option is deprecated. Use the "output.inlineDynamicImports" option instead.', URL_OUTPUT_INLINEDYNAMICIMPORTS, true, warn, strictDeprecations);
+        warnDeprecationWithOptions('The "inlineDynamicImports" option is deprecated. Use the "output.inlineDynamicImports" option instead.', false, warn, strictDeprecations);
     }
     return configInlineDynamicImports;
 };
@@ -24992,55 +22963,62 @@
 const getManualChunks$1 = (config, warn, strictDeprecations) => {
     const configManualChunks = config.manualChunks;
     if (configManualChunks) {
-        warnDeprecationWithOptions('The "manualChunks" option is deprecated. Use the "output.manualChunks" option instead.', URL_OUTPUT_MANUALCHUNKS, true, warn, strictDeprecations);
+        warnDeprecationWithOptions('The "manualChunks" option is deprecated. Use the "output.manualChunks" option instead.', false, warn, strictDeprecations);
     }
     return configManualChunks;
 };
-const getmaxParallelFileOps = (config, warn, strictDeprecations) => {
+const getMaxParallelFileReads = (config) => {
     const maxParallelFileReads = config.maxParallelFileReads;
     if (typeof maxParallelFileReads === 'number') {
-        warnDeprecationWithOptions('The "maxParallelFileReads" option is deprecated. Use the "maxParallelFileOps" option instead.', URL_MAXPARALLELFILEOPS, true, warn, strictDeprecations);
-    }
-    const maxParallelFileOps = config.maxParallelFileOps ?? maxParallelFileReads;
-    if (typeof maxParallelFileOps === 'number') {
-        if (maxParallelFileOps <= 0)
+        if (maxParallelFileReads <= 0)
             return Infinity;
-        return maxParallelFileOps;
+        return maxParallelFileReads;
     }
     return 20;
 };
 const getModuleContext = (config, context) => {
     const configModuleContext = config.moduleContext;
     if (typeof configModuleContext === 'function') {
-        return id => configModuleContext(id) ?? context;
+        return id => { var _a; return (_a = configModuleContext(id)) !== null && _a !== void 0 ? _a : context; };
     }
     if (configModuleContext) {
         const contextByModuleId = Object.create(null);
         for (const [key, moduleContext] of Object.entries(configModuleContext)) {
-            contextByModuleId[node_path.resolve(key)] = moduleContext;
+            contextByModuleId[path$2.resolve(key)] = moduleContext;
         }
-        return id => contextByModuleId[id] ?? context;
+        return id => contextByModuleId[id] || context;
     }
     return () => context;
 };
+const getPreserveEntrySignatures = (config, unsetOptions) => {
+    const configPreserveEntrySignatures = config.preserveEntrySignatures;
+    if (configPreserveEntrySignatures == null) {
+        unsetOptions.add('preserveEntrySignatures');
+    }
+    return configPreserveEntrySignatures !== null && configPreserveEntrySignatures !== void 0 ? configPreserveEntrySignatures : 'strict';
+};
 const getPreserveModules$1 = (config, warn, strictDeprecations) => {
     const configPreserveModules = config.preserveModules;
     if (configPreserveModules) {
-        warnDeprecationWithOptions('The "preserveModules" option is deprecated. Use the "output.preserveModules" option instead.', URL_OUTPUT_PRESERVEMODULES, true, warn, strictDeprecations);
+        warnDeprecationWithOptions('The "preserveModules" option is deprecated. Use the "output.preserveModules" option instead.', false, warn, strictDeprecations);
     }
     return configPreserveModules;
 };
-const getTreeshake = (config) => {
+const getTreeshake = (config, warn, strictDeprecations) => {
     const configTreeshake = config.treeshake;
     if (configTreeshake === false) {
         return false;
     }
-    const configWithPreset = getOptionWithPreset(config.treeshake, treeshakePresets, 'treeshake', URL_TREESHAKE, 'false, true, ');
+    const configWithPreset = getOptionWithPreset(config.treeshake, treeshakePresets, 'treeshake', 'false, true, ');
+    if (typeof configWithPreset.pureExternalModules !== 'undefined') {
+        warnDeprecationWithOptions(`The "treeshake.pureExternalModules" option is deprecated. The "treeshake.moduleSideEffects" option should be used instead. "treeshake.pureExternalModules: true" is equivalent to "treeshake.moduleSideEffects: 'no-external'"`, true, warn, strictDeprecations);
+    }
     return {
         annotations: configWithPreset.annotations !== false,
         correctVarValueBeforeDeclaration: configWithPreset.correctVarValueBeforeDeclaration === true,
-        manualPureFunctions: configWithPreset.manualPureFunctions ?? EMPTY_ARRAY,
-        moduleSideEffects: getHasModuleSideEffects(configWithPreset.moduleSideEffects),
+        moduleSideEffects: typeof configTreeshake === 'object' && configTreeshake.pureExternalModules
+            ? getHasModuleSideEffects(configTreeshake.moduleSideEffects, configTreeshake.pureExternalModules)
+            : getHasModuleSideEffects(configWithPreset.moduleSideEffects, undefined),
         propertyReadSideEffects: configWithPreset.propertyReadSideEffects === 'always'
             ? 'always'
             : configWithPreset.propertyReadSideEffects !== false,
@@ -25048,7 +23026,7 @@
         unknownGlobalSideEffects: configWithPreset.unknownGlobalSideEffects !== false
     };
 };
-const getHasModuleSideEffects = (moduleSideEffectsOption) => {
+const getHasModuleSideEffects = (moduleSideEffectsOption, pureExternalModules) => {
     if (typeof moduleSideEffectsOption === 'boolean') {
         return () => moduleSideEffectsOption;
     }
@@ -25056,31 +23034,29 @@
         return (_id, external) => !external;
     }
     if (typeof moduleSideEffectsOption === 'function') {
-        return (id, external) => id.startsWith('\0') ? true : moduleSideEffectsOption(id, external) !== false;
+        return (id, external) => !id.startsWith('\0') ? moduleSideEffectsOption(id, external) !== false : true;
     }
     if (Array.isArray(moduleSideEffectsOption)) {
         const ids = new Set(moduleSideEffectsOption);
         return id => ids.has(id);
     }
     if (moduleSideEffectsOption) {
-        error(errorInvalidOption('treeshake.moduleSideEffects', URL_TREESHAKE_MODULESIDEEFFECTS, 'please use one of false, "no-external", a function or an array'));
+        error(errInvalidOption('treeshake.moduleSideEffects', 'treeshake', 'please use one of false, "no-external", a function or an array'));
     }
-    return () => true;
+    const isPureExternalModule = getIdMatcher(pureExternalModules);
+    return (id, external) => !(external && isPureExternalModule(id));
 };
 
-// https://datatracker.ietf.org/doc/html/rfc2396
-// eslint-disable-next-line no-control-regex
-const INVALID_CHAR_REGEX = /[\u0000-\u001F"#$&*+,:;<=>?[\]^`{|}\u007F]/g;
-const DRIVE_LETTER_REGEX = /^[a-z]:/i;
 function sanitizeFileName(name) {
-    const match = DRIVE_LETTER_REGEX.exec(name);
+    const match = /^[a-z]:/i.exec(name);
     const driveLetter = match ? match[0] : '';
     // A `:` is only allowed as part of a windows drive letter (ex: C:\foo)
     // Otherwise, avoid them because they can refer to NTFS alternate data streams.
-    return driveLetter + name.slice(driveLetter.length).replace(INVALID_CHAR_REGEX, '_');
+    return driveLetter + name.substr(driveLetter.length).replace(/[\0?*:]/g, '_');
 }
 
-async function normalizeOutputOptions(config, inputOptions, unsetInputOptions) {
+function normalizeOutputOptions(config, inputOptions, unsetInputOptions) {
+    var _a, _b, _c, _d, _e, _f, _g;
     // These are options that may trigger special warnings or behaviour later
     // if the user did not select an explicit value
     const unsetOptions = new Set(unsetInputOptions);
@@ -25090,42 +23066,38 @@
     const preserveModules = getPreserveModules(config, inlineDynamicImports, inputOptions);
     const file = getFile(config, preserveModules, inputOptions);
     const preferConst = getPreferConst(config, inputOptions);
-    const generatedCode = getGeneratedCode(config, preferConst);
     const outputOptions = {
         amd: getAmd(config),
-        assetFileNames: config.assetFileNames ?? 'assets/[name]-[hash][extname]',
+        assetFileNames: (_a = config.assetFileNames) !== null && _a !== void 0 ? _a : 'assets/[name]-[hash][extname]',
         banner: getAddon(config, 'banner'),
-        chunkFileNames: config.chunkFileNames ?? '[name]-[hash].js',
+        chunkFileNames: (_b = config.chunkFileNames) !== null && _b !== void 0 ? _b : '[name]-[hash].js',
         compact,
         dir: getDir(config, file),
-        dynamicImportFunction: getDynamicImportFunction(config, inputOptions, format),
-        dynamicImportInCjs: config.dynamicImportInCjs ?? true,
+        dynamicImportFunction: getDynamicImportFunction(config, inputOptions),
         entryFileNames: getEntryFileNames(config, unsetOptions),
-        esModule: config.esModule ?? 'if-default-prop',
-        experimentalMinChunkSize: config.experimentalMinChunkSize || 0,
+        esModule: (_c = config.esModule) !== null && _c !== void 0 ? _c : true,
         exports: getExports(config, unsetOptions),
         extend: config.extend || false,
-        externalImportAssertions: config.externalImportAssertions ?? true,
-        externalLiveBindings: config.externalLiveBindings ?? true,
+        externalLiveBindings: (_d = config.externalLiveBindings) !== null && _d !== void 0 ? _d : true,
         file,
         footer: getAddon(config, 'footer'),
         format,
-        freeze: config.freeze ?? true,
-        generatedCode,
+        freeze: (_e = config.freeze) !== null && _e !== void 0 ? _e : true,
+        generatedCode: getGeneratedCode(config, preferConst),
         globals: config.globals || {},
-        hoistTransitiveImports: config.hoistTransitiveImports ?? true,
+        hoistTransitiveImports: (_f = config.hoistTransitiveImports) !== null && _f !== void 0 ? _f : true,
         indent: getIndent(config, compact),
         inlineDynamicImports,
-        interop: getInterop(config),
+        interop: getInterop(config, inputOptions),
         intro: getAddon(config, 'intro'),
         manualChunks: getManualChunks(config, inlineDynamicImports, preserveModules, inputOptions),
         minifyInternalExports: getMinifyInternalExports(config, format, compact),
         name: config.name,
-        namespaceToStringTag: getNamespaceToStringTag(config, generatedCode, inputOptions),
+        namespaceToStringTag: config.namespaceToStringTag || false,
         noConflict: config.noConflict || false,
         outro: getAddon(config, 'outro'),
         paths: config.paths || {},
-        plugins: await normalizePluginOption(config.plugins),
+        plugins: ensureArray$1(config.plugins),
         preferConst,
         preserveModules,
         preserveModulesRoot: getPreserveModulesRoot(config),
@@ -25135,12 +23107,11 @@
                 ? id => id
                 : sanitizeFileName,
         sourcemap: config.sourcemap || false,
-        sourcemapBaseUrl: getSourcemapBaseUrl(config),
         sourcemapExcludeSources: config.sourcemapExcludeSources || false,
         sourcemapFile: config.sourcemapFile,
         sourcemapPathTransform: config.sourcemapPathTransform,
-        strict: config.strict ?? true,
-        systemNullSetters: config.systemNullSetters ?? true,
+        strict: (_g = config.strict) !== null && _g !== void 0 ? _g : true,
+        systemNullSetters: config.systemNullSetters || false,
         validate: config.validate || false
     };
     warnUnknownOptions(config, Object.keys(outputOptions), 'output options', inputOptions.onwarn);
@@ -25150,10 +23121,10 @@
     const { file } = config;
     if (typeof file === 'string') {
         if (preserveModules) {
-            return error(errorInvalidOption('output.file', URL_OUTPUT_DIR, 'you must set "output.dir" instead of "output.file" when using the "output.preserveModules" option'));
+            return error(errInvalidOption('output.file', 'outputdir', 'you must set "output.dir" instead of "output.file" when using the "output.preserveModules" option'));
         }
         if (!Array.isArray(inputOptions.input))
-            return error(errorInvalidOption('output.file', URL_OUTPUT_DIR, 'you must set "output.dir" instead of "output.file" when providing named inputs'));
+            return error(errInvalidOption('output.file', 'outputdir', 'you must set "output.dir" instead of "output.file" when providing named inputs'));
     }
     return file;
 };
@@ -25163,43 +23134,43 @@
         case undefined:
         case 'es':
         case 'esm':
-        case 'module': {
+        case 'module':
             return 'es';
-        }
         case 'cjs':
-        case 'commonjs': {
+        case 'commonjs':
             return 'cjs';
-        }
         case 'system':
-        case 'systemjs': {
+        case 'systemjs':
             return 'system';
-        }
         case 'amd':
         case 'iife':
-        case 'umd': {
+        case 'umd':
             return configFormat;
-        }
-        default: {
-            return error(errorInvalidOption('output.format', URL_OUTPUT_FORMAT, `Valid values are "amd", "cjs", "system", "es", "iife" or "umd"`, configFormat));
-        }
+        default:
+            return error({
+                message: `You must specify "output.format", which can be one of "amd", "cjs", "system", "es", "iife" or "umd".`,
+                url: `https://rollupjs.org/guide/en/#outputformat`
+            });
     }
 };
 const getInlineDynamicImports = (config, inputOptions) => {
-    const inlineDynamicImports = (config.inlineDynamicImports ?? inputOptions.inlineDynamicImports) || false;
+    var _a;
+    const inlineDynamicImports = ((_a = config.inlineDynamicImports) !== null && _a !== void 0 ? _a : inputOptions.inlineDynamicImports) || false;
     const { input } = inputOptions;
     if (inlineDynamicImports && (Array.isArray(input) ? input : Object.keys(input)).length > 1) {
-        return error(errorInvalidOption('output.inlineDynamicImports', URL_OUTPUT_INLINEDYNAMICIMPORTS, 'multiple inputs are not supported when "output.inlineDynamicImports" is true'));
+        return error(errInvalidOption('output.inlineDynamicImports', 'outputinlinedynamicimports', 'multiple inputs are not supported when "output.inlineDynamicImports" is true'));
     }
     return inlineDynamicImports;
 };
 const getPreserveModules = (config, inlineDynamicImports, inputOptions) => {
-    const preserveModules = (config.preserveModules ?? inputOptions.preserveModules) || false;
+    var _a;
+    const preserveModules = ((_a = config.preserveModules) !== null && _a !== void 0 ? _a : inputOptions.preserveModules) || false;
     if (preserveModules) {
         if (inlineDynamicImports) {
-            return error(errorInvalidOption('output.inlineDynamicImports', URL_OUTPUT_INLINEDYNAMICIMPORTS, `this option is not supported for "output.preserveModules"`));
+            return error(errInvalidOption('output.inlineDynamicImports', 'outputinlinedynamicimports', `this option is not supported for "output.preserveModules"`));
         }
         if (inputOptions.preserveEntrySignatures === false) {
-            return error(errorInvalidOption('preserveEntrySignatures', URL_PRESERVEENTRYSIGNATURES, 'setting this option to false is not supported for "output.preserveModules"'));
+            return error(errInvalidOption('preserveEntrySignatures', 'preserveentrysignatures', 'setting this option to false is not supported for "output.preserveModules"'));
         }
     }
     return preserveModules;
@@ -25207,7 +23178,7 @@
 const getPreferConst = (config, inputOptions) => {
     const configPreferConst = config.preferConst;
     if (configPreferConst != null) {
-        warnDeprecation(`The "output.preferConst" option is deprecated. Use the "output.generatedCode.constBindings" option instead.`, URL_OUTPUT_GENERATEDCODE_CONSTBINDINGS, true, inputOptions);
+        warnDeprecation(`The "output.preferConst" option is deprecated. Use the "output.generatedCode.constBindings" option instead.`, false, inputOptions);
     }
     return !!configPreferConst;
 };
@@ -25216,35 +23187,37 @@
     if (preserveModulesRoot === null || preserveModulesRoot === undefined) {
         return undefined;
     }
-    return node_path.resolve(preserveModulesRoot);
+    return path$2.resolve(preserveModulesRoot);
 };
 const getAmd = (config) => {
     const mergedOption = {
         autoId: false,
         basePath: '',
         define: 'define',
-        forceJsExtensionForImports: false,
         ...config.amd
     };
     if ((mergedOption.autoId || mergedOption.basePath) && mergedOption.id) {
-        return error(errorInvalidOption('output.amd.id', URL_OUTPUT_AMD_ID, 'this option cannot be used together with "output.amd.autoId"/"output.amd.basePath"'));
+        return error(errInvalidOption('output.amd.id', 'outputamd', 'this option cannot be used together with "output.amd.autoId"/"output.amd.basePath"'));
     }
     if (mergedOption.basePath && !mergedOption.autoId) {
-        return error(errorInvalidOption('output.amd.basePath', URL_OUTPUT_AMD_BASEPATH, 'this option only works with "output.amd.autoId"'));
+        return error(errInvalidOption('output.amd.basePath', 'outputamd', 'this option only works with "output.amd.autoId"'));
     }
-    return mergedOption.autoId
-        ? {
+    let normalized;
+    if (mergedOption.autoId) {
+        normalized = {
             autoId: true,
             basePath: mergedOption.basePath,
-            define: mergedOption.define,
-            forceJsExtensionForImports: mergedOption.forceJsExtensionForImports
-        }
-        : {
+            define: mergedOption.define
+        };
+    }
+    else {
+        normalized = {
             autoId: false,
             define: mergedOption.define,
-            forceJsExtensionForImports: mergedOption.forceJsExtensionForImports,
             id: mergedOption.id
         };
+    }
+    return normalized;
 };
 const getAddon = (config, name) => {
     const configAddon = config[name];
@@ -25253,21 +23226,17 @@
     }
     return () => configAddon || '';
 };
-// eslint-disable-next-line unicorn/prevent-abbreviations
 const getDir = (config, file) => {
     const { dir } = config;
     if (typeof dir === 'string' && typeof file === 'string') {
-        return error(errorInvalidOption('output.dir', URL_OUTPUT_DIR, 'you must set either "output.file" for a single-file build or "output.dir" when generating multiple chunks'));
+        return error(errInvalidOption('output.dir', 'outputdir', 'you must set either "output.file" for a single-file build or "output.dir" when generating multiple chunks'));
     }
     return dir;
 };
-const getDynamicImportFunction = (config, inputOptions, format) => {
+const getDynamicImportFunction = (config, inputOptions) => {
     const configDynamicImportFunction = config.dynamicImportFunction;
     if (configDynamicImportFunction) {
-        warnDeprecation(`The "output.dynamicImportFunction" option is deprecated. Use the "renderDynamicImport" plugin hook instead.`, URL_RENDERDYNAMICIMPORT, true, inputOptions);
-        if (format !== 'es') {
-            inputOptions.onwarn(errorInvalidOption('output.dynamicImportFunction', URL_OUTPUT_DYNAMICIMPORTFUNCTION, 'this option is ignored for formats other than "es"'));
-        }
+        warnDeprecation(`The "output.dynamicImportFunction" option is deprecated. Use the "renderDynamicImport" plugin hook instead.`, false, inputOptions);
     }
     return configDynamicImportFunction;
 };
@@ -25276,7 +23245,7 @@
     if (configEntryFileNames == null) {
         unsetOptions.add('entryFileNames');
     }
-    return configEntryFileNames ?? '[name].js';
+    return configEntryFileNames !== null && configEntryFileNames !== void 0 ? configEntryFileNames : '[name].js';
 };
 function getExports(config, unsetOptions) {
     const configExports = config.exports;
@@ -25284,18 +23253,17 @@
         unsetOptions.add('exports');
     }
     else if (!['default', 'named', 'none', 'auto'].includes(configExports)) {
-        return error(errorInvalidExportOptionValue(configExports));
+        return error(errInvalidExportOptionValue(configExports));
     }
     return configExports || 'auto';
 }
 const getGeneratedCode = (config, preferConst) => {
-    const configWithPreset = getOptionWithPreset(config.generatedCode, generatedCodePresets, 'output.generatedCode', URL_OUTPUT_GENERATEDCODE, '');
+    const configWithPreset = getOptionWithPreset(config.generatedCode, generatedCodePresets, 'output.generatedCode', '');
     return {
         arrowFunctions: configWithPreset.arrowFunctions === true,
         constBindings: configWithPreset.constBindings === true || preferConst,
         objectShorthand: configWithPreset.objectShorthand === true,
-        reservedNamesAsProps: configWithPreset.reservedNamesAsProps !== false,
-        symbols: configWithPreset.symbols === true
+        reservedNamesAsProps: configWithPreset.reservedNamesAsProps === true
     };
 };
 const getIndent = (config, compact) => {
@@ -25303,17 +23271,27 @@
         return '';
     }
     const configIndent = config.indent;
-    return configIndent === false ? '' : configIndent ?? true;
+    return configIndent === false ? '' : configIndent !== null && configIndent !== void 0 ? configIndent : true;
 };
-const ALLOWED_INTEROP_TYPES = new Set([
-    'compat',
-    'auto',
-    'esModule',
-    'default',
-    'defaultOnly'
-]);
-const getInterop = (config) => {
+const ALLOWED_INTEROP_TYPES = new Set(['auto', 'esModule', 'default', 'defaultOnly', true, false]);
+const getInterop = (config, inputOptions) => {
     const configInterop = config.interop;
+    const validatedInteropTypes = new Set();
+    const validateInterop = (interop) => {
+        if (!validatedInteropTypes.has(interop)) {
+            validatedInteropTypes.add(interop);
+            if (!ALLOWED_INTEROP_TYPES.has(interop)) {
+                return error(errInvalidOption('output.interop', 'outputinterop', `use one of ${Array.from(ALLOWED_INTEROP_TYPES.values(), value => JSON.stringify(value)).join(', ')}`, interop));
+            }
+            if (typeof interop === 'boolean') {
+                warnDeprecation({
+                    message: `The boolean value "${interop}" for the "output.interop" option is deprecated. Use ${interop ? '"auto"' : '"esModule", "default" or "defaultOnly"'} instead.`,
+                    url: 'https://rollupjs.org/guide/en/#outputinterop'
+                }, false, inputOptions);
+            }
+        }
+        return interop;
+    };
     if (typeof configInterop === 'function') {
         const interopPerId = Object.create(null);
         let defaultInterop = null;
@@ -25323,46 +23301,21 @@
                 ? interopPerId[id]
                 : validateInterop((interopPerId[id] = configInterop(id)));
     }
-    return configInterop === undefined ? () => 'default' : () => validateInterop(configInterop);
-};
-const validateInterop = (interop) => {
-    if (!ALLOWED_INTEROP_TYPES.has(interop)) {
-        return error(errorInvalidOption('output.interop', URL_OUTPUT_INTEROP, 
-        // eslint-disable-next-line unicorn/prefer-spread
-        `use one of ${Array.from(ALLOWED_INTEROP_TYPES, value => JSON.stringify(value)).join(', ')}`, interop));
-    }
-    return interop;
+    return configInterop === undefined ? () => true : () => validateInterop(configInterop);
 };
 const getManualChunks = (config, inlineDynamicImports, preserveModules, inputOptions) => {
     const configManualChunks = config.manualChunks || inputOptions.manualChunks;
     if (configManualChunks) {
         if (inlineDynamicImports) {
-            return error(errorInvalidOption('output.manualChunks', URL_OUTPUT_MANUALCHUNKS, 'this option is not supported for "output.inlineDynamicImports"'));
+            return error(errInvalidOption('output.manualChunks', 'outputmanualchunks', 'this option is not supported for "output.inlineDynamicImports"'));
         }
         if (preserveModules) {
-            return error(errorInvalidOption('output.manualChunks', URL_OUTPUT_MANUALCHUNKS, 'this option is not supported for "output.preserveModules"'));
+            return error(errInvalidOption('output.manualChunks', 'outputmanualchunks', 'this option is not supported for "output.preserveModules"'));
         }
     }
     return configManualChunks || {};
 };
-const getMinifyInternalExports = (config, format, compact) => config.minifyInternalExports ?? (compact || format === 'es' || format === 'system');
-const getNamespaceToStringTag = (config, generatedCode, inputOptions) => {
-    const configNamespaceToStringTag = config.namespaceToStringTag;
-    if (configNamespaceToStringTag != null) {
-        warnDeprecation(`The "output.namespaceToStringTag" option is deprecated. Use the "output.generatedCode.symbols" option instead.`, URL_OUTPUT_GENERATEDCODE_SYMBOLS, true, inputOptions);
-        return configNamespaceToStringTag;
-    }
-    return generatedCode.symbols || false;
-};
-const getSourcemapBaseUrl = (config) => {
-    const { sourcemapBaseUrl } = config;
-    if (sourcemapBaseUrl) {
-        if (isValidUrl(sourcemapBaseUrl)) {
-            return sourcemapBaseUrl;
-        }
-        return error(errorInvalidOption('output.sourcemapBaseUrl', URL_OUTPUT_SOURCEMAPBASEURL, `must be a valid URL, received ${JSON.stringify(sourcemapBaseUrl)}`));
-    }
-};
+const getMinifyInternalExports = (config, format, compact) => { var _a; return (_a = config.minifyInternalExports) !== null && _a !== void 0 ? _a : (compact || format === 'es' || format === 'system'); };
 
 function rollup(rawInputOptions) {
     return rollupInternal(rawInputOptions, null);
@@ -25371,31 +23324,25 @@
     const { options: inputOptions, unsetOptions: unsetInputOptions } = await getInputOptions(rawInputOptions, watcher !== null);
     initialiseTimers(inputOptions);
     const graph = new Graph(inputOptions, watcher);
-    // remove the cache object from the memory after graph creation (cache is not used anymore)
+    // remove the cache option from the memory after graph creation (cache is not used anymore)
     const useCache = rawInputOptions.cache !== false;
-    if (rawInputOptions.cache) {
-        inputOptions.cache = undefined;
-        rawInputOptions.cache = undefined;
-    }
+    delete inputOptions.cache;
+    delete rawInputOptions.cache;
     timeStart('BUILD', 1);
-    await catchUnfinishedHookActions(graph.pluginDriver, async () => {
-        try {
-            timeStart('initialize', 2);
-            await graph.pluginDriver.hookParallel('buildStart', [inputOptions]);
-            timeEnd('initialize', 2);
-            await graph.build();
-        }
-        catch (error_) {
-            const watchFiles = Object.keys(graph.watchFiles);
-            if (watchFiles.length > 0) {
-                error_.watchFiles = watchFiles;
-            }
-            await graph.pluginDriver.hookParallel('buildEnd', [error_]);
-            await graph.pluginDriver.hookParallel('closeBundle', []);
-            throw error_;
-        }
-        await graph.pluginDriver.hookParallel('buildEnd', []);
-    });
+    try {
+        await graph.pluginDriver.hookParallel('buildStart', [inputOptions]);
+        await graph.build();
+    }
+    catch (err) {
+        const watchFiles = Object.keys(graph.watchFiles);
+        if (watchFiles.length > 0) {
+            err.watchFiles = watchFiles;
+        }
+        await graph.pluginDriver.hookParallel('buildEnd', [err]);
+        await graph.pluginDriver.hookParallel('closeBundle', []);
+        throw err;
+    }
+    await graph.pluginDriver.hookParallel('buildEnd', []);
     timeEnd('BUILD', 1);
     const result = {
         cache: useCache ? graph.getCache() : undefined,
@@ -25408,13 +23355,13 @@
         closed: false,
         async generate(rawOutputOptions) {
             if (result.closed)
-                return error(errorAlreadyClosed());
+                return error(errAlreadyClosed());
             return handleGenerateWrite(false, inputOptions, unsetInputOptions, rawOutputOptions, graph);
         },
         watchFiles: Object.keys(graph.watchFiles),
         async write(rawOutputOptions) {
             if (result.closed)
-                return error(errorAlreadyClosed());
+                return error(errAlreadyClosed());
             return handleGenerateWrite(true, inputOptions, unsetInputOptions, rawOutputOptions, graph);
         }
     };
@@ -25426,57 +23373,58 @@
     if (!rawInputOptions) {
         throw new Error('You must supply an options object to rollup');
     }
-    const rawPlugins = getSortedValidatedPlugins('options', await normalizePluginOption(rawInputOptions.plugins));
-    const { options, unsetOptions } = await normalizeInputOptions(await rawPlugins.reduce(applyOptionHook(watchMode), Promise.resolve(rawInputOptions)));
+    const rawPlugins = ensureArray$1(rawInputOptions.plugins);
+    const { options, unsetOptions } = normalizeInputOptions(await rawPlugins.reduce(applyOptionHook(watchMode), Promise.resolve(rawInputOptions)));
     normalizePlugins(options.plugins, ANONYMOUS_PLUGIN_PREFIX);
     return { options, unsetOptions };
 }
 function applyOptionHook(watchMode) {
     return async (inputOptions, plugin) => {
-        const handler = 'handler' in plugin.options ? plugin.options.handler : plugin.options;
-        return ((await handler.call({ meta: { rollupVersion: version$1, watchMode } }, await inputOptions)) ||
-            inputOptions);
+        if (plugin.options) {
+            return ((await plugin.options.call({ meta: { rollupVersion: version$1, watchMode } }, await inputOptions)) || inputOptions);
+        }
+        return inputOptions;
     };
 }
 function normalizePlugins(plugins, anonymousPrefix) {
-    for (const [index, plugin] of plugins.entries()) {
+    for (let pluginIndex = 0; pluginIndex < plugins.length; pluginIndex++) {
+        const plugin = plugins[pluginIndex];
         if (!plugin.name) {
-            plugin.name = `${anonymousPrefix}${index + 1}`;
+            plugin.name = `${anonymousPrefix}${pluginIndex + 1}`;
         }
     }
 }
 async function handleGenerateWrite(isWrite, inputOptions, unsetInputOptions, rawOutputOptions, graph) {
-    const { options: outputOptions, outputPluginDriver, unsetOptions } = await getOutputOptionsAndPluginDriver(rawOutputOptions, graph.pluginDriver, inputOptions, unsetInputOptions);
-    return catchUnfinishedHookActions(outputPluginDriver, async () => {
-        const bundle = new Bundle(outputOptions, unsetOptions, inputOptions, outputPluginDriver, graph);
-        const generated = await bundle.generate(isWrite);
-        if (isWrite) {
-            timeStart('WRITE', 1);
-            if (!outputOptions.dir && !outputOptions.file) {
-                return error(errorMissingFileOrDirOption());
-            }
-            await Promise.all(Object.values(generated).map(chunk => graph.fileOperationQueue.run(() => writeOutputFile(chunk, outputOptions))));
-            await outputPluginDriver.hookParallel('writeBundle', [outputOptions, generated]);
-            timeEnd('WRITE', 1);
+    const { options: outputOptions, outputPluginDriver, unsetOptions } = getOutputOptionsAndPluginDriver(rawOutputOptions, graph.pluginDriver, inputOptions, unsetInputOptions);
+    const bundle = new Bundle(outputOptions, unsetOptions, inputOptions, outputPluginDriver, graph);
+    const generated = await bundle.generate(isWrite);
+    if (isWrite) {
+        if (!outputOptions.dir && !outputOptions.file) {
+            return error({
+                code: 'MISSING_OPTION',
+                message: 'You must specify "output.file" or "output.dir" for the build.'
+            });
         }
-        return createOutput(generated);
-    });
+        await Promise.all(Object.values(generated).map(chunk => writeOutputFile(chunk, outputOptions)));
+        await outputPluginDriver.hookParallel('writeBundle', [outputOptions, generated]);
+    }
+    return createOutput(generated);
 }
-async function getOutputOptionsAndPluginDriver(rawOutputOptions, inputPluginDriver, inputOptions, unsetInputOptions) {
+function getOutputOptionsAndPluginDriver(rawOutputOptions, inputPluginDriver, inputOptions, unsetInputOptions) {
     if (!rawOutputOptions) {
         throw new Error('You must supply an options object');
     }
-    const rawPlugins = await normalizePluginOption(rawOutputOptions.plugins);
+    const rawPlugins = ensureArray$1(rawOutputOptions.plugins);
     normalizePlugins(rawPlugins, ANONYMOUS_OUTPUT_PLUGIN_PREFIX);
     const outputPluginDriver = inputPluginDriver.createOutputPluginDriver(rawPlugins);
     return {
-        ...(await getOutputOptions(inputOptions, unsetInputOptions, rawOutputOptions, outputPluginDriver)),
+        ...getOutputOptions(inputOptions, unsetInputOptions, rawOutputOptions, outputPluginDriver),
         outputPluginDriver
     };
 }
 function getOutputOptions(inputOptions, unsetInputOptions, rawOutputOptions, outputPluginDriver) {
-    return normalizeOutputOptions(outputPluginDriver.hookReduceArg0Sync('outputOptions', [rawOutputOptions], (outputOptions, result) => result || outputOptions, pluginContext => {
-        const emitError = () => pluginContext.error(errorCannotEmitFromOptionsHook());
+    return normalizeOutputOptions(outputPluginDriver.hookReduceArg0Sync('outputOptions', [rawOutputOptions.output || rawOutputOptions], (outputOptions, result) => result || outputOptions, pluginContext => {
+        const emitError = () => pluginContext.error(errCannotEmitFromOptionsHook());
         return {
             ...pluginContext,
             emitFile: emitError,
@@ -25486,7 +23434,13 @@
 }
 function createOutput(outputBundle) {
     return {
-        output: Object.values(outputBundle).filter(outputFile => Object.keys(outputFile).length > 0).sort((outputFileA, outputFileB) => getSortingFileType(outputFileA) - getSortingFileType(outputFileB))
+        output: Object.values(outputBundle).filter(outputFile => Object.keys(outputFile).length > 0).sort((outputFileA, outputFileB) => {
+            const fileTypeA = getSortingFileType(outputFileA);
+            const fileTypeB = getSortingFileType(outputFileB);
+            if (fileTypeA === fileTypeB)
+                return 0;
+            return fileTypeA < fileTypeB ? -1 : 1;
+        })
     };
 }
 var SortingFileType;
@@ -25504,11 +23458,30 @@
     }
     return SortingFileType.SECONDARY_CHUNK;
 }
-async function writeOutputFile(outputFile, outputOptions) {
-    const fileName = node_path.resolve(outputOptions.dir || node_path.dirname(outputOptions.file), outputFile.fileName);
-    // 'recursive: true' does not throw if the folder structure, or parts of it, already exist
-    await promises.mkdir(node_path.dirname(fileName), { recursive: true });
-    return promises.writeFile(fileName, outputFile.type === 'asset' ? outputFile.source : outputFile.code);
+function writeOutputFile(outputFile, outputOptions) {
+    const fileName = path$2.resolve(outputOptions.dir || path$2.dirname(outputOptions.file), outputFile.fileName);
+    let writeSourceMapPromise;
+    let source;
+    if (outputFile.type === 'asset') {
+        source = outputFile.source;
+    }
+    else {
+        source = outputFile.code;
+        if (outputOptions.sourcemap && outputFile.map) {
+            let url;
+            if (outputOptions.sourcemap === 'inline') {
+                url = outputFile.map.toUrl();
+            }
+            else {
+                url = `${path$2.basename(outputFile.fileName)}.map`;
+                writeSourceMapPromise = writeFile(`${fileName}.map`, outputFile.map.toString());
+            }
+            if (outputOptions.sourcemap !== 'hidden') {
+                source += `//# ${SOURCEMAPPING_URL}=${url}\n`;
+            }
+        }
+    }
+    return Promise.all([writeFile(fileName, source), writeSourceMapPromise]);
 }
 /**
  * Auxiliary function for defining rollup configuration
@@ -25519,119 +23492,48 @@
     return options;
 }
 
-class WatchEmitter {
+class WatchEmitter extends require$$0.EventEmitter {
     constructor() {
-        this.currentHandlers = Object.create(null);
-        this.persistentHandlers = Object.create(null);
-    }
-    // Will be overwritten by Rollup
-    async close() { }
-    emit(event, ...parameters) {
-        return Promise.all([...this.getCurrentHandlers(event), ...this.getPersistentHandlers(event)].map(handler => handler(...parameters)));
-    }
-    off(event, listener) {
-        const listeners = this.persistentHandlers[event];
-        if (listeners) {
-            // A hack stolen from "mitt": ">>> 0" does not change numbers >= 0, but -1
-            // (which would remove the last array element if used unchanged) is turned
-            // into max_int, which is outside the array and does not change anything.
-            listeners.splice(listeners.indexOf(listener) >>> 0, 1);
-        }
-        return this;
-    }
-    on(event, listener) {
-        this.getPersistentHandlers(event).push(listener);
-        return this;
-    }
-    onCurrentRun(event, listener) {
-        this.getCurrentHandlers(event).push(listener);
-        return this;
-    }
-    once(event, listener) {
-        const selfRemovingListener = (...parameters) => {
-            this.off(event, selfRemovingListener);
-            return listener(...parameters);
-        };
-        this.on(event, selfRemovingListener);
-        return this;
-    }
-    removeAllListeners() {
-        this.removeListenersForCurrentRun();
-        this.persistentHandlers = Object.create(null);
-        return this;
-    }
-    removeListenersForCurrentRun() {
-        this.currentHandlers = Object.create(null);
-        return this;
-    }
-    getCurrentHandlers(event) {
-        return this.currentHandlers[event] || (this.currentHandlers[event] = []);
-    }
-    getPersistentHandlers(event) {
-        return this.persistentHandlers[event] || (this.persistentHandlers[event] = []);
+        super();
+        // Allows more than 10 bundles to be watched without
+        // showing the `MaxListenersExceededWarning` to the user.
+        this.setMaxListeners(Infinity);
     }
+    close() { }
 }
-
 function watch(configs) {
     const emitter = new WatchEmitter();
-    watchInternal(configs, emitter).catch(error => {
-        handleError(error);
-    });
+    const configArray = ensureArray$1(configs);
+    const watchConfigs = configArray.filter(config => config.watch !== false);
+    if (watchConfigs.length === 0) {
+        return error(errInvalidOption('watch', 'watch', 'there must be at least one config where "watch" is not set to "false"'));
+    }
+    loadFsEvents()
+        .then(() => Promise.resolve().then(() => require('./watch.js')))
+        .then(({ Watcher }) => new Watcher(watchConfigs, emitter));
     return emitter;
 }
-async function watchInternal(configs, emitter) {
-    const optionsList = await Promise.all(ensureArray$1(configs).map(config => mergeOptions(config)));
-    const watchOptionsList = optionsList.filter(config => config.watch !== false);
-    if (watchOptionsList.length === 0) {
-        return error(errorInvalidOption('watch', URL_WATCH, 'there must be at least one config where "watch" is not set to "false"'));
-    }
-    await loadFsEvents();
-    const { Watcher } = await Promise.resolve().then(() => require('./watch.js'));
-    new Watcher(watchOptionsList, emitter);
-}
-
-exports.URL_AVOIDING_EVAL = URL_AVOIDING_EVAL;
-exports.URL_NAME_IS_NOT_EXPORTED = URL_NAME_IS_NOT_EXPORTED;
-exports.URL_OUTPUT_EXPORTS = URL_OUTPUT_EXPORTS;
-exports.URL_OUTPUT_GLOBALS = URL_OUTPUT_GLOBALS;
-exports.URL_SOURCEMAP_IS_LIKELY_TO_BE_INCORRECT = URL_SOURCEMAP_IS_LIKELY_TO_BE_INCORRECT;
-exports.URL_THIS_IS_UNDEFINED = URL_THIS_IS_UNDEFINED;
-exports.URL_TREATING_MODULE_AS_EXTERNAL_DEPENDENCY = URL_TREATING_MODULE_AS_EXTERNAL_DEPENDENCY;
-exports.bold = bold;
-exports.commandAliases = commandAliases;
+
 exports.commonjsGlobal = commonjsGlobal;
 exports.createFilter = createFilter;
-exports.cyan = cyan;
+exports.defaultOnWarn = defaultOnWarn;
 exports.defineConfig = defineConfig;
+exports.ensureArray = ensureArray$1;
 exports.error = error;
-exports.errorCannotBundleConfigAsEsm = errorCannotBundleConfigAsEsm;
-exports.errorCannotLoadConfigAsCjs = errorCannotLoadConfigAsCjs;
-exports.errorCannotLoadConfigAsEsm = errorCannotLoadConfigAsEsm;
-exports.errorDuplicateImportOptions = errorDuplicateImportOptions;
-exports.errorFailAfterWarnings = errorFailAfterWarnings;
-exports.errorMissingConfig = errorMissingConfig;
-exports.errorMissingExternalConfig = errorMissingExternalConfig;
-exports.errorOnlyInlineSourcemapsForStdout = errorOnlyInlineSourcemapsForStdout;
 exports.fseventsImporter = fseventsImporter;
+exports.generatedCodePresets = generatedCodePresets;
 exports.getAliasName = getAliasName;
 exports.getAugmentedNamespace = getAugmentedNamespace;
-exports.getNewArray = getNewArray;
 exports.getOrCreate = getOrCreate;
-exports.getRollupUrl = getRollupUrl;
-exports.gray = gray;
-exports.green = green;
-exports.handleError = handleError;
-exports.isWatchEnabled = isWatchEnabled;
 exports.loadFsEvents = loadFsEvents;
-exports.mergeOptions = mergeOptions;
-exports.normalizePluginOption = normalizePluginOption;
+exports.objectifyOptionWithPresets = objectifyOptionWithPresets;
+exports.picomatch = picomatch;
 exports.printQuotedStringList = printQuotedStringList;
 exports.relativeId = relativeId;
 exports.rollup = rollup;
 exports.rollupInternal = rollupInternal;
-exports.stderr = stderr;
-exports.underline = underline;
+exports.treeshakePresets = treeshakePresets;
 exports.version = version$1;
+exports.warnUnknownOptions = warnUnknownOptions;
 exports.watch = watch;
-exports.yellow = yellow;
 //# sourceMappingURL=rollup.js.map
diff -urN /chromium-112.0.5615.49/third_party/node/node_modules/rollup/dist/shared/watch-cli.js /chromium-111.0.5563.110/third_party/node/node_modules/rollup/dist/shared/watch-cli.js
--- a/third_party/node/node_modules/rollup/dist/shared/watch-cli.js	2023-02-03 20:05:52.000000000 +0000
+++ b/third_party/node/node_modules/rollup/dist/shared/watch-cli.js	2023-01-12 22:12:55.000000000 +0000
@@ -1,7 +1,8 @@
 /*
   @license
-	Rollup.js v3.12.0
-	Sat, 28 Jan 2023 05:55:49 GMT - commit 01ddea09dfdf1c396c1c24ba3d97743698fe1508
+	Rollup.js v2.58.0
+	Fri, 01 Oct 2021 06:54:03 GMT - commit 3a404a07f41a10d10b7af536f05b90ea46d8ad3d
+
 
 	https://github.com/rollup/rollup
 
@@ -9,28 +10,22 @@
 */
 'use strict';
 
-Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
-
-const promises = require('node:fs/promises');
-const process$2 = require('node:process');
+const fs = require('fs');
 const index = require('./index.js');
+const loadConfigFile_js = require('./loadConfigFile.js');
 const cli = require('../bin/rollup');
 const rollup = require('./rollup.js');
 const require$$0 = require('assert');
 const require$$0$1 = require('events');
-const loadConfigFile_js = require('./loadConfigFile.js');
-const node_child_process = require('node:child_process');
-require('fs');
+require('path');
 require('util');
 require('stream');
-require('path');
 require('os');
-require('node:path');
-require('node:perf_hooks');
-require('node:crypto');
-require('node:events');
+require('url');
 require('tty');
-require('node:url');
+require('./mergeOptions.js');
+require('module');
+require('crypto');
 
 function timeZone(date = new Date()) {
 	const offset = date.getTimezoneOffset();
@@ -70,108 +65,77 @@
 		.replace(/\..+/, end);
 }
 
-var signalExitExports = {};
-var signalExit = {
-  get exports(){ return signalExitExports; },
-  set exports(v){ signalExitExports = v; },
-};
-
-var signalsExports = {};
-var signals$1 = {
-  get exports(){ return signalsExports; },
-  set exports(v){ signalsExports = v; },
-};
-
-var hasRequiredSignals;
-
-function requireSignals () {
-	if (hasRequiredSignals) return signalsExports;
-	hasRequiredSignals = 1;
-	(function (module) {
-		// This is not the set of all possible signals.
-		//
-		// It IS, however, the set of all signals that trigger
-		// an exit on either Linux or BSD systems.  Linux is a
-		// superset of the signal names supported on BSD, and
-		// the unknown signals just fail to register, so we can
-		// catch that easily enough.
-		//
-		// Don't bother with SIGKILL.  It's uncatchable, which
-		// means that we can't fire any callbacks anyway.
-		//
-		// If a user does happen to register a handler on a non-
-		// fatal signal like SIGWINCH or something, and then
-		// exit, it'll end up firing `process.emit('exit')`, so
-		// the handler will be fired anyway.
-		//
-		// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised
-		// artificially, inherently leave the process in a
-		// state from which it is not safe to try and enter JS
-		// listeners.
-		module.exports = [
-		  'SIGABRT',
-		  'SIGALRM',
-		  'SIGHUP',
-		  'SIGINT',
-		  'SIGTERM'
-		];
-
-		if (process.platform !== 'win32') {
-		  module.exports.push(
-		    'SIGVTALRM',
-		    'SIGXCPU',
-		    'SIGXFSZ',
-		    'SIGUSR2',
-		    'SIGTRAP',
-		    'SIGSYS',
-		    'SIGQUIT',
-		    'SIGIOT'
-		    // should detect profiler and enable/disable accordingly.
-		    // see #21
-		    // 'SIGPROF'
-		  );
-		}
-
-		if (process.platform === 'linux') {
-		  module.exports.push(
-		    'SIGIO',
-		    'SIGPOLL',
-		    'SIGPWR',
-		    'SIGSTKFLT',
-		    'SIGUNUSED'
-		  );
-		}
-} (signals$1));
-	return signalsExports;
+var signalExit = {exports: {}};
+
+var signals$1 = {exports: {}};
+
+(function (module) {
+// This is not the set of all possible signals.
+//
+// It IS, however, the set of all signals that trigger
+// an exit on either Linux or BSD systems.  Linux is a
+// superset of the signal names supported on BSD, and
+// the unknown signals just fail to register, so we can
+// catch that easily enough.
+//
+// Don't bother with SIGKILL.  It's uncatchable, which
+// means that we can't fire any callbacks anyway.
+//
+// If a user does happen to register a handler on a non-
+// fatal signal like SIGWINCH or something, and then
+// exit, it'll end up firing `process.emit('exit')`, so
+// the handler will be fired anyway.
+//
+// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised
+// artificially, inherently leave the process in a
+// state from which it is not safe to try and enter JS
+// listeners.
+module.exports = [
+  'SIGABRT',
+  'SIGALRM',
+  'SIGHUP',
+  'SIGINT',
+  'SIGTERM'
+];
+
+if (process.platform !== 'win32') {
+  module.exports.push(
+    'SIGVTALRM',
+    'SIGXCPU',
+    'SIGXFSZ',
+    'SIGUSR2',
+    'SIGTRAP',
+    'SIGSYS',
+    'SIGQUIT',
+    'SIGIOT'
+    // should detect profiler and enable/disable accordingly.
+    // see #21
+    // 'SIGPROF'
+  );
+}
+
+if (process.platform === 'linux') {
+  module.exports.push(
+    'SIGIO',
+    'SIGPOLL',
+    'SIGPWR',
+    'SIGSTKFLT',
+    'SIGUNUSED'
+  );
 }
+}(signals$1));
 
 // Note: since nyc uses this module to output coverage, any lines
 // that are in the direct sync flow of nyc's outputCoverage are
 // ignored, since we can never get coverage for them.
 // grab a reference to node's real process object right away
 var process$1 = rollup.commonjsGlobal.process;
-
-const processOk = function (process) {
-  return process &&
-    typeof process === 'object' &&
-    typeof process.removeListener === 'function' &&
-    typeof process.emit === 'function' &&
-    typeof process.reallyExit === 'function' &&
-    typeof process.listeners === 'function' &&
-    typeof process.kill === 'function' &&
-    typeof process.pid === 'number' &&
-    typeof process.on === 'function'
-};
-
 // some kind of non-node environment, just no-op
-/* istanbul ignore if */
-if (!processOk(process$1)) {
-  signalExit.exports = function () {
-    return function () {}
-  };
+if (typeof process$1 !== 'object' || !process$1) {
+  signalExit.exports = function () {};
 } else {
   var assert = require$$0;
-  var signals = requireSignals();
+  var signals = signals$1.exports;
   var isWin = /^win/i.test(process$1.platform);
 
   var EE = require$$0$1;
@@ -199,9 +163,8 @@
   }
 
   signalExit.exports = function (cb, opts) {
-    /* istanbul ignore if */
-    if (!processOk(rollup.commonjsGlobal.process)) {
-      return function () {}
+    if (rollup.commonjsGlobal.process !== process$1) {
+      return
     }
     assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler');
 
@@ -227,7 +190,7 @@
   };
 
   var unload = function unload () {
-    if (!loaded || !processOk(rollup.commonjsGlobal.process)) {
+    if (!loaded || rollup.commonjsGlobal.process !== process$1) {
       return
     }
     loaded = false;
@@ -241,10 +204,9 @@
     process$1.reallyExit = originalProcessReallyExit;
     emitter.count -= 1;
   };
-  signalExitExports.unload = unload;
+  signalExit.exports.unload = unload;
 
   var emit = function emit (event, code, signal) {
-    /* istanbul ignore if */
     if (emitter.emitted[event]) {
       return
     }
@@ -256,8 +218,7 @@
   var sigListeners = {};
   signals.forEach(function (sig) {
     sigListeners[sig] = function listener () {
-      /* istanbul ignore if */
-      if (!processOk(rollup.commonjsGlobal.process)) {
+      if (process$1 !== rollup.commonjsGlobal.process) {
         return
       }
       // If there are no other listeners, an exit is coming!
@@ -276,20 +237,19 @@
           // so use a supported signal instead
           sig = 'SIGINT';
         }
-        /* istanbul ignore next */
         process$1.kill(process$1.pid, sig);
       }
     };
   });
 
-  signalExitExports.signals = function () {
+  signalExit.exports.signals = function () {
     return signals
   };
 
   var loaded = false;
 
   var load = function load () {
-    if (loaded || !processOk(rollup.commonjsGlobal.process)) {
+    if (loaded || process$1 !== rollup.commonjsGlobal.process) {
       return
     }
     loaded = true;
@@ -312,15 +272,14 @@
     process$1.emit = processEmit;
     process$1.reallyExit = processReallyExit;
   };
-  signalExitExports.load = load;
+  signalExit.exports.load = load;
 
   var originalProcessReallyExit = process$1.reallyExit;
   var processReallyExit = function processReallyExit (code) {
-    /* istanbul ignore if */
-    if (!processOk(rollup.commonjsGlobal.process)) {
+    if (process$1 !== rollup.commonjsGlobal.process) {
       return
     }
-    process$1.exitCode = code || /* istanbul ignore next */ 0;
+    process$1.exitCode = code || 0;
     emit('exit', process$1.exitCode, null);
     /* istanbul ignore next */
     emit('afterexit', process$1.exitCode, null);
@@ -330,17 +289,14 @@
 
   var originalProcessEmit = process$1.emit;
   var processEmit = function processEmit (ev, arg) {
-    if (ev === 'exit' && processOk(rollup.commonjsGlobal.process)) {
-      /* istanbul ignore else */
+    if (ev === 'exit' && process$1 === rollup.commonjsGlobal.process) {
       if (arg !== undefined) {
         process$1.exitCode = arg;
       }
       var ret = originalProcessEmit.apply(this, arguments);
-      /* istanbul ignore next */
       emit('exit', process$1.exitCode, null);
       /* istanbul ignore next */
       emit('afterexit', process$1.exitCode, null);
-      /* istanbul ignore next */
       return ret
     } else {
       return originalProcessEmit.apply(this, arguments)
@@ -348,6 +304,8 @@
   };
 }
 
+const onExit = signalExit.exports;
+
 const CLEAR_SCREEN = '\u001Bc';
 function getResetScreen(configs, allowClearScreen) {
     let clearScreen = allowClearScreen;
@@ -357,87 +315,70 @@
         }
     }
     if (clearScreen) {
-        return (heading) => rollup.stderr(CLEAR_SCREEN + heading);
+        return (heading) => loadConfigFile_js.stderr(CLEAR_SCREEN + heading);
     }
     let firstRun = true;
     return (heading) => {
         if (firstRun) {
-            rollup.stderr(heading);
+            loadConfigFile_js.stderr(heading);
             firstRun = false;
         }
     };
 }
 
-function extractWatchHooks(command) {
-    if (!Array.isArray(command.watch))
-        return {};
-    return command.watch
-        .filter(value => typeof value === 'object')
-        .reduce((accumulator, keyValueOption) => ({ ...accumulator, ...keyValueOption }), {});
-}
-function createWatchHooks(command) {
-    const watchHooks = extractWatchHooks(command);
-    return function (hook) {
-        if (watchHooks[hook]) {
-            const cmd = watchHooks[hook];
-            if (!command.silent) {
-                rollup.stderr(rollup.cyan(`watch.${hook} ${rollup.bold(`$ ${cmd}`)}`));
-            }
-            try {
-                // !! important - use stderr for all writes from execSync
-                const stdio = [process.stdin, process.stderr, process.stderr];
-                node_child_process.execSync(cmd, { stdio: command.silent ? 'ignore' : stdio });
-            }
-            catch (error) {
-                rollup.stderr(error.message);
-            }
-        }
-    };
-}
-
 async function watch(command) {
-    process$2.env.ROLLUP_WATCH = 'true';
-    const isTTY = process$2.stderr.isTTY;
+    process.env.ROLLUP_WATCH = 'true';
+    const isTTY = process.stderr.isTTY;
     const silent = command.silent;
+    let configs;
+    let warnings;
     let watcher;
     let configWatcher;
-    let resetScreen;
-    const configFile = command.config ? await cli.getConfigPath(command.config) : null;
-    const runWatchHook = createWatchHooks(command);
-    signalExitExports(close);
-    process$2.on('uncaughtException', close);
-    if (!process$2.stdin.isTTY) {
-        process$2.stdin.on('end', close);
-        process$2.stdin.resume();
+    const configFile = command.config ? cli.getConfigPath(command.config) : null;
+    onExit(close);
+    process.on('uncaughtException', close);
+    if (!process.stdin.isTTY) {
+        process.stdin.on('end', close);
+        process.stdin.resume();
     }
     async function loadConfigFromFileAndTrack(configFile) {
+        let reloadingConfig = false;
+        let aborted = false;
         let configFileData = null;
-        let configFileRevision = 0;
-        configWatcher = index.chokidar.watch(configFile).on('change', reloadConfigFile);
+        configWatcher = index.chokidar.watch(configFile).on('change', () => reloadConfigFile());
         await reloadConfigFile();
         async function reloadConfigFile() {
             try {
-                const newConfigFileData = await promises.readFile(configFile, 'utf8');
+                const newConfigFileData = fs.readFileSync(configFile, 'utf-8');
                 if (newConfigFileData === configFileData) {
                     return;
                 }
-                configFileRevision++;
-                const currentConfigFileRevision = configFileRevision;
+                if (reloadingConfig) {
+                    aborted = true;
+                    return;
+                }
                 if (configFileData) {
-                    rollup.stderr(`\nReloading updated config...`);
+                    loadConfigFile_js.stderr(`\nReloading updated config...`);
                 }
                 configFileData = newConfigFileData;
-                const { options, warnings } = await loadConfigFile_js.loadConfigFile(configFile, command);
-                if (currentConfigFileRevision !== configFileRevision) {
-                    return;
+                reloadingConfig = true;
+                ({ options: configs, warnings } = await loadConfigFile_js.loadAndParseConfigFile(configFile, command));
+                reloadingConfig = false;
+                if (aborted) {
+                    aborted = false;
+                    reloadConfigFile();
                 }
-                if (watcher) {
-                    await watcher.close();
+                else {
+                    if (watcher) {
+                        watcher.close();
+                    }
+                    start(configs);
                 }
-                start(options, warnings);
             }
-            catch (error) {
-                rollup.handleError(error, true);
+            catch (err) {
+                configs = [];
+                reloadingConfig = false;
+                loadConfigFile_js.handleError(err, true);
             }
         }
     }
@@ -445,30 +386,29 @@
         await loadConfigFromFileAndTrack(configFile);
     }
     else {
-        const { options, warnings } = await cli.loadConfigFromCommand(command);
-        await start(options, warnings);
+        ({ options: configs, warnings } = await cli.loadConfigFromCommand(command));
+        start(configs);
     }
-    async function start(configs, warnings) {
-        watcher = rollup.watch(configs);
+    const resetScreen = getResetScreen(configs, isTTY);
+    function start(configs) {
+        try {
+            watcher = rollup.watch(configs);
+        }
+        catch (err) {
+            return loadConfigFile_js.handleError(err);
+        }
         watcher.on('event', event => {
             switch (event.code) {
-                case 'ERROR': {
+                case 'ERROR':
                     warnings.flush();
-                    rollup.handleError(event.error, true);
-                    runWatchHook('onError');
+                    loadConfigFile_js.handleError(event.error, true);
                     break;
-                }
-                case 'START': {
+                case 'START':
                     if (!silent) {
-                        if (!resetScreen) {
-                            resetScreen = getResetScreen(configs, isTTY);
-                        }
-                        resetScreen(rollup.underline(`rollup v${rollup.version}`));
+                        resetScreen(loadConfigFile_js.underline(`rollup v${rollup.version}`));
                     }
-                    runWatchHook('onStart');
                     break;
-                }
-                case 'BUNDLE_START': {
+                case 'BUNDLE_START':
                     if (!silent) {
                         let input = event.input;
                         if (typeof input !== 'string') {
@@ -476,44 +416,37 @@
                                 ? input.join(', ')
                                 : Object.values(input).join(', ');
                         }
-                        rollup.stderr(rollup.cyan(`bundles ${rollup.bold(input)} → ${rollup.bold(event.output.map(rollup.relativeId).join(', '))}...`));
+                        loadConfigFile_js.stderr(loadConfigFile_js.cyan(`bundles ${loadConfigFile_js.bold(input)} → ${loadConfigFile_js.bold(event.output.map(rollup.relativeId).join(', '))}...`));
                     }
-                    runWatchHook('onBundleStart');
                     break;
-                }
-                case 'BUNDLE_END': {
+                case 'BUNDLE_END':
                     warnings.flush();
                     if (!silent)
-                        rollup.stderr(rollup.green(`created ${rollup.bold(event.output.map(rollup.relativeId).join(', '))} in ${rollup.bold(cli.prettyMilliseconds(event.duration))}`));
-                    runWatchHook('onBundleEnd');
+                        loadConfigFile_js.stderr(loadConfigFile_js.green(`created ${loadConfigFile_js.bold(event.output.map(rollup.relativeId).join(', '))} in ${loadConfigFile_js.bold(cli.ms(event.duration))}`));
                     if (event.result && event.result.getTimings) {
                         cli.printTimings(event.result.getTimings());
                     }
                     break;
-                }
-                case 'END': {
-                    runWatchHook('onEnd');
+                case 'END':
                     if (!silent && isTTY) {
-                        rollup.stderr(`\n[${dateTime()}] waiting for changes...`);
+                        loadConfigFile_js.stderr(`\n[${dateTime()}] waiting for changes...`);
                     }
-                }
             }
             if ('result' in event && event.result) {
-                event.result.close().catch(error => rollup.handleError(error, true));
+                event.result.close().catch(error => loadConfigFile_js.handleError(error, true));
             }
         });
     }
-    async function close(code) {
-        process$2.removeListener('uncaughtException', close);
+    function close(code) {
+        process.removeListener('uncaughtException', close);
         // removing a non-existent listener is a no-op
-        process$2.stdin.removeListener('end', close);
+        process.stdin.removeListener('end', close);
         if (watcher)
-            await watcher.close();
+            watcher.close();
         if (configWatcher)
             configWatcher.close();
         if (code) {
-            // eslint-disable-next-line unicorn/no-process-exit
-            process$2.exit(code);
+            process.exit(code);
         }
     }
 }
diff -urN /chromium-112.0.5615.49/third_party/node/node_modules/rollup/dist/shared/watch.js /chromium-111.0.5563.110/third_party/node/node_modules/rollup/dist/shared/watch.js
--- a/third_party/node/node_modules/rollup/dist/shared/watch.js	2023-02-03 20:05:52.000000000 +0000
+++ b/third_party/node/node_modules/rollup/dist/shared/watch.js	2023-01-12 22:12:55.000000000 +0000
@@ -1,7 +1,8 @@
 /*
   @license
-	Rollup.js v3.12.0
-	Sat, 28 Jan 2023 05:55:49 GMT - commit 01ddea09dfdf1c396c1c24ba3d97743698fe1508
+	Rollup.js v2.58.0
+	Fri, 01 Oct 2021 06:54:03 GMT - commit 3a404a07f41a10d10b7af536f05b90ea46d8ad3d
+
 
 	https://github.com/rollup/rollup
 
@@ -9,24 +10,29 @@
 */
 'use strict';
 
-Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
-
-const node_path = require('node:path');
-const process = require('node:process');
+const path = require('path');
 const rollup = require('./rollup.js');
-const node_os = require('node:os');
+const mergeOptions = require('./mergeOptions.js');
+const require$$2 = require('os');
 const index = require('./index.js');
-require('path');
-require('node:perf_hooks');
-require('node:crypto');
-require('node:fs/promises');
-require('node:events');
-require('tty');
+require('crypto');
 require('fs');
+require('events');
 require('util');
 require('stream');
-require('os');
-require('events');
+
+function _interopNamespaceDefault(e) {
+    const n = Object.create(null);
+    if (e) {
+        for (const k in e) {
+            n[k] = e[k];
+        }
+    }
+    n.default = e;
+    return n;
+}
+
+const path__namespace = /*#__PURE__*/_interopNamespaceDefault(path);
 
 class FileWatcher {
     constructor(task, chokidarOptions) {
@@ -51,7 +57,7 @@
     }
     watch(id, isTransformDependency) {
         if (isTransformDependency) {
-            const watcher = this.transformWatchers.get(id) ?? this.createWatcher(id);
+            const watcher = this.transformWatchers.get(id) || this.createWatcher(id);
             watcher.add(id);
             this.transformWatchers.set(id, watcher);
         }
@@ -61,7 +67,7 @@
     }
     createWatcher(transformWatcherId) {
         const task = this.task;
-        const isLinux = node_os.platform() === 'linux';
+        const isLinux = require$$2.platform() === 'linux';
         const isTransformDependency = transformWatcherId !== null;
         const handleChange = (id, event) => {
             const changedId = transformWatcherId || id;
@@ -101,39 +107,33 @@
     }
 };
 class Watcher {
-    constructor(optionsList, emitter) {
+    constructor(configs, emitter) {
         this.buildDelay = 0;
         this.buildTimeout = null;
-        this.closed = false;
         this.invalidatedIds = new Map();
         this.rerun = false;
         this.running = true;
         this.emitter = emitter;
         emitter.close = this.close.bind(this);
-        this.tasks = optionsList.map(options => new Task(this, options));
-        for (const { watch } of optionsList) {
-            if (watch && typeof watch.buildDelay === 'number') {
-                this.buildDelay = Math.max(this.buildDelay, watch.buildDelay);
-            }
-        }
+        this.tasks = configs.map(config => new Task(this, config));
+        this.buildDelay = configs.reduce((buildDelay, { watch }) => watch && typeof watch.buildDelay === 'number'
+            ? Math.max(buildDelay, watch.buildDelay)
+            : buildDelay, this.buildDelay);
         process.nextTick(() => this.run());
     }
-    async close() {
-        if (this.closed)
-            return;
-        this.closed = true;
+    close() {
         if (this.buildTimeout)
             clearTimeout(this.buildTimeout);
         for (const task of this.tasks) {
             task.close();
         }
-        await this.emitter.emit('close');
+        this.emitter.emit('close');
         this.emitter.removeAllListeners();
     }
     invalidate(file) {
         if (file) {
-            const previousEvent = this.invalidatedIds.get(file.id);
-            const event = previousEvent ? eventsRewrites[previousEvent][file.event] : file.event;
+            const prevEvent = this.invalidatedIds.get(file.id);
+            const event = prevEvent ? eventsRewrites[prevEvent][file.event] : file.event;
             if (event === 'buggy') {
                 //TODO: throws or warn? Currently just ignore, uses new event
                 this.invalidatedIds.set(file.id, file.event);
@@ -151,38 +151,26 @@
         }
         if (this.buildTimeout)
             clearTimeout(this.buildTimeout);
-        this.buildTimeout = setTimeout(async () => {
+        this.buildTimeout = setTimeout(() => {
             this.buildTimeout = null;
-            try {
-                await Promise.all([...this.invalidatedIds].map(([id, event]) => this.emitter.emit('change', id, { event })));
-                this.invalidatedIds.clear();
-                await this.emitter.emit('restart');
-                this.emitter.removeListenersForCurrentRun();
-                this.run();
-            }
-            catch (error) {
-                this.invalidatedIds.clear();
-                await this.emitter.emit('event', {
-                    code: 'ERROR',
-                    error,
-                    result: null
-                });
-                await this.emitter.emit('event', {
-                    code: 'END'
-                });
+            for (const [id, event] of this.invalidatedIds.entries()) {
+                this.emitter.emit('change', id, { event });
             }
+            this.invalidatedIds.clear();
+            this.emitter.emit('restart');
+            this.run();
         }, this.buildDelay);
     }
     async run() {
         this.running = true;
-        await this.emitter.emit('event', {
+        this.emitter.emit('event', {
             code: 'START'
         });
         for (const task of this.tasks) {
             await task.run();
         }
         this.running = false;
-        await this.emitter.emit('event', {
+        this.emitter.emit('event', {
             code: 'END'
         });
         if (this.rerun) {
@@ -192,19 +180,19 @@
     }
 }
 class Task {
-    constructor(watcher, options) {
+    constructor(watcher, config) {
         this.cache = { modules: [] };
         this.watchFiles = [];
         this.closed = false;
         this.invalidated = true;
         this.watched = new Set();
         this.watcher = watcher;
-        this.options = options;
-        this.skipWrite = Boolean(options.watch && options.watch.skipWrite);
+        this.skipWrite = Boolean(config.watch && config.watch.skipWrite);
+        this.options = mergeOptions.mergeOptions(config);
         this.outputs = this.options.output;
         this.outputFiles = this.outputs.map(output => {
             if (output.file || output.dir)
-                return node_path.resolve(output.file || output.dir);
+                return path__namespace.resolve(output.file || output.dir);
             return undefined;
         });
         const watchOptions = this.options.watch || {};
@@ -223,7 +211,7 @@
         this.invalidated = true;
         if (details.isTransformDependency) {
             for (const module of this.cache.modules) {
-                if (!module.transformDependencies.includes(id))
+                if (module.transformDependencies.indexOf(id) === -1)
                     continue;
                 // effective invalidation
                 module.originalCode = null;
@@ -240,7 +228,7 @@
             cache: this.cache
         };
         const start = Date.now();
-        await this.watcher.emitter.emit('event', {
+        this.watcher.emitter.emit('event', {
             code: 'BUNDLE_START',
             input: this.options.input,
             output: this.outputFiles
@@ -253,7 +241,7 @@
             }
             this.updateWatchedFiles(result);
             this.skipWrite || (await Promise.all(this.outputs.map(output => result.write(output))));
-            await this.watcher.emitter.emit('event', {
+            this.watcher.emitter.emit('event', {
                 code: 'BUNDLE_END',
                 duration: Date.now() - start,
                 input: this.options.input,
@@ -272,7 +260,7 @@
                     this.cache.modules = this.cache.modules.filter(module => module.id !== error.id);
                 }
             }
-            await this.watcher.emitter.emit('event', {
+            this.watcher.emitter.emit('event', {
                 code: 'ERROR',
                 error,
                 result
@@ -302,7 +290,7 @@
         if (!this.filter(id))
             return;
         this.watched.add(id);
-        if (this.outputFiles.includes(id)) {
+        if (this.outputFiles.some(file => file === id)) {
             throw new Error('Cannot import the generated bundle');
         }
         // this is necessary to ensure that any 'renamed' files
diff -urN /chromium-112.0.5615.49/third_party/node/node_modules/rollup/package.json /chromium-111.0.5563.110/third_party/node/node_modules/rollup/package.json
--- a/third_party/node/node_modules/rollup/package.json	2023-02-03 20:05:52.000000000 +0000
+++ b/third_party/node/node_modules/rollup/package.json	2023-01-12 22:12:56.000000000 +0000
@@ -1,168 +1 @@
-{
-  "name": "rollup",
-  "version": "3.12.0",
-  "description": "Next-generation ES module bundler",
-  "main": "dist/rollup.js",
-  "module": "dist/es/rollup.js",
-  "types": "dist/rollup.d.ts",
-  "bin": {
-    "rollup": "dist/bin/rollup"
-  },
-  "scripts": {
-    "build": "rollup --config rollup.config.ts --configPlugin typescript",
-    "dev": "vitepress dev docs",
-    "build:cjs": "rollup --config rollup.config.ts --configPlugin typescript --configTest",
-    "build:bootstrap": "node dist/bin/rollup --config rollup.config.ts --configPlugin typescript",
-    "build:docs": "vitepress build docs",
-    "preview:docs": "vitepress preview docs",
-    "ci:lint": "concurrently 'npm:lint:js:nofix' 'npm:lint:markdown:nofix'",
-    "ci:test": "npm run build:cjs && npm run build:bootstrap && npm run test:all",
-    "ci:test:only": "npm run build:cjs && npm run build:bootstrap && npm run test:only",
-    "ci:coverage": "npm run build:cjs && npm run build:bootstrap && nyc --reporter lcovonly mocha",
-    "lint": "concurrently -c red,green 'npm:lint:js' 'npm:lint:markdown'",
-    "lint:js": "eslint . --fix --cache",
-    "lint:js:nofix": "eslint . --cache",
-    "lint:markdown": "prettier --write \"**/*.md\"",
-    "lint:markdown:nofix": "prettier --check \"**/*.md\"",
-    "perf": "npm run build:cjs && node --expose-gc scripts/perf.js",
-    "perf:init": "node scripts/perf-init.js",
-    "prepare": "husky install && node scripts/check-release.js || npm run build",
-    "prepublishOnly": "node scripts/check-release.js",
-    "release": "node scripts/release.js",
-    "test": "npm run build && npm run test:all",
-    "test:update-snapshots": "node scripts/update-snapshots.js",
-    "test:cjs": "npm run build:cjs && npm run test:only",
-    "test:quick": "mocha -b test/test.js",
-    "test:all": "concurrently --kill-others-on-fail -c green,blue,magenta,cyan,red 'npm:test:only' 'npm:test:browser' 'npm:test:typescript' 'npm:test:leak' 'npm:test:package' 'npm:test:options'",
-    "test:coverage": "npm run build:cjs && shx rm -rf coverage/* && nyc --reporter html mocha test/test.js",
-    "test:coverage:browser": "npm run build && shx rm -rf coverage/* && nyc mocha test/browser/index.js",
-    "test:leak": "node --expose-gc test/leak/index.js",
-    "test:package": "node scripts/test-package.js",
-    "test:options": "node scripts/test-options.js",
-    "test:only": "mocha test/test.js",
-    "test:typescript": "shx rm -rf test/typescript/dist && shx cp -r dist test/typescript/ && tsc --noEmit -p test/typescript && tsc --noEmit",
-    "test:browser": "mocha test/browser/index.js",
-    "watch": "rollup --config rollup.config.ts --configPlugin typescript --watch"
-  },
-  "repository": "rollup/rollup",
-  "keywords": [
-    "modules",
-    "bundler",
-    "bundling",
-    "es6",
-    "optimizer"
-  ],
-  "author": "Rich Harris",
-  "license": "MIT",
-  "bugs": {
-    "url": "https://github.com/rollup/rollup/issues"
-  },
-  "homepage": "https://rollupjs.org/",
-  "optionalDependencies": {
-    "fsevents": "~2.3.2"
-  },
-  "devDependencies": {
-    "@codemirror/commands": "^6.1.3",
-    "@codemirror/lang-javascript": "^6.1.2",
-    "@codemirror/language": "^6.3.2",
-    "@codemirror/search": "^6.2.3",
-    "@codemirror/state": "^6.2.0",
-    "@codemirror/view": "^6.7.2",
-    "@jridgewell/sourcemap-codec": "^1.4.14",
-    "@rollup/plugin-alias": "^4.0.2",
-    "@rollup/plugin-buble": "^1.0.1",
-    "@rollup/plugin-commonjs": "^24.0.0",
-    "@rollup/plugin-json": "^6.0.0",
-    "@rollup/plugin-node-resolve": "^15.0.1",
-    "@rollup/plugin-replace": "^5.0.2",
-    "@rollup/plugin-terser": "^0.3.0",
-    "@rollup/plugin-typescript": "^11.0.0",
-    "@rollup/pluginutils": "^5.0.2",
-    "@types/estree": "1.0.0",
-    "@types/node": "^14.18.36",
-    "@types/signal-exit": "^3.0.1",
-    "@types/yargs-parser": "^21.0.0",
-    "@typescript-eslint/eslint-plugin": "^5.48.0",
-    "@typescript-eslint/parser": "^5.48.0",
-    "@vue/eslint-config-prettier": "^7.0.0",
-    "@vue/eslint-config-typescript": "^11.0.2",
-    "acorn": "^8.8.1",
-    "acorn-import-assertions": "^1.8.0",
-    "acorn-jsx": "^5.3.2",
-    "acorn-walk": "^8.2.0",
-    "buble": "^0.20.0",
-    "builtin-modules": "^3.3.0",
-    "chokidar": "^3.5.3",
-    "colorette": "^2.0.19",
-    "concurrently": "^7.6.0",
-    "core-js": "^3.27.1",
-    "date-time": "^4.0.0",
-    "es5-shim": "^4.6.7",
-    "es6-shim": "^0.35.7",
-    "eslint": "^8.31.0",
-    "eslint-config-prettier": "^8.6.0",
-    "eslint-plugin-import": "^2.26.0",
-    "eslint-plugin-prettier": "^4.2.1",
-    "eslint-plugin-unicorn": "^45.0.2",
-    "eslint-plugin-vue": "^9.8.0",
-    "fixturify": "^3.0.0",
-    "flru": "^1.0.2",
-    "fs-extra": "^11.1.0",
-    "github-api": "^3.4.0",
-    "hash.js": "^1.1.7",
-    "husky": "^8.0.3",
-    "inquirer": "^9.1.4",
-    "is-reference": "^3.0.1",
-    "lint-staged": "^13.1.0",
-    "locate-character": "^2.0.5",
-    "magic-string": "^0.27.0",
-    "mermaid": "~9.1.7",
-    "mocha": "^10.2.0",
-    "nyc": "^15.1.0",
-    "pinia": "^2.0.28",
-    "prettier": "^2.8.2",
-    "pretty-bytes": "^6.0.0",
-    "pretty-ms": "^8.0.0",
-    "requirejs": "^2.3.6",
-    "rollup": "^3.9.1",
-    "rollup-plugin-license": "^3.0.1",
-    "rollup-plugin-string": "^3.0.0",
-    "rollup-plugin-thatworks": "^1.0.4",
-    "semver": "^7.3.8",
-    "shx": "^0.3.4",
-    "signal-exit": "^3.0.7",
-    "source-map": "^0.7.4",
-    "source-map-support": "^0.5.21",
-    "systemjs": "^6.13.0",
-    "terser": "^5.16.1",
-    "tslib": "^2.4.1",
-    "typescript": "^4.9.4",
-    "vitepress": "^1.0.0-alpha.35",
-    "vitepress-plugin-mermaid": "^2.0.8",
-    "vue": "^3.2.45",
-    "weak-napi": "^2.0.2",
-    "yargs-parser": "^21.1.1"
-  },
-  "overrides": {
-    "d3": "7.8.0"
-  },
-  "files": [
-    "dist/**/*.js",
-    "dist/*.d.ts",
-    "dist/bin/rollup",
-    "dist/es/package.json"
-  ],
-  "engines": {
-    "node": ">=14.18.0",
-    "npm": ">=8.0.0"
-  },
-  "exports": {
-    ".": {
-      "types": "./dist/rollup.d.ts",
-      "require": "./dist/rollup.js",
-      "import": "./dist/es/rollup.js"
-    },
-    "./loadConfigFile": "./dist/loadConfigFile.js",
-    "./dist/*": "./dist/*"
-  }
-}
+{"name": "rollup", "version": "2.58.0", "description": "Next-generation ES module bundler", "main": "dist/rollup.js", "module": "dist/es/rollup.js", "typings": "dist/rollup.d.ts", "bin": {"rollup": "dist/bin/rollup"}, "scripts": {"build": "shx rm -rf dist && git rev-parse HEAD > .commithash && rollup --config rollup.config.ts --configPlugin typescript && shx cp src/rollup/types.d.ts dist/rollup.d.ts && shx chmod a+x dist/bin/rollup", "build:cjs": "shx rm -rf dist && rollup --config rollup.config.ts --configPlugin typescript --configTest && shx cp src/rollup/types.d.ts dist/rollup.d.ts && shx chmod a+x dist/bin/rollup", "build:bootstrap": "node dist/bin/rollup --config rollup.config.ts --configPlugin typescript && shx cp src/rollup/types.d.ts dist/rollup.d.ts && shx chmod a+x dist/bin/rollup", "ci:lint": "npm run lint:nofix", "ci:test": "npm run build:cjs && npm run build:bootstrap && npm run test:all", "ci:test:only": "npm run build:cjs && npm run build:bootstrap && npm run test:only", "ci:coverage": "npm run build:cjs && npm run build:bootstrap && nyc --reporter lcovonly mocha", "lint": "eslint . --fix --cache && prettier --write \"**/*.md\"", "lint:nofix": "eslint . && prettier --check \"**/*.md\"", "lint:markdown": "prettier --write \"**/*.md\"", "perf": "npm run build:cjs && node --expose-gc scripts/perf.js", "perf:debug": "node --inspect-brk scripts/perf-debug.js", "perf:init": "node scripts/perf-init.js", "postpublish": "pinst --enable && git push && git push --tags", "prepare": "husky install && npm run build", "prepublishOnly": "pinst --disable && npm ci && npm run lint:nofix && npm run security && npm run build:bootstrap && npm run test:all", "security": "npm audit", "test": "npm run build && npm run test:all", "test:cjs": "npm run build:cjs && npm run test:only", "test:quick": "mocha -b test/test.js", "test:all": "npm run test:only && npm run test:browser && npm run test:typescript && npm run test:leak && npm run test:package", "test:coverage": "npm run build:cjs && shx rm -rf coverage/* && nyc --reporter html mocha test/test.js", "test:coverage:browser": "npm run build && shx rm -rf coverage/* && nyc mocha test/browser/index.js", "test:leak": "node --expose-gc test/leak/index.js", "test:package": "node scripts/test-package.js", "test:only": "mocha test/test.js", "test:typescript": "shx rm -rf test/typescript/dist && shx cp -r dist test/typescript/ && tsc --noEmit -p test/typescript && tsc --noEmit", "test:browser": "mocha test/browser/index.js", "watch": "rollup --config rollup.config.ts --configPlugin typescript --watch"}, "repository": "rollup/rollup", "keywords": ["modules", "bundler", "bundling", "es6", "optimizer"], "author": "Rich Harris", "license": "MIT", "bugs": {"url": "https://github.com/rollup/rollup/issues"}, "homepage": "https://rollupjs.org/", "optionalDependencies": {"fsevents": "~2.3.2"}, "devDependencies": {"@rollup/plugin-alias": "^3.1.5", "@rollup/plugin-buble": "^0.21.3", "@rollup/plugin-commonjs": "^20.0.0", "@rollup/plugin-json": "^4.1.0", "@rollup/plugin-node-resolve": "^13.0.5", "@rollup/plugin-replace": "^3.0.0", "@rollup/plugin-typescript": "^8.2.5", "@rollup/pluginutils": "^4.1.1", "@types/node": "^10.17.60", "@types/require-relative": "^0.8.0", "@types/signal-exit": "^3.0.1", "@types/yargs-parser": "^20.2.1", "@typescript-eslint/eslint-plugin": "^4.32.0", "@typescript-eslint/parser": "^4.32.0", "acorn": "^8.5.0", "acorn-jsx": "^5.3.2", "acorn-walk": "^8.2.0", "buble": "^0.20.0", "chokidar": "^3.5.2", "colorette": "^1.4.0", "core-js": "^3.18.0", "date-time": "^4.0.0", "es5-shim": "^4.6.2", "es6-shim": "^0.35.6", "eslint": "^7.32.0", "eslint-config-prettier": "^8.3.0", "eslint-plugin-import": "^2.24.2", "eslint-plugin-prettier": "^3.4.1", "execa": "^5.1.1", "fixturify": "^2.1.1", "hash.js": "^1.1.7", "husky": "^6.0.0", "is-reference": "^3.0.0", "lint-staged": "^10.5.4", "locate-character": "^2.0.5", "magic-string": "^0.25.7", "mocha": "^8.4.0", "nyc": "^15.1.0", "pinst": "^2.1.6", "prettier": "^2.4.1", "pretty-bytes": "^5.6.0", "pretty-ms": "^7.0.1", "require-relative": "^0.8.7", "requirejs": "^2.3.6", "rollup": "^2.57.0", "rollup-plugin-license": "^2.5.0", "rollup-plugin-string": "^3.0.0", "rollup-plugin-terser": "^7.0.2", "rollup-plugin-thatworks": "^1.0.4", "sander": "^0.6.0", "shx": "^0.3.3", "signal-exit": "^3.0.5", "source-map": "^0.7.3", "source-map-support": "^0.5.20", "sourcemap-codec": "^1.4.8", "systemjs": "^6.10.3", "terser": "^5.9.0", "tslib": "^2.3.1", "typescript": "^4.4.3", "weak-napi": "^2.0.2", "yargs-parser": "^20.2.9"}, "files": ["dist/**/*.js", "dist/*.d.ts", "dist/bin/rollup", "dist/rollup.browser.js.map"], "engines": {"node": ">=10.0.0"}, "exports": {".": {"node": {"require": "./dist/rollup.js", "import": "./dist/es/rollup.js"}, "default": "./dist/es/rollup.browser.js"}, "./dist/": "./dist/"}}
\ No newline at end of file
